(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["diva"] = factory(require("jquery"));
	else
		root["diva"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(7);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var diva = __webpack_require__(2);
	
	diva.registerPlugin(__webpack_require__(6));
	diva.registerPlugin(__webpack_require__(42));
	diva.registerPlugin(__webpack_require__(43));
	diva.registerPlugin(__webpack_require__(44));
	diva.registerPlugin(__webpack_require__(45));
	diva.registerPlugin(__webpack_require__(46));


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var Events = __webpack_require__(4);
	var PluginRegistry = __webpack_require__(5);
	
	var diva = module.exports = {
	    Events: new Events(),
	
	    registerPlugin: function (plugin)
	    {
	        PluginRegistry.register(plugin);
	    },
	
	    /**
	     * Create a new Diva instance at the given element
	     *
	     * @param element {Element}
	     * @param options {Object}
	     * @returns {Diva}
	     */
	    create: function (element, options)
	    {
	        if (diva.find(element))
	            throw new Error('Diva is already initialized on ' + reprElem(element));
	
	        var $elem = $(element);
	        $elem.diva(options);
	
	        return $elem.data('diva');
	    },
	
	    /**
	     * Return the Diva instance attached to the
	     * element, if any.
	     *
	     * @param element
	     * @returns {Diva|null}
	     */
	    find: function (element)
	    {
	        return $(element).data('diva') || null;
	    }
	};
	
	function reprElem(elem)
	{
	    var id = elem.id ? '#' + elem.id : elem.id;
	    var classes = elem.className ? '.' + elem.className.split(/\s+/g).join('.') : '';
	
	    return (id ? id : elem.tagName.toLowerCase()) + classes;
	}


/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports) {

	module.exports = Events;
	
	/**
	 *      Events. Pub/Sub system for Loosely Coupled logic.
	 *      Based on Peter Higgins' port from Dojo to jQuery
	 *      https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js
	 *
	 *      Re-adapted to vanilla Javascript
	 *
	 *      @class Events
	 */
	function Events()
	{
	    this._cache = {};
	}
	
	/**
	 *      diva.Events.publish
	 *      e.g.: diva.Events.publish("PageDidLoad", [pageIndex, filename, pageSelector], this);
	 *
	 *      @class Events
	 *      @method publish
	 *      @param topic {String}
	 *      @param args  {Array}
	 *      @param scope {Object=} Optional - Subscribed functions will be executed with the supplied object as `this`.
	 *          It is necessary to supply this argument with the self variable when within a Diva instance.
	 *          The scope argument is matched with the instance ID of subscribers to determine whether they
	 *              should be executed. (See instanceID argument of subscribe.)
	 */
	Events.prototype.publish = function (topic, args, scope)
	{
	    if (this._cache[topic])
	    {
	        var thisTopic = this._cache[topic];
	
	        if (typeof thisTopic.global !== 'undefined')
	        {
	            var thisTopicGlobal = thisTopic.global;
	            var globalCount = thisTopicGlobal.length;
	
	            for (var i=0; i < globalCount; i++)
	            {
	                thisTopicGlobal[i].apply(scope || null, args || []);
	            }
	        }
	
	        if (scope && typeof scope.getInstanceId !== 'undefined')
	        {
	            // get publisher instance ID from scope arg, compare, and execute if match
	            var instanceID = scope.getInstanceId();
	
	            if (this._cache[topic][instanceID])
	            {
	                var thisTopicInstance = this._cache[topic][instanceID];
	                var scopedCount = thisTopicInstance.length;
	
	                for (var j=0; j < scopedCount; j++)
	                {
	                    thisTopicInstance[j].apply(scope, args || []);
	                }
	            }
	        }
	    }
	};
	
	/**
	 *      diva.Events.subscribe
	 *      e.g.: diva.Events.subscribe("PageDidLoad", highlight, settings.ID)
	 *
	 *      @class Events
	 *      @method subscribe
	 *      @param topic {String}
	 *      @param callback {Function}
	 *      @param instanceID {String=} Optional - String representing the ID of a Diva instance; if provided,
	 *                                            callback only fires for events published from that instance.
	 *      @return Event handler {Array}
	 */
	Events.prototype.subscribe = function (topic, callback, instanceID)
	{
	    if (!this._cache[topic])
	    {
	        this._cache[topic] = {};
	    }
	
	    if (typeof instanceID === 'string')
	    {
	        if (!this._cache[topic][instanceID])
	        {
	            this._cache[topic][instanceID] = [];
	        }
	
	        this._cache[topic][instanceID].push(callback);
	    }
	    else
	    {
	        if (!this._cache[topic].global)
	        {
	            this._cache[topic].global = [];
	        }
	
	        this._cache[topic].global.push(callback);
	    }
	
	    var handle = instanceID ? [topic, callback, instanceID] : [topic, callback];
	
	    return handle;
	};
	
	/**
	 *      diva.Events.unsubscribe
	 *      e.g.: var handle = Events.subscribe("PageDidLoad", highlight);
	 *              Events.unsubscribe(handle);
	 *
	 *      @class Events
	 *      @method unsubscribe
	 *      @param handle {Array}
	 *      @param completely {Boolean=} - Unsubscribe all events for a given topic.
	 *      @return success {Boolean}
	 */
	Events.prototype.unsubscribe = function (handle, completely)
	{
	    var t = handle[0];
	
	    if (this._cache[t])
	    {
	        var topicArray;
	        var instanceID = handle.length === 3 ? handle[2] : 'global';
	
	        topicArray = this._cache[t][instanceID];
	
	        if (!topicArray)
	        {
	            return false;
	        }
	
	        if (completely)
	        {
	            delete this._cache[t][instanceID];
	            return topicArray.length > 0;
	        }
	
	        var i = topicArray.length;
	        while (i--)
	        {
	            if (topicArray[i] === handle[1])
	            {
	                this._cache[t][instanceID].splice(i, 1);
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	/**
	 *      diva.Events.unsubscribeAll
	 *      e.g.: diva.Events.unsubscribeAll('global');
	 *
	 *      @class Events
	 *      @param instanceID {String=} Optional - instance ID to remove subscribers from or 'global' (if omitted,
	 *                                   subscribers in all scopes removed)
	 *      @method unsubscribeAll
	 */
	Events.prototype.unsubscribeAll = function (instanceID)
	{
	    if (instanceID)
	    {
	        var topics = Object.keys(this._cache);
	        var i = topics.length;
	        var topic;
	
	        while (i--)
	        {
	            topic = topics[i];
	
	            if (typeof this._cache[topic][instanceID] !== 'undefined')
	            {
	                delete this._cache[topic][instanceID];
	            }
	        }
	    }
	    else
	    {
	        this._cache = {};
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * @module
	 * @private
	 * The global plugin registry.
	 */
	
	var plugins = [];
	
	module.exports = {
	    register: function (plugin)
	    {
	        plugins.push(plugin);
	    },
	    getAll: function ()
	    {
	        return plugins;
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Diva.JS autoscroll plugin
	Author: Andrew Horwitz
	
	Lets Diva scroll in the primary direction (as determined by
	settings.verticallyOriented) automatically at a given/changeable rate.
	
	Relevant settings:
	    -scrollSpeed: pixels per second (defaults to 10)
	    -disableManualScroll: disables manual scroll while automatic scroll is on (defaults to false)
	    -currentlyAutoScrolling: whether or not autoscroll is currently on
	    -autoScrollRefresh: ms between scrolling actions
	    -disableAutoscrollPrefs: disables the autoscroll preferences panel
	
	Relevant methods:
	    -startScrolling, stopScrolling, toggleScrolling
	    -changeRefresh, changeScrollSpeed (setters for respective options)
	    -disableManualScroll, enableManualScroll
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var pixelsPerScroll;
	                var disableManualScroll;
	                var autoScrollRefresh;
	                var defaultAutoRefresh;
	                var scrollSpeed;
	
	                function log10(x)
	                {
	                    return Math.log(x) / Math.log(10);
	                }
	
	                divaInstance.startScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to start autoscrolling, but it is already scrolling.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn off");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = true;
	                    restartScrollingInterval();
	                };
	
	                var restartScrollingInterval = function()
	                {
	                    clearInterval(divaSettings.autoScrollInterval);
	                    if (divaSettings.verticallyOriented)
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollTop(divaSettings.viewportObject.scrollTop() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                    else
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollLeft(divaSettings.viewportObject.scrollLeft() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.stopScrolling = function()
	                {
	                    if (!divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to stop autoscrolling, but it is not currently active.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn on");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = false;
	                    clearInterval(divaSettings.autoScrollInterval);
	                };
	
	                divaInstance.toggleScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                        divaInstance.stopScrolling();
	                    else
	                        divaInstance.startScrolling();
	                };
	
	                divaInstance.changeRefresh = function(newRefresh)
	                {
	                    autoScrollRefresh = newRefresh;
	                    updatePixelsPerScroll();
	                };
	
	                divaInstance.changeScrollSpeed = function(newSpeed)
	                {
	                    scrollSpeed = newSpeed;
	                    updatePixelsPerScroll();
	
	                    $("#" + divaSettings.ID + "autoscroll-pps").val(log10(scrollSpeed));
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        restartScrollingInterval();
	                    }
	                };
	
	                var updatePixelsPerScroll = function()
	                {
	                    autoScrollRefresh = defaultAutoRefresh;
	                    pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	
	                    //should be minimum of one otherwise it won't change the actual value
	                    //user can change autoscrollrefresh or scrollspeed; this may overwrite autoScrollRefresh
	                    if (pixelsPerScroll < 1)
	                    {
	                        autoScrollRefresh = autoScrollRefresh * (1 / pixelsPerScroll);
	                        pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.disableManualScroll = function()
	                {
	                    disableManualScroll = true;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	                };
	
	                divaInstance.enableManualScroll = function()
	                {
	                    disableManualScroll = false;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	                };
	
	                divaSettings.currentlyAutoScrolling = false;
	                divaSettings.autoScrollInterval = "";
	
	                disableManualScroll = divaSettings.disableManualScroll || false;
	                autoScrollRefresh = divaSettings.autoScrollRefresh || 50;
	                defaultAutoRefresh = autoScrollRefresh;
	
	                divaInstance.changeScrollSpeed((divaSettings.scrollSpeed || 10));
	
	                $(window).on('keyup', function(e)
	                {
	                    if (e.shiftKey && e.keyCode === 32)
	                    {
	                        divaInstance.toggleScrolling();
	                    }
	                });
	
	                if (!divaSettings.disableAutoscrollPrefs)
	                {
	                    var setPosition = function(isFullscreen)
	                    {
	                        if (divaSettings.inFullscreen)
	                        {
	                            var fullscreenTools = $(divaSettings.selector + 'tools');
	                            var toolsMargin = fullscreenTools.css('right');
	                            settings.jqObj.css({
	                                'right': toolsMargin,
	                                'margin-right': 0,
	                                'top': fullscreenTools.offset().top + fullscreenTools.outerHeight() + 15
	                            });
	                        }
	                        else
	                        {
	                            settings.jqObj.css({
	                                'right': $(window).width() - (divaSettings.viewportObject.offset().left + divaSettings.viewportObject.outerWidth()) + divaSettings.scrollbarWidth,
	                                'margin-right': '.6em'
	                            });
	                            settings.jqObj.offset({'top': divaSettings.viewportObject.offset().top + 1});
	                        }
	                    };
	
	                    diva.Events.subscribe('ModeDidSwitch', setPosition, divaSettings.ID);
	
	                    diva.Events.subscribe('ViewerDidLoad', function(s)
	                    {
	                        var autoscrollPrefsString =
	                        "<div id='" + divaSettings.ID + "autoscroll-prefs' class='diva-autoscroll-prefs diva-popup'>" +
	                            "<b>Autoscrolling options:</b><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Speed:</span>" +
	                            "<input type='range' id='" + divaSettings.ID + "autoscroll-pps' class='diva-autoscroll-pps diva-autoscroll-prefs-input' value='" + log10(scrollSpeed) + "' min='0' max='3' step='0.1'><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Allow manual scroll:</span>" +
	                            "<input type='checkbox' id='" + divaSettings.ID + "autoscroll-manual' class='diva-autoscroll-manual diva-autoscroll-prefs-input' checked='checked'><br>" +
	                            "<button id='" + divaSettings.ID + "autoscroll-toggle' class='diva-autoscroll-prefs-toggle diva-autoscroll-prefs-input'> Turn on </button>" +
	                        "</div>";
	                        $("#" + divaSettings.ID + "page-nav").before("<div id='" + divaSettings.ID + "autoscroll-icon' class='diva-button diva-autoscroll-icon' title='Expand autoscroll options'></div>");
	                        $("body").prepend(autoscrollPrefsString);
	
	                        $("#" + divaSettings.ID + "autoscroll-pps").on('change', function(e)
	                        {
	                            divaInstance.changeScrollSpeed(Math.pow(10, e.target.value));
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-manual").on('change', function(e)
	                        {
	                            if (e.target.checked)
	                                divaInstance.enableManualScroll();
	                            else
	                                divaInstance.disableManualScroll();
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-toggle").on('click', divaInstance.toggleScrolling);
	
	                        $("#" + divaSettings.ID + "autoscroll-icon").on('click', function(e)
	                        {
	                            settings.jqObj = $("#" + divaSettings.ID + "autoscroll-prefs");
	
	                            if (settings.jqObj.css('display') === 'none')
	                            {
	                                settings.jqObj.css({'display': 'block'});
	
	                                setPosition(divaSettings.inFullscreen);
	
	                            }
	                            else
	                            {
	                                settings.jqObj.css('display', 'none');
	                            }
	                        });
	                    }, divaSettings.ID);
	                }
	            },
	            pluginName: 'autoscroll',
	            titleText: 'Automatically scrolls page along primary axis'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Copyright (C) 2011-2016 by Wendy Liu, Evan Magoni, Andrew Hankinson, Andrew Horwitz, Laurent Pugin
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	
	var jQuery = __webpack_require__(3);
	
	var elt = __webpack_require__(8);
	var HashParams = __webpack_require__(9);
	
	var ActiveDivaController = __webpack_require__(10);
	var diva = __webpack_require__(2);
	var ImageManifest = __webpack_require__(11);
	var createToolbar = __webpack_require__(13);
	var ViewerCore = __webpack_require__(14);
	
	// Start the active Diva tracker
	var activeDiva = new ActiveDivaController(); // jshint ignore: line
	
	module.exports = diva;
	
	// this pattern was taken from http://www.virgentech.com/blog/2009/10/building-object-oriented-jquery-plugin.html
	(function ($)
	{
	    var Diva = function (element, options)
	    {
	        // Global instance variables (set way down in `init`)
	        var settings, viewerState, divaState;
	        var self = this;
	
	        // These are elements that can be overridden upon instantiation
	        // See https://github.com/DDMAL/diva.js/wiki/Settings for more details
	        options = $.extend({
	            adaptivePadding: 0.05,      // The ratio of padding to the page dimension
	            arrowScrollAmount: 40,      // The amount (in pixels) to scroll by when using arrow keys
	            blockMobileMove: false,     // Prevent moving or scrolling the page on mobile devices
	            objectData: '',             // A IIIF Manifest or a JSON file generated by process.py that provides the object dimension data, or a URL pointing to such data - *REQUIRED*
	            enableAutoTitle: true,      // Shows the title within a div of id diva-title
	            enableFilename: true,       // Uses filenames and not page numbers for links (i=bm_001.tif, not p=1)
	            enableFullscreen: true,     // Enable or disable fullscreen icon (mode still available)
	            enableGotoPage: true,       // A "go to page" jump box
	            enableGotoSuggestions: true, // Controls whether suggestions are shown under the input field when the user is typing in the 'go to page' form
	            enableGridIcon: true,       // A grid view of all the pages
	            enableGridControls: 'buttons',  // Specify control of pages per grid row in Grid view. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            enableImageTitles: true,    // Adds "Page {n}" title to page images if true
	            enableKeyScroll: true,      // Captures scrolling using the arrow and page up/down keys regardless of page focus. When off, defers to default browser scrolling behavior.
	            enableLinkIcon: true,       // Controls the visibility of the link icon
	            enableNonPagedVisibilityIcon: true, // Controls the visibility of the icon to toggle the visibility of non-paged pages. (Automatically hidden if no 'non-paged' pages).
	            enableSpaceScroll: false,   // Scrolling down by pressing the space key
	            enableToolbar: true,        // Enables the toolbar. Note that disabling this means you have to handle all controls yourself.
	            enableZoomControls: 'buttons', // Specify controls for zooming in and out. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            fillParentHeight: true,     // Use a flexbox layout to allow Diva to fill its parent's height
	            fixedPadding: 10,           // Fallback if adaptive padding is set to 0
	            fixedHeightGrid: true,      // So each page in grid view has the same height (only widths differ)
	            goDirectlyTo: 0,            // Default initial page to show (0-indexed)
	            hashParamSuffix: null,      // Used when there are multiple document viewers on a page
	            iipServerURL: '',           // The URL to the IIPImage installation, including the `?FIF=` - *REQUIRED*, unless using IIIF
	            inFullscreen: false,        // Set to true to load fullscreen mode initially
	            inBookLayout: false,       // Set to true to view the document with facing pages in document mode
	            inGrid: false,              // Set to true to load grid view initially
	            imageDir: '',               // Image directory, either absolute path or relative to IIP's FILESYSTEM_PREFIX - *REQUIRED*, unless using IIIF
	            maxPagesPerRow: 8,          // Maximum number of pages per row in grid view
	            maxZoomLevel: -1,           // Optional; defaults to the max zoom returned in the JSON response
	            minPagesPerRow: 2,          // Minimum pages per row in grid view. Recommended default.
	            minZoomLevel: 0,            // Defaults to 0 (the minimum zoom)
	            onGotoSubmit: null,         // When set to a function that takes a string and returns a page index, this will override the default behaviour of the 'go to page' form submission
	            pageAliases: {},            // An object mapping specific page indices to aliases (has priority over 'pageAliasFunction'
	            pageAliasFunction: function(){return false;},  // A function mapping page indices to an alias. If false is returned, default page number is displayed
	            pageLoadTimeout: 200,       // Number of milliseconds to wait before loading pages
	            pagesPerRow: 5,             // The default number of pages per row in grid view
	            showNonPagedPages: false,   // Whether pages tagged as 'non-paged' (in IIIF manifests only) should be visible after initial load
	            throbberTimeout: 100,       // Number of milliseconds to wait before showing throbber
	            tileHeight: 256,            // The height of each tile, in pixels; usually 256
	            tileWidth: 256,             // The width of each tile, in pixels; usually 256
	            toolbarParentObject: null,  // The toolbar parent object.
	            verticallyOriented: true,   // Determines vertical vs. horizontal orientation
	            viewportMargin: 200,        // Pretend tiles +/- 200px away from viewport are in
	            zoomLevel: 2                // The initial zoom level (used to store the current zoom level)
	        }, options);
	
	        // Returns the page index associated with the given filename; must called after setting settings.manifest
	        var getPageIndex = function (filename)
	        {
	            return getPageIndexForManifest(settings.manifest, filename);
	        };
	
	        var getPageIndexForManifest = function (manifest, filename)
	        {
	            var i,
	                np = manifest.pages.length;
	
	            for (i = 0; i < np; i++)
	            {
	                if (manifest.pages[i].f === filename)
	                {
	                    return i;
	                }
	            }
	
	            return -1;
	        };
	
	        // Check if a page index is valid
	        var isPageValid = function (pageIndex)
	        {
	            return settings.manifest.isPageValid(pageIndex, settings.showNonPagedPages);
	        };
	
	        var reloadViewer = function (newOptions)
	        {
	            return divaState.viewerCore.reload(newOptions);
	        };
	
	        // Called when the change view icon is clicked
	        var changeView = function (destinationView)
	        {
	            switch (destinationView)
	            {
	                case 'document':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: false
	                    });
	
	                case 'book':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: true
	                    });
	
	                case 'grid':
	                    return reloadViewer({
	                        inGrid: true
	                    });
	
	                default:
	                    return false;
	            }
	        };
	
	        //toggles between orientations
	        var toggleOrientation = function ()
	        {
	            var verticallyOriented = !settings.verticallyOriented;
	
	            //if in grid, switch out of grid
	            reloadViewer({
	                inGrid: false,
	                verticallyOriented: verticallyOriented,
	                goDirectlyTo: settings.currentPageIndex,
	                verticalOffset: divaState.viewerCore.getYOffset(),
	                horizontalOffset: divaState.viewerCore.getXOffset()
	            });
	
	            return verticallyOriented;
	        };
	
	        // Called when the fullscreen icon is clicked
	        var toggleFullscreen = function ()
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        };
	
	        var getState = function ()
	        {
	            var view;
	
	            if (settings.inGrid)
	            {
	                view = 'g';
	            }
	            else if (settings.inBookLayout)
	            {
	                view = 'b';
	            }
	            else
	            {
	                view = 'd';
	            }
	
	            var layout = divaState.viewerCore.getCurrentLayout();
	            var pageOffset = layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            var state = {
	                'f': settings.inFullscreen,
	                'v': view,
	                'z': settings.zoomLevel,
	                'n': settings.pagesPerRow,
	                'i': settings.enableFilename ? settings.manifest.pages[settings.currentPageIndex].f : false,
	                'p': settings.enableFilename ? false : settings.currentPageIndex + 1,
	                'y': pageOffset ? pageOffset.y : false,
	                'x': pageOffset ? pageOffset.x : false
	            };
	
	            return state;
	        };
	
	        var getLoadOptionsForState = function (state, manifest)
	        {
	            manifest = manifest || settings.manifest;
	
	            var options = ('v' in state) ? getViewState(state.v) : {};
	
	            if ('f' in state)
	                options.inFullscreen = state.f;
	
	            if ('z' in state)
	                options.zoomLevel = state.z;
	
	            if ('n' in state)
	                options.pagesPerRow = state.n;
	
	            // Only change specify the page if state.i or state.p is valid
	            var pageIndex = getPageIndexForManifest(manifest, state.i);
	
	            if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	            {
	                pageIndex = state.p - 1;
	
	                // Possibly NaN
	                if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	                    pageIndex = null;
	            }
	
	            if (pageIndex !== null)
	            {
	                var horizontalOffset = parseInt(state.x, 10);
	                var verticalOffset = parseInt(state.y, 10);
	
	                options.goDirectlyTo = pageIndex;
	                options.horizontalOffset = horizontalOffset;
	                options.verticalOffset = verticalOffset;
	            }
	
	            return options;
	        };
	
	        var getURLHash = function ()
	        {
	            var hashParams = getState();
	            var hashStringBuilder = [];
	            var param;
	
	            for (param in hashParams)
	            {
	                if (hashParams[param] !== false)
	                    hashStringBuilder.push(param + settings.hashParamSuffix + '=' + encodeURIComponent(hashParams[param]));
	            }
	
	            return hashStringBuilder.join('&');
	        };
	
	        // Returns the URL to the current state of the document viewer (so it should be an exact replica)
	        var getCurrentURL = function ()
	        {
	            return location.protocol + '//' + location.host + location.pathname + location.search + '#' + getURLHash();
	        };
	
	        var getViewState = function(view)
	        {
	            switch (view)
	            {
	                case 'd':
	                    return {
	                        inGrid: false,
	                        inBookLayout: false
	                    };
	
	                case 'b':
	                    return {
	                        inGrid: false,
	                        inBookLayout: true
	                    };
	
	                case 'g':
	                    return {
	                        inGrid: true,
	                        inBookLayout: false
	                    };
	
	                default:
	                    return null;
	            }
	        };
	
	        var showError = function(message)
	        {
	            divaState.viewerCore.showError(message);
	        };
	
	        var ajaxError = function(jqxhr, status, error)
	        {
	            // Show a basic error message within the document viewer pane
	
	            var errorMessage = ['Invalid objectData setting. Error code: ' + jqxhr.status + ' ' + error];
	
	            // Detect and handle CORS errors
	            var dataHasAbsolutePath = settings.objectData.lastIndexOf('http', 0) === 0;
	
	            if (dataHasAbsolutePath && error === '')
	            {
	                var jsonHost = settings.objectData.replace(/https?:\/\//i, "").split(/[/?#]/)[0];
	
	                if (location.hostname !== jsonHost)
	                {
	                    errorMessage.push(
	                        elt('p', 'Attempted to access cross-origin data without CORS.'),
	                        elt('p',
	                            'You may need to update your server configuration to support CORS. For help, see the ',
	                            elt('a', {
	                                href: 'https://github.com/DDMAL/diva.js/wiki/Installation#a-note-about-cross-site-requests',
	                                target: '_blank'
	                            }, 'cross-site request documentation.')
	                        )
	                    );
	                }
	            }
	
	            showError(errorMessage);
	        };
	
	        var loadObjectData = function (responseData, hashState)
	        {
	            var isIIIF, manifest;
	
	            // parse IIIF manifest if it is an IIIF manifest. TODO improve IIIF detection method
	            if (responseData.hasOwnProperty('@context') && (responseData['@context'].indexOf('iiif') !== -1 ||
	                responseData['@context'].indexOf('shared-canvas') !== -1))
	            {
	                isIIIF = true;
	
	                // trigger ManifestDidLoad event
	                // FIXME: Why is this triggered before the manifest is parsed? See https://github.com/DDMAL/diva.js/issues/357
	                diva.Events.publish('ManifestDidLoad', [responseData], self);
	
	                manifest = ImageManifest.fromIIIF(responseData);
	            }
	            else
	            {
	                // IIP support is now deprecated
	                console.warn("Usage of IIP manifests is deprecated. Consider switching to IIIF manifests. Visit http://iiif.io/ for more information.");
	
	                isIIIF = false;
	                manifest = ImageManifest.fromLegacyManifest(responseData, {
	                    iipServerURL: settings.iipServerURL,
	                    imageDir: settings.imageDir
	                });
	            }
	
	            var loadOptions = hashState ? getLoadOptionsForState(hashState, manifest) : {};
	
	            divaState.viewerCore.setManifest(manifest, isIIIF, loadOptions);
	        };
	
	        /** Parse the hash parameters into the format used by getState and setState */
	        var getHashParamState = function ()
	        {
	            var state = {};
	
	            ['f', 'v', 'z', 'n', 'i', 'p', 'y', 'x'].forEach(function (param)
	            {
	                var value = HashParams.get(param + settings.hashParamSuffix);
	
	                // `false` is returned if the value is missing
	                if (value !== false)
	                    state[param] = value;
	            });
	
	            // Do some awkward special-casing, since this format is kind of weird.
	
	            // For inFullscreen (f), true and false strings should be interpreted
	            // as booleans.
	            if (state.f === 'true')
	                state.f = true;
	            else if (state.f === 'false')
	                state.f = false;
	
	            // Convert numerical values to integers, if provided
	            ['z', 'n', 'p', 'x', 'y'].forEach(function (param)
	            {
	                if (param in state)
	                    state[param] = parseInt(state[param], 10);
	            });
	
	            return state;
	        };
	
	        var checkLoaded = function()
	        {
	            if (!viewerState.loaded)
	            {
	                console.warn("The viewer is not completely initialized. This is likely because it is still downloading data. To fix this, only call this function if the isReady() method returns true.");
	                return false;
	            }
	            return true;
	        };
	
	        var init = function ()
	        {
	            // In order to fill the height, use a wrapper div displayed using a flexbox layout
	            var wrapperElement = elt('div', {
	                class: "diva-wrapper" + (options.fillParentHeight ? " diva-wrapper-flexbox" : "")
	            });
	            element.appendChild(wrapperElement);
	            options.toolbarParentObject = options.toolbarParentObject || $(wrapperElement);
	
	            var viewerCore = new ViewerCore(wrapperElement, options, self);
	
	            viewerState = viewerCore.getInternalState();
	            settings = viewerCore.getSettings();
	
	            // Add the ID to the wrapper element now that the ID has been generated by the viewer core
	            wrapperElement.id = settings.ID + 'wrapper';
	
	            divaState = {
	                viewerCore: viewerCore,
	                toolbar: settings.enableToolbar ? createToolbar(self) : null
	            };
	
	            var hashState = getHashParamState();
	
	            if (typeof settings.objectData === 'object')
	            {
	                // Defer execution until initialization has completed
	                setTimeout(function ()
	                {
	                    loadObjectData(settings.objectData, hashState);
	                }, 0);
	            }
	            else
	            {
	                var pendingManifestRequest = $.ajax({
	                    url: settings.objectData,
	                    cache: true,
	                    dataType: 'json',
	                    error: ajaxError,
	                    success: function (responseData)
	                    {
	                        loadObjectData(responseData, hashState);
	                    }
	                });
	
	                // Store the pending request so that it can be cancelled in the event that Diva needs to be destroyed
	                viewerCore.setPendingManifestRequest(pendingManifestRequest);
	            }
	        };
	
	        /* PUBLIC FUNCTIONS
	        ===============================================
	        */
	
	        // Returns the title of the document, based on the directory name
	        this.getItemTitle = function ()
	        {
	            return settings.manifest.itemTitle;
	        };
	
	        // Go to a particular page by its page number (with indexing starting at 1)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page number passed is valid; false if it is not.
	        this.gotoPageByNumber = function (pageNumber, xAnchor, yAnchor)
	        {
	            console.warn("This method is deprecated. Consider using gotoPageByIndex(pageIndex, xAnchor, yAnchor) instead.");
	            var pageIndex = parseInt(pageNumber, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Go to a particular page (with indexing starting at 0)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page index is valid; false if it is not.
	        this.gotoPageByIndex = function (pageIndex, xAnchor, yAnchor)
	        {
	            pageIndex = parseInt(pageIndex, 10);
	            if (isPageValid(pageIndex))
	            {
	                var xOffset = divaState.viewerCore.getXOffset(pageIndex, xAnchor);
	                var yOffset = divaState.viewerCore.getYOffset(pageIndex, yAnchor);
	
	                viewerState.renderer.goto(pageIndex, yOffset, xOffset);
	                return true;
	            }
	            return false;
	        };
	
	        this.getNumberOfPages = function ()
	        {
	            if (!checkLoaded())
	                return false;
	
	            return settings.numPages;
	        };
	
	        // Get page dimensions in the current view and zoom level
	        this.getPageDimensions = function (pageIndex)
	        {
	            if (!checkLoaded())
	                return null;
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of a given page index at a given zoom level
	        this.getPageDimensionsAtZoomLevel = function (pageIdx, zoomLevel)
	        {
	            if (!checkLoaded())
	                return false;
	
	            if (zoomLevel > settings.maxZoomLevel)
	                zoomLevel = settings.maxZoomLevel;
	
	            var pg = settings.manifest.pages[parseInt(pageIdx, 10)];
	            var pgAtZoom = pg.d[parseInt(zoomLevel, 10)];
	            return {'width': pgAtZoom.w, 'height': pgAtZoom.h};
	        };
	
	        // Returns the dimensions of a given page at the current zoom level
	        // The current page index will be used if no pageIndex is specified
	        // Also works in Grid view
	        this.getPageDimensionsAtCurrentZoomLevel = function(pageIndex)
	        {
	            pageIndex = isPageValid(pageIndex) ? pageIndex : settings.currentPageIndex;
	
	            if (!isPageValid(pageIndex))
	                throw new Error('Invalid Page Index');
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of the current page at the current zoom level
	        // Also works in Grid view
	        this.getCurrentPageDimensionsAtCurrentZoomLevel = function ()
	        {
	            return this.getPageDimensionsAtCurrentZoomLevel(settings.currentPageIndex);
	        };
	
	        this.isReady = function ()
	        {
	            return viewerState.loaded;
	        };
	
	        this.getCurrentPageIndex = function ()
	        {
	            return settings.currentPageIndex;
	        };
	
	        this.getCurrentPageFilename = function ()
	        {
	            return settings.manifest.pages[settings.currentPageIndex].f;
	        };
	
	        this.getCurrentPageNumber = function ()
	        {
	            console.warn("This method is deprecated. Consider using getCurrentPageIndex() instead.");
	            return settings.currentPageIndex + 1;
	        };
	
	        // Returns an array of all filenames in the document
	        this.getFilenames = function ()
	        {
	            var filenames = [];
	
	            for (var i = 0; i < settings.numPages; i++)
	            {
	                filenames[i] = settings.manifest.pages[i].f;
	            }
	
	            return filenames;
	        };
	
	        // Returns the current zoom level
	        this.getZoomLevel = function ()
	        {
	            return settings.zoomLevel;
	        };
	
	        // gets the maximum zoom level for the entire document
	        this.getMaxZoomLevel = function ()
	        {
	            return settings.maxZoomLevel;
	        };
	
	        // gets the max zoom level for a given page
	        this.getMaxZoomLevelForPage = function (pageIdx)
	        {
	            if (!checkLoaded)
	                return false;
	
	            return settings.manifest.pages[pageIdx].m;
	        };
	
	        this.getMinZoomLevel = function ()
	        {
	            return settings.minZoomLevel;
	        };
	
	        // Use the provided zoom level (will check for validity first)
	        // Returns false if the zoom level is invalid, true otherwise
	        this.setZoomLevel = function (zoomLevel)
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({
	                    inGrid: false
	                });
	            }
	
	            return divaState.viewerCore.zoom(zoomLevel);
	        };
	
	        this.getGridPagesPerRow = function ()
	        {
	            // TODO(wabain): Add test case
	            return this.pagesPerRow;
	        };
	
	        this.setGridPagesPerRow = function (newValue)
	        {
	            // TODO(wabain): Add test case
	            if (!divaState.viewerCore.isValidOption('pagesPerRow', newValue))
	                return false;
	
	            return reloadViewer({
	                inGrid: true,
	                pagesPerRow: newValue
	            });
	        };
	
	        // Zoom in. Will return false if it's at the maximum zoom
	        this.zoomIn = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel + 1);
	        };
	
	        // Zoom out. Will return false if it's at the minimum zoom
	        this.zoomOut = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel - 1);
	        };
	
	        // Check if something (e.g. a highlight box on a particular page) is visible
	        this.isRegionInViewport = function (pageIndex, leftOffset, topOffset, width, height)
	        {
	            var layout = divaState.viewerCore.getCurrentLayout();
	
	            if (!layout)
	                return false;
	
	            var offset = layout.getPageOffset(pageIndex);
	
	            var top = offset.top + topOffset;
	            var left = offset.left + leftOffset;
	
	            return viewerState.viewport.intersectsRegion({
	                top: top,
	                bottom: top + height,
	                left: left,
	                right: left + width
	            });
	        };
	
	        //Public wrapper for isPageVisible
	        //Determines if a page is currently in the viewport
	        this.isPageInViewport = function (pageIndex)
	        {
	            return viewerState.renderer.isPageVisible(pageIndex);
	        };
	
	        //Public wrapper for isPageLoaded
	        //Determines if a page is currently in the DOM
	        this.isPageLoaded = function (pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using isPageInViewport(pageIndex) instead.");
	            return this.isPageInViewport(pageIndex);
	        };
	
	        // Toggle fullscreen mode
	        this.toggleFullscreenMode = function ()
	        {
	            toggleFullscreen();
	        };
	
	        // Show/Hide non-paged pages
	        this.toggleNonPagedPagesVisibility = function ()
	        {
	            reloadViewer({ showNonPagedPages: !settings.showNonPagedPages });
	        };
	
	        // Show non-paged pages
	        this.showNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: true });
	        };
	
	        // Hide non-paged pages
	        this.hideNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: false });
	        };
	
	        // Close toolbar popups
	        this.closePopups = function ()
	        {
	            divaState.toolbar.closePopups();
	        };
	
	        // Enter fullscreen mode if currently not in fullscreen mode
	        // Returns false if in fullscreen mode initially, true otherwise
	        // This function will work even if enableFullscreen is set to false
	        this.enterFullscreenMode = function ()
	        {
	            if (!settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave fullscreen mode if currently in fullscreen mode
	        // Returns true if in fullscreen mode intitially, false otherwise
	        this.leaveFullscreenMode = function ()
	        {
	            if (settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        this.isInFullscreen = function ()
	        {
	            return settings.inFullscreen;
	        };
	
	        // Change views. Takes 'document', 'book', or 'grid' to specify which view to switch into
	        this.changeView = function(destinationView)
	        {
	            return changeView(destinationView);
	        };
	
	        // Enter grid view if currently not in grid view
	        // Returns false if in grid view initially, true otherwise
	        this.enterGridView = function ()
	        {
	            if (!settings.inGrid)
	            {
	                changeView('grid');
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave grid view if currently in grid view
	        // Returns true if in grid view initially, false otherwise
	        this.leaveGridView = function ()
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({ inGrid: false });
	                return true;
	            }
	
	            return false;
	        };
	
	        // Jump to a page based on its filename
	        // Returns true if successful and false if the filename is invalid
	        this.gotoPageByName = function (filename, xAnchor, yAnchor)
	        {
	            var pageIndex = getPageIndex(filename);
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        this.gotoPageByLabel = function (label, xAnchor, yAnchor)
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0, len = pages.length; i < len; i++)
	            {
	                if (pages[i].l.toLowerCase().indexOf(label.toLowerCase()) > -1)
	                    return this.gotoPageByIndex(i, xAnchor, yAnchor);
	            }
	
	            // If no label was found, try to parse a page number
	            var pageIndex = parseInt(label, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Get the page index (0-based) corresponding to a given filename
	        // If the page index doesn't exist, this will return -1
	        this.getPageIndex = function (filename)
	        {
	            return getPageIndex(filename);
	        };
	
	        // Get the current URL (exposes the private method)
	        this.getCurrentURL = function ()
	        {
	            return getCurrentURL();
	        };
	
	        // Check if a page index is within the range of the document
	        this.isPageIndexValid = function (pageIndex)
	        {
	            return isPageValid(pageIndex);
	        };
	
	        // Get the hash part only of the current URL (without the leading #)
	        this.getURLHash = function ()
	        {
	            return getURLHash();
	        };
	
	        // Get an object representing the state of this diva instance (for setState)
	        this.getState = function ()
	        {
	            return getState();
	        };
	
	        // Align this diva instance with a state object (as returned by getState)
	        this.setState = function (state)
	        {
	            reloadViewer(getLoadOptionsForState(state));
	        };
	
	        // Get the instance selector for this instance, since it's auto-generated.
	        this.getInstanceSelector = function ()
	        {
	            return settings.selector;
	        };
	
	        // Get the instance ID -- essentially the selector without the leading '#'.
	        this.getInstanceId = function ()
	        {
	            return settings.ID;
	        };
	
	        this.getSettings = function ()
	        {
	            return settings;
	        };
	
	        /*
	            Translates a measurement from the zoom level on the largest size
	            to one on the current zoom level.
	
	            For example, a point 1000 on an image that is on zoom level 2 of 5
	            translates to a position of 111.111... (1000 / (5 - 2)^2).
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 1000 pixels wide on the original to one that is 111.111 pixels wide
	            on the current zoom level).
	        */
	        this.translateFromMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	            return position / Math.pow(2, zoomDifference);
	        };
	
	        /*
	            Translates a measurement from the current zoom level to the position on the
	            largest zoom level.
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 111.111 pixels wide on the current image to one that is 1000 pixels wide
	            on the current zoom level).
	        */
	        this.translateToMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	
	            // if there is no difference, it's a box on the max zoom level and
	            // we can just return the position.
	            if (zoomDifference === 0)
	                return position;
	
	            return position * Math.pow(2, zoomDifference);
	        };
	
	        // Re-enables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.enableScrollable = function()
	        {
	            divaState.viewerCore.enableScrollable();
	        };
	
	        // Disables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.disableScrollable = function ()
	        {
	            divaState.viewerCore.disableScrollable();
	        };
	
	        //Changes between horizontal layout and vertical layout. Returns true if document is now vertically oriented, false otherwise.
	        this.toggleOrientation = function ()
	        {
	            return toggleOrientation();
	        };
	
	        //Returns distance between the northwest corners of diva-inner and page index
	        this.getPageOffset = function(pageIndex, options)
	        {
	            var region = divaState.viewerCore.getPageRegion(pageIndex, options);
	
	            return {
	                top: region.top,
	                left: region.left
	            };
	        };
	
	        //shortcut to getPageOffset for current page
	        this.getCurrentPageOffset = function()
	        {
	            return this.getPageOffset(settings.currentPageIndex);
	        };
	
	        //Returns the page dimensions of given page at the current zoom level
	        this.getPageDimensionsAtCurrentGridLevel = function(pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using getPageDimensionsAtCurrentZoomLevel(pageIndex) instead.");
	            return this.getPageDimensionsAtCurrentZoomLevel(pageIndex);
	        };
	
	        /*
	            Given a pageX and pageY value (as could be retreived from a jQuery event object),
	                returns either the page visible at that (x,y) position or -1 if no page is.
	        */
	        this.getPageIndexForPageXYValues = function(pageX, pageY)
	        {
	            //get the four edges of the outer element
	            var outerOffset = viewerState.outerElement.getBoundingClientRect();
	            var outerTop = outerOffset.top;
	            var outerLeft = outerOffset.left;
	            var outerBottom = outerOffset.bottom;
	            var outerRight = outerOffset.right;
	
	            //if the clicked position was outside the diva-outer object, it was not on a visible portion of a page
	            if (pageX < outerLeft || pageX > outerRight)
	                return -1;
	
	            if (pageY < outerTop || pageY > outerBottom)
	                return -1;
	
	            //navigate through all diva page objects
	            var pages = document.getElementsByClassName('diva-page');
	            var curPageIdx = pages.length;
	            while (curPageIdx--)
	            {
	                //get the offset for each page
	                var curPage = pages[curPageIdx];
	                var curOffset = curPage.getBoundingClientRect();
	
	                //if this point is outside the horizontal boundaries of the page, continue
	                if (pageX < curOffset.left || pageX > curOffset.right)
	                    continue;
	
	                //same with vertical boundaries
	                if (pageY < curOffset.top || pageY > curOffset.bottom)
	                    continue;
	
	                //if we made it through the above two, we found the page we're looking for
	                return curPage.getAttribute('data-index');
	            }
	
	            //if we made it through that entire while loop, we didn't click on a page
	            return -1;
	        };
	
	        /**
	         * Returns a URL for the image of the page at the given index. The
	         * optional size parameter supports setting the image width or height
	         * (default is full-sized).
	         */
	        this.getPageImageURL = function (pageIndex, size)
	        {
	            return settings.manifest.getPageImageURL(pageIndex, size);
	        };
	
	        //Pretty self-explanatory.
	        this.isVerticallyOriented = function()
	        {
	            return settings.verticallyOriented;
	        };
	
	        this.changeObject = function(objectData)
	        {
	            viewerState.loaded = false;
	            divaState.viewerCore.clear();
	
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            viewerState.options.objectData = objectData;
	
	            if (typeof objectData === 'object')
	            {
	                setTimeout(function ()
	                {
	                    loadObjectData(objectData);
	                });
	
	                return;
	            }
	
	            viewerState.throbberTimeoutID = setTimeout(function ()
	            {
	                $(settings.selector + 'throbber').show();
	            }, settings.throbberTimeout);
	
	            $.ajax({
	                url: settings.objectData,
	                cache: true,
	                dataType: 'json',
	                error: ajaxError,
	                success: function (responseData)
	                {
	                    loadObjectData(responseData);
	                }
	            });
	        };
	
	        this.activate = function ()
	        {
	            viewerState.isActiveDiva = true;
	        };
	
	        this.deactivate = function ()
	        {
	            viewerState.isActiveDiva = false;
	        };
	
	        // Destroys this instance, tells plugins to do the same (for testing)
	        this.destroy = function ()
	        {
	            divaState.viewerCore.destroy();
	        };
	
	        // "Secretly" expose the page overlay API for the highlight plugin
	        this.__addPageOverlay = function (overlay)
	        {
	            divaState.viewerCore.addPageOverlay(overlay);
	        };
	
	        this.__removePageOverlay = function (overlay)
	        {
	            divaState.viewerCore.removePageOverlay(overlay);
	        };
	
	        /**** Page Alias Functions ****/
	        /*
	         Main function. Will return the first of these three that
	         resolves to boolean true:
	         -Explicit alias as defined in pageAliases
	         -Result of pageAliasFunction
	         -originalPageIndex + 1 (to simulate the original mapping)
	
	         Else the function will return false.
	         */
	        this.getAliasForPageIndex = function(originalPageIndex)
	        {
	            var pageIndex = parseInt(originalPageIndex, 10);
	            return settings.pageAliases[pageIndex] || settings.pageAliasFunction(pageIndex) || pageIndex + 1;
	        };
	
	        /*
	         Returns the first page index found for a given aliased number or false if not found.
	         This may cause issues if a specific alias is found for multiple page indices; use getPageIndicesForAlias and reimplement functions as necessary if this is the case.
	         */
	        this.getPageIndexForAlias = function(aliasedNumber)
	        {
	            for(var idx = 0; idx < settings.numPages; idx++)
	            {
	                if(this.getAliasForPageIndex(idx) === aliasedNumber)
	                {
	                    return idx;
	                }
	            }
	            return false;
	        };
	
	        //Returns array of page indices for a given aliased number. Returns an empty array if none are found.
	        this.getPageIndicesForAlias = function(aliasedNumber)
	        {
	            var indexArr = [];
	            for(var idx = 0; idx < settings.numPages; idx++)
	            {
	                if(this.getAliasForPageIndex(idx) === aliasedNumber)
	                {
	                    indexArr.push(idx);
	                }
	            }
	            return indexArr;
	        };
	
	
	        //Maps the current page index to getAliasForPageIndex
	        this.getCurrentAliasedPageIndex = function()
	        {
	            return this.getAliasForPageIndex(settings.currentPageIndex);
	        };
	
	        //Wrapper for gotoPageByIndex, keeping the aliased numbers in mind
	        this.gotoPageByAliasedNumber = function(aliasedNumber, xAnchor, yAnchor)
	        {
	            return this.gotoPageByIndex(this.getPageIndexForAlias(aliasedNumber), xAnchor, yAnchor);
	        };
	
	        // Call the init function when this object is created.
	        init();
	    };
	
	    $.fn.diva = function (options)
	    {
	        return this.each(function ()
	        {
	            var divaParent = $(this);
	
	            // Return early if this element already has a plugin instance
	            if (divaParent.data('diva'))
	                return;
	
	            // Throw an error if the element is not in the DOM, since it causes some problems
	            if (!document.body.contains(this))
	                throw new Error('Diva could not be initialized because this element is not attached to the DOM');
	
	            // Otherwise, instantiate the document viewer
	            var diva = new Diva(this, options);
	            divaParent.data('diva', diva);
	        });
	    };
	})(jQuery);


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = elt;
	module.exports.setAttributes = setDOMAttributes;
	
	/**
	 * Convenience function to create a DOM element, set attributes on it, and
	 * append children. All arguments which are not of primitive type, are not
	 * arrays, and are not DOM nodes are treated as attribute hashes and are
	 * handled as described for setDOMAttributes. Children can either be a DOM
	 * node or a primitive value, which is converted to a text node. Arrays are
	 * handled recursively. Null and undefined values are ignored.
	 *
	 * Inspired by the ProseMirror helper of the same name.
	 */
	function elt(tag)
	{
	    var el = document.createElement(tag);
	    var args = Array.prototype.slice.call(arguments, 1);
	
	    while (args.length)
	    {
	        var arg = args.shift();
	        handleEltConstructorArg(el, arg);
	    }
	
	    return el;
	}
	
	function handleEltConstructorArg(el, arg)
	{
	    if (arg == null)
	        return;
	
	    if (typeof arg !== 'object' && typeof arg !== 'function')
	    {
	        // Coerce to string
	        el.appendChild(document.createTextNode(arg));
	    }
	    else if (arg instanceof window.Node)
	    {
	        el.appendChild(arg);
	    }
	    else if (arg instanceof Array)
	    {
	        var childCount = arg.length;
	        for (var i = 0; i < childCount; i++)
	            handleEltConstructorArg(el, arg[i]);
	    }
	    else
	    {
	        setDOMAttributes(el, arg);
	    }
	}
	
	/**
	 * Set attributes of a DOM element. The `style` property is special-cased to
	 * accept either a string or an object whose own attributes are assigned to
	 * el.style.
	 */
	function setDOMAttributes(el, attributes)
	{
	    for (var prop in attributes)
	    {
	        if (!attributes.hasOwnProperty(prop))
	            continue;
	
	        if (prop === 'style')
	        {
	            setStyle(el, attributes.style);
	        }
	        else
	        {
	            el.setAttribute(prop, attributes[prop]);
	        }
	    }
	}
	
	function setStyle(el, style)
	{
	    if (!style)
	        return;
	
	    if (typeof style !== 'object')
	    {
	        el.style.cssText = style;
	        return;
	    }
	
	    for (var cssProp in style)
	    {
	        if (!style.hasOwnProperty(cssProp))
	            continue;
	
	        el.style[cssProp] = style[cssProp];
	    }
	}


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports.get = getHashParam;
	module.exports.update = updateHashParam;
	
	// For getting the #key values from the URL. For specifying a page and zoom level
	// Look into caching, because we only need to get this during the initial load
	// Although for the tests I guess we would need to override caching somehow
	function getHashParam(key) {
	    var hash = window.location.hash;
	    if (hash !== '') {
	        // Check if there is something that looks like either &key= or #key=
	        var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	
	        // If startIndex is still -1, it means it can't find either
	        if (startIndex >= 0) {
	            // Add the length of the key plus the & and =
	            startIndex += key.length + 2;
	
	            // Either to the next ampersand or to the end of the string
	            var endIndex = hash.indexOf('&', startIndex);
	            if (endIndex > startIndex) {
	                return decodeURIComponent(hash.substring(startIndex, endIndex));
	            } else if (endIndex < 0) {
	                // This means this hash param is the last one
	                return decodeURIComponent(hash.substring(startIndex));
	            }
	            // If the key doesn't have a value I think
	            return '';
	        } else {
	            // If it can't find the key
	            return false;
	        }
	    } else {
	        // If there are no hash params just return false
	        return false;
	    }
	}
	
	function updateHashParam(key, value) {
	    // First make sure that we have to do any work at all
	    var originalValue = getHashParam(key);
	    var hash = window.location.hash;
	    if (originalValue !== value) {
	        // Is the key already in the URL?
	        if (typeof originalValue == 'string') {
	            // Already in the URL. Just get rid of the original value
	            var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	            var endIndex = startIndex + key.length + 2 + originalValue.length;
	            // # if it's the first, & otherwise
	            var startThing = (startIndex === 0) ? '#' : '&';
	            window.location.replace(hash.substring(0, startIndex) + startThing + key + '=' + value + hash.substring(endIndex));
	        } else {
	            // It's not present - add it
	            if (hash.length === 0) {
	                window.location.replace('#' + key + '=' + value);
	            } else {
	                // Append it
	                window.location.replace(hash + '&' + key + '=' + value);
	            }
	        }
	    }
	}


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var jQuery = __webpack_require__(3);
	
	//Used to keep track of whether Diva was last clicked or which Diva was last clicked when there are multiple
	var ActiveDivaController = (function ($)
	{
	    return function ()
	    {
	        var active;
	
	        //global click listener
	        $(document).on('click', function(e)
	        {
	            updateActive($(e.target));
	        });
	
	        //parameter should already be a jQuery selector
	        var updateActive = function (target)
	        {
	            var nearestOuter;
	
	            //these will find 0 or 1 objects, never more
	            var findOuter = target.find('.diva-outer');
	            var closestOuter = target.closest('.diva-outer');
	            var outers = document.getElementsByClassName('diva-outer');
	            var outerLen = outers.length;
	            var idx;
	
	            //clicked on something that was not either a parent or sibling of a diva-outer
	            if (findOuter.length > 0)
	            {
	                nearestOuter = findOuter;
	            }
	            //clicked on something that was a child of a diva-outer
	            else if (closestOuter.length > 0)
	            {
	                nearestOuter = closestOuter;
	            }
	            //clicked on something that was not in any Diva tree
	            else
	            {
	                //deactivate everything and return
	                for (idx = 0; idx < outerLen; idx++)
	                {
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	                }
	                return;
	            }
	
	            //if we found one, activate it...
	            nearestOuter.parent().parent().data('diva').activate();
	            active = nearestOuter.parent();
	
	            //...and deactivate all the others
	            outers = document.getElementsByClassName('diva-outer');
	            for(idx = 0; idx < outerLen; idx++)
	            {
	                //getAttribute to attr - comparing DOM element to jQuery element
	                if (outers[idx].getAttribute('id') != nearestOuter.attr('id'))
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	            }
	        };
	
	        //public accessor in case. Will return a jQuery selector.
	        this.getActive = function()
	        {
	            return active;
	        };
	    };
	})(jQuery);
	
	module.exports = ActiveDivaController;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused: true */
	
	var parseIIIFManifest = __webpack_require__(12);
	
	module.exports = ImageManifest;
	
	function ImageManifest(data, urlAdapter)
	{
	    // Save all the data we need
	    this.pages = data.pgs;
	    this.maxZoom = data.max_zoom;
	    this.maxRatio = data.dims.max_ratio;
	    this.minRatio = data.dims.min_ratio;
	    this.itemTitle = data.item_title;
	
	    // Only given for IIIF manifests
	    this.paged = !!data.paged;
	
	    // These are arrays, the index corresponding to the zoom level
	    this._maxWidths = data.dims.max_w;
	    this._maxHeights = data.dims.max_h;
	    this._averageWidths = data.dims.a_wid;
	    this._averageHeights = data.dims.a_hei;
	    this._totalHeights = data.dims.t_hei;
	    this._totalWidths = data.dims.t_wid;
	
	    this._urlAdapter = urlAdapter;
	}
	
	ImageManifest.fromIIIF = function (iiifManifest)
	{
	    var data = parseIIIFManifest(iiifManifest);
	    return new ImageManifest(data, new IIIFSourceAdapter());
	};
	
	ImageManifest.fromLegacyManifest = function (data, config)
	{
	    // For IIP manifests, use the page number (indexed starting from 1) as a label for each page
	    for (var i = 0, len = data.pgs.length; i < len; i++)
	        data.pgs[i].l = (i + 1).toString();
	
	    return new ImageManifest(data, new LegacyManifestSourceAdapter(config));
	};
	
	ImageManifest.prototype.isPageValid = function (pageIndex, showNonPagedPages)
	{
	    if (!showNonPagedPages && this.paged && !this.pages[pageIndex].paged)
	        return false;
	
	    return pageIndex >= 0 && pageIndex < this.pages.length;
	};
	
	ImageManifest.prototype.getMaxPageDimensions = function (pageIndex)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    return {
	        height: maxDims.h,
	        width: maxDims.w
	    };
	};
	
	ImageManifest.prototype.getPageDimensionsAtZoomLevel = function (pageIndex, zoomLevel)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    var scaleRatio = getScaleRatio(this.maxZoom, zoomLevel);
	
	    return {
	        height: maxDims.h * scaleRatio,
	        width: maxDims.w * scaleRatio
	    };
	};
	
	/**
	 * Returns a URL for the image of the given page. The optional size
	 * parameter supports setting the image width or height (default is
	 * full-sized).
	 */
	ImageManifest.prototype.getPageImageURL = function (pageIndex, size)
	{
	    return this._urlAdapter.getPageImageURL(this, pageIndex, size);
	};
	
	/**
	 * Return an array of tile objects for the specified page and integer zoom level
	 */
	ImageManifest.prototype.getPageImageTiles = function (pageIndex, zoomLevel, tileDimensions)
	{
	    var page = this.pages[pageIndex];
	
	    if (!isFinite(zoomLevel) || zoomLevel % 1 !== 0)
	        throw new TypeError('Zoom level must be an integer: ' + zoomLevel);
	
	    var rows = Math.ceil(page.d[zoomLevel].h / tileDimensions.height);
	    var cols = Math.ceil(page.d[zoomLevel].w / tileDimensions.width);
	
	    var tiles = [];
	
	    var row, col, url;
	
	    for (row = 0; row < rows; row++)
	    {
	        for (col = 0; col < cols; col++)
	        {
	            url = this._urlAdapter.getTileImageURL(this, pageIndex, {
	                row: row,
	                col: col,
	                rowCount: rows,
	                colCount: cols,
	                zoomLevel: zoomLevel,
	                tileDimensions: tileDimensions
	            });
	
	            // FIXME: Dimensions should account for partial tiles (e.g. the
	            // last row and column in a tiled image)
	            tiles.push({
	                row: row,
	                col: col,
	                zoomLevel: zoomLevel,
	                dimensions: {
	                    height: tileDimensions.height,
	                    width: tileDimensions.width
	                },
	                offset: {
	                    top: row * tileDimensions.height,
	                    left: col * tileDimensions.width
	                },
	                url: url
	            });
	        }
	    }
	
	    return {
	        zoomLevel: zoomLevel,
	        rows: rows,
	        cols: cols,
	        tiles: tiles
	    };
	};
	
	ImageManifest.prototype.getMaxWidth = zoomedPropertyGetter('_maxWidths');
	ImageManifest.prototype.getMaxHeight = zoomedPropertyGetter('_maxHeights');
	ImageManifest.prototype.getAverageWidth = zoomedPropertyGetter('_averageWidths');
	ImageManifest.prototype.getAverageHeight = zoomedPropertyGetter('_averageHeights');
	ImageManifest.prototype.getTotalWidth = zoomedPropertyGetter('_totalWidths');
	ImageManifest.prototype.getTotalHeight = zoomedPropertyGetter('_totalHeights');
	
	function zoomedPropertyGetter(privateName)
	{
	    return function (zoomLevel)
	    {
	        return this[privateName][zoomLevel];
	    };
	}
	
	function getScaleRatio(sourceZoomLevel, targetZoomLevel)
	{
	    return 1 / Math.pow(2, sourceZoomLevel - targetZoomLevel);
	}
	
	function IIIFSourceAdapter()
	{
	    // No-op
	}
	
	IIIFSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    var dimens;
	
	    if (!size || (size.width == null && size.height == null))
	        dimens = 'full';
	    else
	        dimens = (size.width == null ? '' : size.width) + ',' + (size.height == null ? '' : size.height);
	
	    var page = manifest.pages[pageIndex];
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + 'full/' + dimens + '/0/' + quality + '.jpg');
	};
	
	IIIFSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	
	    var height, width;
	
	    if (params.row === params.rowCount - 1)
	        height = page.d[params.zoomLevel].h - (params.rowCount - 1) * params.tileDimensions.height;
	    else
	        height = params.tileDimensions.height;
	
	    if (params.col === params.colCount - 1)
	        width = page.d[params.zoomLevel].w - (params.colCount - 1) * params.tileDimensions.width;
	    else
	        width = params.tileDimensions.width;
	
	    var zoomDifference = Math.pow(2, manifest.maxZoom - params.zoomLevel);
	
	    var x = params.col * params.tileDimensions.width * zoomDifference;
	    var y = params.row * params.tileDimensions.height * zoomDifference;
	
	    if (page.hasOwnProperty('xoffset'))
	    {
	        x += page.xoffset;
	        y += page.yoffset;
	    }
	
	    var region = [x, y, width * zoomDifference, height * zoomDifference].join(',');
	
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + region + '/' + width + ',' + height + '/0/' + quality + '.jpg');
	};
	
	function LegacyManifestSourceAdapter(config)
	{
	    this._config = config;
	}
	
	LegacyManifestSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    // Without width or height specified, IIPImage defaults to full-size
	    var dimens = '';
	
	    if (size)
	    {
	        if (size.width != null)
	            dimens += '&WID=' + size.width;
	
	        if (size.height != null)
	            dimens += '&HEI=' + size.height;
	    }
	
	    var filename = manifest.pages[pageIndex].f;
	
	    return this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + filename + dimens + '&CVT=JPEG';
	};
	
	LegacyManifestSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	    var requestedZoomLevel = params.zoomLevel + page.m - manifest.maxZoom;
	    var index = (params.row * params.colCount) + params.col;
	    var jtl = requestedZoomLevel + ',' + index;
	
	    return encodeURI(this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + page.f + '&JTL=' + jtl + '&CVT=JPEG');
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	/* jshint unused: true */
	"use strict"
	
	module.exports = parseIIIFManifest;
	
	var getMaxZoomLevel = function (width, height)
	{
	    var largestDimension = Math.max(width, height);
	    return Math.ceil(Math.log((largestDimension + 1) / (256 + 1)) / Math.log(2));
	};
	
	var incorporateZoom = function (imageDimension, zoomDifference)
	{
	    return imageDimension / (Math.pow(2, zoomDifference));
	};
	
	var getOtherImageData = function(otherImages, lowestMaxZoom, canvasWidth, canvasHeight)
	{
	    return otherImages.map(
	        function (itm)
	        {
	            var w = itm.width || canvasWidth;
	            var h = itm.height || canvasHeight;
	
	            var dims = new Array(lowestMaxZoom + 1);
	            for (var j = 0; j < lowestMaxZoom + 1; j++)
	            {
	                dims[j] = {
	                    h: Math.floor(incorporateZoom(h, lowestMaxZoom - j)),
	                    w: Math.floor(incorporateZoom(w, lowestMaxZoom - j))
	                };
	            }
	            return {
	                label: itm.label || "",
	                dims: dims
	            };
	        }
	    );
	};
	
	/**
	 * Parses a IIIF Presentation API Manifest and converts it into a Diva.js-format object
	 * (See https://github.com/DDMAL/diva.js/wiki/Development-notes#data-received-through-ajax-request)
	 * (This is a client-side re-implementation of generate_json.py)
	 *
	 * @param {Object} manifest - an object that represents a valid IIIF manifest
	 * @returns {Object} divaServiceBlock - the data needed by Diva to show a view of a single document
	 */
	function parseIIIFManifest(manifest)
	{
	    var sequence = manifest.sequences[0];
	    var canvases = sequence.canvases;
	    var numCanvases = canvases.length;
	
	    var pages = new Array(canvases.length);
	
	    var thisCanvas, thisResource, thisImage, otherImages, context, url, info, imageAPIVersion,
	        width, height, maxZoom, canvas, label, imageLabel, zoomDimensions, widthAtCurrentZoomLevel,
	        heightAtCurrentZoomLevel;
	
	    var lowestMaxZoom = 100;
	    var maxRatio = 0;
	    var minRatio = 100;
	
	    // quickly determine the lowest possible max zoom level (i.e., the upper bound for images) across all canvases.
	    // while we're here, compute the global ratios as well.
	    for (var z = 0; z < numCanvases; z++)
	    {
	        var c = canvases[z];
	        var w = c.width;
	        var h = c.height;
	        var mz = getMaxZoomLevel(w, h);
	        var ratio = w / h;
	        maxRatio = Math.max(ratio, maxRatio);
	        minRatio = Math.min(ratio, minRatio);
	
	        lowestMaxZoom = Math.min(lowestMaxZoom, mz);
	    }
	
	    // Uint8Arrays are pre-initialized with zeroes.
	    var totalWidths = new Uint8Array(lowestMaxZoom + 1);
	    var totalHeights = new Uint8Array(lowestMaxZoom + 1);
	    var maxWidths = new Uint8Array(lowestMaxZoom + 1);
	    var maxHeights = new Uint8Array(lowestMaxZoom + 1);
	
	    for (var i = 0; i < numCanvases; i++)
	    {
	        thisCanvas = canvases[i];
	        canvas = thisCanvas['@id'];
	        label = thisCanvas.label;
	        thisResource = thisCanvas.images[0].resource;
	
	        /*
	         * If a canvas has multiple images it will be encoded
	         * with a resource type of "oa:Choice". The primary image will be available
	         * on the 'default' key, with other images available under 'item.'
	         * */
	        if (thisResource['@type'] === "oa:Choice")
	        {
	            thisImage = thisResource.default;
	        }
	        else
	        {
	            thisImage = thisResource;
	        }
	
	        // Prioritize the canvas height / width first, since images may not have h/w
	        width = thisCanvas.width || thisImage.width;
	        height = thisCanvas.height || thisImage.height;
	        maxZoom = getMaxZoomLevel(width, height);
	
	        if (thisResource.item)
	        {
	            otherImages = getOtherImageData(thisResource.item, lowestMaxZoom, width, height);
	        }
	
	        imageLabel = thisImage.label || null;
	
	        info = parseImageInfo(thisImage);
	        url = info.url.slice(-1) === '/' ? info.url + '/' : info.url;  // append trailing slash to url if it's not there.
	
	        context = thisImage.service['@context'];
	
	        if (context === 'http://iiif.io/api/image/2/context.json')
	        {
	            imageAPIVersion = 2;
	        }
	        else if (context === 'http://library.stanford.edu/iiif/image-api/1.1/context.json')
	        {
	            imageAPIVersion = 1.1;
	        }
	        else
	        {
	            imageAPIVersion = 1.0;
	        }
	
	        zoomDimensions = new Array(lowestMaxZoom + 1);
	        for (var k = 0; k < lowestMaxZoom + 1; k++)
	        {
	            widthAtCurrentZoomLevel = Math.floor(incorporateZoom(width, lowestMaxZoom - k));
	            heightAtCurrentZoomLevel = Math.floor(incorporateZoom(height, lowestMaxZoom - k));
	            zoomDimensions[k] = {
	                h: heightAtCurrentZoomLevel,
	                w: widthAtCurrentZoomLevel
	            };
	
	            totalWidths[k] += widthAtCurrentZoomLevel;
	            totalHeights[k] += heightAtCurrentZoomLevel;
	            maxWidths[k] = Math.max(widthAtCurrentZoomLevel, maxWidths[k]);
	            maxHeights[k] = Math.max(heightAtCurrentZoomLevel, maxHeights[k])
	        }
	
	        pages[i] = {
	            d: zoomDimensions,
	            m: maxZoom,
	            l: label,         // canvas label ('page 1, page 2', etc.)
	            il: imageLabel,   // default image label ('primary image', 'UV light', etc.)
	            f: url,
	            url: url,
	            api: imageAPIVersion,
	            paged: thisCanvas.viewingHint !== 'non-paged',
	            facingPages: thisCanvas.viewingHint === 'facing-pages',
	            canvas: canvas,
	            otherImages: otherImages,
	            xoffset: info.x || null,
	            yoffset: info.y || null
	        };
	    }
	
	    var averageWidths = new Array(lowestMaxZoom + 1).fill(0);
	    var averageHeights = new Array(lowestMaxZoom + 1).fill(0);
	    for (var a = 0; a < lowestMaxZoom + 1; a++)
	    {
	        averageWidths[a] = totalWidths[a] / numCanvases;
	        averageHeights[a] = totalHeights[a] / numCanvases;
	    }
	
	    var dims = {
	        a_wid: averageWidths,
	        a_hei: averageHeights,
	        max_w: maxWidths,
	        max_h: maxHeights,
	        max_ratio: maxRatio,
	        min_ratio: minRatio,
	        t_hei: totalHeights,
	        t_wid: totalWidths
	    };
	
	    return {
	        item_title: manifest.label,
	        dims: dims,
	        max_zoom: lowestMaxZoom,
	        pgs: pages,
	        pages: manifest.viewingHint === 'paged' || sequence.viewingHint === 'paged'
	    };
	}
	
	/**
	 * Takes in a resource block from a canvas and outputs the following information associated with that resource:
	 * - Image URL
	 * - Image region to be displayed
	 *
	 * @param {Object} resource - an object representing the resource block of a canvas section in a IIIF manifest
	 * @returns {Object} imageInfo - an object containing image URL and region
	 */
	function parseImageInfo(resource)
	{
	    var url = resource['@id'];
	    var fragmentRegex = /#xywh=([0-9]+,[0-9]+,[0-9]+,[0-9]+)/;
	    var xywh = '';
	    var stripURL = true;
	
	    if (/\/([0-9]+,[0-9]+,[0-9]+,[0-9]+)\//.test(url))
	    {
	        // if resource in image API format, extract region x,y,w,h from URL (after 4th slash from last)
	        // matches coordinates in URLs of the form http://www.example.org/iiif/book1-page1/40,50,1200,1800/full/0/default.jpg
	        var urlArray = url.split('/');
	        xywh = urlArray[urlArray.length - 4];
	    }
	    else if (fragmentRegex.test(url))
	    {
	        // matches coordinates of the style http://www.example.org/iiif/book1/canvas/p1#xywh=50,50,320,240
	        var result = fragmentRegex.exec(url);
	        xywh = result[1];
	    }
	    else if (resource.service && resource.service['@id'])
	    {
	        // assume canvas size based on image size
	        url = resource.service['@id'];
	        // this URL excludes region parameters so we don't need to remove them
	        stripURL = false;
	    }
	
	    if (stripURL)
	    {
	        // extract URL up to identifier (we eliminate the last 5 parameters: /region/size/rotation/quality.format)
	        url = url.split('/').slice(0, -4).join('/');
	    }
	
	    var imageInfo = {
	        url: url
	    };
	
	    if (xywh.length)
	    {
	        // parse into separate components
	        var dimensions = xywh.split(',');
	        imageInfo.x = parseInt(dimensions[0], 10);
	        imageInfo.y = parseInt(dimensions[1], 10);
	        imageInfo.w = parseInt(dimensions[2], 10);
	        imageInfo.h = parseInt(dimensions[3], 10);
	    }
	
	    return imageInfo;
	}

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var diva = __webpack_require__(2);
	var elt = __webpack_require__(8);
	
	module.exports = createToolbar;
	
	function createToolbar(viewer)
	{
	    var settings = viewer.getSettings();
	
	    // FIXME(wabain): Temporarily copied from within Diva
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    /** Convenience function to subscribe to a Diva event */
	    var subscribe = function (event, callback)
	    {
	        diva.Events.subscribe(event, callback, settings.ID);
	    };
	
	    // Creates a toolbar button
	    var createButtonElement = function(name, label, callback)
	    {
	        var button = elt('button', {
	            type: 'button',
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-button',
	            title: label
	        });
	
	        if (callback)
	            button.addEventListener('click', callback, false);
	
	        return button;
	    };
	
	    // Higher-level function for creators of zoom and grid controls
	    var getResolutionControlCreator = function (config)
	    {
	        return function ()
	        {
	            var controls;
	
	            switch (settings[config.controllerSetting])
	            {
	                case 'slider':
	                    controls = config.createSlider();
	                    break;
	
	                case 'buttons':
	                    controls = config.createButtons();
	                    break;
	
	                default:
	                    // Don't display anything
	                    return null;
	            }
	
	            var wrapper = elt('span',
	                controls,
	                config.createLabel()
	            );
	
	            var updateWrapper = function ()
	            {
	                if (settings.inGrid === config.showInGrid)
	                    wrapper.style.display = 'inline';
	                else
	                    wrapper.style.display = 'none';
	            };
	
	            subscribe('ViewDidSwitch', updateWrapper);
	            subscribe('ObjectDidLoad', updateWrapper);
	
	            // Set initial value
	            updateWrapper();
	
	            return wrapper;
	        };
	    };
	
	    // Zoom controls
	    var createZoomControls = getResolutionControlCreator({
	        controllerSetting: 'enableZoomControls',
	        showInGrid: false,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('zoom-slider', {
	                step: 0.1,
	                value: settings.zoomLevel,
	                min: settings.minZoomLevel,
	                max: settings.maxZoomLevel
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var floatValue = parseFloat(this.value);
	                viewer.setZoomLevel(floatValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var floatValue = parseFloat(this.value);
	                if (floatValue !== settings.zoomLevel)
	                    viewer.setZoomLevel(floatValue);
	            });
	
	            var updateSlider = function ()
	            {
	                if (settings.zoomLevel !== $elem.val())
	                    $elem.val(settings.zoomLevel);
	            };
	
	            subscribe('ZoomLevelDidChange', updateSlider);
	            subscribe('ViewerDidLoad', function ()
	            {
	                elt.setAttributes(elem, {
	                    min: settings.minZoomLevel,
	                    max: settings.maxZoomLevel
	                });
	
	                updateSlider();
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('zoom-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel - 1);
	                }),
	                createButtonElement('zoom-in-button', 'Zoom In', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-zoom-label', 'zoom-label', 'Zoom level: ', 'zoom-level', settings.zoomLevel);
	            var textSpan = $(elem).find(settings.selector + 'zoom-level')[0];
	
	            var updateText = function ()
	            {
	                textSpan.textContent = settings.zoomLevel.toFixed(2);
	            };
	
	            subscribe('ZoomLevelDidChange', updateText);
	            subscribe('ViewerDidLoad', updateText);
	
	            return elem;
	        }
	    });
	
	    // Grid controls
	    var createGridControls = getResolutionControlCreator({
	        controllerSetting: 'enableGridControls',
	        showInGrid: true,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('grid-slider', {
	                value: settings.pagesPerRow,
	                min: settings.minPagesPerRow,
	                max: settings.maxPagesPerRow
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var intValue = parseInt(elem.value, 10);
	                viewer.setGridPagesPerRow(intValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var intValue = parseInt(elem.value, 10);
	                if (intValue !== settings.pagesPerRow)
	                    viewer.setGridPagesPerRow(intValue);
	            });
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                // Update the position of the handle within the slider
	                if (settings.pagesPerRow !== $elem.val())
	                    $elem.val(settings.pagesPerRow);
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('grid-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow - 1);
	                }),
	                createButtonElement('grid-in-button', 'Zoom In', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-grid-label', 'grid-label', 'Pages per row: ', 'pages-per-row', settings.pagesPerRow);
	            var textSpan = $(elem).find(settings.selector + 'pages-per-row')[0];
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                textSpan.textContent = settings.pagesPerRow;
	            });
	
	            return elem;
	        }
	    });
	
	    var createViewMenu = function()
	    {
	        var viewOptionsList = elt('div', elemAttrs('view-options'));
	
	        var changeViewButton = createButtonElement('view-icon', 'Change view', function ()
	        {
	            $(viewOptionsList).toggle();
	        });
	
	        $(document).mouseup(function (event)
	        {
	            var container = $(viewOptionsList);
	
	            if (!container.is(event.target) && container.has(event.target).length === 0 && event.target.id !== settings.ID + 'view-icon')
	            {
	                container.hide();
	            }
	        });
	
	        var selectView = function (view)
	        {
	            viewer.changeView(view);
	
	            //hide view menu
	            $(viewOptionsList).hide();
	        };
	
	        var updateViewMenu = function()
	        {
	            var viewIconClasses = ' diva-view-icon diva-button';
	
	            // display the icon of the mode we're currently in (?)
	            if (settings.inGrid)
	            {
	                changeViewButton.className = 'diva-grid-icon' + viewIconClasses;
	            }
	            else if (settings.inBookLayout)
	            {
	                changeViewButton.className = 'diva-book-icon' + viewIconClasses;
	            }
	            else
	            {
	                changeViewButton.className = 'diva-document-icon' + viewIconClasses;
	            }
	
	            var viewOptions = document.createDocumentFragment();
	
	            // then display document, book, and grid buttons in that order, excluding the current view
	            if (settings.inGrid || settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('document-icon', 'Document View', selectView.bind(null, 'document')));
	
	            if (settings.inGrid || !settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('book-icon', 'Book View', selectView.bind(null, 'book')));
	
	            if (!settings.inGrid)
	                viewOptions.appendChild(createButtonElement('grid-icon', 'Grid View', selectView.bind(null, 'grid')));
	
	            // remove old menu
	            while (viewOptionsList.firstChild)
	            {
	                viewOptionsList.removeChild(viewOptionsList.firstChild);
	            }
	
	            // insert new menu
	            viewOptionsList.appendChild(viewOptions);
	        };
	
	        subscribe('ViewDidSwitch', updateViewMenu);
	        subscribe('ObjectDidLoad', updateViewMenu);
	
	        return elt('div', elemAttrs('view-menu'),
	            changeViewButton,
	            viewOptionsList
	        );
	    };
	
	    var createSlider = function(name, options)
	    {
	        return elt('input', options, {
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-slider',
	            type: 'range'
	        });
	    };
	
	    var createLabel = function(name, id, label, innerName, innerValue)
	    {
	        return elt('div', {
	                id: settings.ID + id,
	                class: name + ' diva-label'
	            },
	            [
	                label,
	                elt('span', {
	                    id: settings.ID + innerName
	                }, innerValue)
	            ]);
	    };
	
	    var createPageNavigationControls = function ()
	    {
	        // Go to page form
	        var gotoForm = settings.enableGotoPage ? createGotoPageForm() : null;
	
	        return elt('span', elemAttrs('page-nav'),
	            createPageLabel(), // 'Page x of y' label
	            gotoForm
	        );
	    };
	
	    var createGotoPageForm = function ()
	    {
	        var gotoPageInput = elt('input', {
	            id: settings.ID + 'goto-page-input',
	            class: 'diva-input diva-goto-page-input',
	            autocomplete: 'off',
	            type: 'text'
	        });
	
	        var gotoPageSubmit = elt('input', {
	            id: settings.ID + 'goto-page-submit',
	            class: 'diva-button diva-button-text',
	            type: 'submit',
	            value: 'Go'
	        });
	
	        var inputSuggestions = elt('div', {
	                id: settings.ID + 'input-suggestions',
	                class: 'diva-input-suggestions'
	            }
	        );
	
	        var gotoForm = elt('form', {
	                id: settings.ID + 'goto-page',
	                class: 'diva-goto-form'
	            },
	            gotoPageInput,
	            gotoPageSubmit,
	            inputSuggestions
	        );
	
	        $(gotoForm).on('submit', function ()
	        {
	            var desiredPageLabel = gotoPageInput.value;
	
	            if (settings.onGotoSubmit && typeof settings.onGotoSubmit === "function")
	            {
	                var pageIndex = settings.onGotoSubmit(desiredPageLabel);
	                if (!viewer.gotoPageByIndex(pageIndex))
	                    alert("No page could be found with that label or page number");
	
	            }
	            else // Default if no function is specified in the settings
	            {
	                if (!viewer.gotoPageByLabel(desiredPageLabel))
	                    alert("No page could be found with that label or page number");
	            }
	
	            // Hide the suggestions
	            inputSuggestions.style.display = 'none';
	
	            // Prevent the default action of reloading the page
	            return false;
	        });
	
	        $(gotoPageInput).on('input focus', function ()
	        {
	            inputSuggestions.innerHTML = ''; // Remove all previous suggestions
	
	            var value = gotoPageInput.value;
	            var numSuggestions = 0;
	            if (settings.enableGotoSuggestions && value)
	            {
	                var pages = settings.manifest.pages;
	                for (var i = 0, len = pages.length; i < len && numSuggestions < 10; i++)
	                {
	                    if (pages[i].l.toLowerCase().indexOf(value.toLowerCase()) > -1)
	                    {
	                        var newInputSuggestion = elt('div', {
	                                class: 'diva-input-suggestion'
	                            },
	                            pages[i].l
	                        );
	
	                        inputSuggestions.appendChild(newInputSuggestion);
	
	                        numSuggestions++;
	                    }
	                }
	
	                // Show label suggestions
	                if (numSuggestions > 0)
	                    inputSuggestions.style.display = 'block';
	            }
	            else
	                inputSuggestions.style.display = 'none';
	        });
	
	        $(gotoPageInput).on('keydown', function (e)
	        {
	            var el;
	            if (e.keyCode === 13) // 'Enter' key
	            {
	                var active = $('.active', inputSuggestions);
	                if (active.length)
	                    gotoPageInput.value = active.text();
	
	            }
	            if (e.keyCode === 38) // Up arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var prevEl = el.prev();
	                if (prevEl.length)
	                {
	                    el.removeClass('active');
	                    prevEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:last', inputSuggestions).addClass('active');
	                }
	            }
	            else if (e.keyCode === 40) // Down arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var nextEl = el.next();
	                if (nextEl.length)
	                {
	                    el.removeClass('active');
	                    nextEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:first', inputSuggestions).addClass('active');
	                }
	            }
	        });
	
	        $(inputSuggestions).on('mousedown', '.diva-input-suggestion', function()
	        {
	            gotoPageInput.value = this.textContent;
	            inputSuggestions.style.display = 'none';
	            $(gotoPageInput).trigger('submit');
	        });
	
	        $(gotoPageInput).on('blur', function ()
	        {
	            // Hide label suggestions
	            inputSuggestions.style.display = 'none';
	        });
	
	        return gotoForm;
	    };
	
	    var createPageLabel = function()
	    {
	        // Current page
	        var currentPage = elt('span', {
	            id: settings.ID + 'current-page'
	        });
	
	        var updateCurrentPage = function ()
	        {
	            currentPage.textContent = viewer.getCurrentAliasedPageIndex();
	        };
	
	        subscribe('VisiblePageDidChange', updateCurrentPage);
	        subscribe('ViewerDidLoad', updateCurrentPage);
	
	        // Number of pages
	        var numPages = elt('span', {
	            id: settings.ID + 'num-pages'
	        });
	
	        var updateNumPages = function ()
	        {
	            numPages.textContent = settings.numPages;
	        };
	
	        subscribe('NumberOfPagesDidChange', updateNumPages);
	        subscribe('ObjectDidLoad', updateNumPages);
	
	        return elt('span', {
	                class: 'diva-page-label diva-label'
	            },
	            'Page ', currentPage, ' of ', numPages
	        );
	    };
	
	    var createToolbarButtonGroup = function ()
	    {
	        var buttons = [createViewMenu()];
	
	        if (settings.enableLinkIcon)
	            buttons.push(createLinkIcon());
	
	        if (settings.enableNonPagedVisibilityIcon)
	            buttons.push(createToggleNonPagedButton());
	
	        if (settings.enableFullscreen)
	            buttons.push(createFullscreenButton());
	
	        return elt('span', elemAttrs('toolbar-button-group'), buttons);
	    };
	
	    var createLinkIcon = function ()
	    {
	        var elem = createButtonElement('link-icon', 'Link to this page');
	        var linkIcon = $(elem);
	
	        linkIcon.on('click', function ()
	        {
	            $('body').prepend(
	                elt('div', {
	                    id: settings.ID + 'link-popup',
	                    class: 'diva-popup diva-link-popup'
	                }, [
	                    elt('input', {
	                        id: settings.ID + 'link-popup-input',
	                        class: 'diva-input',
	                        type: 'text',
	                        value: viewer.getCurrentURL()
	                    })
	                ])
	            );
	
	            if (settings.inFullscreen)
	            {
	                $(settings.selector + 'link-popup').addClass('in-fullscreen');
	            }
	            else
	            {
	                // Calculate the left and top offsets
	                var leftOffset = linkIcon.offset().left - 222 + linkIcon.outerWidth();
	                var topOffset = linkIcon.offset().top + linkIcon.outerHeight() - 1;
	
	                $(settings.selector + 'link-popup').css({
	                    'top': topOffset + 'px',
	                    'left': leftOffset + 'px'
	                });
	            }
	
	            // Catch onmouseup events outside of this div
	            $('body').mouseup(function (event)
	            {
	                var targetID = event.target.id;
	
	                if (targetID !== settings.ID + 'link-popup' && targetID !== settings.ID + 'link-popup-input')
	                    $(settings.selector + 'link-popup').remove();
	            });
	
	            // Also delete it upon scroll and page up/down key events
	            // FIXME(wabain): This is aggressive
	            settings.viewportObject.scroll(function ()
	            {
	                $(settings.selector + 'link-popup').remove();
	            });
	            $(settings.selector + 'link-popup input').click(function ()
	            {
	                $(this).focus().select();
	            });
	
	            return false;
	        });
	
	        return elem;
	    };
	
	    var createFullscreenButton = function ()
	    {
	        return createButtonElement('fullscreen-icon', 'Toggle fullscreen mode', function ()
	        {
	            viewer.toggleFullscreenMode();
	        });
	    };
	
	    var createToggleNonPagedButton = function ()
	    {
	        var getClassName = function()
	        {
	            return 'toggle-nonpaged-icon' + (viewer.getSettings().showNonPagedPages ? '-active' : '');
	        };
	
	        var toggleNonPagedButton = createButtonElement(getClassName(), 'Toggle visibility of non-paged pages', function()
	        {
	            viewer.toggleNonPagedPagesVisibility();
	            var newClassName = 'diva-' + getClassName();
	            this.className = this.className.replace(/diva-toggle-nonpaged-icon(-active)?/, newClassName);
	        });
	
	        var updateNonPagedButtonVisibility = function ()
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0; i < pages.length; i++)
	            {
	                if (settings.manifest.paged && !pages[i].paged)
	                {
	                    // Show the button, there is at least one non-paged page
	                    toggleNonPagedButton.style.display = 'inline-block';
	                    return;
	                }
	            }
	
	            // No non-paged pages were found, hide the button
	            toggleNonPagedButton.style.display = 'none';
	        };
	        subscribe('ObjectDidLoad', updateNonPagedButtonVisibility);
	
	        return toggleNonPagedButton;
	    };
	
	    // Handles all status updating etc (both fullscreen and not)
	    var init = function ()
	    {
	        var leftTools = [createZoomControls(), createGridControls()];
	        var rightTools = [createPageNavigationControls(), createToolbarButtonGroup()];
	
	        var tools = elt('div', elemAttrs('tools'),
	            elt('div', elemAttrs('tools-left'), leftTools),
	            elt('div', elemAttrs('tools-right'), rightTools)
	        );
	
	        settings.toolbarParentObject.prepend(tools);
	
	        // Handle entry to and exit from fullscreen mode
	        var switchMode = function ()
	        {
	            var toolsRightElement = document.getElementById(settings.ID + 'tools-right');
	            var pageNavElement = document.getElementById(settings.ID + 'page-nav');
	
	            if (!settings.inFullscreen)
	            {
	                // Leaving fullscreen
	                $(tools).removeClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to beginning of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.insertBefore(pageNavElement, toolsRightElement.firstChild);
	            }
	            else
	            {
	                // Entering fullscreen
	                $(tools).addClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to end of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.appendChild(pageNavElement);
	            }
	        };
	
	        subscribe('ModeDidSwitch', switchMode);
	        subscribe('ViewerDidLoad', switchMode);
	
	        var toolbar = {
	            element: tools,
	            closePopups: function ()
	            {
	                $('.diva-popup').css('display', 'none');
	            }
	        };
	
	        return toolbar;
	    };
	
	    return init();
	}


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	__webpack_require__(15);
	
	var elt = __webpack_require__(8);
	var getScrollbarWidth = __webpack_require__(16);
	
	var gestureEvents = __webpack_require__(17);
	var diva = __webpack_require__(2);
	var DocumentHandler = __webpack_require__(18);
	var GridHandler = __webpack_require__(22);
	var PageOverlayManager = __webpack_require__(23);
	var PluginRegistry = __webpack_require__(5);
	var Renderer = __webpack_require__(24);
	var getPageLayouts = __webpack_require__(34);
	var createSettingsView = __webpack_require__(39);
	var ValidationRunner = __webpack_require__(40);
	var Viewport = __webpack_require__(41);
	
	var debug = __webpack_require__(25)('diva:ViewerCore');
	
	module.exports = ViewerCore;
	
	// Define validations
	var optionsValidations = [
	    {
	        key: 'goDirectlyTo',
	        validate: function (value, settings)
	        {
	            if (value < 0 || value >= settings.manifest.pages.length)
	                return 0;
	        }
	    },
	    {
	        key: 'minPagesPerRow',
	        validate: function (value)
	        {
	            return Math.max(2, value);
	        }
	    },
	    {
	        key: 'maxPagesPerRow',
	        validate: function (value, settings)
	        {
	            return Math.max(value, settings.minPagesPerRow);
	        }
	    },
	    {
	        key: 'pagesPerRow',
	        validate: function (value, settings)
	        {
	            // Default to the maximum
	            if (value < settings.minPagesPerRow || value > settings.maxPagesPerRow)
	                return settings.maxPagesPerRow;
	        }
	    },
	    {
	        key: 'maxZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changing this value isn't really an error, it just depends on the
	            // source manifest
	            config.suppressWarning();
	
	            if (value < 0 || value > settings.manifest.maxZoom)
	                return settings.manifest.maxZoom;
	        }
	    },
	    {
	        key: 'minZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changes based on the manifest value shouldn't trigger a
	            // warning
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < 0 || value > settings.maxZoomLevel)
	                return 0;
	        }
	    },
	    {
	        key: 'zoomLevel',
	        validate: function (value, settings, config)
	        {
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < settings.minZoomLevel || value > settings.maxZoomLevel)
	                return settings.minZoomLevel;
	        }
	    }
	];
	
	function ViewerCore(element, options, publicInstance)
	{
	    var self = this;
	    var parentObject = $(element);
	
	    // Things that cannot be changed because of the way they are used by the script
	    // Many of these are declared with arbitrary values that are changed later on
	    var viewerState = {
	        currentPageIndex: 0,        // The current page in the viewport (center-most page)
	        horizontalOffset: 0,        // Distance from the center of the diva element to the top of the current page
	        horizontalPadding: 0,       // Either the fixed padding or adaptive padding
	        ID: null,                   // The prefix of the IDs of the elements (usually 1-diva-)
	        initialKeyScroll: false,    // Holds the initial state of enableKeyScroll
	        initialSpaceScroll: false,  // Holds the initial state of enableSpaceScroll
	        innerElement: null,         // The native .diva-outer DOM object
	        innerObject: {},            // $(settings.ID + 'inner'), for selecting the .diva-inner element
	        isActiveDiva: true,         // In the case that multiple diva panes exist on the same page, this should have events funneled to it.
	        isIIIF: false,              // Specifies whether objectData is in Diva native or IIIF Manifest format
	        isScrollable: true,         // Used in enable/disableScrollable public methods
	        isZooming: false,           // Flag to keep track of whether zooming is still in progress, for handleZoom
	        loaded: false,              // A flag for when everything is loaded and ready to go.
	        manifest: null,
	        mobileWebkit: false,        // Checks if the user is on a touch device (iPad/iPod/iPhone/Android)
	        numPages: 0,                // Number of pages in the array
	        oldZoomLevel: -1,           // Holds the previous zoom level after zooming in or out
	        options: options,
	        outerElement: null,         // The native .diva-outer DOM object
	        outerObject: {},            // $(settings.ID + 'outer'), for selecting the .diva-outer element
	        pageOverlays: new PageOverlayManager(),
	        pageTools: [],              // The plugins which are enabled as page tools
	        parentObject: parentObject, // JQuery object referencing the parent element
	        pendingManifestRequest: null, // Reference to the xhr request retrieving the manifest. Used to cancel the request on destroy()
	        plugins: [],                // Filled with the enabled plugins from the registry
	        renderer: null,
	        resizeTimer: -1,            // Holds the ID of the timeout used when resizing the window (for clearing)
	        scrollbarWidth: 0,          // Set to the actual scrollbar width in init()
	        selector: '',               // Uses the generated ID prefix to easily select elements
	        throbberTimeoutID: -1,      // Holds the ID of the throbber loading timeout
	        toolbar: null,              // Holds an object with some toolbar-related functions
	        verticalOffset: 0,          // Distance from the center of the diva element to the left side of the current page
	        verticalPadding: 0,         // Either the fixed padding or adaptive padding
	        viewHandler: null,
	        viewport: null,             // Object caching the viewport dimensions
	        viewportElement: null,
	        viewportObject: null
	    };
	
	    var settings = createSettingsView([options, viewerState]);
	
	    // Aliases for compatibilty
	    Object.defineProperties(settings, {
	        // Height of the document viewer pane
	        panelHeight: {
	            get: function ()
	            {
	                return viewerState.viewport.height;
	            }
	        },
	        // Width of the document viewer pane
	        panelWidth: {
	            get: function ()
	            {
	                return viewerState.viewport.width;
	            }
	        }
	    });
	
	    var optionsValidator = new ValidationRunner({
	        additionalProperties: [
	            {
	                key: 'manifest',
	                get: function ()
	                {
	                    return viewerState.manifest;
	                }
	            }
	        ],
	
	        validations: optionsValidations
	    });
	
	    var isValidOption = function (key, value)
	    {
	        return optionsValidator.isValid(key, value, viewerState.options);
	    };
	
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    var getPageData = function (pageIndex, attribute)
	    {
	        return settings.manifest.pages[pageIndex].d[settings.zoomLevel][attribute];
	    };
	
	    // Reset some settings and empty the viewport
	    var clearViewer = function ()
	    {
	        viewerState.viewport.top = 0;
	
	        // Clear all the timeouts to prevent undesired pages from loading
	        clearTimeout(viewerState.resizeTimer);
	    };
	
	    /**
	     * Update settings to match the specified options. Load the viewer,
	     * fire appropriate events for changed options.
	     */
	    var reloadViewer = function (newOptions)
	    {
	        var queuedEvents = [];
	
	        newOptions = optionsValidator.getValidatedOptions(settings, newOptions);
	
	        // Set the zoom level if valid and fire a ZoomLevelDidChange event
	        if (hasChangedOption(newOptions, 'zoomLevel'))
	        {
	            viewerState.oldZoomLevel = settings.zoomLevel;
	            viewerState.options.zoomLevel = newOptions.zoomLevel;
	            queuedEvents.push(["ZoomLevelDidChange", newOptions.zoomLevel]);
	        }
	
	        // Set the pages per row if valid and fire an event
	        if (hasChangedOption(newOptions, 'pagesPerRow'))
	        {
	            viewerState.options.pagesPerRow = newOptions.pagesPerRow;
	            queuedEvents.push(["GridRowNumberDidChange", newOptions.pagesPerRow]);
	        }
	
	        // Update verticallyOriented (no event fired)
	        if (hasChangedOption(newOptions, 'verticallyOriented'))
	            viewerState.options.verticallyOriented = newOptions.verticallyOriented;
	
	        // Show/Hide non-paged pages
	        if (hasChangedOption(newOptions, 'showNonPagedPages'))
	        {
	            viewerState.options.showNonPagedPages = newOptions.showNonPagedPages;
	        }
	
	        // Update page position (no event fired here)
	        if ('goDirectlyTo' in newOptions)
	        {
	            viewerState.options.goDirectlyTo = newOptions.goDirectlyTo;
	
	            if ('verticalOffset' in newOptions)
	                viewerState.verticalOffset = newOptions.verticalOffset;
	
	            if ('horizontalOffset' in newOptions)
	                viewerState.horizontalOffset = newOptions.horizontalOffset;
	        }
	        else
	        {
	            // Otherwise the default is to remain on the current page
	            viewerState.options.goDirectlyTo = settings.currentPageIndex;
	        }
	
	        if (hasChangedOption(newOptions, 'inGrid') || hasChangedOption(newOptions, 'inBookLayout'))
	        {
	            if ('inGrid' in newOptions)
	                viewerState.options.inGrid = newOptions.inGrid;
	
	            if ('inBookLayout' in newOptions)
	                viewerState.options.inBookLayout = newOptions.inBookLayout;
	
	            queuedEvents.push(["ViewDidSwitch", settings.inGrid]);
	        }
	
	        // Note: prepareModeChange() depends on inGrid and the vertical/horizontalOffset (for now)
	        if (hasChangedOption(newOptions, 'inFullscreen'))
	        {
	            viewerState.options.inFullscreen = newOptions.inFullscreen;
	            prepareModeChange(newOptions);
	            queuedEvents.push(["ModeDidSwitch", settings.inFullscreen]);
	        }
	
	        clearViewer();
	        updateViewHandlerAndRendering();
	
	        if (viewerState.renderer)
	        {
	            // TODO: The usage of padding variables is still really
	            // messy and inconsistent
	            var rendererConfig = {
	                pageLayouts: getPageLayouts(settings),
	                padding: getPadding(),
	                maxZoomLevel: settings.inGrid ? null : viewerState.manifest.maxZoom,
	                verticallyOriented: settings.verticallyOriented || settings.inGrid,
	            };
	
	            var viewportPosition = {
	                zoomLevel: settings.inGrid ? null : settings.zoomLevel,
	                anchorPage: settings.goDirectlyTo,
	                verticalOffset: viewerState.verticalOffset,
	                horizontalOffset: viewerState.horizontalOffset
	            };
	
	            var sourceProvider = getCurrentSourceProvider();
	
	            if (debug.enabled)
	            {
	                var serialized = Object.keys(rendererConfig)
	                    .filter(function (key)
	                    {
	                        // Too long
	                        return key !== 'pageLayouts' && key !== 'padding';
	                    })
	                    .map(function (key)
	                    {
	                        var value = rendererConfig[key];
	                        return key + ': ' + JSON.stringify(value);
	                    })
	                    .join(', ');
	
	                debug('reload with %s', serialized);
	            }
	
	            viewerState.renderer.load(rendererConfig, viewportPosition, sourceProvider);
	        }
	
	        queuedEvents.forEach(function (params)
	        {
	            publish.apply(null, params);
	        });
	
	        return true;
	    };
	
	    var hasChangedOption = function (options, key)
	    {
	        return key in options && options[key] !== settings[key];
	    };
	
	    // Handles switching in and out of fullscreen mode
	    var prepareModeChange = function (options)
	    {
	        // Toggle the classes
	        var changeClass = options.inFullscreen ? 'addClass' : 'removeClass';
	        viewerState.outerObject[changeClass]('diva-fullscreen');
	        $('body')[changeClass]('diva-hide-scrollbar');
	        settings.parentObject[changeClass]('diva-full-width');
	
	        // Adjust Diva's internal panel size, keeping the old values
	        var storedHeight = settings.panelHeight;
	        var storedWidth = settings.panelWidth;
	        viewerState.viewport.invalidate();
	
	        // If this isn't the original load, the offsets matter, and the position isn't being changed...
	        if (!viewerState.loaded && !settings.inGrid && !('verticalOffset' in options))
	        {
	            //get the updated panel size
	            var newHeight = settings.panelHeight;
	            var newWidth = settings.panelWidth;
	
	            //and re-center the new panel on the same point
	            viewerState.verticalOffset += ((storedHeight - newHeight) / 2);
	            viewerState.horizontalOffset += ((storedWidth - newWidth) / 2);
	        }
	
	        //turn on/off escape key listener
	        if (options.inFullscreen)
	            $(document).on('keyup', escapeListener);
	        else
	            $(document).off('keyup', escapeListener);
	    };
	
	    // Update the view handler and the view rendering for the current view
	    var updateViewHandlerAndRendering = function ()
	    {
	        var Handler = settings.inGrid ? GridHandler : DocumentHandler;
	
	        if (viewerState.viewHandler && !(viewerState.viewHandler instanceof Handler))
	        {
	            viewerState.viewHandler.destroy();
	            viewerState.viewHandler = null;
	        }
	
	        if (!viewerState.viewHandler)
	            viewerState.viewHandler = new Handler(self);
	
	        if (!viewerState.renderer)
	            initializeRenderer();
	    };
	
	    // TODO: This could probably be done upon ViewerCore initialization
	    var initializeRenderer = function ()
	    {
	        var compatErrors = Renderer.getCompatibilityErrors();
	
	        if (compatErrors)
	        {
	            showError(compatErrors);
	        }
	        else
	        {
	            var options = {
	                viewport: viewerState.viewport,
	                outerElement: viewerState.outerElement,
	                innerElement: viewerState.innerElement
	            };
	
	            var hooks = {
	                onViewWillLoad: function ()
	                {
	                    viewerState.viewHandler.onViewWillLoad();
	                },
	                onViewDidLoad: function ()
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidLoad();
	                },
	                onViewDidUpdate: function (pages, targetPage)
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidUpdate(pages, targetPage);
	                },
	                onViewDidTransition: function ()
	                {
	                    updatePageOverlays();
	                },
	                onPageWillLoad: function (pageIndex)
	                {
	                    publish('PageWillLoad', pageIndex);
	                }
	            };
	
	            viewerState.renderer = new Renderer(options, hooks);
	        }
	    };
	
	    var getCurrentSourceProvider = function ()
	    {
	        if (settings.inGrid)
	        {
	            var gridSourceProvider = {
	                getAllZoomLevelsForPage: function (page)
	                {
	                    return [gridSourceProvider.getBestZoomLevelForPage(page)];
	                },
	                getBestZoomLevelForPage: function (page)
	                {
	                    var url = settings.manifest.getPageImageURL(page.index, {
	                        width: page.dimensions.width
	                    });
	
	                    return {
	                        zoomLevel: 1, // FIXME
	                        rows: 1,
	                        cols: 1,
	                        tiles: [{
	                            url: url,
	                            zoomLevel: 1, // FIXME
	                            row: 0,
	                            col: 0,
	                            dimensions: page.dimensions,
	                            offset: {
	                                top: 0,
	                                left: 0
	                            }
	                        }]
	                    };
	                }
	            };
	
	            return gridSourceProvider;
	        }
	
	        var tileDimens = {
	            width: settings.tileWidth,
	            height: settings.tileHeight
	        };
	
	        return {
	            getBestZoomLevelForPage: function (page)
	            {
	                return settings.manifest.getPageImageTiles(page.index, Math.ceil(settings.zoomLevel), tileDimens);
	            },
	            getAllZoomLevelsForPage: function (page)
	            {
	                var levels = [];
	
	                var levelCount = viewerState.manifest.maxZoom;
	                for (var level=0; level <= levelCount; level++)
	                {
	                    levels.push(settings.manifest.getPageImageTiles(page.index, level, tileDimens));
	                }
	
	                levels.reverse();
	
	                return levels;
	            }
	        };
	    };
	
	    var getPadding = function ()
	    {
	        var topPadding, leftPadding;
	        var docVPadding, docHPadding;
	
	        if (settings.inGrid)
	        {
	            docVPadding = settings.fixedPadding;
	            topPadding = leftPadding = docHPadding = 0;
	        }
	        else
	        {
	            topPadding = settings.verticallyOriented ? viewerState.verticalPadding : 0;
	            leftPadding = settings.verticallyOriented ? 0 : viewerState.horizontalPadding;
	
	            docVPadding = settings.verticallyOriented ? 0 : viewerState.verticalPadding;
	            docHPadding = settings.verticallyOriented ? viewerState.horizontalPadding : 0;
	        }
	
	        return {
	            document: {
	                top: docVPadding,
	                bottom: docVPadding,
	                left: docHPadding,
	                right: docHPadding
	            },
	            page: {
	                top: topPadding,
	                bottom: 0,
	                left: leftPadding,
	                right: 0
	            }
	        };
	    };
	
	    var updatePageOverlays = function ()
	    {
	        viewerState.pageOverlays.updateOverlays(viewerState.renderer.getRenderedPages());
	    };
	
	    //Shortcut for closing fullscreen with the escape key
	    var escapeListener = function (e)
	    {
	        if (e.keyCode == 27)
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        }
	    };
	
	    // Called to handle any zoom level
	    var handleZoom = function (newZoomLevel, focalPoint)
	    {
	        // If the zoom level provided is invalid, return false
	        if (!isValidOption('zoomLevel', newZoomLevel))
	            return false;
	
	        // If no focal point was given, zoom on the center of the viewport
	        if (focalPoint == null)
	        {
	            var viewport = viewerState.viewport;
	            var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	            focalPoint = {
	                anchorPage: settings.currentPageIndex,
	                offset: {
	                    left: (viewport.width / 2) - (currentRegion.left - viewport.left),
	                    top: (viewport.height / 2) - (currentRegion.top - viewport.top)
	                }
	            };
	        }
	
	        var pageRegion = viewerState.renderer.layout.getPageRegion(focalPoint.anchorPage);
	
	        // calculate distance from cursor coordinates to center of viewport
	        var focalXToCenter = (pageRegion.left + focalPoint.offset.left) -
	            (settings.viewport.left + (settings.viewport.width / 2));
	        var focalYToCenter = (pageRegion.top + focalPoint.offset.top) -
	            (settings.viewport.top + (settings.viewport.height / 2));
	
	        function getPositionForZoomLevel(zoomLevel)
	        {
	            var zoomRatio = Math.pow(2, zoomLevel - initialZoomLevel);
	
	            //TODO(jeromepl): Calculate position from page top left to viewport top left
	            // calculate horizontal/verticalOffset: distance from viewport center to page upper left corner
	            var horizontalOffset = (focalPoint.offset.left * zoomRatio) - focalXToCenter;
	            var verticalOffset = (focalPoint.offset.top * zoomRatio) - focalYToCenter;
	
	            return {
	                zoomLevel: zoomLevel,
	                anchorPage: focalPoint.anchorPage,
	                verticalOffset: verticalOffset,
	                horizontalOffset: horizontalOffset
	            };
	        }
	
	        var initialZoomLevel = viewerState.oldZoomLevel = settings.zoomLevel;
	        viewerState.options.zoomLevel = newZoomLevel;
	
	        var endPosition = getPositionForZoomLevel(newZoomLevel);
	        viewerState.options.goDirectlyTo = endPosition.anchorPage;
	        viewerState.verticalOffset = endPosition.verticalOffset;
	        viewerState.horizontalOffset = endPosition.horizontalOffset;
	
	        viewerState.renderer.transitionViewportPosition({
	            duration: 300,
	            parameters: {
	                zoomLevel: {
	                    from: initialZoomLevel,
	                    to: newZoomLevel
	                }
	            },
	            getPosition: function (parameters)
	            {
	                return getPositionForZoomLevel(parameters.zoomLevel);
	            },
	            onEnd: function (info)
	            {
	                viewerState.viewportObject.scroll(scrollFunction);
	
	                if (info.interrupted)
	                    viewerState.oldZoomLevel = newZoomLevel;
	            }
	        });
	
	        // Update the slider
	        publish("ZoomLevelDidChange", newZoomLevel);
	
	        // While zooming, don't update scroll offsets based on the scaled version of diva-inner
	        viewerState.viewportObject.off('scroll');
	
	        return true;
	    };
	
	    /*
	     Gets the Y-offset for a specific point on a specific page
	     Acceptable values for "anchor":
	     "top" (default) - will anchor top of the page to the top of the diva-outer element
	     "bottom" - top, s/top/bottom
	     "center" - will center the page on the diva element
	     Returned value will be the distance from the center of the diva-outer element to the top of the current page for the specified anchor
	     */
	    var getYOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "center" || anchor === "centre") //how you can tell an American coded this
	        {
	            return parseInt(getPageData(pageIndex, "h") / 2, 10);
	        }
	        else if (anchor === "bottom")
	        {
	            return parseInt(getPageData(pageIndex, "h") - settings.panelHeight / 2, 10);
	        }
	        else
	        {
	            return parseInt(settings.panelHeight / 2, 10);
	        }
	    };
	
	    //Same as getYOffset with "left" and "right" as acceptable values instead of "top" and "bottom"
	    var getXOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "left")
	        {
	            return parseInt(settings.panelWidth / 2, 10);
	        }
	        else if (anchor === "right")
	        {
	            return parseInt(getPageData(pageIndex, "w") - settings.panelWidth / 2, 10);
	        }
	        else
	        {
	            return parseInt(getPageData(pageIndex, "w") / 2, 10);
	        }
	    };
	
	    // updates panelHeight/panelWidth on resize
	    var updatePanelSize = function ()
	    {
	        viewerState.viewport.invalidate();
	
	        // FIXME(wabain): This should really only be called after initial load
	        if (viewerState.renderer)
	        {
	            updateOffsets();
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        return true;
	    };
	
	    var updateOffsets = function ()
	    {
	        var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	        if (pageOffset)
	        {
	            viewerState.horizontalOffset = pageOffset.x;
	            viewerState.verticalOffset = pageOffset.y;
	        }
	    };
	
	    // Bind mouse events (drag to scroll, double-click)
	    var bindMouseEvents = function()
	    {
	        // Set drag scroll on first descendant of class dragger on both selected elements
	        viewerState.viewportObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	        viewerState.innerObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	
	        gestureEvents.onDoubleClick(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double click at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    var onResize = function()
	    {
	        updatePanelSize();
	        // Cancel any previously-set resize timeouts
	        clearTimeout(viewerState.resizeTimer);
	
	        viewerState.resizeTimer = setTimeout(function ()
	        {
	            var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            if (pageOffset)
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex,
	                    verticalOffset: pageOffset.y,
	                    horizontalOffset: pageOffset.x
	                });
	            }
	            else
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex
	                });
	            }
	        }, 200);
	    };
	
	    // Bind touch and orientation change events
	    var bindTouchEvents = function()
	    {
	        // Block the user from moving the window only if it's not integrated
	        if (settings.blockMobileMove)
	        {
	            $('body').bind('touchmove', function (event)
	            {
	                var e = event.originalEvent;
	                e.preventDefault();
	
	                return false;
	            });
	        }
	
	        // Touch events for swiping in the viewport to scroll pages
	        viewerState.viewportObject.kinetic({
	            triggerHardware: true
	        });
	
	        gestureEvents.onPinch(viewerState.viewportObject, function (event, coords, start, end)
	        {
	            debug('Pinch %s at %s, %s', end - start, coords.left, coords.top);
	            viewerState.viewHandler.onPinch(event, coords, start, end);
	        });
	
	        gestureEvents.onDoubleTap(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double tap at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    // Handle the scroll
	    var scrollFunction = function ()
	    {
	        var previousTopScroll = viewerState.viewport.top;
	        var previousLeftScroll = viewerState.viewport.left;
	
	        var direction;
	
	        viewerState.viewport.invalidate();
	
	        var newScrollTop = viewerState.viewport.top;
	        var newScrollLeft = viewerState.viewport.left;
	
	        if (settings.verticallyOriented || settings.inGrid)
	            direction = newScrollTop - previousTopScroll;
	        else
	            direction = newScrollLeft - previousLeftScroll;
	
	        //give adjust the direction we care about
	        viewerState.renderer.adjust(direction);
	
	        var primaryScroll = (settings.verticallyOriented || settings.inGrid) ? newScrollTop : newScrollLeft;
	
	        publish("ViewerDidScroll", primaryScroll);
	
	        if (direction > 0)
	        {
	            publish("ViewerDidScrollDown", primaryScroll);
	        }
	        else if (direction < 0)
	        {
	            publish("ViewerDidScrollUp", primaryScroll);
	        }
	
	        updateOffsets();
	    };
	
	    // Binds most of the event handlers (some more in createToolbar)
	    var handleEvents = function ()
	    {
	        // Change the cursor for dragging
	        viewerState.innerObject.mousedown(function ()
	        {
	            viewerState.innerObject.addClass('diva-grabbing');
	        });
	
	        viewerState.innerObject.mouseup(function ()
	        {
	            viewerState.innerObject.removeClass('diva-grabbing');
	        });
	
	        bindMouseEvents();
	
	        viewerState.viewportObject.scroll(scrollFunction);
	
	        var upArrowKey = 38,
	            downArrowKey = 40,
	            leftArrowKey = 37,
	            rightArrowKey = 39,
	            spaceKey = 32,
	            pageUpKey = 33,
	            pageDownKey = 34,
	            homeKey = 36,
	            endKey = 35;
	
	        // Catch the key presses in document
	        $(document).on('keydown.diva', function (event)
	        {
	            if (!viewerState.isActiveDiva)
	                return true;
	
	            // Space or page down - go to the next page
	            if ((settings.enableSpaceScroll && !event.shiftKey && event.keyCode === spaceKey) || (settings.enableKeyScroll && event.keyCode === pageDownKey))
	            {
	                viewerState.viewport.top += settings.panelHeight;
	                return false;
	            }
	            else if (!settings.enableSpaceScroll && event.keyCode === spaceKey)
	            {
	                event.preventDefault();
	            }
	
	            if (settings.enableKeyScroll)
	            {
	                // Don't steal keyboard shortcuts (metaKey = command [OS X], super [Win/Linux])
	                if (event.shiftKey || event.ctrlKey || event.metaKey)
	                    return true;
	
	                switch (event.keyCode)
	                {
	                    case pageUpKey:
	                        // Page up - go to the previous page
	                        viewerState.viewport.top -= settings.panelHeight;
	                        return false;
	
	                    case upArrowKey:
	                        // Up arrow - scroll up
	                        viewerState.viewport.top -= settings.arrowScrollAmount;
	                        return false;
	
	                    case downArrowKey:
	                        // Down arrow - scroll down
	                        viewerState.viewport.top += settings.arrowScrollAmount;
	                        return false;
	
	                    case leftArrowKey:
	                        // Left arrow - scroll left
	                        viewerState.viewport.left -= settings.arrowScrollAmount;
	                        return false;
	
	                    case rightArrowKey:
	                        // Right arrow - scroll right
	                        viewerState.viewport.left += settings.arrowScrollAmount;
	                        return false;
	
	                    case homeKey:
	                        // Home key - go to the beginning of the document
	                        viewerState.viewport.top = 0;
	                        return false;
	
	                    case endKey:
	                        // End key - go to the end of the document
	                        // Count on the viewport coordinate value being normalized
	                        if (settings.verticallyOriented)
	                            viewerState.viewport.top = Infinity;
	                        else
	                            viewerState.viewport.left = Infinity;
	
	                        return false;
	
	                    default:
	                        return true;
	                }
	            }
	            return true;
	        });
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            $(document).off('keydown.diva');
	        }, settings.ID);
	
	        bindTouchEvents();
	
	        // Handle window resizing events
	        window.addEventListener('resize', onResize, false);
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            window.removeEventListener('resize', onResize, false);
	        }, settings.ID);
	
	        // Handle orientation change separately
	        if ('onorientationchange' in window)
	        {
	            window.addEventListener('orientationchange', onResize, false);
	
	            diva.Events.subscribe('ViewerDidTerminate', function()
	            {
	                window.removeEventListener('orientationchange', onResize, false);
	            }, settings.ID);
	        }
	
	        diva.Events.subscribe('PanelSizeDidChange', updatePanelSize, settings.ID);
	
	        // Clear page and resize timeouts when the viewer is destroyed
	        diva.Events.subscribe('ViewerDidTerminate', function ()
	        {
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            clearTimeout(viewerState.resizeTimer);
	        }, settings.ID);
	    };
	
	    var initPlugins = function ()
	    {
	        // Add all the plugins that have not been explicitly disabled to
	        // settings.plugins
	        PluginRegistry.getAll().forEach(function (plugin)
	        {
	            var pluginProperName = plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1);
	
	            if (settings['enable' + pluginProperName])
	            {
	                // Call the init function and check return value
	                var enablePlugin = plugin.init(settings, publicInstance);
	
	                // If int returns false, consider the plugin disabled
	                if (!enablePlugin)
	                    return;
	
	                // Create the pageTools bar if handleClick is set to a function
	                if (typeof plugin.handleClick === 'function')
	                {
	                    viewerState.pageTools.push(plugin);
	                }
	
	                // Add it to settings.plugins so it can be used later
	                settings.plugins.push(plugin);
	            }
	        });
	    };
	
	    var showThrobber = function ()
	    {
	        hideThrobber();
	
	        viewerState.throbberTimeoutID = setTimeout(function ()
	        {
	            $(settings.selector + 'throbber').show();
	        }, settings.throbberTimeout);
	    };
	
	    var hideThrobber = function ()
	    {
	        // Clear the timeout, if it hasn't executed yet
	        clearTimeout(viewerState.throbberTimeoutID);
	
	        // Hide the throbber if it has already executed
	        $(settings.selector + 'throbber').hide();
	    };
	
	    var showError = function(message)
	    {
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    var setManifest = function (manifest, isIIIF, loadOptions)
	    {
	        viewerState.manifest = manifest;
	
	        // FIXME: is isIIIF even needed?
	        viewerState.isIIIF = isIIIF;
	
	        hideThrobber();
	
	        // Convenience value
	        viewerState.numPages = settings.manifest.pages.length;
	
	        optionsValidator.validate(viewerState.options);
	
	        publish('NumberOfPagesDidChange', settings.numPages);
	
	        if (settings.enableAutoTitle)
	        {
	            if ($(settings.selector + 'title').length)
	                $(settings.selector + 'title').html(settings.manifest.itemTitle);
	            else
	                settings.parentObject.prepend(elt('div', elemAttrs('title'), [settings.manifest.itemTitle]));
	        }
	
	        // Calculate the horizontal and vertical inter-page padding based on the dimensions of the average zoom level
	        if (settings.adaptivePadding > 0)
	        {
	            var z = Math.floor((settings.minZoomLevel + settings.maxZoomLevel) / 2);
	            viewerState.horizontalPadding = parseInt(settings.manifest.getAverageWidth(z) * settings.adaptivePadding, 10);
	            viewerState.verticalPadding = parseInt(settings.manifest.getAverageHeight(z) * settings.adaptivePadding, 10);
	        }
	        else
	        {
	            // It's less than or equal to 0; use fixedPadding instead
	            viewerState.horizontalPadding = settings.fixedPadding;
	            viewerState.verticalPadding = settings.fixedPadding;
	        }
	
	        // Make sure the vertical padding is at least 40, if plugin icons are enabled
	        if (viewerState.pageTools.length)
	        {
	            viewerState.verticalPadding = Math.max(40, viewerState.verticalPadding);
	        }
	
	        // If we detect a viewingHint of 'paged' in the manifest or sequence, enable book view by default
	        if (settings.manifest.paged)
	        {
	            viewerState.options.inBookLayout = true;
	        }
	
	        // Plugin setup hooks should be bound to the ObjectDidLoad event
	        publish('ObjectDidLoad', settings);
	
	        // Adjust the document panel dimensions
	        updatePanelSize();
	
	        var needsXCoord, needsYCoord;
	
	        var anchoredVertically = false;
	        var anchoredHorizontally = false;
	
	        if (loadOptions.goDirectlyTo == null)
	        {
	            loadOptions.goDirectlyTo = settings.goDirectlyTo;
	            needsXCoord = needsYCoord = true;
	        }
	        else
	        {
	            needsXCoord = loadOptions.horizontalOffset == null || isNaN(loadOptions.horizontalOffset);
	            needsYCoord = loadOptions.verticalOffset == null || isNaN(loadOptions.verticalOffset);
	        }
	
	        // Set default values for the horizontal and vertical offsets
	        if (needsXCoord)
	        {
	            // FIXME: What if inBookLayout/verticallyOriented is changed by loadOptions?
	            if (loadOptions.goDirectlyTo === 0 && settings.inBookLayout && settings.verticallyOriented)
	            {
	                // if in book layout, center the first opening by default
	                loadOptions.horizontalOffset = viewerState.horizontalPadding;
	            }
	            else
	            {
	                anchoredHorizontally = true;
	                loadOptions.horizontalOffset = getXOffset(loadOptions.goDirectlyTo, "center");
	            }
	        }
	
	        if (needsYCoord)
	        {
	            anchoredVertically = true;
	            loadOptions.verticalOffset = getYOffset(loadOptions.goDirectlyTo, "top");
	        }
	
	        reloadViewer(loadOptions);
	
	        //prep dimensions one last time now that pages have loaded
	        updatePanelSize();
	
	        // FIXME: This is a hack to ensure that the outerElement scrollbars are taken into account
	        if (settings.verticallyOriented)
	            viewerState.innerElement.style.minWidth = settings.panelWidth + 'px';
	        else
	            viewerState.innerElement.style.minHeight = settings.panelHeight + 'px';
	
	        // FIXME: If the page was supposed to be positioned relative to the viewport we need to
	        // recalculate it to take into account the scrollbars
	        if (anchoredVertically || anchoredHorizontally)
	        {
	            if (anchoredVertically)
	                viewerState.verticalOffset = getYOffset(settings.currentPageIndex, "top");
	
	            if (anchoredHorizontally)
	                viewerState.horizontalOffset = getXOffset(settings.currentPageIndex, "center");
	
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        // signal that everything should be set up and ready to go.
	        viewerState.loaded = true;
	
	        publish("ViewerDidLoad", settings);
	    };
	
	    var publish = function (event)
	    {
	        var args = Array.prototype.slice.call(arguments, 1);
	        diva.Events.publish(event, args, publicInstance);
	    };
	
	    var init = function ()
	    {
	        // First figure out the width of the scrollbar in this browser
	        // TODO(wabain): Cache this somewhere else
	        // Only some of the plugins rely on this now
	        viewerState.scrollbarWidth = getScrollbarWidth();
	
	        // If window.orientation is defined, then it's probably mobileWebkit
	        viewerState.mobileWebkit = window.orientation !== undefined;
	
	        // Generate an ID that can be used as a prefix for all the other IDs
	        var idNumber = generateId();
	        viewerState.ID = 'diva-' + idNumber + '-';
	        viewerState.selector = '#' + settings.ID;
	
	        if (options.hashParamSuffix === null)
	        {
	            // Omit the suffix from the first instance
	            if (idNumber === 1)
	                options.hashParamSuffix = '';
	            else
	                options.hashParamSuffix = idNumber + '';
	        }
	
	        // Create the inner and outer panels
	        var innerElem = elt('div', elemAttrs('inner', { class: 'diva-inner diva-dragger' }));
	        var viewportElem = elt('div', elemAttrs('viewport'), innerElem);
	        var outerElem = elt('div', elemAttrs('outer'),
	            viewportElem,
	            elt('div', elemAttrs('throbber')));
	
	        viewerState.innerElement = innerElem;
	        viewerState.viewportElement = viewportElem;
	        viewerState.outerElement = outerElem;
	
	        viewerState.innerObject = $(innerElem);
	        viewerState.viewportObject = $(viewportElem);
	        viewerState.outerObject = $(outerElem);
	
	        settings.parentObject.append(outerElem);
	
	        viewerState.viewport = new Viewport(viewerState.viewportElement, {
	            intersectionTolerance: settings.viewportMargin
	        });
	
	        // Do all the plugin initialisation
	        initPlugins();
	
	        handleEvents();
	
	        // Show the throbber while waiting for the manifest to load
	        showThrobber();
	    };
	
	    this.getSettings = function ()
	    {
	        return settings;
	    };
	
	    // Temporary accessor for the state of the viewer core
	    // TODO: Replace this with a more restricted view of whatever needs
	    // be exposed through settings for backwards compat
	    this.getInternalState = function ()
	    {
	        return viewerState;
	    };
	
	    this.getPublicInstance = function ()
	    {
	        return publicInstance;
	    };
	
	    this.getPageTools = function ()
	    {
	        return viewerState.pageTools;
	    };
	
	    this.getCurrentLayout = function ()
	    {
	        return viewerState.renderer ? viewerState.renderer.layout : null;
	    };
	
	    /** Get a copy of the current viewport dimensions */
	    this.getViewport = function ()
	    {
	        var viewport = viewerState.viewport;
	
	        return {
	            top: viewport.top,
	            left: viewport.left,
	            bottom: viewport.bottom,
	            right: viewport.right,
	
	            width: viewport.width,
	            height: viewport.height
	        };
	    };
	
	    this.addPageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.addOverlay(overlay);
	    };
	
	    this.removePageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.removeOverlay(overlay);
	    };
	
	    this.getPageRegion = function (pageIndex, options)
	    {
	        var layout = viewerState.renderer.layout;
	        var region = layout.getPageRegion(pageIndex, options);
	
	        if (options && options.incorporateViewport)
	        {
	            var secondaryDim = settings.verticallyOriented ? 'width' : 'height';
	
	            if (viewerState.viewport[secondaryDim] > layout.dimensions[secondaryDim])
	            {
	                var docOffset = (viewerState.viewport[secondaryDim] - layout.dimensions[secondaryDim]) / 2;
	
	                if (settings.verticallyOriented)
	                {
	                    return {
	                        top: region.top,
	                        bottom: region.bottom,
	
	                        left: region.left + docOffset,
	                        right: region.right + docOffset
	                    };
	                }
	                else
	                {
	                    return {
	                        top: region.top + docOffset,
	                        bottom: region.bottom + docOffset,
	
	                        left: region.left,
	                        right: region.right
	                    };
	                }
	            }
	        }
	
	        return region;
	    };
	
	    this.getPagePositionAtViewportOffset = function (coords)
	    {
	        var docCoords = {
	            left: coords.left + viewerState.viewport.left,
	            top: coords.top + viewerState.viewport.top
	        };
	
	        var renderedPages = viewerState.renderer.getRenderedPages();
	        var pageCount = renderedPages.length;
	
	        // Find the page on which the coords occur
	        for (var i=0; i < pageCount; i++)
	        {
	            var pageIndex = renderedPages[i];
	            var region = viewerState.renderer.layout.getPageRegion(pageIndex);
	
	            if (region.left <= docCoords.left && region.right >= docCoords.left &&
	                region.top <= docCoords.top && region.bottom >= docCoords.top)
	            {
	                return {
	                    anchorPage: pageIndex,
	                    offset: {
	                        left: docCoords.left - region.left,
	                        top: docCoords.top - region.top
	                    }
	                };
	            }
	        }
	
	        // Fall back to current page
	        // FIXME: Would be better to use the closest page or something
	        var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	        return {
	            anchorPage: settings.currentPageIndex,
	            offset: {
	                left: docCoords.left - currentRegion.left,
	                top: docCoords.top - currentRegion.top
	            }
	        };
	    };
	
	    this.setManifest = function (manifest, isIIIF, loadOptions)
	    {
	        setManifest(manifest, isIIIF, loadOptions || {});
	    };
	
	    /**
	     * Set the current page to the given index, firing VisiblePageDidChange
	     *
	     * @param pageIndex
	     */
	    this.setCurrentPage = function (pageIndex)
	    {
	        if (viewerState.currentPageIndex !== pageIndex)
	        {
	            viewerState.currentPageIndex = pageIndex;
	            publish("VisiblePageDidChange", pageIndex, this.getPageName(pageIndex));
	        }
	    };
	
	    this.getPageName = function (pageIndex)
	    {
	        return viewerState.manifest.pages[pageIndex].f;
	    };
	
	    this.reload = function (newOptions)
	    {
	        reloadViewer(newOptions);
	    };
	
	    this.zoom = function (zoomLevel, focalPoint)
	    {
	        return handleZoom(zoomLevel, focalPoint);
	    };
	
	    this.enableScrollable = function ()
	    {
	        if (!viewerState.isScrollable)
	        {
	            bindMouseEvents();
	            viewerState.options.enableKeyScroll = viewerState.initialKeyScroll;
	            viewerState.options.enableSpaceScroll = viewerState.initialSpaceScroll;
	            viewerState.viewportElement.style.overflow = 'auto';
	            viewerState.isScrollable = true;
	        }
	    };
	
	    this.disableScrollable = function ()
	    {
	        if (viewerState.isScrollable)
	        {
	            // block dragging/double-click zooming
	            if (viewerState.innerObject.hasClass('diva-dragger'))
	                viewerState.innerObject.unbind('mousedown');
	            viewerState.outerObject.unbind('dblclick');
	            viewerState.outerObject.unbind('contextmenu');
	
	            // disable all other scrolling actions
	            viewerState.viewportElement.style.overflow = 'hidden';
	
	            // block scrolling keys behavior, respecting initial scroll settings
	            viewerState.initialKeyScroll = settings.enableKeyScroll;
	            viewerState.initialSpaceScroll = settings.enableSpaceScroll;
	            viewerState.options.enableKeyScroll = false;
	            viewerState.options.enableSpaceScroll = false;
	
	            viewerState.isScrollable = false;
	        }
	    };
	
	    this.isValidOption = function (key, value)
	    {
	        return isValidOption(key, value);
	    };
	
	    this.showError = function (message)
	    {
	        // FIXME: Not totally sure it makes sense to always do that here
	        hideThrobber();
	
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    this.getXOffset = function (pageIndex, xAnchor)
	    {
	        return getXOffset(pageIndex, xAnchor);
	    };
	
	    this.getYOffset = function (pageIndex, yAnchor)
	    {
	        return getYOffset(pageIndex, yAnchor);
	    };
	
	    this.publish = publish;
	
	    this.clear = function ()
	    {
	        clearViewer();
	    };
	
	    this.setPendingManifestRequest = function (pendingManifestRequest)
	    {
	        viewerState.pendingManifestRequest = pendingManifestRequest;
	    };
	
	    // Destroys this instance, tells plugins to do the same (for testing)
	    this.destroy = function ()
	    {
	        // Useful event to access elements in diva before they get destroyed. Used by the highlight plugin.
	        publish('ViewerWillTerminate', settings);
	
	        // Cancel any pending request retrieving a manifest
	        if (settings.pendingManifestRequest)
	            settings.pendingManifestRequest.abort();
	
	        // Removes the hide-scrollbar class from the body
	        $('body').removeClass('diva-hide-scrollbar');
	
	        // Empty the parent container and remove any diva-related data
	        settings.parentObject.parent().empty().removeData('diva');
	
	        // Remove any additional styling on the parent element
	        settings.parentObject.parent().removeAttr('style').removeAttr('class');
	
	        publish('ViewerDidTerminate', settings);
	
	        // Clear the Events cache
	        diva.Events.unsubscribeAll(settings.ID);
	    };
	
	    // Call the init function when this object is created.
	    init();
	}
	
	generateId.counter = 1;
	
	function generateId() {
	    return generateId.counter++;
	}


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused: false */
	
	var jQuery = __webpack_require__(3);
	
	/* istanbul ignore next This is a vendored dependency */
	/*
	 * jQuery dragscrollable Plugin
	 * version: 1.0 (25-Jun-2009)
	 * Copyright (c) 2009 Miquel Herrera
	 * http://plugins.jquery.com/project/Dragscrollable
	 *
	 * Dual licensed under the MIT and GPL licenses:
	 *   http://www.opensource.org/licenses/mit-license.php
	 *   http://www.gnu.org/licenses/gpl.html
	 *
	 */
	(function ($) { // secure $ jQuery alias
	
	    /**
	     * Adds the ability to manage elements scroll by dragging
	     * one or more of its descendant elements. Options parameter
	     * allow to specifically select which inner elements will
	     * respond to the drag events.
	     *
	     * options properties:
	     * ------------------------------------------------------------------------
	     *  dragSelector         | jquery selector to apply to each wrapped element
	     *                       | to find which will be the dragging elements.
	     *                       | Defaults to '>:first' which is the first child of
	     *                       | scrollable element
	     * ------------------------------------------------------------------------
	     *  acceptPropagatedEvent| Will the dragging element accept propagated
	     *                       | events? default is yes, a propagated mouse event
	     *                       | on a inner element will be accepted and processed.
	     *                       | If set to false, only events originated on the
	     *                       | draggable elements will be processed.
	     * ------------------------------------------------------------------------
	     *  preventDefault       | Prevents the event to propagate further effectivey
	     *                       | dissabling other default actions. Defaults to true
	     * ------------------------------------------------------------------------
	     *
	     *  usage examples:
	     *
	     *  To add the scroll by drag to the element id=viewport when dragging its
	     *  first child accepting any propagated events
	     *  $('#viewport').dragscrollable();
	     *
	     *  To add the scroll by drag ability to any element div of class viewport
	     *  when dragging its first descendant of class dragMe responding only to
	     *  evcents originated on the '.dragMe' elements.
	     *  $('div.viewport').dragscrollable({dragSelector:'.dragMe:first',
	 *                                    acceptPropagatedEvent: false});
	     *
	     *  Notice that some 'viewports' could be nested within others but events
	     *  would not interfere as acceptPropagatedEvent is set to false.
	     *
	     */
	    $.fn.dragscrollable = function( options ){
	
	        var settings = $.extend(
	            {
	                dragSelector:'>:first',
	                acceptPropagatedEvent: true,
	                preventDefault: true
	            },options || {});
	
	
	        var dragscroll= {
	            mouseDownHandler : function(event) {
	                // mousedown, left click, check propagation
	                if (event.which!=1 ||
	                    (!event.data.acceptPropagatedEvent && event.target != this)){
	                    return false;
	                }
	
	                // Initial coordinates will be the last when dragging
	                event.data.lastCoord = {left: event.clientX, top: event.clientY};
	
	                $.event.add( document, "mouseup",
	                    dragscroll.mouseUpHandler, event.data );
	                $.event.add( document, "mousemove",
	                    dragscroll.mouseMoveHandler, event.data );
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            },
	            mouseMoveHandler : function(event) { // User is dragging
	                // How much did the mouse move?
	                var delta = {left: (event.clientX - event.data.lastCoord.left),
	                    top: (event.clientY - event.data.lastCoord.top)};
	
	                // Set the scroll position relative to what ever the scroll is now
	                event.data.scrollable.scrollLeft(
	                    event.data.scrollable.scrollLeft() - delta.left);
	                event.data.scrollable.scrollTop(
	                    event.data.scrollable.scrollTop() - delta.top);
	
	                // Save where the cursor is
	                event.data.lastCoord={left: event.clientX, top: event.clientY};
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	
	            },
	            mouseUpHandler : function(event) { // Stop scrolling
	                $.event.remove( document, "mousemove", dragscroll.mouseMoveHandler);
	                $.event.remove( document, "mouseup", dragscroll.mouseUpHandler);
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            }
	        };
	
	        // set up the initial events
	        this.each(function() {
	            // closure object data for each scrollable element
	            var data = {scrollable : $(this),
	                acceptPropagatedEvent : settings.acceptPropagatedEvent,
	                preventDefault : settings.preventDefault };
	            // Set mouse initiating event on the desired descendant
	            $(this).find(settings.dragSelector).
	            bind('mousedown', data, dragscroll.mouseDownHandler);
	        });
	    }; //end plugin dragscrollable
	
	})( jQuery ); // confine scope
	
	/* istanbul ignore next This is a vendored dependency */
	/**
	 jQuery.kinetic v2.2.1
	 Dave Taylor http://davetayls.me
	
	 @license The MIT License (MIT)
	 @preserve Copyright (c) 2012 Dave Taylor http://davetayls.me
	 */
	(function ($){
	    'use strict';
	
	    var ACTIVE_CLASS = 'kinetic-active';
	
	    /**
	     * Provides requestAnimationFrame in a cross browser way.
	     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	     */
	    if (!window.requestAnimationFrame){
	
	        window.requestAnimationFrame = ( function (){
	
	            return window.webkitRequestAnimationFrame ||
	                window.mozRequestAnimationFrame ||
	                window.oRequestAnimationFrame ||
	                window.msRequestAnimationFrame ||
	                function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
	                    window.setTimeout(callback, 1000 / 60);
	                };
	
	        }());
	
	    }
	
	    // add touch checker to jQuery.support
	    $.support = $.support || {};
	    $.extend($.support, {
	        touch: 'ontouchend' in document
	    });
	
	
	    // KINETIC CLASS DEFINITION
	    // ======================
	
	    var Kinetic = function (element, settings) {
	        this.settings = settings;
	        this.el       = element;
	        this.$el      = $(element);
	
	        this._initElements();
	
	        return this;
	    };
	
	    Kinetic.DATA_KEY = 'kinetic';
	    Kinetic.DEFAULTS = {
	        cursor: 'move',
	        decelerate: true,
	        triggerHardware: false,
	        threshold: 0,
	        y: true,
	        x: true,
	        slowdown: 0.9,
	        maxvelocity: 40,
	        throttleFPS: 60,
	        invert: false,
	        movingClass: {
	            up: 'kinetic-moving-up',
	            down: 'kinetic-moving-down',
	            left: 'kinetic-moving-left',
	            right: 'kinetic-moving-right'
	        },
	        deceleratingClass: {
	            up: 'kinetic-decelerating-up',
	            down: 'kinetic-decelerating-down',
	            left: 'kinetic-decelerating-left',
	            right: 'kinetic-decelerating-right'
	        }
	    };
	
	
	    // Public functions
	
	    Kinetic.prototype.start = function (options){
	        this.settings = $.extend(this.settings, options);
	        this.velocity = options.velocity || this.velocity;
	        this.velocityY = options.velocityY || this.velocityY;
	        this.settings.decelerate = false;
	        this._move();
	    };
	
	    Kinetic.prototype.end = function (){
	        this.settings.decelerate = true;
	    };
	
	    Kinetic.prototype.stop = function (){
	        this.velocity = 0;
	        this.velocityY = 0;
	        this.settings.decelerate = true;
	        if ($.isFunction(this.settings.stopped)){
	            this.settings.stopped.call(this);
	        }
	    };
	
	    Kinetic.prototype.detach = function (){
	        this._detachListeners();
	        this.$el
	            .removeClass(ACTIVE_CLASS)
	            .css('cursor', '');
	    };
	
	    Kinetic.prototype.attach = function (){
	        if (this.$el.hasClass(ACTIVE_CLASS)) {
	            return;
	        }
	        this._attachListeners(this.$el);
	        this.$el
	            .addClass(ACTIVE_CLASS)
	            .css('cursor', this.settings.cursor);
	    };
	
	
	    // Internal functions
	
	    Kinetic.prototype._initElements = function (){
	        this.$el.addClass(ACTIVE_CLASS);
	
	        $.extend(this, {
	            xpos: null,
	            prevXPos: false,
	            ypos: null,
	            prevYPos: false,
	            mouseDown: false,
	            throttleTimeout: 1000 / this.settings.throttleFPS,
	            lastMove: null,
	            elementFocused: null
	        });
	
	        this.velocity = 0;
	        this.velocityY = 0;
	
	        // make sure we reset everything when mouse up
	        $(document)
	            .mouseup($.proxy(this._resetMouse, this))
	            .click($.proxy(this._resetMouse, this));
	
	        this._initEvents();
	
	        this.$el.css('cursor', this.settings.cursor);
	
	        if (this.settings.triggerHardware){
	            this.$el.css({
	                '-webkit-transform': 'translate3d(0,0,0)',
	                '-webkit-perspective': '1000',
	                '-webkit-backface-visibility': 'hidden'
	            });
	        }
	    };
	
	    Kinetic.prototype._initEvents = function(){
	        var self = this;
	        this.settings.events = {
	            touchStart: function (e){
	                var touch;
	                if (self._useTarget(e.target, e)){
	                    touch = e.originalEvent.touches[0];
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(touch.clientX, touch.clientY);
	                    e.stopPropagation();
	                }
	            },
	            touchMove: function (e){
	                var touch;
	                if (self.mouseDown){
	                    touch = e.originalEvent.touches[0];
	                    self._inputmove(touch.clientX, touch.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputDown: function (e){
	                if (self._useTarget(e.target, e)){
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(e.clientX, e.clientY);
	                    self.elementFocused = e.target;
	                    if (e.target.nodeName === 'IMG'){
	                        e.preventDefault();
	                    }
	                    e.stopPropagation();
	                }
	            },
	            inputEnd: function (e){
	                if (self._useTarget(e.target, e)){
	                    self._end();
	                    self.elementFocused = null;
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputMove: function (e){
	                if (self.mouseDown){
	                    self._inputmove(e.clientX, e.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            scroll: function (e){
	                if ($.isFunction(self.settings.moved)){
	                    self.settings.moved.call(self, self.settings);
	                }
	                if (e.preventDefault){
	                    e.preventDefault();
	                }
	            },
	            inputClick: function (e){
	                if (Math.abs(self.velocity) > 0){
	                    e.preventDefault();
	                    return false;
	                }
	            },
	            // prevent drag and drop images in ie
	            dragStart: function (e){
	                if (self._useTarget(e.target, e) && self.elementFocused){
	                    return false;
	                }
	            },
	            // prevent selection when dragging
	            selectStart: function (e){
	                if ($.isFunction(self.settings.selectStart)){
	                    return self.settings.selectStart.apply(self, arguments);
	                } else if (self._useTarget(e.target, e)) {
	                    return false;
	                }
	            }
	        };
	
	        this._attachListeners(this.$el, this.settings);
	
	    };
	
	    Kinetic.prototype._inputmove = function (clientX, clientY){
	        var $this = this.$el;
	        var el = this.el;
	
	        if (!this.lastMove || new Date() > new Date(this.lastMove.getTime() + this.throttleTimeout)){
	            this.lastMove = new Date();
	
	            if (this.mouseDown && (this.xpos || this.ypos)){
	                var movedX = (clientX - this.xpos);
	                var movedY = (clientY - this.ypos);
	                if (this.settings.invert) {
	                    movedX *= -1;
	                    movedY *= -1;
	                }
	                if(this.threshold > 0){
	                    var moved = Math.sqrt(movedX * movedX + movedY * movedY);
	                    if(this.threshold > moved){
	                        return;
	                    } else {
	                        this.threshold = 0;
	                    }
	                }
	                if (this.elementFocused){
	                    $(this.elementFocused).blur();
	                    this.elementFocused = null;
	                    $this.focus();
	                }
	
	                this.settings.decelerate = false;
	                this.velocity = this.velocityY = 0;
	
	                var scrollLeft = this.scrollLeft();
	                var scrollTop = this.scrollTop();
	
	                this.scrollLeft(this.settings.x ? scrollLeft - movedX : scrollLeft);
	                this.scrollTop(this.settings.y ? scrollTop - movedY : scrollTop);
	
	                this.prevXPos = this.xpos;
	                this.prevYPos = this.ypos;
	                this.xpos = clientX;
	                this.ypos = clientY;
	
	                this._calculateVelocities();
	                this._setMoveClasses(this.settings.movingClass);
	
	                if ($.isFunction(this.settings.moved)){
	                    this.settings.moved.call(this, this.settings);
	                }
	            }
	        }
	    };
	
	    Kinetic.prototype._calculateVelocities = function (){
	        this.velocity = this._capVelocity(this.prevXPos - this.xpos, this.settings.maxvelocity);
	        this.velocityY = this._capVelocity(this.prevYPos - this.ypos, this.settings.maxvelocity);
	        if (this.settings.invert) {
	            this.velocity *= -1;
	            this.velocityY *= -1;
	        }
	    };
	
	    Kinetic.prototype._end = function (){
	        if (this.xpos && this.prevXPos && this.settings.decelerate === false){
	            this.settings.decelerate = true;
	            this._calculateVelocities();
	            this.xpos = this.prevXPos = this.mouseDown = false;
	            this._move();
	        }
	    };
	
	    Kinetic.prototype._useTarget = function (target, event){
	        if ($.isFunction(this.settings.filterTarget)){
	            return this.settings.filterTarget.call(this, target, event) !== false;
	        }
	        return true;
	    };
	
	    Kinetic.prototype._threshold = function (target, event){
	        if ($.isFunction(this.settings.threshold)){
	            return this.settings.threshold.call(this, target, event);
	        }
	        return this.settings.threshold;
	    };
	
	    Kinetic.prototype._start = function (clientX, clientY){
	        this.mouseDown = true;
	        this.velocity = this.prevXPos = 0;
	        this.velocityY = this.prevYPos = 0;
	        this.xpos = clientX;
	        this.ypos = clientY;
	    };
	
	    Kinetic.prototype._resetMouse = function (){
	        this.xpos = false;
	        this.ypos = false;
	        this.mouseDown = false;
	    };
	
	    Kinetic.prototype._decelerateVelocity = function (velocity, slowdown){
	        return Math.floor(Math.abs(velocity)) === 0 ? 0 // is velocity less than 1?
	            : velocity * slowdown; // reduce slowdown
	    };
	
	    Kinetic.prototype._capVelocity = function (velocity, max){
	        var newVelocity = velocity;
	        if (velocity > 0){
	            if (velocity > max){
	                newVelocity = max;
	            }
	        } else {
	            if (velocity < (0 - max)){
	                newVelocity = (0 - max);
	            }
	        }
	        return newVelocity;
	    };
	
	    Kinetic.prototype._setMoveClasses = function (classes){
	        // FIXME: consider if we want to apply PL #44, this should not remove
	        // classes we have not defined on the element!
	        var settings = this.settings;
	        var $this = this.$el;
	
	        $this.removeClass(settings.movingClass.up)
	            .removeClass(settings.movingClass.down)
	            .removeClass(settings.movingClass.left)
	            .removeClass(settings.movingClass.right)
	            .removeClass(settings.deceleratingClass.up)
	            .removeClass(settings.deceleratingClass.down)
	            .removeClass(settings.deceleratingClass.left)
	            .removeClass(settings.deceleratingClass.right);
	
	        if (this.velocity > 0){
	            $this.addClass(classes.right);
	        }
	        if (this.velocity < 0){
	            $this.addClass(classes.left);
	        }
	        if (this.velocityY > 0){
	            $this.addClass(classes.down);
	        }
	        if (this.velocityY < 0){
	            $this.addClass(classes.up);
	        }
	
	    };
	
	
	    // do the actual kinetic movement
	    Kinetic.prototype._move = function (){
	        var $scroller = this._getScroller();
	        var scroller = $scroller[0];
	        var self = this;
	        var settings = self.settings;
	
	        // set scrollLeft
	        if (settings.x && scroller.scrollWidth > 0){
	            this.scrollLeft(this.scrollLeft() + this.velocity);
	            if (Math.abs(this.velocity) > 0){
	                this.velocity = settings.decelerate ?
	                    self._decelerateVelocity(this.velocity, settings.slowdown) : this.velocity;
	            }
	        } else {
	            this.velocity = 0;
	        }
	
	        // set scrollTop
	        if (settings.y && scroller.scrollHeight > 0){
	            this.scrollTop(this.scrollTop() + this.velocityY);
	            if (Math.abs(this.velocityY) > 0){
	                this.velocityY = settings.decelerate ?
	                    self._decelerateVelocity(this.velocityY, settings.slowdown) : this.velocityY;
	            }
	        } else {
	            this.velocityY = 0;
	        }
	
	        self._setMoveClasses(settings.deceleratingClass);
	
	        if ($.isFunction(settings.moved)){
	            settings.moved.call(this, settings);
	        }
	
	        if (Math.abs(this.velocity) > 0 || Math.abs(this.velocityY) > 0){
	            if (!this.moving) {
	                this.moving = true;
	                // tick for next movement
	                window.requestAnimationFrame(function (){
	                    self.moving = false;
	                    self._move();
	                });
	            }
	        } else {
	            self.stop();
	        }
	    };
	
	    // get current scroller to apply positioning to
	    Kinetic.prototype._getScroller = function(){
	        var $scroller = this.$el;
	        if (this.$el.is('body') || this.$el.is('html')){
	            $scroller = $(window);
	        }
	        return $scroller;
	    };
	
	    // set the scroll position
	    Kinetic.prototype.scrollLeft = function(left){
	        var $scroller = this._getScroller();
	        if (typeof left === 'number'){
	            $scroller.scrollLeft(left);
	            this.settings.scrollLeft = left;
	        } else {
	            return $scroller.scrollLeft();
	        }
	    };
	    Kinetic.prototype.scrollTop = function(top){
	        var $scroller = this._getScroller();
	        if (typeof top === 'number'){
	            $scroller.scrollTop(top);
	            this.settings.scrollTop = top;
	        } else {
	            return $scroller.scrollTop();
	        }
	    };
	
	    Kinetic.prototype._attachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch){
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .mousedown(settings.events.inputDown)
	            .mouseup(settings.events.inputEnd)
	            .mousemove(settings.events.inputMove);
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    Kinetic.prototype._detachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	        if ($.support.touch){
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('mousedown', settings.events.inputDown)
	            .unbind('mouseup', settings.events.inputEnd)
	            .unbind('mousemove', settings.events.inputMove);
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	
	
	    // EXPOSE KINETIC CONSTRUCTOR
	    // ==========================
	    $.Kinetic = Kinetic;
	
	    // KINETIC PLUGIN DEFINITION
	    // =======================
	
	    $.fn.kinetic = function (option, callOptions) {
	        return this.each(function () {
	            var $this    = $(this);
	            var instance = $this.data(Kinetic.DATA_KEY);
	            var options  = $.extend({}, Kinetic.DEFAULTS, $this.data(), typeof option === 'object' && option);
	
	            if (!instance) {
	                $this.data(Kinetic.DATA_KEY, (instance = new Kinetic(this, options)));
	            }
	
	            if (typeof option === 'string') {
	                instance[option](callOptions);
	            }
	
	        });
	    };
	
	}(jQuery));
	
	/* istanbul ignore next
	    We should maybe be testing this, but realistically that would mean maintaining a real fork */
	
	// jQuery.kinetic core modifications for diva.js (compatible with jQuery.kinetic 2.2.1)
	// use jQuery.kinetic for touch handlers only since we are using dragscrollable for mouse handlers
	//    - (kinetic provides inertial scrolling [ease into stopped state on release] for touch events and dragscrollable
	//      allows non-inertial scrolling which we like for mice)
	
	(function($)
	{
	    $.Kinetic.prototype._attachListeners = function()
	    {
	        // attach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    $.Kinetic.prototype._detachListeners = function()
	    {
	        // detach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	})(jQuery);


/***/ },
/* 16 */
/***/ function(module, exports) {

	// From http://www.alexandre-gomes.com/?p=115, modified slightly
	module.exports = function getScrollbarWidth() {
	    var inner = document.createElement('p');
	    inner.style.width = '100%';
	    inner.style.height = '200px';
	
	    var outer = document.createElement('div');
	    outer.style.position = 'absolute';
	    outer.style.top = '0px';
	    outer.style.left = '0px';
	    outer.style.visibility = 'hidden';
	    outer.style.width = '200px';
	    outer.style.height = '150px';
	    outer.style.overflow = 'hidden';
	    outer.appendChild(inner);
	
	    document.body.appendChild(outer);
	
	    var w1 = inner.offsetWidth;
	    outer.style.overflow = 'scroll';
	    var w2 = inner.offsetWidth;
	    if (w1 == w2) {
	        w2 = outer.clientWidth; // for IE i think
	    }
	
	    document.body.removeChild(outer);
	    return w1 - w2;
	};


/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = {
	    onDoubleClick: onDoubleClick,
	    onPinch: onPinch,
	    onDoubleTap: onDoubleTap
	};
	
	var DOUBLE_CLICK_TIMEOUT = 500;
	
	var DOUBLE_TAP_DISTANCE_THRESHOLD = 50;
	var DOUBLE_TAP_TIMEOUT = 250;
	
	function onDoubleClick(elem, callback)
	{
	    elem.on('dblclick', function (event)
	    {
	        if (!event.ctrlKey)
	        {
	            callback(event, getRelativeOffset(event.currentTarget, event));
	        }
	    });
	
	    // Handle the control key for macs (in conjunction with double-clicking)
	    // FIXME: Does a click get handled with ctrl pressed on non-Macs?
	    var tracker = createDoubleEventTracker(DOUBLE_CLICK_TIMEOUT);
	
	    elem.on('contextmenu', function (event)
	    {
	        event.preventDefault();
	
	        if (event.ctrlKey)
	        {
	            if (tracker.isTriggered())
	            {
	                tracker.reset();
	                callback(event, getRelativeOffset(event.currentTarget, event));
	            }
	            else
	            {
	                tracker.trigger();
	            }
	        }
	    });
	}
	
	function onPinch(elem, callback)
	{
	    var startDistance = 0;
	
	    elem.on('touchstart', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            startDistance = distance(
	                event.originalEvent.touches[0].clientX,
	                event.originalEvent.touches[0].clientY,
	                event.originalEvent.touches[1].clientX,
	                event.originalEvent.touches[1].clientY
	            );
	        }
	    });
	
	    elem.on('touchmove', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            var touches = event.originalEvent.touches;
	
	            var moveDistance = distance(
	                touches[0].clientX,
	                touches[0].clientY,
	                touches[1].clientX,
	                touches[1].clientY
	            );
	
	            var zoomDelta = moveDistance - startDistance;
	
	            if (Math.abs(zoomDelta) > 0)
	            {
	                var touchCenter = {
	                    pageX: (touches[0].clientX + touches[1].clientX) / 2,
	                    pageY: (touches[0].clientY + touches[1].clientY) / 2
	                };
	
	                callback(event, getRelativeOffset(event.currentTarget, touchCenter), startDistance, moveDistance);
	            }
	        }
	    });
	}
	
	function onDoubleTap(elem, callback)
	{
	    var tracker = createDoubleEventTracker(DOUBLE_TAP_TIMEOUT);
	    var firstTap = null;
	
	    elem.on('touchend', function (event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (tracker.isTriggered())
	        {
	            tracker.reset();
	
	            // Doubletap has occurred
	            var secondTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            // If first tap is close to second tap (prevents interference with scale event)
	            var tapDistance = distance(firstTap.pageX, firstTap.pageY, secondTap.pageX, secondTap.pageY);
	
	            // TODO: Could give something higher-level than secondTap to callback
	            if (tapDistance < DOUBLE_TAP_DISTANCE_THRESHOLD)
	                callback(event, getRelativeOffset(event.currentTarget, secondTap));
	
	            firstTap = null;
	        }
	        else
	        {
	            firstTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            tracker.trigger();
	        }
	    });
	}
	
	// Pythagorean theorem to get the distance between two points (used for
	// calculating finger distance for double-tap and pinch-zoom)
	function distance(x1, y1, x2, y2)
	{
	    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	}
	
	// Utility to keep track of whether an event has been triggered twice
	// during a a given duration
	function createDoubleEventTracker(timeoutDuration)
	{
	    var triggered = false;
	    var timeoutId = null;
	
	    return {
	        trigger: function ()
	        {
	            triggered = true;
	            resetTimeout();
	            timeoutId = setTimeout(function ()
	            {
	                triggered = false;
	                timeoutId = null;
	            }, timeoutDuration);
	        },
	        isTriggered: function ()
	        {
	            return triggered;
	        },
	        reset: function ()
	        {
	            triggered = false;
	            resetTimeout();
	        }
	    };
	
	    function resetTimeout()
	    {
	        if (timeoutId !== null)
	        {
	            clearTimeout(timeoutId);
	            timeoutId = null;
	        }
	    }
	}
	
	function getRelativeOffset(elem, pageCoords)
	{
	    var bounds = elem.getBoundingClientRect();
	
	    return {
	        left: pageCoords.pageX - bounds.left,
	        top: pageCoords.pageY - bounds.top
	    };
	}


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(19);
	var PageToolsOverlay = __webpack_require__(21);
	
	module.exports = DocumentHandler;
	
	function DocumentHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	    this._viewerState = viewerCore.getInternalState();
	    this._overlays = [];
	
	    if (viewerCore.getPageTools().length)
	    {
	        var numPages = viewerCore.getSettings().numPages;
	
	        for (var i=0; i < numPages; i++)
	        {
	            var overlay = new PageToolsOverlay(i, viewerCore);
	            this._overlays.push(overlay);
	            viewerCore.addPageOverlay(overlay);
	        }
	    }
	}
	
	// USER EVENTS
	DocumentHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var settings = this._viewerCore.getSettings();
	    var newZoomLevel = event.ctrlKey ? settings.zoomLevel - 1 : settings.zoomLevel + 1;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    this._viewerCore.zoom(newZoomLevel, position);
	};
	
	DocumentHandler.prototype.onPinch = function (event, coords, startDistance, endDistance)
	{
	    // FIXME: Do this check in a way which is less spaghetti code-y
	    var viewerState = this._viewerCore.getInternalState();
	    var settings = this._viewerCore.getSettings();
	
	    var newZoomLevel = Math.log(Math.pow(2, settings.zoomLevel) * endDistance / (startDistance * Math.log(2))) / Math.log(2);
	    newZoomLevel = Math.max(settings.minZoomLevel, newZoomLevel);
	    newZoomLevel = Math.min(settings.maxZoomLevel, newZoomLevel);
	
	    if (newZoomLevel === settings.zoomLevel)
	        return;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var centerOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewerState.viewport);
	    var scaleRatio = 1 / Math.pow(2, settings.zoomLevel - newZoomLevel);
	
	    this._viewerCore.reload({
	        zoomLevel: newZoomLevel,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: (centerOffset.x - position.offset.left) + position.offset.left * scaleRatio,
	        verticalOffset: (centerOffset.y - position.offset.top) + position.offset.top * scaleRatio
	    });
	};
	
	// VIEW EVENTS
	DocumentHandler.prototype.onViewWillLoad = function ()
	{
	    this._viewerCore.publish('DocumentWillLoad', this._viewerCore.getSettings());
	};
	
	DocumentHandler.prototype.onViewDidLoad = function ()
	{
	    // TODO: Should only be necessary to handle changes on view update, not
	    // initial load
	    this._handleZoomLevelChange();
	
	    var currentPageIndex = this._viewerCore.getSettings().currentPageIndex;
	    var fileName = this._viewerCore.getPageName(currentPageIndex);
	    this._viewerCore.publish("DocumentDidLoad", currentPageIndex, fileName);
	};
	
	DocumentHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    var currentPage = (targetPage !== null) ?
	        targetPage :
	        getCentermostPage(renderedPages, this._viewerCore.getCurrentLayout(), this._viewerCore.getViewport());
	
	    // Don't change the current page if there is no page in the viewport
	    // FIXME: Would be better to fall back to the page closest to the viewport
	    if (currentPage !== null)
	        this._viewerCore.setCurrentPage(currentPage);
	
	    if (targetPage !== null)
	        this._viewerCore.publish("ViewerDidJump", targetPage);
	
	    this._handleZoomLevelChange();
	};
	
	DocumentHandler.prototype._handleZoomLevelChange = function ()
	{
	    var viewerState = this._viewerState;
	    var zoomLevel = viewerState.options.zoomLevel;
	
	    // If this is not the initial load, trigger the zoom events
	    if (viewerState.oldZoomLevel !== zoomLevel && viewerState.oldZoomLevel >= 0)
	    {
	        if (viewerState.oldZoomLevel < zoomLevel)
	        {
	            this._viewerCore.publish("ViewerDidZoomIn", zoomLevel);
	        }
	        else
	        {
	            this._viewerCore.publish("ViewerDidZoomOut", zoomLevel);
	        }
	
	        this._viewerCore.publish("ViewerDidZoom", zoomLevel);
	    }
	
	    viewerState.oldZoomLevel = zoomLevel;
	};
	
	DocumentHandler.prototype.destroy = function ()
	{
	    this._overlays.forEach(function (overlay)
	    {
	        this._viewerCore.removePageOverlay(overlay);
	    }, this);
	};
	
	function getCentermostPage(renderedPages, layout, viewport)
	{
	    var centerY = viewport.top + (viewport.height / 2);
	    var centerX = viewport.left + (viewport.width / 2);
	
	    // Find the minimum distance from the viewport center to a page.
	    // Compute minus the squared distance from viewport center to the page's border.
	    // http://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
	    var centerPage = maxBy(renderedPages, function (pageIndex)
	    {
	        var dims = layout.getPageDimensions(pageIndex);
	        var imageOffset = layout.getPageOffset(pageIndex, {excludePadding: false});
	
	        var midX = imageOffset.left + (dims.height / 2);
	        var midY = imageOffset.top + (dims.width / 2);
	
	        var dx = Math.max(Math.abs(centerX - midX) - (dims.width / 2), 0);
	        var dy = Math.max(Math.abs(centerY - midY) - (dims.height / 2), 0);
	
	        return -(dx * dx + dy * dy);
	    });
	
	    return centerPage != null ? centerPage : null;
	}


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;
	
	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];
	
	  var length = result.length,
	      skipIndexes = !!length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);
	
	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}
	
	/**
	 * The base implementation of `_.gt` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than `other`,
	 *  else `false`.
	 */
	function baseGt(value, other) {
	  return value > other;
	}
	
	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}
	
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}
	
	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}
	
	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
	
	  stack.set(array, other);
	  stack.set(other, array);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	
	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;
	
	  while (length--) {
	    var key = result[length],
	        value = object[key];
	
	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var result,
	      index = -1,
	      length = path.length;
	
	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);
	
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	
	/**
	 * This method is like `_.max` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.maxBy(objects, function(o) { return o.n; });
	 * // => { 'n': 2 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.maxBy(objects, 'n');
	 * // => { 'n': 2 }
	 */
	function maxBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)
	    : undefined;
	}
	
	module.exports = maxBy;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(20)(module)))

/***/ },
/* 20 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	var elt = __webpack_require__(8);
	
	module.exports = PageToolsOverlay;
	
	function PageToolsOverlay(pageIndex, viewerCore)
	{
	    this.page = pageIndex;
	
	    this._viewerCore = viewerCore;
	
	    this._innerElement = viewerCore.getSettings().innerElement;
	    this._pageToolsElem = null;
	}
	
	PageToolsOverlay.prototype.mount = function ()
	{
	    if (this._pageToolsElem === null)
	    {
	        var buttons = this._initializePageToolButtons();
	
	        this._pageToolsElem = elt('div', {class: 'diva-page-tools-wrapper'},
	            elt('div', {class: 'diva-page-tools'}, buttons)
	        );
	    }
	
	    this.refresh();
	    this._innerElement.appendChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype._initializePageToolButtons = function ()
	{
	    // Callback parameters
	    var settings = this._viewerCore.getSettings();
	    var publicInstance = this._viewerCore.getPublicInstance();
	    var pageIndex = this.page;
	
	    return this._viewerCore.getPageTools().map(function (plugin)
	    {
	        // If the title text is undefined, use the name of the plugin
	        var titleText = plugin.titleText || plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1) + " plugin";
	
	        var button = elt('div', {
	            class: 'diva-' + plugin.pluginName + '-icon',
	            title: titleText
	        });
	
	        button.addEventListener('click', function (event)
	        {
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        button.addEventListener('touchend', function (event)
	        {
	            // Prevent firing of emulated mouse events
	            event.preventDefault();
	
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        return button;
	    }, this);
	};
	
	PageToolsOverlay.prototype.unmount = function ()
	{
	    this._innerElement.removeChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype.refresh = function ()
	{
	    var pos = this._viewerCore.getPageRegion(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._pageToolsElem.style.top = pos.top + 'px';
	    this._pageToolsElem.style.left = pos.left + 'px';
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(19);
	
	module.exports = GridHandler;
	
	function GridHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	}
	
	// USER EVENTS
	GridHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var viewport = this._viewerCore.getViewport();
	    var pageToViewportCenterOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewport);
	
	    this._viewerCore.reload({
	        inGrid: false,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: pageToViewportCenterOffset.x + position.offset.left,
	        verticalOffset: pageToViewportCenterOffset.y + position.offset.top
	    });
	};
	
	GridHandler.prototype.onPinch = function ()
	{
	    this._viewerCore.reload({ inGrid: false });
	};
	
	// VIEW EVENTS
	GridHandler.prototype.onViewWillLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    if (targetPage !== null)
	    {
	        this._viewerCore.setCurrentPage(targetPage);
	        return;
	    }
	
	    // Select the current page from the first row if it is fully visible, or from
	    // the second row if it is fully visible, or from the centermost row otherwise.
	    // If the current page is in that group then don't change it. Otherwise, set
	    // the current page to the group's first page.
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var groups = [];
	    renderedPages.forEach(function (pageIndex)
	    {
	        var group = layout.getPageInfo(pageIndex).group;
	        if (groups.length === 0 || group !== groups[groups.length - 1])
	            groups.push(group);
	    });
	
	    var viewport = this._viewerCore.getViewport();
	    var chosenGroup;
	
	    if (groups.length === 1 || groups[0].region.top >= viewport.top)
	        chosenGroup = groups[0];
	    else if (groups[1].region.bottom <= viewport.bottom)
	        chosenGroup = groups[1];
	    else
	        chosenGroup = getCentermostGroup(groups, viewport);
	
	    var currentPage = this._viewerCore.getSettings().currentPageIndex;
	
	    var hasCurrentPage = chosenGroup.pages.some(function (page)
	    {
	        return page.index === currentPage;
	    });
	
	    if (!hasCurrentPage)
	        this._viewerCore.setCurrentPage(chosenGroup.pages[0].index);
	};
	
	GridHandler.prototype.destroy = function ()
	{
	    // No-op
	};
	
	function getCentermostGroup(groups, viewport)
	{
	    var viewportMiddle = viewport.top + viewport.height / 2;
	
	    return maxBy(groups, function (group)
	    {
	        var groupMiddle = group.region.top + group.dimensions.height / 2;
	        return -Math.abs(viewportMiddle - groupMiddle);
	    });
	}


/***/ },
/* 23 */
/***/ function(module, exports) {

	module.exports = PageOverlayManager;
	
	/**
	 * Manages a collection of page overlays, which implement a low-level
	 * API for synchronizing HTML pages to the canvas. Each overlay needs
	 * to implement the following protocol:
	 *
	 *   mount(): Called when a page is first rendered
	 *   refresh(): Called when a page is moved
	 *   unmount(): Called when a previously rendered page has stopped being rendered
	 *
	 * @class
	 */
	
	function PageOverlayManager()
	{
	    this._pages = {};
	    this._renderedPages = [];
	    this._renderedPageMap = {};
	}
	
	PageOverlayManager.prototype.addOverlay = function (overlay)
	{
	    var overlaysByPage = this._pages[overlay.page] || (this._pages[overlay.page] = []);
	
	    overlaysByPage.push(overlay);
	
	    if (this._renderedPageMap[overlay.page])
	        overlay.mount();
	};
	
	PageOverlayManager.prototype.removeOverlay = function (overlay)
	{
	    var page = overlay.page;
	    var overlaysByPage = this._pages[page];
	
	    if (!overlaysByPage)
	        return;
	
	    var overlayIndex = overlaysByPage.indexOf(overlay);
	
	    if (overlayIndex === -1)
	        return;
	
	    if (this._renderedPageMap[page])
	        overlaysByPage[overlayIndex].unmount();
	
	    overlaysByPage.splice(overlayIndex, 1);
	
	    if (overlaysByPage.length === 0)
	        delete this._pages[page];
	};
	
	PageOverlayManager.prototype.updateOverlays = function (renderedPages)
	{
	    var previouslyRendered = this._renderedPages;
	    var newRenderedMap = {};
	
	    renderedPages.forEach(function (pageIndex)
	    {
	        newRenderedMap[pageIndex] = true;
	
	        if (!this._renderedPageMap[pageIndex])
	        {
	            this._renderedPageMap[pageIndex] = true;
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.mount();
	            });
	        }
	    }, this);
	
	    previouslyRendered.forEach(function (pageIndex)
	    {
	        if (newRenderedMap[pageIndex])
	        {
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.refresh();
	            });
	        }
	        else
	        {
	            delete this._renderedPageMap[pageIndex];
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.unmount();
	            });
	        }
	    }, this);
	
	    this._renderedPages = renderedPages;
	};
	
	PageOverlayManager.prototype._invokeOnOverlays = function (pageIndex, func)
	{
	    var overlays = this._pages[pageIndex];
	    if (overlays)
	        overlays.forEach(func, this);
	};


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(25)('diva:Renderer');
	var debugPaints = __webpack_require__(25)('diva:Renderer:paints');
	
	var elt = __webpack_require__(8);
	
	var CompositeImage = __webpack_require__(29);
	var DocumentLayout = __webpack_require__(30);
	var ImageCache = __webpack_require__(31);
	var ImageRequestHandler = __webpack_require__(32);
	var InterpolateAnimation = __webpack_require__(33);
	
	var REQUEST_DEBOUNCE_INTERVAL = 250;
	
	
	module.exports = Renderer;
	
	function Renderer(options, hooks)
	{
	    this._viewport = options.viewport;
	    this._outerElement = options.outerElement;
	    this._documentElement = options.innerElement;
	
	    this._hooks = hooks || {};
	
	    this._canvas = elt('canvas', { class: 'diva-viewer-canvas' });
	    this._ctx = this._canvas.getContext('2d');
	
	    this.layout = null;
	
	    this._sourceResolver = null;
	    this._renderedPages = null;
	    this._config = null;
	    this._zoomLevel = null;
	    this._compositeImages = null;
	    this._renderedTiles = null;
	    this._animation = null;
	
	    // FIXME(wabain): What level should this be maintained at?
	    // Diva global?
	    this._cache = new ImageCache();
	    this._pendingRequests = {};
	}
	
	Renderer.getCompatibilityErrors = function ()
	{
	    if (typeof HTMLCanvasElement !== 'undefined')
	        return null;
	
	    return [
	        'Your browser lacks support for the ', elt('pre', 'canvas'),
	        ' element. Please upgrade your browser.'
	    ];
	};
	
	Renderer.prototype.load = function (config, viewportPosition, sourceResolver)
	{
	    this._clearAnimation();
	
	    if (this._hooks.onViewWillLoad)
	        this._hooks.onViewWillLoad();
	
	    this._sourceResolver = sourceResolver;
	    this._config = config;
	    this._compositeImages = {};
	    this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	
	    // FIXME(wabain): Remove this when there's more confidence the check shouldn't be needed
	    if (!this.layout.getPageInfo(viewportPosition.anchorPage))
	        throw new Error('invalid page: ' + viewportPosition.anchorPage);
	
	    if (this._canvas.width !== this._viewport.width || this._canvas.height !== this._viewport.height)
	    {
	        debug('Canvas dimension change: (%s, %s) -> (%s, %s)', this._canvas.width, this._canvas.height,
	            this._viewport.width, this._viewport.height);
	
	        this._canvas.width = this._viewport.width;
	        this._canvas.height = this._viewport.height;
	    } else {
	        debug('Reload, no size change');
	    }
	
	    // FIXME: What hooks should be called here?
	    this.goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	
	    if (this._canvas.parentNode !== this._outerElement)
	        this._outerElement.insertBefore(this._canvas, this._outerElement.firstChild);
	
	    if (this._hooks.onViewDidLoad)
	        this._hooks.onViewDidLoad();
	};
	
	Renderer.prototype._setViewportPosition = function (viewportPosition)
	{
	    if (viewportPosition.zoomLevel !== this._zoomLevel)
	    {
	        if (this._zoomLevel === null)
	            throw new TypeError('The current view is not zoomable');
	        else if (viewportPosition.zoomLevel === null)
	            throw new TypeError('The current view requires a zoom level');
	
	        this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	    }
	
	    this._goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	};
	
	Renderer.prototype._setLayoutToZoomLevel = function (zoomLevel)
	{
	    this.layout = new DocumentLayout(this._config, zoomLevel);
	    this._zoomLevel = zoomLevel;
	
	    elt.setAttributes(this._documentElement, {
	        style: {
	            height: this.layout.dimensions.height + 'px',
	            width: this.layout.dimensions.width + 'px'
	        }
	    });
	
	    this._viewport.setInnerDimensions(this.layout.dimensions);
	};
	
	Renderer.prototype.adjust = function (direction)
	{
	    this._clearAnimation();
	
	    this._render(direction);
	
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), null);
	    }
	};
	
	// FIXME(wabain): Remove the direction argument if it doesn't end up being needed.
	Renderer.prototype._render = function (direction) // jshint ignore:line
	{
	    var newRenderedPages = [];
	    this.layout.pageGroups.forEach(function (group)
	    {
	        if (!this._viewport.intersectsRegion(group.region))
	            return;
	
	        var visiblePages = group.pages
	            .filter(function (page)
	            {
	                return this.isPageVisible(page.index);
	            }, this)
	            .map(function (page)
	            {
	                return page.index;
	            });
	
	        newRenderedPages.push.apply(newRenderedPages, visiblePages);
	    }, this);
	
	    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
	    this._paintOutline(newRenderedPages);
	
	    newRenderedPages.forEach(function (pageIndex)
	    {
	        if (!this._compositeImages[pageIndex])
	        {
	            var page = this.layout.getPageInfo(pageIndex);
	            var zoomLevels = this._sourceResolver.getAllZoomLevelsForPage(page);
	            var composite = new CompositeImage(zoomLevels);
	            composite.updateFromCache(this._cache);
	            this._compositeImages[pageIndex] = composite;
	        }
	    }, this);
	
	    this._initiateTileRequests(newRenderedPages);
	
	    var changes = findChanges(this._renderedPages || [], newRenderedPages);
	
	    changes.removed.forEach(function (pageIndex)
	    {
	        delete this._compositeImages[pageIndex];
	    }, this);
	
	    this._renderedPages = newRenderedPages;
	    this._paint();
	
	    if (this._hooks.onPageWillLoad)
	    {
	        changes.added.forEach(function (pageIndex)
	        {
	            this._hooks.onPageWillLoad(pageIndex);
	        }, this);
	    }
	};
	
	Renderer.prototype._paint = function ()
	{
	    debug('Repainting');
	
	    var renderedTiles = [];
	
	    this._renderedPages.forEach(function (pageIndex)
	    {
	        this._compositeImages[pageIndex].getTiles(this._zoomLevel).forEach(function (source)
	        {
	            var scaled = getScaledTileRecord(source, this._zoomLevel);
	
	            if (this._isTileVisible(pageIndex, scaled))
	            {
	                renderedTiles.push(source.url);
	                this._drawTile(pageIndex, scaled, this._cache.get(source.url));
	            }
	        }, this);
	    }, this);
	
	    var cache = this._cache;
	
	    var changes = findChanges(this._renderedTiles || [], renderedTiles);
	
	    changes.added.forEach(function (url)
	    {
	        cache.acquire(url);
	    });
	
	    changes.removed.forEach(function (url)
	    {
	        cache.release(url);
	    });
	
	    if (changes.removed)
	    {
	        // FIXME: Should only need to update the composite images
	        // for which tiles were removed
	        this._renderedPages.forEach(function (pageIndex)
	        {
	            this._compositeImages[pageIndex].updateFromCache(this._cache);
	        }, this);
	    }
	
	    this._renderedTiles = renderedTiles;
	};
	
	// Paint a page outline while the tiles are loading.
	Renderer.prototype._paintOutline = function (pages)
	{
	    pages.forEach(function (pageIndex)
	    {
	        var pageInfo = this.layout.getPageInfo(pageIndex);
	        var pageOffset = this._getImageOffset(pageIndex);
	
	        // Ensure the document is drawn to the center of the viewport
	        var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	        var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	        var viewportOffsetX = pageOffset.left - this._viewport.left + viewportPaddingX;
	        var viewportOffsetY = pageOffset.top - this._viewport.top + viewportPaddingY;
	
	        var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	        var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	        var canvasX = Math.max(0, viewportOffsetX);
	        var canvasY = Math.max(0, viewportOffsetY);
	
	        var destWidth = pageInfo.dimensions.width - destXOffset;
	        var destHeight = pageInfo.dimensions.height - destYOffset;
	
	        this._ctx.strokeStyle = '#AAA';
	        // In order to get a 1px wide line using strokes, we need to start at a 'half pixel'
	        this._ctx.strokeRect(canvasX + 0.5, canvasY + 0.5, destWidth, destHeight);
	    }, this);
	};
	
	// This method should be sent all visible pages at once because it will initiate
	// all image requests and cancel any remaining image requests. In the case that
	// a request is ongoing and the tile is still visible in the viewport, the old request
	// is kept active instead of restarting it. The image requests are given a timeout
	// before loading in order to debounce them and have a small reaction time
	// to cancel them and avoid useless requests.
	Renderer.prototype._initiateTileRequests = function(pages)
	{
	    // Only requests in this object are kept alive, since all others are not visible in the viewport
	    var newPendingRequests = {};
	
	    // Used later as a closure to initiate the image requests with the right source and pageIndex
	    var initiateRequest = function (source, pageIndex)
	    {
	        var composite = this._compositeImages[pageIndex];
	
	        newPendingRequests[source.url] = new ImageRequestHandler({
	            url: source.url,
	            timeoutTime: REQUEST_DEBOUNCE_INTERVAL,
	            load: function (img)
	            {
	                delete this._pendingRequests[source.url];
	                this._cache.put(source.url, img);
	
	                // Awkward way to check for updates
	                if (composite === this._compositeImages[pageIndex])
	                {
	                    composite.updateWithLoadedUrls([source.url]);
	
	                    if (this._isTileForSourceVisible(pageIndex, source))
	                        this._paint();
	                    else
	                        debugPaints('Page %s, tile %s no longer visible on image load', pageIndex, source.url);
	                }
	            }.bind(this),
	            error: function ()
	            {
	                // TODO: Could make a limited number of retries, etc.
	                delete this._pendingRequests[source.url];
	            }.bind(this)
	        });
	    }.bind(this);
	
	    for (var i = 0; i < pages.length; i++)
	    {
	        var pageIndex = pages[i];
	        var tiles = this._sourceResolver.getBestZoomLevelForPage(this.layout.getPageInfo(pageIndex)).tiles;
	
	        for (var j = 0; j < tiles.length; j++)
	        {
	            var source = tiles[j];
	            if (this._cache.has(source.url) || !this._isTileForSourceVisible(pageIndex, source))
	                continue;
	
	            // Don't create a new request if the tile is already being loaded
	            if (this._pendingRequests[source.url])
	            {
	                newPendingRequests[source.url] = this._pendingRequests[source.url];
	                delete this._pendingRequests[source.url];
	                continue;
	            }
	
	            // Use a closure since the load and error methods are going to be called later and
	            // we need to keep the right reference to the source and the page index
	            initiateRequest(source, pageIndex);
	        }
	    }
	
	    for (var url in this._pendingRequests)
	        this._pendingRequests[url].abort();
	    this._pendingRequests = newPendingRequests;
	};
	
	Renderer.prototype._drawTile = function (pageIndex, scaledTile, img)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // Ensure the document is drawn to the center of the viewport
	    var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	    var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	    var viewportOffsetX = tileOffset.left - this._viewport.left + viewportPaddingX;
	    var viewportOffsetY = tileOffset.top - this._viewport.top + viewportPaddingY;
	
	    var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	    var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	    var sourceXOffset = destXOffset / scaledTile.scaleRatio;
	    var sourceYOffset = destYOffset / scaledTile.scaleRatio;
	
	    var canvasX = Math.max(0, viewportOffsetX);
	    var canvasY = Math.max(0, viewportOffsetY);
	
	    // Ensure that the specified dimensions are no greater than the actual
	    // size of the image. Safari won't display the tile if they are.
	    var destWidth = Math.min(scaledTile.dimensions.width, img.width * scaledTile.scaleRatio) - destXOffset;
	    var destHeight = Math.min(scaledTile.dimensions.height, img.height * scaledTile.scaleRatio) - destYOffset;
	
	    var sourceWidth = destWidth / scaledTile.scaleRatio;
	    var sourceHeight = destHeight / scaledTile.scaleRatio;
	
	    if (debugPaints.enabled) {
	        debugPaints('Drawing page %s, tile %sx (%s, %s) from %s, %s to viewport at %s, %s, scale %s%%',
	            pageIndex,
	            scaledTile.sourceZoomLevel, scaledTile.row, scaledTile.col,
	            sourceXOffset, sourceYOffset,
	            canvasX, canvasY,
	            Math.round(scaledTile.scaleRatio * 100));
	    }
	
	    this._ctx.drawImage(
	        img,
	        sourceXOffset, sourceYOffset,
	        sourceWidth, sourceHeight,
	        canvasX, canvasY,
	        destWidth, destHeight);
	};
	
	Renderer.prototype._isTileForSourceVisible = function (pageIndex, tileSource)
	{
	    return this._isTileVisible(pageIndex, getScaledTileRecord(tileSource, this._zoomLevel));
	};
	
	Renderer.prototype._isTileVisible = function (pageIndex, scaledTile)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // FIXME(wabain): This check is insufficient during a zoom transition
	    return this._viewport.intersectsRegion({
	        top: tileOffset.top,
	        bottom: tileOffset.top + scaledTile.dimensions.height,
	        left: tileOffset.left,
	        right: tileOffset.left + scaledTile.dimensions.width
	    });
	};
	
	Renderer.prototype._getTileToDocumentOffset = function (pageIndex, scaledTile)
	{
	    var imageOffset = this._getImageOffset(pageIndex);
	
	    return {
	        top: imageOffset.top + scaledTile.offset.top,
	        left: imageOffset.left + scaledTile.offset.left
	    };
	};
	
	Renderer.prototype._getImageOffset = function (pageIndex)
	{
	    return this.layout.getPageOffset(pageIndex, {excludePadding: true});
	};
	
	// TODO: Update signature
	Renderer.prototype.goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    this._clearAnimation();
	    this._goto(pageIndex, verticalOffset, horizontalOffset);
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), pageIndex);
	    }
	};
	
	Renderer.prototype._goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    // FIXME(wabain): Move this logic to the viewer
	    var pageOffset = this.layout.getPageOffset(pageIndex);
	
	    var desiredVerticalCenter = pageOffset.top + verticalOffset;
	    var top = desiredVerticalCenter - parseInt(this._viewport.height / 2, 10);
	
	    var desiredHorizontalCenter = pageOffset.left + horizontalOffset;
	    var left = desiredHorizontalCenter - parseInt(this._viewport.width / 2, 10);
	
	    this._viewport.top = top;
	    this._viewport.left = left;
	
	    this._render(0);
	};
	
	Renderer.prototype.transitionViewportPosition = function (options)
	{
	    this._clearAnimation();
	
	    var getPosition = options.getPosition;
	    var self = this;
	
	    var onViewDidTransition = this._hooks.onViewDidTransition;
	
	    this._animation = InterpolateAnimation.animate({
	        duration: options.duration,
	        parameters: options.parameters,
	        onUpdate: function (values)
	        {
	            // TODO: Do image preloading, work with that
	            self._setViewportPosition(getPosition(values));
	
	            if (onViewDidTransition)
	                onViewDidTransition();
	        },
	        onEnd: function (info)
	        {
	            if (options.onEnd)
	                options.onEnd(info);
	
	            if (self._hooks.onViewDidUpdate && !info.interrupted)
	            {
	                self._hooks.onViewDidUpdate(self._renderedPages.slice(), null);
	            }
	        }
	    });
	};
	
	Renderer.prototype._clearAnimation = function ()
	{
	    if (this._animation)
	    {
	        this._animation.cancel();
	        this._animation = null;
	    }
	};
	
	Renderer.prototype.preload = function ()
	{
	    // TODO
	};
	
	Renderer.prototype.isPageVisible = function (pageIndex)
	{
	    if (!this.layout)
	        return false;
	
	    var page = this.layout.getPageInfo(pageIndex);
	
	    if (!page)
	        return false;
	
	    return this._viewport.intersectsRegion(this.layout.getPageRegion(pageIndex));
	};
	
	Renderer.prototype.getRenderedPages = function ()
	{
	    return this._renderedPages.slice();
	};
	
	Renderer.prototype.destroy = function ()
	{
	    this._clearAnimation();
	
	    // FIXME(wabain): I don't know if we should actually do this
	    Object.keys(this._pendingRequests).forEach(function (req)
	    {
	        var handler = this._pendingRequests[req];
	        delete this._pendingRequests[req];
	
	        handler.abort();
	    }, this);
	
	    this._canvas.parentNode.removeChild(this._canvas);
	};
	
	function getScaledTileRecord(source, scaleFactor)
	{
	    var scaleRatio;
	
	    if (scaleFactor === null)
	        scaleRatio = 1;
	    else
	        scaleRatio = Math.pow(2, scaleFactor - source.zoomLevel);
	
	    return {
	        sourceZoomLevel: source.zoomLevel,
	        scaleRatio: scaleRatio,
	        row: source.row,
	        col: source.col,
	        dimensions: {
	            width: source.dimensions.width * scaleRatio,
	            height: source.dimensions.height * scaleRatio
	        },
	        offset: {
	            left: source.offset.left * scaleRatio,
	            top: source.offset.top * scaleRatio
	        },
	        url: source.url
	    };
	}
	
	function findChanges(oldArray, newArray)
	{
	    if (oldArray === newArray)
	    {
	        return {
	            added: [],
	            removed: []
	        };
	    }
	
	    var removed = oldArray.filter(function (oldEntry)
	    {
	        return newArray.indexOf(oldEntry) === -1;
	    });
	
	    var added = newArray.filter(function (newEntry)
	    {
	        return oldArray.indexOf(newEntry) === -1;
	    });
	
	    return {
	        added: added,
	        removed: removed
	    };
	}


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(27);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26)))

/***/ },
/* 26 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(28);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0, i;
	
	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 29 */
/***/ function(module, exports) {

	module.exports = CompositeImage;
	
	/**
	 * @class CompositeImage
	 * @private
	 *
	 * Utility class to composite tiles into a complete image
	 * and track the rendered state of an image as new tiles
	 * load.
	 */
	
	/**
	 * @param levels {Array.<Array.<Tile>>}
	 * @constructor
	 */
	function CompositeImage(levels)
	{
	    this._levels = levels;  // Assume levels sorted high-res first
	    var urlsToTiles = this._urlsToTiles = {};
	
	    levels.forEach(function (level)
	    {
	        level.tiles.forEach(function (tile)
	        {
	            urlsToTiles[tile.url] = {
	                zoomLevel: level.zoomLevel,
	                row: tile.row,
	                col: tile.col
	            };
	        });
	    });
	
	    this.clear();
	}
	
	CompositeImage.prototype.clear = function ()
	{
	    var loadedByLevel = this._loadedByLevel = {};
	
	    this._levels.forEach(function (level)
	    {
	        loadedByLevel[level.zoomLevel] = new TileCoverageMap(level.rows, level.cols);
	    });
	};
	
	CompositeImage.prototype.getTiles = function (baseZoomLevel)
	{
	    var toRenderByLevel = [];
	    var highestZoomLevel = this._levels[0].zoomLevel;
	    var covered = new TileCoverageMap(this._levels[0].rows, this._levels[0].cols);
	
	    var bestLevelIndex;
	
	    // Default to the lowest zoom level
	    if (baseZoomLevel === null)
	    {
	        bestLevelIndex = 0;
	    }
	    else
	    {
	        var ceilLevel = Math.ceil(baseZoomLevel);
	        bestLevelIndex = findIndex(this._levels, function (level)
	        {
	            return level.zoomLevel <= ceilLevel;
	        });
	    }
	
	
	    // The best level, followed by higher-res levels in ascending order of resolution,
	    // followed by lower-res levels in descending order of resolution
	    var levelsByPreference = this._levels.slice(0, bestLevelIndex + 1).reverse()
	        .concat(this._levels.slice(bestLevelIndex + 1));
	
	    levelsByPreference.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        var additionalTiles = level.tiles.filter(function (tile)
	        {
	            return loaded.isLoaded(tile.row, tile.col);
	        });
	
	        // Filter out entirely covered tiles
	
	        // FIXME: Is it better to draw all of a partially covered tile,
	        // with some of it ultimately covered, or to pick out the region
	        // which needs to be drawn?
	        // See https://github.com/DDMAL/diva.js/issues/358
	
	        var scaleRatio = Math.pow(2, highestZoomLevel - level.zoomLevel);
	
	        additionalTiles = additionalTiles.filter(function (tile)
	        {
	            var isNeeded = false;
	
	            var highResRow = tile.row * scaleRatio;
	            var highResCol = tile.col * scaleRatio;
	
	            for (var i=0; i < scaleRatio; i++)
	            {
	                for (var j=0; j < scaleRatio; j++)
	                {
	                    if (!covered.isLoaded(highResRow + i, highResCol + j))
	                    {
	                        isNeeded = true;
	                        covered.set(highResRow + i, highResCol + j, true);
	                    }
	                }
	            }
	
	            return isNeeded;
	        });
	
	        toRenderByLevel.push(additionalTiles);
	    }, this);
	
	    // Less-preferred tiles should come first
	    toRenderByLevel.reverse();
	
	    var tiles = [];
	
	    toRenderByLevel.forEach(function (byLevel)
	    {
	        tiles.push.apply(tiles, byLevel);
	    });
	
	    return tiles;
	};
	
	/**
	 * Update the composite image to take into account all the URLs
	 * loaded in an image cache.
	 *
	 * @param cache {ImageCache}
	 */
	CompositeImage.prototype.updateFromCache = function (cache)
	{
	    this.clear();
	
	    this._levels.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        level.tiles.forEach(function (tile)
	        {
	            if (cache.has(tile.url))
	                loaded.set(tile.row, tile.col, true);
	        });
	    }, this);
	};
	
	CompositeImage.prototype.updateWithLoadedUrls = function (urls)
	{
	    urls.forEach(function (url)
	    {
	        var entry = this._urlsToTiles[url];
	        this._loadedByLevel[entry.zoomLevel].set(entry.row, entry.col, true);
	    }, this);
	};
	
	function TileCoverageMap(rows, cols)
	{
	    this._rows = rows;
	    this._cols = cols;
	
	    this._map = fill(rows).map(function ()
	    {
	        return fill(cols, false);
	    });
	}
	
	TileCoverageMap.prototype.isLoaded = function (row, col)
	{
	    // Return true for out of bounds tiles because they
	    // don't need to load. (Unfortunately this will also
	    // mask logical errors.)
	    if (row >= this._rows || col >= this._cols)
	        return true;
	
	    return this._map[row][col];
	};
	
	TileCoverageMap.prototype.set = function (row, col, value)
	{
	    this._map[row][col] = value;
	};
	
	function fill(count, value)
	{
	    var arr = new Array(count);
	
	    for (var i=0; i < count; i++)
	        arr[i] = value;
	
	    return arr;
	}
	
	function findIndex(array, predicate)
	{
	    var length = array.length;
	    for (var i = 0; i < length; i++)
	    {
	        if (predicate(array[i], i))
	            return i;
	    }
	
	    return -1;
	}


/***/ },
/* 30 */
/***/ function(module, exports) {

	module.exports = DocumentLayout;
	
	/**
	 * Translate page layouts, as generated by page-layouts, into an
	 * object which computes layout information for the document as
	 * a whole.
	 */
	function DocumentLayout(config, zoomLevel)
	{
	    var computedLayout = getComputedLayout(config, zoomLevel);
	
	    this.dimensions = computedLayout.dimensions;
	    this.pageGroups = computedLayout.pageGroups;
	    this._pageLookup = getPageLookup(computedLayout.pageGroups);
	}
	
	/**
	 * @typedef {Object} PageInfo
	 * @property {number} index
	 * @property {{index, dimensions, pages, region, padding}} group
	 * @property {{height: number, width: number}} dimensions
	 * @property {{top: number, left: number}} groupOffset
	 */
	
	/**
	 * @param pageIndex
	 * @returns {PageInfo|null}
	 */
	DocumentLayout.prototype.getPageInfo = function (pageIndex)
	{
	    return this._pageLookup[pageIndex] || null;
	};
	
	/**
	 * Get the dimensions of a page
	 *
	 * @param pageIndex
	 * @returns {{height: number, width: number}}
	 */
	DocumentLayout.prototype.getPageDimensions = function (pageIndex)
	{
	    if (!this._pageLookup || !this._pageLookup[pageIndex])
	        return null;
	
	    var region = getPageRegionFromPageInfo(this._pageLookup[pageIndex]);
	
	    return {
	        height: region.bottom - region.top,
	        width: region.right - region.left
	    };
	};
	
	// TODO(wabain): Get rid of this; it's a subset of the page region, so
	// give that instead
	/**
	 * Get the top-left coordinates of a page, including*** padding
	 *
	 * @param pageIndex
	 * @param options
	 * @returns {{top: number, left: number} | null}
	 */
	DocumentLayout.prototype.getPageOffset = function (pageIndex, options)
	{
	    var region = this.getPageRegion(pageIndex, options);
	
	    if (!region)
	        return null;
	
	    return {
	        top: region.top,
	        left: region.left
	    };
	};
	
	DocumentLayout.prototype.getPageRegion = function (pageIndex, options)
	{
	    var pageInfo = this._pageLookup[pageIndex];
	
	    if (!pageInfo)
	        return null;
	
	    var region = getPageRegionFromPageInfo(pageInfo);
	
	    if (options && options.excludePadding)
	    {
	        // FIXME?
	        var padding = pageInfo.group.padding;
	
	        return {
	            top: region.top + padding.top,
	            left: region.left + padding.left,
	            bottom: region.bottom,
	            right: region.right
	        };
	    }
	
	    return region;
	};
	
	/**
	 * Get the distance from the top-right of the page to the center of the
	 * specified viewport region
	 *
	 * @param pageIndex
	 * @param viewport {{top: number, left: number, bottom: number, right: number}}
	 * @returns {{x: number, y: number}}
	 */
	DocumentLayout.prototype.getPageToViewportCenterOffset = function (pageIndex, viewport)
	{
	    var scrollLeft = viewport.left;
	    var elementWidth = viewport.right - viewport.left;
	
	    var offset = this.getPageOffset(pageIndex);
	
	    var x = scrollLeft - offset.left + parseInt(elementWidth / 2, 10);
	
	    var scrollTop = viewport.top;
	    var elementHeight = viewport.bottom - viewport.top;
	
	    var y = scrollTop - offset.top + parseInt(elementHeight / 2, 10);
	
	    return {
	        x: x,
	        y: y
	    };
	};
	
	function getPageRegionFromPageInfo(page)
	{
	    var top    = page.groupOffset.top  + page.group.region.top;
	    var bottom = top + page.dimensions.height;
	    var left   = page.groupOffset.left + page.group.region.left;
	    var right  = left + page.dimensions.width;
	
	    return {
	        top: top,
	        bottom: bottom,
	        left: left,
	        right: right
	    };
	}
	
	function getPageLookup(pageGroups)
	{
	    var pageLookup = {};
	
	    pageGroups.forEach(function (group)
	    {
	        group.pages.forEach(function (page)
	        {
	            pageLookup[page.index] = {
	                index: page.index,
	                group: group,
	                dimensions: page.dimensions,
	                groupOffset: page.groupOffset
	            };
	        });
	    });
	
	    return pageLookup;
	}
	
	function getComputedLayout(config, zoomLevel)
	{
	    var scaledLayouts = zoomLevel === null ? config.pageLayouts : getScaledPageLayouts(config, zoomLevel);
	
	    var documentSecondaryExtent = getExtentAlongSecondaryAxis(config, scaledLayouts);
	
	    // The current position in the document along the primary axis
	    var primaryDocPosition = config.verticallyOriented ?
	        config.padding.document.top :
	        config.padding.document.left;
	
	    var pageGroups = [];
	
	    // TODO: Use bottom, right as well
	    var pagePadding = {
	        top: config.padding.page.top,
	        left: config.padding.page.left
	    };
	
	    scaledLayouts.forEach(function (layout, index)
	    {
	        var top, left;
	
	        if (config.verticallyOriented)
	        {
	            top = primaryDocPosition;
	            left = (documentSecondaryExtent - layout.dimensions.width) / 2;
	        }
	        else
	        {
	            top = (documentSecondaryExtent - layout.dimensions.height) / 2;
	            left = primaryDocPosition;
	        }
	
	        var region = {
	            top: top,
	            bottom: top + pagePadding.top + layout.dimensions.height,
	            left: left,
	            right: left + pagePadding.left + layout.dimensions.width
	        };
	
	        pageGroups.push({
	            index: index,
	            dimensions: layout.dimensions,
	            pages: layout.pages,
	            region: region,
	            padding: pagePadding
	        });
	
	        primaryDocPosition = config.verticallyOriented ? region.bottom : region.right;
	    });
	
	    var height, width;
	
	    if (config.verticallyOriented)
	    {
	        height = primaryDocPosition + pagePadding.top;
	        width = documentSecondaryExtent;
	    }
	    else
	    {
	        height = documentSecondaryExtent;
	        width = primaryDocPosition + pagePadding.left;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pageGroups: pageGroups
	    };
	}
	
	function getScaledPageLayouts(config, zoomLevel)
	{
	    var scaleRatio = Math.pow(2, zoomLevel - config.maxZoomLevel);
	
	    return config.pageLayouts.map(function (group)
	    {
	        return {
	            dimensions: scaleDimensions(group.dimensions, scaleRatio),
	            pages: group.pages.map(function (page)
	            {
	                return {
	                    index: page.index,
	                    groupOffset: {
	                        top: Math.floor(page.groupOffset.top * scaleRatio),
	                        left: Math.floor(page.groupOffset.left * scaleRatio)
	                    },
	                    dimensions: scaleDimensions(page.dimensions, scaleRatio)
	                };
	            })
	        };
	    });
	}
	
	function scaleDimensions(dimensions, scaleRatio)
	{
	    return {
	        height: Math.floor(dimensions.height * scaleRatio),
	        width: Math.floor(dimensions.width * scaleRatio)
	    };
	}
	
	function getExtentAlongSecondaryAxis(config, scaledLayouts)
	{
	    // Get the extent of the document along the secondary axis
	    var secondaryDim, secondaryPadding;
	    var docPadding = config.padding.document;
	
	    if (config.verticallyOriented)
	    {
	        secondaryDim = 'width';
	        secondaryPadding = docPadding.left + docPadding.right;
	    }
	    else
	    {
	        secondaryDim = 'height';
	        secondaryPadding = docPadding.top + docPadding.bottom;
	    }
	
	    return secondaryPadding + scaledLayouts.reduce(function (maxDim, layout)
	    {
	        return Math.max(layout.dimensions[secondaryDim], maxDim);
	    }, 0);
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(25)('diva:ImageCache');
	
	module.exports = ImageCache;
	
	/* FIXME(wabain): The caching strategy here is completely
	 * arbitrary and the implementation isn't especially efficient.
	 */
	
	var DEFAULT_MAX_KEYS = 100;
	
	function ImageCache(options)
	{
	    options = options || { maxKeys: DEFAULT_MAX_KEYS };
	    this.maxKeys = options.maxKeys || DEFAULT_MAX_KEYS;
	
	    this._held = {};
	    this._urls = {};
	    this._lru = [];
	}
	
	ImageCache.prototype.get = function (url)
	{
	    var record = this._urls[url];
	    return record ? record.img : null;
	};
	
	ImageCache.prototype.has = function (url)
	{
	    return !!this._urls[url];
	};
	
	ImageCache.prototype.put = function (url, img)
	{
	    var record = this._urls[url];
	    if (record)
	    {
	        // FIXME: Does this make sense for this use case?
	        record.img = img;
	        this._promote(record);
	    }
	    else
	    {
	        record = {
	            img: img,
	            url: url
	        };
	
	        this._urls[url] = record;
	        this._tryEvict(1);
	        this._lru.unshift(record);
	    }
	};
	
	ImageCache.prototype._promote = function (record)
	{
	    var index = this._lru.indexOf(record);
	    this._lru.splice(index, 1);
	    this._lru.unshift(record);
	};
	
	ImageCache.prototype._tryEvict = function (extraCapacity)
	{
	    var allowedEntryCount = this.maxKeys - extraCapacity;
	
	    if (this._lru.length <= allowedEntryCount)
	        return;
	
	    var evictionIndex = this._lru.length - 1;
	
	    for (;;)
	    {
	        var target = this._lru[evictionIndex];
	
	        if (!this._held[target.url])
	        {
	            debug('Evicting image %s', target.url);
	            this._lru.splice(evictionIndex, 1);
	            delete this._urls[target.url];
	
	            if (this._lru.length <= allowedEntryCount)
	                break;
	        }
	
	        if (evictionIndex === 0)
	        {
	            /* istanbul ignore next */
	            debug.enabled && debug('Cache overfull by %s (all entries are being held)',
	                this._lru.length - allowedEntryCount);
	
	            break;
	        }
	
	        evictionIndex--;
	    }
	};
	
	ImageCache.prototype.acquire = function (url)
	{
	    this._held[url] = (this._held[url] || 0) + 1;
	    this._promote(this._urls[url]);
	};
	
	ImageCache.prototype.release = function (url)
	{
	    var count = this._held[url];
	
	    if (count > 1)
	        this._held[url]--;
	    else
	        delete this._held[url];
	
	    this._tryEvict(0);
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var debug = __webpack_require__(25)('diva:ImageRequestHandler');
	
	module.exports = ImageRequestHandler;
	
	/**
	 * Handler for the request for an image tile
	 *
	 * @param url
	 * @param callback
	 * @constructor
	 */
	function ImageRequestHandler(options)
	{
	    this._url = options.url;
	    this._callback = options.load;
	    this._errorCallback = options.error;
	    this.timeoutTime = options.timeoutTime || 0;
	    this._aborted = this._complete = false;
	
	    //Use a timeout to allow the requests to be debounced (as they are in renderer)
	    this.timeout = setTimeout(function()
	    {
	        // Initiate the request
	        this._image = new Image();
	        this._image.crossOrigin = "anonymous";
	        this._image.onload = this._handleLoad.bind(this);
	        this._image.onerror = this._handleError.bind(this);
	        this._image.src = options.url;
	
	        debug('Requesting image %s', options.url);
	    }.bind(this), this.timeoutTime);
	}
	
	ImageRequestHandler.prototype.abort = function ()
	{
	    debug('Aborting request to %s', this._url);
	
	    clearTimeout(this.timeout);
	
	    // FIXME
	    // People on the Internet say that doing this {{should/should not}} abort the request. I believe
	    // it corresponds to what the WHATWG HTML spec says should happen when the UA
	    // updates the image data if selected source is null.
	    //
	    // Sources:
	    //
	    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element
	    // http://stackoverflow.com/questions/7390888/does-changing-the-src-attribute-of-an-image-stop-the-image-from-downloading
	    if (this._image)
	    {
	        this._image.onload = this._image.onerror = null;
	
	        this._image.src = '';
	    }
	
	    this._aborted = true;
	};
	
	ImageRequestHandler.prototype._handleLoad = function ()
	{
	    if (this._aborted)
	    {
	        console.error('ImageRequestHandler invoked on cancelled request for ' + this._url);
	        return;
	    }
	
	    if (this._complete)
	    {
	        console.error('ImageRequestHandler invoked on completed request for ' + this._url);
	        return;
	    }
	
	    this._complete = true;
	
	    debug('Received image %s', this._url);
	    this._callback(this._image);
	};
	
	ImageRequestHandler.prototype._handleError = function ()
	{
	    debug('Failed to load image %s', this._url);
	    this._errorCallback(this._image);
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	/* global performance */
	
	// TODO: requestAnimationFrame fallback
	
	module.exports = {
	    animate: animate,
	    easing: {
	        linear: linearEasing
	    }
	};
	
	function animate(options)
	{
	    var durationMs = options.duration;
	    var parameters = options.parameters;
	    var onUpdate = options.onUpdate;
	    var onEnd = options.onEnd;
	
	    // Setup
	    // Times are in milliseconds from a basically arbitrary start
	    var start = now();
	    var end = start + durationMs;
	
	    var tweenFns = {};
	    var values = {};
	    var paramKeys = Object.keys(parameters);
	
	    paramKeys.forEach(function (key)
	    {
	        var config = parameters[key];
	        tweenFns[key] = interpolate(config.from, config.to, config.easing || linearEasing);
	    });
	
	    // Run it!
	    var requestId = requestAnimationFrame(update);
	
	    return {
	        cancel: function ()
	        {
	            if (requestId !== null)
	            {
	                cancelAnimationFrame(requestId);
	                handleAnimationCompletion({
	                    interrupted: true
	                });
	            }
	        }
	    };
	
	    function update()
	    {
	        var current = now();
	        var elapsed = Math.min((current - start) / durationMs, 1);
	
	        updateValues(elapsed);
	        onUpdate(values);
	
	        if (current < end)
	            requestId = requestAnimationFrame(update);
	        else
	            handleAnimationCompletion({
	                interrupted: false
	            });
	    }
	
	    function updateValues(elapsed)
	    {
	        paramKeys.forEach(function (key)
	        {
	            values[key] = tweenFns[key](elapsed);
	        });
	    }
	
	    function handleAnimationCompletion(info)
	    {
	        requestId = null;
	
	        if (onEnd)
	            onEnd(info);
	    }
	}
	
	function interpolate(start, end, easing)
	{
	    return function (elapsed)
	    {
	        return start + (end - start) * easing(elapsed);
	    };
	}
	
	function linearEasing(e)
	{
	    return e;
	}
	
	var now;
	
	if (typeof performance !== 'undefined' && performance.now)
	{
	    now = function ()
	    {
	        return performance.now();
	    };
	}
	else
	{
	    now = function ()
	    {
	        return Date.now();
	    };
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var getBookLayoutGroups = __webpack_require__(35);
	var getSinglesLayoutGroups = __webpack_require__(37);
	var getGridLayoutGroups = __webpack_require__(38);
	
	module.exports = getPageLayouts;
	
	/** Get the relative positioning of pages for the current view */
	function getPageLayouts(settings)
	{
	    if (settings.inGrid)
	    {
	        return getGridLayoutGroups(pluck(settings, [
	            'manifest',
	            'viewport',
	            'pagesPerRow',
	            'fixedHeightGrid',
	            'fixedPadding',
	            'showNonPagedPages'
	        ]));
	    }
	    else
	    {
	        var config = pluck(settings, ['manifest', 'verticallyOriented', 'showNonPagedPages']);
	
	        if (settings.inBookLayout)
	            return getBookLayoutGroups(config);
	        else
	            return getSinglesLayoutGroups(config);
	    }
	}
	
	function pluck(obj, keys)
	{
	    var out = {};
	    keys.forEach(function (key)
	    {
	        out[key] = obj[key];
	    });
	    return out;
	}


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(36);
	
	module.exports = getBookLayoutGroups;
	
	function getBookLayoutGroups(viewerConfig)
	{
	    var groupings = getGroupings(viewerConfig);
	
	    return groupings.map(function (grouping)
	    {
	        return getGroupLayoutsFromPageGrouping(viewerConfig, grouping);
	    });
	}
	
	function getGroupings(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    var pagesByGroup = [];
	    var leftPage = null;
	    var nonPagedPages = []; // Pages to display below the current group
	
	    var _addNonPagedPages = function()
	    {
	        for (var i = 0; i < nonPagedPages.length; i++)
	        {
	            pagesByGroup.push([ nonPagedPages[i] ]);
	        }
	        nonPagedPages = [];
	    };
	
	    manifest.pages.forEach(function (page, index)
	    {
	        var pageRecord = {
	            index: index,
	            dimensions: getPageDimensions(index, manifest),
	            paged: (!manifest.paged || page.paged)
	        };
	
	        // Only display non-paged pages if specified in the settings
	        if (!viewerConfig.showNonPagedPages && !pageRecord.paged)
	            return;
	
	        if (!pageRecord.paged)
	        {
	            nonPagedPages.push(pageRecord);
	        }
	        else if (index === 0 || page.facingPages)
	        {
	            // The first page is placed on its own
	            pagesByGroup.push([pageRecord]);
	            _addNonPagedPages();
	        }
	        else if (leftPage === null)
	        {
	            leftPage = pageRecord;
	        }
	        else
	        {
	            pagesByGroup.push([leftPage, pageRecord]);
	            leftPage = null;
	            _addNonPagedPages();
	        }
	    });
	
	    // Flush a final left page
	    if (leftPage !== null)
	    {
	        pagesByGroup.push([leftPage]);
	        _addNonPagedPages();
	    }
	
	    return pagesByGroup;
	}
	
	function getGroupLayoutsFromPageGrouping(viewerConfig, grouping)
	{
	    var verticallyOriented = viewerConfig.verticallyOriented;
	
	    if (grouping.length === 2)
	        return getFacingPageGroup(grouping[0], grouping[1], verticallyOriented);
	
	    var page = grouping[0];
	    var pageDims = page.dimensions;
	
	    // The first page is placed on its own to the right in vertical orientation.
	    // NB that this needs to be the page with index 0; if the first page is excluded
	    // from the layout then this special case shouldn't apply.
	    // If the page is tagged as 'non-paged', center it horizontally
	    var leftOffset;
	    if (page.paged)
	        leftOffset = (page.index === 0 && verticallyOriented) ? pageDims.width : 0;
	    else
	        leftOffset = (verticallyOriented) ? pageDims.width / 2 : 0;
	
	    var shouldBeHorizontallyAdjusted =
	        verticallyOriented && !viewerConfig.manifest.pages[page.index].facingPages;
	
	    // We need to left-align the page in vertical orientation, so we double
	    // the group width
	    return {
	        dimensions: {
	            height: pageDims.height,
	            width: shouldBeHorizontallyAdjusted ? pageDims.width * 2 : pageDims.width
	        },
	        pages: [{
	            index: page.index,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            },
	            dimensions: pageDims
	        }]
	    };
	}
	
	function getFacingPageGroup(leftPage, rightPage, verticallyOriented)
	{
	    var leftDims = leftPage.dimensions;
	    var rightDims = rightPage.dimensions;
	
	    var height = Math.max(leftDims.height, rightDims.height);
	
	    var width, firstLeftOffset, secondLeftOffset;
	
	    if (verticallyOriented)
	    {
	        var midWidth = Math.max(leftDims.width, rightDims.width);
	
	        width = midWidth * 2;
	
	        firstLeftOffset = midWidth - leftDims.width;
	        secondLeftOffset = midWidth;
	    }
	    else
	    {
	        width = leftDims.width + rightDims.width;
	        firstLeftOffset = 0;
	        secondLeftOffset = leftDims.width;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pages: [
	            {
	                index: leftPage.index,
	                dimensions: leftDims,
	                groupOffset: {
	                    top: 0,
	                    left: firstLeftOffset
	                }
	            },
	            {
	                index: rightPage.index,
	                dimensions: rightDims,
	                groupOffset: {
	                    top: 0,
	                    left: secondLeftOffset
	                }
	            }
	        ]
	    };
	}


/***/ },
/* 36 */
/***/ function(module, exports) {

	module.exports = function getPageDimensions(pageIndex, manifest)
	{
	    var dims = manifest.getMaxPageDimensions(pageIndex);
	
	    return {
	        width: Math.floor(dims.width),
	        height: Math.floor(dims.height)
	    };
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(36);
	
	module.exports = function getSinglesLayoutGroups(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    // Render each page alone in a group
	    var pages = [];
	    manifest.pages.forEach(function (page, index)
	    {
	        if (!viewerConfig.showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        var pageDims = getPageDimensions(index, manifest);
	
	        pages.push({
	            dimensions: pageDims,
	            pages: [
	                {
	                    index: index,
	                    groupOffset: {top: 0, left: 0},
	                    dimensions: pageDims
	                }
	            ]
	        });
	    });
	
	    return pages;
	};


/***/ },
/* 38 */
/***/ function(module, exports) {

	module.exports = getGridLayoutGroups;
	
	function getGridLayoutGroups(viewerConfig)
	{
	    var viewportWidth = viewerConfig.viewport.width;
	    var manifest = viewerConfig.manifest;
	    var pagesPerRow = viewerConfig.pagesPerRow;
	    var fixedHeightGrid = viewerConfig.fixedHeightGrid;
	    var fixedPadding = viewerConfig.fixedPadding;
	    var showNonPagedPages = viewerConfig.showNonPagedPages;
	
	    var horizontalPadding = fixedPadding * (pagesPerRow + 1);
	    var pageWidth = (viewportWidth - horizontalPadding) / pagesPerRow;
	    var gridPageWidth = pageWidth;
	
	    // Calculate the row height depending on whether we want to fix the width or the height
	    var rowHeight = (fixedHeightGrid) ? fixedPadding + manifest.minRatio * pageWidth : fixedPadding + manifest.maxRatio * pageWidth;
	
	    var groups = [];
	    var currentPages = [];
	
	    var getGridPageDimensions = function (pageData)
	    {
	        // Calculate the width, height and horizontal placement of this page
	        // Get dimensions at max zoom level, although any level should be fine
	        var pageDimenData = pageData.d[pageData.d.length - 1];
	        var heightToWidthRatio = pageDimenData.h / pageDimenData.w;
	
	        var pageWidth, pageHeight;
	
	        if (fixedHeightGrid)
	        {
	            pageWidth = (rowHeight - fixedPadding) / heightToWidthRatio;
	            pageHeight = rowHeight - fixedPadding;
	        }
	        else
	        {
	            pageWidth = gridPageWidth;
	            pageHeight = pageWidth * heightToWidthRatio;
	        }
	
	        return {
	            width: Math.round(pageWidth),
	            height: Math.round(pageHeight)
	        };
	    };
	
	    var rowDimensions = {
	        height: rowHeight,
	        width: viewportWidth
	    };
	
	    manifest.pages.forEach(function (page, pageIndex)
	    {
	        if (!showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        // Calculate the width, height and horizontal placement of this page
	        var pageDimens = getGridPageDimensions(page);
	        var leftOffset = Math.floor(currentPages.length * (fixedPadding + gridPageWidth) + fixedPadding);
	
	        // Center the page if the height is fixed (otherwise, there is no horizontal padding)
	        if (fixedHeightGrid)
	        {
	            leftOffset += (gridPageWidth - pageDimens.width) / 2;
	        }
	
	        // TODO: Precompute page dimensions everywhere
	        currentPages.push({
	            index: pageIndex,
	            dimensions: pageDimens,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            }
	        });
	
	        if (currentPages.length === pagesPerRow)
	        {
	            groups.push({
	                dimensions: rowDimensions,
	                pages: currentPages
	            });
	
	            currentPages = [];
	        }
	    });
	
	    if (currentPages.length > 0)
	    {
	        groups.push({
	            dimensions: rowDimensions,
	            pages: currentPages
	        });
	    }
	
	    return groups;
	}


/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = createSettingsView;
	
	function createSettingsView(sources)
	{
	    var obj = {};
	
	    sources.forEach(function (source)
	    {
	        registerMixin(obj, source);
	    });
	
	    return obj;
	}
	
	function registerMixin(obj, mixin)
	{
	    Object.keys(mixin).forEach(function (key)
	    {
	        Object.defineProperty(obj, key, {
	            get: function ()
	            {
	                return mixin[key];
	            },
	            set: function ()
	            {
	                // TODO: Make everything strict mode so this isn't needed
	                throw new TypeError('Cannot set settings.' + key);
	            }
	        });
	    });
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	var extend = __webpack_require__(3).extend;
	
	module.exports = ValidationRunner;
	
	function ValidationRunner(options)
	{
	    this.whitelistedKeys = options.whitelistedKeys || [];
	    this.additionalProperties = options.additionalProperties || [];
	    this.validations = options.validations;
	}
	
	ValidationRunner.prototype.isValid = function (key, value, settings)
	{
	    // Get the validation index
	    var validationIndex = null;
	
	    this.validations.some(function (validation, index)
	    {
	        if (validation.key !== key)
	            return false;
	
	        validationIndex = index;
	        return true;
	    });
	
	    if (validationIndex === null)
	        return true;
	
	    // Run the validation
	    var dummyChanges = {};
	    dummyChanges[key] = value;
	    var proxier = createSettingsProxier(settings, dummyChanges, this);
	
	    return !this._runValidation(validationIndex, value, proxier);
	};
	
	ValidationRunner.prototype.validate = function (settings)
	{
	    this._validateOptions({}, settings);
	};
	
	ValidationRunner.prototype.getValidatedOptions = function (settings, options)
	{
	    var cloned = extend({}, options);
	    this._validateOptions(settings, cloned);
	    return cloned;
	};
	
	ValidationRunner.prototype._validateOptions = function (settings, options)
	{
	    var settingsProxier = createSettingsProxier(settings, options, this);
	    this._applyValidations(options, settingsProxier);
	};
	
	ValidationRunner.prototype._applyValidations = function (options, proxier)
	{
	    this.validations.forEach(function (validation, index)
	    {
	        if (!options.hasOwnProperty(validation.key))
	            return;
	
	        var input = options[validation.key];
	        var corrected = this._runValidation(index, input, proxier);
	
	        if (corrected)
	        {
	            if (!corrected.warningSuppressed)
	                emitWarning(validation.key, input, corrected.value);
	
	            options[validation.key] = corrected.value;
	        }
	    }, this);
	};
	
	ValidationRunner.prototype._runValidation = function (index, input, proxier)
	{
	    var validation = this.validations[index];
	
	    proxier.index = index;
	
	    var warningSuppressed = false;
	    var config = {
	        suppressWarning: function ()
	        {
	            warningSuppressed = true;
	        }
	    };
	
	    var outputValue = validation.validate(input, proxier.proxy, config);
	
	    if (outputValue === undefined || outputValue === input)
	        return null;
	
	    return {
	        value: outputValue,
	        warningSuppressed: warningSuppressed
	    };
	};
	
	/**
	 * The settings proxy wraps the settings object and ensures that
	 * only values which have previously been validated are accessed,
	 * throwing a TypeError otherwise.
	 *
	 * FIXME(wabain): Is it worth keeping this? When I wrote it I had
	 * multiple validation stages and it was a lot harder to keep track
	 * of everything, so this was more valuable.
	 */
	function createSettingsProxier(settings, options, runner)
	{
	    var proxier = {
	        proxy: {},
	        index: null
	    };
	
	    var lookup = lookupValue.bind(null, settings, options);
	
	    var properties = {};
	
	    runner.whitelistedKeys.forEach(function (whitelisted)
	    {
	        properties[whitelisted] = {
	            get: lookup.bind(null, whitelisted)
	        };
	    });
	
	    runner.additionalProperties.forEach(function (additional)
	    {
	        properties[additional.key] = {
	            get: additional.get
	        };
	    });
	
	    runner.validations.forEach(function (validation, validationIndex)
	    {
	        properties[validation.key] = {
	            get: function ()
	            {
	                if (validationIndex < proxier.index)
	                    return lookup(validation.key);
	
	                var currentKey = runner.validations[proxier.index].key;
	                throw new TypeError('Cannot access setting ' + validation.key + ' while validating ' + currentKey);
	            }
	        };
	    });
	
	    Object.defineProperties(proxier.proxy, properties);
	
	    return proxier;
	}
	
	function emitWarning(key, original, corrected)
	{
	    console.warn('Invalid value for ' + key + ': ' + original + '. Using ' + corrected + ' instead.');
	}
	
	function lookupValue(base, extension, key)
	{
	    if (key in extension)
	        return extension[key];
	
	    return base[key];
	}


/***/ },
/* 41 */
/***/ function(module, exports) {

	module.exports = Viewport;
	
	function Viewport(outer, options)
	{
	    options = options || {};
	
	    this.intersectionTolerance = options.intersectionTolerance || 0;
	    this.maxExtent = options.maxExtent || 2000;
	
	    this.outer = outer;
	
	    this._top = this._left = this._width = this._height = this._innerDimensions = null;
	
	    this.invalidate();
	}
	
	Viewport.prototype.intersectsRegion = function (region)
	{
	    return this.hasHorizontalOverlap(region) && this.hasVerticalOverlap(region);
	};
	
	Viewport.prototype.hasVerticalOverlap = function (region)
	{
	    var top = this.top - this.intersectionTolerance;
	    var bottom = this.bottom + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.top, top, bottom) ||
	        fallsBetween(region.bottom, top, bottom) ||
	        (region.top <= top && region.bottom >= bottom)
	    );
	};
	
	Viewport.prototype.hasHorizontalOverlap = function (region)
	{
	    var left = this.left - this.intersectionTolerance;
	    var right = this.right + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.left, left, right) ||
	        fallsBetween(region.right, left, right) ||
	        (region.left <= left && region.right >= right)
	    );
	};
	
	Viewport.prototype.invalidate = function ()
	{
	    // FIXME: Should this check the inner dimensions as well?
	    this._width = clampMax(this.outer.clientWidth, this.maxExtent);
	    this._height = clampMax(this.outer.clientHeight, this.maxExtent);
	
	    this._top = this.outer.scrollTop;
	    this._left = this.outer.scrollLeft;
	};
	
	Viewport.prototype.setInnerDimensions = function (dimensions)
	{
	    this._innerDimensions = dimensions;
	
	    if (dimensions)
	    {
	        this._top = clamp(this._top, 0, dimensions.height - this._height);
	        this._left = clamp(this._left, 0, dimensions.width - this._width);
	    }
	};
	
	Object.defineProperties(Viewport.prototype, {
	    top: getCoordinateDescriptor('top', 'height'),
	    left: getCoordinateDescriptor('left', 'width'),
	
	    width: getDimensionDescriptor('width'),
	    height: getDimensionDescriptor('height'),
	
	    bottom: {
	        get: function ()
	        {
	            return this._top + this._height;
	        }
	    },
	    right: {
	        get: function ()
	        {
	            return this._left + this._width;
	        }
	    }
	});
	
	function getCoordinateDescriptor(coord, associatedDimension)
	{
	    var privateProp = '_' + coord;
	    var source = 'scroll' + coord.charAt(0).toUpperCase() + coord.slice(1);
	
	    return {
	        get: function ()
	        {
	            return this[privateProp];
	        },
	        set: function (newValue)
	        {
	            var normalized;
	
	            if (this._innerDimensions)
	            {
	                var maxAllowed = this._innerDimensions[associatedDimension] - this[associatedDimension];
	                normalized = clamp(newValue, 0, maxAllowed);
	            }
	            else
	            {
	                normalized = clampMin(newValue, 0);
	            }
	
	            this[privateProp] = this.outer[source] = normalized;
	        }
	    };
	}
	
	function getDimensionDescriptor(dimen)
	{
	    return {
	        get: function ()
	        {
	            return this['_' + dimen];
	        }
	    };
	}
	
	function fallsBetween(point, start, end)
	{
	    return point >= start && point <= end;
	}
	
	function clamp(value, min, max)
	{
	    return clampMin(clampMax(value, max), min);
	}
	
	function clampMin(value, min)
	{
	    return Math.max(value, min);
	}
	
	function clampMax(value, max)
	{
	    return Math.min(value, max);
	}


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/*
	
	Canvas plugin for diva.js
	Adds an adjustment icon next to each image
	
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	__webpack_require__(15);
	
	(function ($)
	{
	    module.exports = (function ()
	    {
	        var canvas = {},
	            map = {},
	            settings = {},
	            image,
	            sliders,
	            sliderMode;
	
	        // Set up some default settings (can be overridden the normal way)
	        var defaults = {
	            brightnessMax: 150,
	            brightnessMin: -100,
	            brightnessStep: 1,
	            contrastMax: 3,
	            contrastMin: -1,
	            contrastStep: 0.05,
	            localStoragePrefix: 'canvas-',
	            mobileWebkitMaxZoom: 2,
	            rgbMax: 50,
	            rgbMin: -50,
	            throbberFadeSpeed: 200,
	            throbberTimeout: 100,
	            buttons: [
	                'contrast',
	                'brightness',
	                'rotation',
	                'zoom'
	            ]
	        };
	
	        // Convert an angle from degrees to radians
	        var toRadians = function (angle)
	        {
	            return angle * Math.PI / 180;
	        };
	
	        // Determine the new center of the page after rotating by the given angle
	        var getNewCenter = function (currentCenter, angle)
	        {
	            var x = currentCenter.x - canvas.centerX;
	            // Take the negative because the rotation is counterclockwise
	            var y = -(currentCenter.y - canvas.centerY);
	
	            var theta = toRadians(sliders.rotation.previous - angle);
	            var newX = Math.cos(theta) * x - Math.sin(theta) * y + canvas.centerX;
	            var newY = -(Math.sin(theta) * x + Math.cos(theta) * y) + canvas.centerY;
	
	            return {'x': newX, 'y': newY};
	        };
	
	        // Rotates the image on the given canvas by the given angle
	        var rotateCanvas = function (aCanvas, angle)
	        {
	            var context = aCanvas.context;
	            var center = aCanvas.size / 2;
	            var startX = -(aCanvas.width / 2);
	            var startY = -(aCanvas.height / 2);
	
	            // Clear the canvas so that remnants of the old image don't show
	            context.clearRect(0, 0, aCanvas.size, aCanvas.size);
	
	            // Do the rotation
	            context.save();
	            context.translate(center, center);
	            context.rotate(toRadians(angle));
	            context.drawImage(image, startX, startY, aCanvas.width, aCanvas.height);
	            context.restore();
	
	            // Save the new pixel data so that it can later be adjusted in adjustLevels
	            aCanvas.data = context.getImageData(0, 0, aCanvas.size, aCanvas.size);
	        };
	
	        // Determine if we need to update the large canvas
	        var shouldAdjustLevels = function ()
	        {
	            var slider;
	
	            // Returns true if something has been changed
	            for (slider in sliders)
	            {
	                if (sliders[slider].current !== sliders[slider].previous)
	                {
	                    return true;
	                }
	            }
	
	            return false;
	        };
	
	        // Sets the "previous" value to the "current" value for every slider
	        var updatePreviousLevels = function ()
	        {
	            var slider;
	
	            for (slider in sliders)
	            {
	                sliders[slider].previous = sliders[slider].current;
	            }
	        };
	
	        // Update the thumbnail preview (called when a slider is moved/reset)
	        var updateMap = function ()
	        {
	            rotateCanvas(map, sliders.rotation.current);
	            adjustLevels(map);
	        };
	
	        // Update the large canvas (rotation, zooming, scrolling, pixel manipulation)
	        var updateCanvas = function ()
	        {
	            var angle = sliders.rotation.current;
	            var oldAngle = sliders.rotation.previous;
	            var zoomLevel = sliders.zoom.current;
	            var oldZoomLevel = sliders.zoom.previous;
	
	            // Scroll the user to the desired location
	            if (angle !== oldAngle || zoomLevel !== oldZoomLevel)
	            {
	                // First figure out the current center of the viewport
	                var leftScroll = $('#diva-canvas-wrapper').scrollLeft();
	                var topScroll = $('#diva-canvas-wrapper').scrollTop();
	                var leftOffset = settings.viewport.width / 2;
	                var topOffset = settings.viewport.height / 2;
	
	                // Then determine the new center (the same part of the image)
	                var newCenter = getNewCenter({x: leftScroll + leftOffset, y: topScroll + topOffset}, angle);
	
	                // Incorporate the zoom change ratio (would be 1 if no change)
	                var zoomChange = Math.pow(2, zoomLevel - oldZoomLevel);
	                var toLeftScroll = zoomChange * newCenter.x - leftOffset;
	                var toTopScroll = zoomChange * newCenter.y - topOffset;
	
	                // Rotate the large canvas
	                rotateCanvas(canvas, angle);
	
	                // Scroll to the new center
	                $('#diva-canvas-wrapper').scrollLeft(toLeftScroll);
	                $('#diva-canvas-wrapper').scrollTop(toTopScroll);
	            }
	
	            // Only call adjustLevels again if we really need to (expensive)
	            if (shouldAdjustLevels())
	            {
	                adjustLevels(canvas);
	                updatePreviousLevels();
	            }
	        };
	
	        // Copies the canvas' pixel array and returns the copy
	        var copyImageData = function (aCanvas)
	        {
	            var oldImageData = aCanvas.data;
	            var newImageData = aCanvas.context.createImageData(oldImageData);
	            var pixelArray = newImageData.data;
	            var i, length;
	
	            for (i = 0, length = pixelArray.length; i < length; i++)
	            {
	                pixelArray[i] = oldImageData.data[i];
	            }
	
	            return newImageData;
	        };
	
	        // Determines whether or not we need to adjust this level - very simple
	        var shouldAdjust = function (mode)
	        {
	            var thisChanged = sliders[mode].current !== sliders[mode].previous;
	            var thisNotDefault = sliders[mode].current !== sliders[mode].initial;
	
	            return thisChanged || thisNotDefault;
	        };
	
	        var adjustLevels = function (aCanvas)
	        {
	            // Copy the pixel array to avoid destructively modifying the original
	            var imageData = copyImageData(aCanvas);
	            var pixelArray = imageData.data;
	
	            // Store and calculate some scale factors and offsets
	            var brightness = sliders.brightness.current;
	            var contrast = sliders.contrast.current;
	
	            var brightMul = 1 + Math.min(settings.brightnessMax, Math.max(settings.brightnessMin, brightness)) / settings.brightnessMax;
	            var brightTimesContrast = brightMul * contrast;
	            var contrastOffset = 128 - (contrast * 128);
	
	            var redOffset = sliders.red.current;
	            var greenOffset = sliders.green.current;
	            var blueOffset = sliders.blue.current;
	
	            // Determine whether or not we need to adjust certain things
	            var adjustRed = shouldAdjust('red');
	            var adjustGreen = shouldAdjust('green');
	            var adjustBlue = shouldAdjust('blue');
	
	            var adjustBrightness = shouldAdjust('brightness');
	            var adjustContrast = shouldAdjust('contrast');
	            var adjustOthers = adjustBrightness || adjustContrast;
	
	            var x, y, width, height, offset, r, g, b;
	
	            for (x = 0, width = imageData.width; x < width; x++)
	            {
	                for (y = 0, height = imageData.height; y < height; y++)
	                {
	                    offset = (y * width + x) * 4;
	
	                    r = pixelArray[offset];
	                    g = pixelArray[offset + 1];
	                    b = pixelArray[offset + 2];
	
	                    // Only do something if the pixel is not black originally
	                    if (r + g + b > 0)
	                    {
	                        // Only adjust individual colour channels if necessary
	                        if (adjustRed && r)
	                            r += redOffset;
	
	                        if (adjustGreen && g)
	                            g += greenOffset;
	
	                        if (adjustBlue && b)
	                            b += blueOffset;
	
	                        // If we need to adjust brightness and/or contrast
	                        if (adjustOthers)
	                        {
	                            if (r)
	                                r = r * brightTimesContrast + contrastOffset;
	
	                            if (g)
	                                g = g * brightTimesContrast + contrastOffset;
	
	                            if (b)
	                                b = b * brightTimesContrast + contrastOffset;
	                        }
	
	                        pixelArray[offset] = r;
	                        pixelArray[offset + 1] = g;
	                        pixelArray[offset + 2] = b;
	                    }
	                }
	            }
	
	            aCanvas.context.clearRect(0, 0, width, height);
	            aCanvas.context.putImageData(imageData, 0, 0);
	        };
	
	        // Update the box in the preview showing where you currently are
	        var updateViewbox = function ()
	        {
	            // Determine the top left corner coordinates based on our current position
	            var cornerX = $('#diva-canvas-wrapper').scrollLeft() * map.scaleFactor;
	            var cornerY = $('#diva-canvas-wrapper').scrollTop() * map.scaleFactor;
	
	            // Subtract 4 to compensate for the borders
	            var height = Math.min(Math.round(settings.viewport.height * map.scaleFactor), settings.mapSize) - 4;
	            var width = Math.min(Math.round(settings.viewport.width * map.scaleFactor), settings.mapSize) - 4;
	
	            $('#diva-map-viewbox').height(height).width(width).css({top: cornerY, left: cornerX});
	        };
	
	        // Draw the thumbnail preview in the toolbar
	        var loadMap = function (image)
	        {
	            map.canvas = document.getElementById('diva-canvas-minimap');
	            map.size = settings.mapSize;
	            map.canvas.width = map.size;
	            map.canvas.height = map.size;
	
	            // Give it a black background
	            map.context = map.canvas.getContext('2d');
	            map.context.fillRect(0, 0, map.size, map.size);
	
	            // Determine the coordinates/dimensions of the preview
	            map.scaleFactor = settings.mapSize / canvas.size;
	            map.cornerX = canvas.cornerX * map.scaleFactor;
	            map.cornerY = canvas.cornerY * map.scaleFactor;
	            map.width = image.width * map.scaleFactor;
	            map.height = image.height * map.scaleFactor;
	
	            // Draw the image within the map (no adjustments) and save the pixel array
	            map.context.drawImage(image, map.cornerX, map.cornerY, map.width, map.height);
	            map.data = map.context.getImageData(0, 0, settings.mapSize, settings.mapSize);
	
	            // Show the viewbox, make it reflect where we currently are
	            $('#diva-map-viewbox').show();
	            updateViewbox();
	        };
	
	        // Load the image within the large and small canvases
	        var loadCanvas = function (imageURL, callback)
	        {
	            image = new Image();
	            image.crossOrigin = "anonymous";
	
	            image.onload = function ()
	            {
	                // Determine the size of the (square) canvas based on the hypoteneuse
	                canvas.size = Math.sqrt(image.width * image.width + image.height * image.height);
	
	                // Resize the canvas if necessary
	                canvas.canvas = document.getElementById('diva-canvas');
	                canvas.canvas.width = canvas.size;
	                canvas.canvas.height = canvas.size;
	                canvas.cornerX = (canvas.size - image.width) / 2;
	                canvas.cornerY = (canvas.size - image.height) / 2;
	                canvas.width = image.width;
	                canvas.height = image.height;
	                canvas.centerX = canvas.size / 2;
	                canvas.centerY = canvas.size / 2;
	
	                // Draw the image to the large canvas, and save the pixel array
	                canvas.context = canvas.canvas.getContext('2d');
	                canvas.context.drawImage(image, canvas.cornerX, canvas.cornerY, canvas.width, canvas.height);
	                try
	                {
	                    canvas.data = canvas.context.getImageData(0, 0, canvas.size, canvas.size);
	                }
	                catch (error)
	                {
	                    var canvasError = '<div id="diva-error" class="diva-error"><p><strong>Error</strong></p><p>' + error.message + '</p>';
	
	                    if (error.name === 'SecurityError')
	                    {
	                        canvasError += '<p>You may need to update your server configuration in order to use the image manipulation tools. ' +
	                        'For help, see the <a href="https://github.com/DDMAL/diva.js/wiki/The-API-and-Plugins#a-note-about-' +
	                        'canvas-and-cross-site-data" target="_blank">canvas cross-site data documentation</a>.</p>' +
	                        '</div>';
	                    }
	                    else
	                    {
	                        throw error;
	                    }
	
	                    canvasError += '</div>';
	                    $('#diva-canvas-backdrop').append(canvasError);
	                    hideThrobber();
	                }
	
	                // Only load the map the first time (when there is no callback)
	                if (callback === undefined) {
	                    loadMap(image);
	                }
	
	                // Update the map and the canvas if necessary
	                updateMap();
	                updateCanvas(canvas);
	
	                // Hide the throbber if it is visible
	                hideThrobber();
	
	                // If the callback function exists, execute it (for zooming)
	                if (typeof callback === 'function')
	                    callback.call(callback);
	            };
	
	            image.src = imageURL;
	
	            // make sure the load event fires for cached images too
	            if ( image.complete || image.complete === undefined ) {
	                image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
	                image.src = imageURL;
	            }
	        };
	
	        var updateSliderLabel = function ()
	        {
	            var thisSlider = sliders[sliderMode];
	            var value = thisSlider.current;
	            var stringValue = (thisSlider.transform) ? thisSlider.transform(value) : value;
	            $('#diva-canvas-value').html(stringValue);
	        };
	
	        var updateSliderValue = function ()
	        {
	            $('#diva-canvas-slider').val(sliders[sliderMode].current);
	        };
	
	        // Returns the URL for the image at the specified zoom level
	        var getImageURL = function (zoomLevel)
	        {
	            var width = settings.zoomWidthRatio * Math.pow(2, zoomLevel);
	
	            return settings.divaInstance.getPageImageURL(settings.selectedPageIndex, { width: width });
	        };
	
	        var showThrobber = function ()
	        {
	            // Only show the throbber if it will take a long time
	            if (sliders.zoom.current > 0 || settings.mobileWebkit)
	                $(settings.selector + 'throbber').addClass('canvas-throbber').show();
	        };
	
	        // Hides the loading indicator icon
	        var hideThrobber = function ()
	        {
	            $(settings.selector + 'throbber').removeClass('canvas-throbber').hide();
	        };
	
	        // If any modifications have been applied, save them to localStorage
	        var saveSettings = function ()
	        {
	            var sliderSettings = {};
	            var changed = false;
	            var storageKey = settings.localStoragePrefix + settings.filename;
	            var slider;
	
	            for (slider in sliders)
	            {
	                if (sliders[slider].previous !== sliders[slider].initial)
	                {
	                    sliderSettings[slider] = sliders[slider].previous;
	                    changed = true;
	                }
	            }
	
	            // If modifications need to be saved, update the canvas plugin icon
	            if (changed)
	            {
	                settings.pluginIcon.addClass('new');
	                storeObject(storageKey, sliderSettings);
	            }
	            else
	            {
	                settings.pluginIcon.removeClass('new');
	                localStorage.removeItem(storageKey);
	            }
	        };
	
	        // Handles zooming in when the zoom slider is changed and the change is applied
	        var updateZoom = function (newZoomLevel, callback)
	        {
	            settings.zoomLevel = newZoomLevel;
	
	            // Figure out the URL for the image at this new zoom level
	            var imageURL = getImageURL(newZoomLevel);
	
	            loadCanvas(imageURL, function ()
	            {
	                // Set the new scale factor and update the viewbox
	                map.scaleFactor = map.size / canvas.size;
	                updateViewbox();
	
	                saveSettings();
	            });
	        };
	
	        var bindCanvasKeyEvents = function (event)
	        {
	            var upArrowKey = 38,
	                downArrowKey = 40,
	                leftArrowKey = 37,
	                rightArrowKey = 39;
	
	            switch (event.keyCode)
	            {
	                case upArrowKey:
	                    // Up arrow - scroll up
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop - settings.arrowScrollAmount);
	                    return false;
	
	                case downArrowKey:
	                    // Down arrow - scroll down
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop + settings.arrowScrollAmount);
	                    return false;
	
	                case leftArrowKey:
	                    // Left arrow - scroll left
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft - settings.arrowScrollAmount);
	                    return false;
	
	                case rightArrowKey:
	                    // Right arrow - scroll right
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft + settings.arrowScrollAmount);
	                    return false;
	            }
	        };
	
	        // Serialize an object to JSON and save it in localStorage
	        var storeObject = function (key, value) {
	            localStorage.setItem(key, JSON.stringify(value));
	        };
	
	        // Load and deserialize a localStorage object
	        var loadStoredObject = function (key) {
	            var value = localStorage.getItem(key);
	            return value && JSON.parse(value);
	        };
	
	        var retval =
	        {
	            init: function (divaSettings, divaInstance)
	            {
	                // If the browser does not support canvas, do nothing
	                // And, disable this plugin
	                var canvasSupported = !!window.HTMLCanvasElement;
	                if (!canvasSupported)
	                    return false;
	
	                // Override all the configurable settings defined under canvasPlugin
	                $.extend(settings, defaults, divaSettings.canvasPlugin);
	
	                settings.divaInstance = divaInstance;
	                settings.inCanvas = false;
	                settings.iipServerURL = divaSettings.iipServerURL;
	                settings.imageDir = divaSettings.imageDir;
	                settings.selector = divaSettings.selector;
	                settings.mobileWebkit = divaSettings.mobileWebkit;
	                settings.arrowScrollAmount = divaSettings.arrowScrollAmount;
	
	                // Set up the settings for the sliders/icons
	                sliders = {
	                    'contrast': {
	                        'initial': 1,
	                        'min': settings.contrastMin,
	                        'max': settings.contrastMax,
	                        'step': settings.contrastStep,
	                        'transform': function (value) {
	                            return value.toFixed(2);
	                        },
	                        'title': 'Change the contrast'
	                    },
	                    'brightness': {
	                        'initial': 0,
	                        'min': settings.brightnessMin,
	                        'max': settings.brightnessMax,
	                        'step': settings.brightnessStep,
	                        'title': 'Adjust the brightness'
	                    },
	                    'rotation': {
	                        'initial': 0,
	                        'min': 0,
	                        'max': 359,
	                        'step': 1,
	                        'transform': function (value) {
	                            return value + '&deg;';
	                        },
	                        'title': 'Rotate the image'
	                    },
	                    'zoom': {
	                        // Default, min and max values updated within setupHook
	                        'initial': 0,
	                        'min': 0,
	                        'max': 0,
	                        'step': 1,
	                        'title': 'Adjust the zoom level'
	                    },
	                    'red': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the red channel'
	                    },
	                    'green': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the green channel'
	                    },
	                    'blue': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the blue channel'
	                    }
	                };
	
	                // Copy the "default" value into "value" and "previous" for each slider
	                var resetSliders = function ()
	                {
	                    var defaultValue, thisSlider, slider;
	                    for (slider in sliders)
	                    {
	                        thisSlider = sliders[slider];
	                        defaultValue = thisSlider.initial;
	                        thisSlider.current = defaultValue;
	                        thisSlider.previous = defaultValue;
	                    }
	                };
	
	                resetSliders();
	
	                // Create the DOM elements if they haven't already been created
	                if ($('#diva-canvas-backdrop').length)
	                {
	                    // Return true to keep the plugin enabled
	                    return true;
	                }
	
	                var canvasButtonsList = [];
	                var buttonHTML, button, buttonTitle, i;
	
	                for (i in settings.buttons)
	                {
	                    button = settings.buttons[i];
	                    buttonTitle = sliders[button].title;
	                    buttonHTML = '<div class="' + button + '" title="' + buttonTitle + '"></div>';
	                    canvasButtonsList.push(buttonHTML);
	                }
	                var canvasButtons = canvasButtonsList.join('');
	
	                var canvasTools = '<div id="diva-canvas-tools">' +
	                    '<div id="diva-canvas-toolbar">' +
	                        '<div id="diva-canvas-close" title="Return to the document viewer"></div>' +
	                        '<div id="diva-canvas-minimise" title="Minimise the toolbar"></div>' +
	                        '<span id="diva-canvas-info">Test</span>' +
	                    '</div>' +
	                    '<div id="diva-canvas-toolwindow">' +
	                        '<div id="diva-map-viewbox"></div>' +
	                        '<canvas id="diva-canvas-minimap"></canvas>' +
	                        '<div id="diva-canvas-buttons">' +
	                            canvasButtons +
	                        '</div>' +
	                        '<div id="diva-canvas-pane">' +
	                            '<p id="diva-canvas-tooltip">' +
	                                '<span id="diva-canvas-mode">contrast</span>: ' +
	                                '<span id="diva-canvas-value">0</span> ' +
	                                '<span id="diva-canvas-reset" class="link">(Reset)</span>' +
	                            '</p>' +
	                            '<input type="range" id="diva-canvas-slider"></input>' +
	                        '</div>' +
	                        '<br />' +
	                        '<div class="action-buttons">' +
	                            '<a href="#" id="diva-canvas-reset-all">Reset all</a>' +
	                            '<a href="#" id="diva-canvas-apply">Apply</a>' +
	                        '</div>' +
	                    '</div>' +
	                '</div>';
	                var canvasWrapper = '<div id="diva-canvas-wrapper">' +
	                    '<canvas id="diva-canvas"></canvas>' +
	                '</div>';
	                var canvasString = '<div id="diva-canvas-backdrop">' +
	                    canvasTools +
	                    canvasWrapper +
	                '</div>';
	
	                $('body').append(canvasString);
	
	                // Save the size of the map, as defined in the CSS
	                settings.mapSize = $('#diva-canvas-minimap').width();
	
	                // Adjust the slider when something is clicked, and make that the current mode
	                $('#diva-canvas-buttons div').click(function ()
	                {
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider($(this).attr('class'));
	                });
	
	                var updateSlider = function (newMode)
	                {
	                    sliderMode = newMode;
	                    var sliderData = sliders[sliderMode];
	
	                    $('#diva-canvas-buttons .' + sliderMode).addClass('clicked');
	
	                    $('#diva-canvas-mode').text(sliderMode);
	
	                    var newValue = sliderData.current;
	                    var newValueString = (sliderData.transform) ? sliderData.transform(newValue) : newValue;
	
	                    var slider = document.getElementById('diva-canvas-slider');
	                    slider.min = sliderData.min;
	                    slider.max = sliderData.max;
	                    slider.step = sliderData.step;
	                    $('#diva-canvas-slider').val(newValue);
	                    $('#diva-canvas-value').html(newValueString);
	                };
	
	                updateSlider('contrast');
	
	                // Create the slider
	                $('#diva-canvas-slider').on('input', function(e){
	                    sliders[sliderMode].current = parseFloat(this.value);
	                    updateSliderLabel();
	                    updateMap();
	                });
	
	                // Reset all the sliders to the default value
	                $('#diva-canvas-reset-all').click(function ()
	                {
	                    var slider;
	
	                    for (slider in sliders)
	                    {
	                        sliders[slider].current = sliders[slider].initial;
	                    }
	
	                    // Change the value of the label
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Reset the current slider to the default value
	                $('#diva-canvas-reset').click(function ()
	                {
	                    // Update the current value and the slider
	                    sliders[sliderMode].current = sliders[sliderMode].initial;
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Update the large canvas when the apply button is clicked
	                $('#diva-canvas-apply').click(function ()
	                {
	                    if (shouldAdjustLevels())
	                    {
	                        showThrobber();
	
	                        setTimeout(function ()
	                        {
	                            if (sliders.zoom.current !== sliders.zoom.previous)
	                            {
	                                updateZoom(sliders.zoom.current);
	                            }
	                            else
	                            {
	                                updateCanvas();
	                                hideThrobber();
	
	                                // Save modifications to localSettings (also done in updateZoom callback)
	                                saveSettings();
	                            }
	                        }, settings.throbberTimeout);
	                    }
	                });
	
	                // Handle exiting canvas mode
	                $('#diva-canvas-close').click(function ()
	                {
	                    $('body').removeClass('overflow-hidden');
	
	                    // Clear the canvases and hide things
	                    // This needs to be improved - not done properly?
	                    canvas.context.clearRect(0, 0, canvas.size, canvas.size);
	                    map.context.clearRect(0, 0, map.size, map.size);
	                    $('#diva-canvas-wrapper').scrollTop(0).scrollLeft(0);
	                    $('#diva-canvas-backdrop').hide();
	                    $('#diva-map-viewbox').hide();
	                    hideThrobber();
	
	                    // Re-enable scrolling of diva when it is in the background
	                    divaInstance.enableScrollable();
	                    $(document).off('keydown', bindCanvasKeyEvents);
	
	                    // Reset everything
	                    resetSliders();
	                    updateSliderLabel();
	                    updateSliderValue();
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider('contrast');
	
	                    diva.Events.publish("CanvasViewDidHide");
	                });
	
	                // Hide the toolbar when the minimise icon is clicked
	                $('#diva-canvas-minimise').click(function ()
	                {
	                    $('#diva-canvas-toolwindow').slideToggle('fast');
	                });
	
	                // Adjust the size of the canvas when the browser window is resized
	                $(window).resize(function ()
	                {
	                    settings.viewport = {
	                        height: window.innerHeight - divaSettings.scrollbarWidth,
	                        width: window.innerWidth - divaSettings.scrollbarWidth
	                    };
	
	                    // Always update the settings but only redraw if in canvas
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Update the viewbox when the large canvas is scrolled
	                $('#diva-canvas-wrapper').scroll(function ()
	                {
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Handle clicking/dragging of the viewbox (should scroll the large canvas)
	                $('#diva-canvas-minimap, #diva-map-viewbox').mouseup(function (event)
	                {
	                    // Consider caching this eventually (can't be done in init though)
	                    var offset = $('#diva-canvas-minimap').offset();
	
	                    var scaledX = (event.pageX - offset.left) / map.scaleFactor;
	                    var scaledY = (event.pageY - offset.top) / map.scaleFactor;
	
	                    $('#diva-canvas-wrapper').scrollTop(scaledY - settings.viewport.height / 2);
	                    $('#diva-canvas-wrapper').scrollLeft(scaledX - settings.viewport.width / 2);
	                });
	
	                // Enable drag scroll
	                $('#diva-canvas').mousedown(function ()
	                {
	                    $(this).addClass('grabbing');
	                }).mouseup(function ()
	                {
	                    $(this).removeClass('grabbing');
	                });
	
	                // touch events
	                $('#diva-canvas-wrapper').kinetic();
	
	                // mouse events
	                $('#diva-canvas-wrapper').dragscrollable({
	                    acceptPropagatedEvent: true
	                });
	
	                diva.Events.subscribe('ObjectDidLoad', this.setupHook, divaSettings.ID);
	                diva.Events.subscribe('ViewerDidTerminate', this.destroy, divaSettings.ID);
	                diva.Events.subscribe('PageDidLoad', this.onPageLoad, divaSettings.ID);
	
	                return true;
	            },
	
	            pluginName: 'canvas',
	
	            titleText: 'View the image on a canvas and adjust various settings',
	
	            setupHook: function(divaSettings)
	            {
	                settings.viewport = {
	                    height: window.innerHeight - divaSettings.scrollbarWidth,
	                    width: window.innerWidth - divaSettings.scrollbarWidth
	                };
	
	                // Save the min and max zoom level, and update the zoom slider
	                settings.minZoomLevel = divaSettings.minZoomLevel;
	                settings.maxZoomLevel = divaSettings.maxZoomLevel;
	
	                // If we're on the iPad, limit the max zoom level to 2
	                // Can't do canvas elements that are > 5 megapixels (issue #112)
	                if (settings.mobileWebkit)
	                    settings.maxZoomLevel = Math.min(settings.maxZoomLevel, settings.mobileWebkitMaxZoom);
	
	                sliders.zoom.min = settings.minZoomLevel;
	                sliders.zoom.max = settings.maxZoomLevel;
	            },
	
	            handleClick: function(event, divaSettings, divaInstance, selectedPageIndex)
	            {
	                // loadCanvas() calls all the other necessary functions to load
	                var filename = divaInstance.getFilenames()[selectedPageIndex];
	
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                    .getPageDimensions(selectedPageIndex)
	                    .width - 1;
	
	                var zoomLevel = divaSettings.zoomLevel;
	                var slider;
	
	                settings.zoomWidthRatio = width / Math.pow(2, zoomLevel);
	                settings.pluginIcon = $(this);
	
	                settings.manifest = divaSettings.manifest;
	                settings.selectedPageIndex = selectedPageIndex;
	
	                // Limit the max zoom level if we're on the iPad
	                if (settings.mobileWebkit) {
	                    zoomLevel = Math.min(settings.maxZoomLevel, zoomLevel);
	                }
	
	                settings.filename = filename;
	                sliders.zoom.initial = zoomLevel;
	                sliders.zoom.current = zoomLevel;
	
	                // Find the settings stored in localStorage, if they exist
	                var sliderSettings = loadStoredObject(settings.localStoragePrefix + settings.filename);
	                if (sliderSettings)
	                {
	                    for (slider in sliderSettings)
	                    {
	                        sliders[slider].current = sliderSettings[slider];
	
	                        // If the current slider's value has changed, update it
	                        if (slider === sliderMode)
	                        {
	                            updateSliderLabel();
	                            updateSliderValue();
	                        }
	
	                        if (slider === 'zoom')
	                        {
	                            zoomLevel = sliderSettings[slider];
	                        }
	                    }
	                }
	
	                sliders.zoom.previous = zoomLevel;
	
	                // Prevent scroll in body, and show the canvas backdrop
	                $('body').addClass('overflow-hidden');
	                $('#diva-canvas-backdrop').show();
	
	                // Disable scrolling on main diva instance
	                divaInstance.disableScrollable();
	                // Enable canvas scrolling
	                $(document).keydown(bindCanvasKeyEvents);
	
	                // Set this to true so events can be captured
	                settings.inCanvas = true;
	
	                var imageURL = getImageURL(zoomLevel);
	
	                // Change the title of the page
	                // FIXME: This is legacy behaviour. Should this be a filename/label?
	                $('#diva-canvas-info').text('Page ' + (selectedPageIndex + 1));
	
	                showThrobber();
	
	                diva.Events.publish('CanvasViewDidActivate', [selectedPageIndex]);
	
	                loadCanvas(imageURL);
	            },
	
	            onPageLoad: function(pageIndex, filename, selector)
	            {
	                // If something exists for this page in localStorage, then change icon color
	                var storageKey = settings.localStoragePrefix + filename;
	
	                if (localStorage.getItem(storageKey) !== null)
	                {
	                    $(selector).find('.diva-canvas-icon').addClass('new');
	                }
	            },
	
	            destroy: function(divaSettings, divaInstance)
	            {
	                $('#diva-canvas-backdrop').remove();
	            }
	        };
	
	        // this returns an object with all of the necessary hooks and callbacks
	        // embedded.
	        return retval;
	
	    })();
	})(jQuery);


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Download plugin for diva.js
	Allows you to download images served by IIPImage or IIIF compatible image servers
	*/
	
	var jQuery = __webpack_require__(3);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                settings.divaInstance = divaInstance;
	                return true;
	            },
	            pluginName: 'download',
	            titleText: 'Download image at the given zoom level',
	            handleClick: function(event, divaSettings, divaInstance, pageIndex)
	            {
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                        .getPageDimensions(pageIndex)
	                        .width - 1;
	
	                var image = settings.divaInstance.getPageImageURL(pageIndex, { width: width });
	
	                window.open(image);
	            }
	        };
	
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/*
	Highlight plugin for diva.js
	Allows you to highlight regions of a page image
	*/
	
	var jQuery = __webpack_require__(3);
	var elt = __webpack_require__(8);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                var currentHighlight;
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be currently appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                * Moves the diva pane to (page) and makes a darker border on (thisDiv)
	                */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	
	                    currentHighlight = {
	                        region: thisDiv,
	                        page: page
	                    };
	
	                    diva.Events.publish("SelectedHighlightChanged", [thisDiv.id, currentHighlight.page]);
	
	                    //selects the highlight
	                    updateCurrentHighlight(divaInstance, currentHighlight);
	                    return thisDiv.id;
	                };
	
	                var getDivCenter = function(thisDiv)
	                {
	                    if (divaSettings.verticallyOriented) return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2);
	                    else return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                var findAdjacentHighlight = function(forward)
	                {
	                    var centerOfTargetDiv;
	                    var highlightFound = false;
	                    var centerOfCurrentDiv;
	                    var currentPage;
	                    var regionArr, arrIndex;
	                    var pageDims;
	                    var centerOfDiv, targetDiv;
	
	                    var thisDiv;
	                    var compFunction;
	
	                    // If currentHighlight does not already exists,
	                    // just pretend we're starting at the northwest corner of diva-inner
	                    if (!currentHighlight)
	                    {
	                        centerOfCurrentDiv = 0;
	                        currentPage = 0;
	                    }
	                    else {
	                        currentPage = currentHighlight.page;
	
	                        //find the center of the current div
	                        centerOfCurrentDiv = getDivCenter(currentHighlight.region);
	                    }
	
	                    //if we do have a current highlight, try to find the next one in the same page
	
	                    regionArr = highlightManager.getHighlightRegions(currentPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(currentPage, divaInstance.getZoomLevel());
	
	                    //initialize the center of the div to the maximum possible value
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    if(forward)
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC > curC && thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC < curC && thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	
	                        //if this div is farther along the main axis but closer than the current closest
	                        if (compFunction(centerOfDiv, centerOfCurrentDiv, centerOfTargetDiv))
	                        {
	                            //update targetDiv
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //if a highlight was found on the current page that was next; this can get overwritten but we're still good
	                    if (highlightFound) return gotoDiv(currentPage, targetDiv);
	                    //if it wasn't found, continue on...
	
	                    //find the minimum div on the next page with highlights and loop around if necessary
	
	                    //find the next page in the pageArr; this will be in order
	                    var pageArr = highlightManager.getHighlightedPages();
	                    var curIdx = pageArr.indexOf(currentPage.toString());
	
	                    var targetPage;
	
	                    if(forward)
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to first page, move to next if possible
	                            if (curIdx == pageArr.length - 1) targetPage = pageArr[0];
	                            else targetPage = pageArr[++curIdx];
	                        }
	                    }
	
	                    else
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to last page, move to previous if possible
	                            if (curIdx === 0) targetPage = pageArr[pageArr.length - 1];
	                            else targetPage = pageArr[--curIdx];
	                        }
	                    }
	
	                    //reset regionArr and centerOfTargetDiv for the new page we're testing
	                    regionArr = highlightManager.getHighlightRegions(targetPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(targetPage, divaInstance.getMaxZoomLevel());
	
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    //find the minimum this time
	                    if(forward)
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	                        if (compFunction(centerOfDiv, centerOfTargetDiv))
	                        {
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //we've found it this time, as there'll be a region in the full regionArr to be the minimum
	                    return gotoDiv(targetPage, targetDiv);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                divaInstance.gotoNextHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(true);
	                    else
	                        return false;
	                };
	
	                /*
	                    Jumps to the previous highlight along the primary axis of the document.
	                */
	                divaInstance.gotoPreviousHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(false);
	                    else
	                        return false;
	                };
	
	                diva.Events.subscribe('ViewerWillTerminate', this.destroy, divaSettings.ID);
	
	                return true;
	            },
	            destroy: function (divaSettings)
	            {
	                var highlightManager = divaSettings.parentObject.data('highlightManager');
	                highlightManager.clear();
	                divaSettings.parentObject.removeData('highlightManager');
	            },
	            pluginName: 'highlight',
	            titleText: 'Highlight regions of pages',
	
	            // Exposed export
	            HighlightManager: HighlightManager
	        };
	        return retval;
	    })();
	})(jQuery);
	
	/** Manages the addition and removal of the page overlays which display the highlights */
	function HighlightManager(divaInstance, getCurrentHighlight)
	{
	    this._divaInstance = divaInstance;
	    this._overlays = {};
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightManager.prototype.getHighlightCount = function ()
	{
	    var count = 0;
	    Object.keys(this._overlays).forEach(function (key)
	    {
	        count += this._overlays[key].highlight.regions.length;
	    }, this);
	
	    return count;
	};
	
	HighlightManager.prototype.getHighlightRegions = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return [];
	
	    return this._overlays[pageIndex].highlight.regions;
	};
	
	HighlightManager.prototype.getHighlightedPages = function ()
	{
	    // FIXME: Conceptually awkward that these are strings
	    return Object.keys(this._overlays);
	};
	
	HighlightManager.prototype.getHighlightByRegionId = function (id)
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        var regions = this._overlays[i].highlight.regions;
	        for (var j in regions)
	        {
	            if (!regions.hasOwnProperty(j))
	                continue;
	
	            if (regions[j].divID === id)
	            {
	                return {
	                    highlight: this._overlays[i].highlight,
	                    region: regions[j]
	                };
	            }
	        }
	    }
	
	    return null;
	};
	
	HighlightManager.prototype.addHighlight = function (highlight)
	{
	    var existingOverlay = this._overlays[highlight.page];
	
	    if (existingOverlay)
	        this._divaInstance.__removePageOverlay(existingOverlay);
	
	    var overlay = new HighlightPageOverlay(highlight, this._divaInstance, this._getCurrentHighlight);
	    this._overlays[highlight.page] = overlay;
	    this._divaInstance.__addPageOverlay(overlay);
	};
	
	HighlightManager.prototype.removeHighlightsOnPage = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return;
	
	    this._divaInstance.__removePageOverlay(this._overlays[pageIndex]);
	    delete this._overlays[pageIndex];
	};
	
	HighlightManager.prototype.clear = function ()
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        this._divaInstance.__removePageOverlay(this._overlays[i]);
	    }
	
	    this._overlays = {};
	};
	
	/**
	 When a new page is loaded, this overlay will be called with the
	 page index for the page. It looks at the 'highlights' data object
	 set on the diva parent element, and determines whether
	 highlights exist for that page.
	
	 If so, the overlay will create and render elements for every
	 highlighted box.
	
	 @param highlight
	 @param divaInstance
	 @param getCurrentHighlight (optional)
	 */
	function HighlightPageOverlay(highlight, divaInstance, getCurrentHighlight)
	{
	    this.page = highlight.page;
	    this.highlight = highlight;
	    this._highlightRegions = [];
	    this._divaInstance = divaInstance;
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightPageOverlay.prototype.mount = function ()
	{
	    var divaSettings = this._divaInstance.getSettings();
	
	    var highlight = this.highlight;
	    var regions = highlight.regions;
	    var colour = highlight.colour;
	    var divClass = highlight.divClass;
	
	    var j = regions.length;
	    while (j--)
	    {
	        var region = regions[j];
	
	        // FIXME: Use CSS class instead of inline style
	        var box = elt('div', {
	            class: divClass,
	            style: {
	                background: colour,
	                border: "1px solid #555",
	                position: "absolute",
	                zIndex: 100
	            }
	        });
	
	        if (region.divID !== undefined)
	        {
	            box.setAttribute('data-highlight-id', region.divID);
	        }
	
	        // Used by IIIFHighlight
	        if (region.name !== undefined)
	        {
	            box.setAttribute('data-name', region.name);
	        }
	
	        this._highlightRegions.push({
	            element: box,
	            region: region
	        });
	    }
	
	    this.refresh();
	
	    var frag = document.createDocumentFragment();
	    this._highlightRegions.forEach(function (highlight)
	    {
	        frag.appendChild(highlight.element);
	    });
	
	    divaSettings.innerElement.appendChild(frag);
	
	    if (this._getCurrentHighlight)
	        updateCurrentHighlight(this._divaInstance, this._getCurrentHighlight());
	
	    diva.Events.publish("HighlightCompleted", [this.page, this._divaInstance.getFilenames()[this.page]]);
	};
	
	HighlightPageOverlay.prototype.unmount = function ()
	{
	    var innerElement = this._divaInstance.getSettings().innerElement;
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        innerElement.removeChild(highlight.element);
	    });
	
	    this._highlightRegions = [];
	};
	
	// FIXME: Updating a box per highlight region might be too expensive
	// Maybe stick all the elements in a container and then scale it using CSS transforms?
	HighlightPageOverlay.prototype.refresh = function ()
	{
	    var maxZoom = this._divaInstance.getMaxZoomLevel();
	
	    var maxZoomWidth = this._divaInstance.getPageDimensionsAtZoomLevel(this.page, maxZoom).width;
	    var currentWidth = this._divaInstance.getPageDimensions(this.page).width;
	    var zoomDifference = Math.log(maxZoomWidth / currentWidth) / Math.log(2);
	
	    var pageOffset = this._divaInstance.getPageOffset(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        var region = highlight.region;
	
	        elt.setAttributes(highlight.element, {
	            style: {
	                width: incorporateZoom(region.width, zoomDifference) + "px",
	                height: incorporateZoom(region.height, zoomDifference) + "px",
	                top: pageOffset.top + incorporateZoom(region.uly, zoomDifference) + "px",
	                left: pageOffset.left + incorporateZoom(region.ulx, zoomDifference) + "px"
	            }
	        });
	    });
	};
	
	function incorporateZoom(position, zoomDifference)
	{
	    return position / Math.pow(2, zoomDifference);
	}
	
	function updateCurrentHighlight(divaInstance, currentHighlight)
	{
	    var classString = divaInstance.getInstanceId() + "selected-highlight";
	    var classElem = document.getElementsByClassName(classString);
	    var idx;
	    var box;
	    var boxes;
	
	    for (idx = 0; idx < classElem.length; idx++)
	    {
	        box = classElem[idx];
	        if (box.id !== currentHighlight.id)
	        {
	            box.className = box.className.replace(' '+classString, '');
	            box.style.border = "1px solid #555";
	        }
	    }
	
	    if (divaInstance.isPageInViewport(currentHighlight.page))
	    {
	        boxes = document.querySelectorAll("*[data-highlight-id=" + currentHighlight.id + "]");
	        for(idx = 0; idx < boxes.length; idx++)
	        {
	            box = boxes[idx];
	            box.className = box.className + " " + classString;
	            box.style.border = "2px solid #000";
	        }
	    }
	}


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/*
	IIIF Highlight plugin for diva.js
	Allows you to highlight regions of a page image based off of annotations in a IIIF Manifest
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	var HighlightManager = __webpack_require__(44).HighlightManager;
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                settings.highlightedPages = [];
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                divaInstance.hideHighlights = function()
	                {
	                    settings.highlightsVisible = false;
	                    $(divaSettings.innerElement).addClass('annotations-hidden');
	                };
	
	                divaInstance.showHighlights = function()
	                {
	                    settings.highlightsVisible = true;
	                    $(divaSettings.innerElement).removeClass('annotations-hidden');
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                 * Moves the diva pane to (page)
	                 */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	                };
	
	                var showAnnotations = function(canvasIndex)
	                {
	                    return function(data, status, jqXHR)
	                    {
	                        var canvasAnnotations = data;
	                        var numAnnotations = data.length;
	
	                        //convert annotations in annotations object to diva highlight objects
	                        var regions = [];
	
	                        //loop over annotations in a single canvas
	                        for (var k = 0; k < numAnnotations; k++)
	                        {
	                            var currentAnnotation = canvasAnnotations[k];
	                            // get text content
	                            var text = currentAnnotation.resource.chars;
	
	                            // get x,y,w,h (slice string from '#xywh=' to end)
	                            var onString = currentAnnotation.on;
	                            var coordString = onString.slice(onString.indexOf('#xywh=') + 6);
	                            var coordinates = coordString.split(',');
	
	                            var region = {
	                                ulx: parseInt(coordinates[0], 10),
	                                uly: parseInt(coordinates[1], 10),
	                                width: parseInt(coordinates[2], 10),
	                                height: parseInt(coordinates[3], 10),
	                                name: text
	                            };
	
	                            regions.push(region);
	                        }
	
	                        divaInstance.highlightOnPage(canvasIndex, regions);
	                        //flag this page's annotations as having been retrieved
	                        settings.highlightedPages.push(canvasIndex);
	                    };
	                };
	
	                var getAnnotationsList = function(pageIndex)
	                {
	                    //if page has annotationList
	                    var canvases = settings.manifest.sequences[0].canvases;
	
	                    if (canvases[pageIndex].hasOwnProperty('otherContent'))
	                    {
	                        var otherContent = canvases[pageIndex].otherContent;
	
	                        for (var j = 0; j < otherContent.length; j++)
	                        {
	                            if (otherContent[j]['@type'] === 'sc:AnnotationList')
	                            {
	                                // canvas has annotations. get the annotations:
	                                $.ajax({
	                                    url: otherContent[j]['@id'],
	                                    cache: true,
	                                    dataType: 'json',
	                                    success: showAnnotations(pageIndex)
	                                });
	                            }
	                        }
	                    }
	                };
	
	                var setManifest = function(manifest)
	                {
	                    settings.manifest = manifest;
	                };
	
	                diva.Events.subscribe('ManifestDidLoad', setManifest, divaSettings.ID);
	
	                diva.Events.subscribe('PageWillLoad', function(pageIndex)
	                {
	                    if (!settings.highlightsVisible)
	                    {
	                        return;
	                    }
	
	                    //if highlights for this page have already been checked/loaded, return
	                    for (var i = 0; i < settings.highlightedPages.length; i++)
	                    {
	                        if (settings.highlightedPages[i] === pageIndex)
	                        {
	                            return;
	                        }
	                    }
	
	                    getAnnotationsList(pageIndex, settings.manifest);
	                }, divaSettings.ID);
	
	                var activeOverlays = [];
	
	                //on mouseover, show the annotation text
	                divaSettings.innerObject.on('mouseenter', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    var annotationElement = e.target;
	                    var name = annotationElement.dataset.name;
	                    var textOverlay = document.createElement('div');
	
	                    textOverlay.style.top = (annotationElement.offsetTop + annotationElement.offsetHeight - 1) + 'px';
	                    textOverlay.style.left = annotationElement.style.left;
	                    textOverlay.style.background = '#fff';
	                    textOverlay.style.border = '1px solid #555';
	                    textOverlay.style.position = 'absolute';
	                    textOverlay.style.zIndex = 101;
	                    textOverlay.className = 'annotation-overlay';
	                    textOverlay.textContent = name;
	
	                    annotationElement.parentNode.appendChild(textOverlay);
	                    activeOverlays.push(textOverlay);
	                });
	
	                divaSettings.innerObject.on('mouseleave', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    while (activeOverlays.length)
	                    {
	                        var textOverlay = activeOverlays.pop();
	                        textOverlay.parentNode.removeChild(textOverlay);
	                    }
	                });
	
	                diva.Events.subscribe('ViewerDidLoad', function(){
	                    //button to toggle annotations
	                    $('#' + divaSettings.ID + 'page-nav').before('<div id="' + divaSettings.ID + 'annotations-icon" class="diva-button diva-annotations-icon" title="Turn annotations on or off"></div>');
	
	                    $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	
	                    $('#' + divaSettings.ID + 'annotations-icon').on('click', function(e)
	                    {
	                        //toggle visibility of annotations
	                        if (settings.highlightsVisible)
	                        {
	                            divaInstance.hideHighlights();
	                            $(divaSettings.selector + 'annotations-icon').removeClass('annotations-icon-active');
	                        }
	                        else
	                        {
	                            divaInstance.showHighlights();
	                            $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	                        }
	                    });
	                }, divaSettings.ID);
	
	                //enable annotations by default
	                settings.highlightsVisible = true;
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	                divaSettings.parentObject.removeData('highlights');
	            },
	            pluginName: 'IIIFHighlight',
	            titleText: 'Highlight regions of pages'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// IIIF Metadata plugin for diva.js
	// Displays object metadata from a IIIF manifest
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var _displayMetadata = function(manifest)
	                {
	                    var showMetadata = function(label, value)
	                    {
	                        var labelProper = label.charAt(0).toUpperCase() + label.slice(1);
	                        var labelFormatted = labelProper.replace('_', ' ');
	
	                        if (value.match(/^https?:\/\//))
	                        {
	                            value = '<a href="' + value + '" target="_blank">' + value + '</a>';
	                        }
	
	                        return '<div class="metadata-row"><span class="metadata-label">' + labelFormatted + ':</span> <span class="metadata-value">' +
	                            value  + '</span></div>';
	                    };
	
	                    var getDataForLanguage = function(data, language)
	                    {
	                        for (var i = 0; i < data.length; i++)
	                        {
	                            if (data[i]['@language'] === language)
	                            {
	                                return data[i]['@value'];
	                            }
	                        }
	
	                        // Handle the case where no language is specified, or when a single object is passed
	                        return data[0]['@value'] || data['@value'];
	                    };
	
	                    /**
	                     * Shows metadata from label names (if the metadata exists).
	                     * @param names {Array} - An array of strings representing field names to display.
	                     */
	                    var showMetadataFromLabelNames = function(names)
	                    {
	                        var elements = '';
	
	                        for (var i = 0; i < names.length; i++)
	                        {
	                            var field = names[i];
	
	                            if (manifest.hasOwnProperty(field))
	                            {
	                                if (manifest[field].constructor === Array)
	                                {
	                                    //multiple languages
	                                    var localizedData = getDataForLanguage(manifest[field], 'en');
	                                    elements += showMetadata(field, localizedData);
	                                }
	                                else
	                                {
	                                    elements += showMetadata(field, manifest[field]);
	                                }
	                            }
	                        }
	
	                        return elements;
	                    };
	
	                    var metadataElement = '<div id="' + divaSettings.ID + 'metadata" class="diva-modal">';
	                    metadataElement += showMetadataFromLabelNames(['label']);
	
	                    if (manifest.hasOwnProperty('metadata'))
	                    {
	                        var metadataField = manifest.metadata;
	
	                        for (var i = 0; i < metadataField.length; i++)
	                        {
	                            if (metadataField[i].value.constructor === Array)
	                            {
	                                var canonicalData = getDataForLanguage(metadataField[i].value, 'en');
	                                metadataElement += showMetadata(metadataField[i].label, canonicalData);
	                            }
	                            else
	                            {
	                                metadataElement += showMetadata(metadataField[i].label, metadataField[i].value);
	                            }
	                        }
	                    }
	
	                    metadataElement += showMetadataFromLabelNames([
	                        'description',
	                        'within',
	                        'see_also',
	                        'license',
	                        'attribution'
	                    ]);
	
	                    metadataElement += '</div>';
	
	                    divaSettings.parentObject.prepend(metadataElement);
	                    $(divaSettings.selector + 'metadata').hide();
	                };
	
	                //subscribe to ManifestDidLoad event, get the manifest
	                diva.Events.subscribe('ManifestDidLoad', _displayMetadata, divaSettings.ID);
	
	                divaSettings.parentObject.prepend('<div style="text-align: center; clear: both"><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	                // $(divaSettings.selector + 'title').append('<div><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	
	                $(divaSettings.selector + 'metadata-link').on('click', function(e)
	                {
	                    $(divaSettings.selector + 'metadata').fadeToggle('fast');
	                });
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	            },
	            pluginName: 'IIIFMetadata',
	            titleText: 'Show metadata from a IIIF manifest'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAyNjI3OGY3MDUyZWUzYTdmYjMzMSIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcmVnaXN0ZXItYnVpbHRpbi1wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9kaXZhLWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwiLFwiY29tbW9uanNcIjpcImpxdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqcXVlcnlcIn0iLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2luLXJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2F1dG9zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RpdmEuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2VsdC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvaGFzaC1wYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2FjdGl2ZS1kaXZhLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2ltYWdlLW1hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYXJzZS1paWlmLW1hbmlmZXN0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy90b29sYmFyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy92aWV3ZXItY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvanF1ZXJ5LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2dldC1zY3JvbGxiYXItd2lkdGguanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2dlc3R1cmUtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9kb2N1bWVudC1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL34vbG9kYXNoLm1heGJ5L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2UtdG9vbHMtb3ZlcmxheS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvZ3JpZC1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLW92ZXJsYXktbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9kZWJ1Zy5qcyIsIndlYnBhY2s6Ly8vLi9+L21zL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9jb21wb3NpdGUtaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RvY3VtZW50LWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW1hZ2UtY2FjaGUuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2ltYWdlLXJlcXVlc3QtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW50ZXJwb2xhdGUtYW5pbWF0aW9uLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ib29rLWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3BhZ2UtZGltZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3NpbmdsZXMtbGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvZ3JpZC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3NldHRpbmdzLXZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3ZhbGlkYXRpb24tcnVubmVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy92aWV3cG9ydC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2lucy9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvZG93bmxvYWQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtaGlnaGxpZ2h0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtbWV0YWRhdGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUEE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLHdCQUF1QjtBQUN2QixrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDbERBLGdEOzs7Ozs7QUNBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEIsdUJBQXNCO0FBQ3RCLHVCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXNCO0FBQ3RCLDBCQUF5QjtBQUN6Qiw0QkFBMkIsUUFBUSwwREFBMEQ7QUFDN0Y7QUFDQSxnQ0FBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLDRCQUEyQixTQUFTO0FBQ3BDLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0VBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLG9EQUFtRCxvREFBb0Q7QUFDdkc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBb0QsbUJBQW1COztBQUV2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCLHNCQUFxQjtBQUNyQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDMVBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF1RCxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCO0FBQzNCLDJDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQThFO0FBQzlFLDhFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQsc0VBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQXlFO0FBQ3pFLDBFQUF5RTtBQUN6RSw0REFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEVBQXlFO0FBQ3pFLDBFQUF5RTtBQUN6RSxvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLGlEQUFpRDtBQUMzRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsMEJBQTBCO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQiwyQkFBMkI7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQThCLGdCQUFnQjtBQUM5QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7Ozs7Ozs7QUNob0NEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDOUZBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNURBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEOzs7Ozs7O0FDdEVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGtCQUFpQixZQUFZO0FBQzdCO0FBQ0Esc0JBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ3ZQQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNFQUFxRTs7QUFFckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFOzs7Ozs7QUM5UEE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0EsNkNBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELGdDQUFnQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSw0QkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDL3JCQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWlDLHFCQUFxQjtBQUN0RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELDJEQUEyRDtBQUM5RyxpREFBZ0QsMkRBQTJEOztBQUUzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFvRCw2QkFBNkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBdUQsbUNBQW1DO0FBQzFGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBb0QsNkJBQTZCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2OUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUMsb0VBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYSxjQUFjOzs7QUFHM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsaURBQWdEO0FBQ2hEO0FBQ0EsOEJBQTZCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE9BQU07O0FBRU4sRUFBQyxZQUFZOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7O0FBR0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVM7QUFDVDs7QUFFQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ2p0QkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlMQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUEyRCxzQkFBc0I7O0FBRWpGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7Ozs7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNILEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsUUFBUTtBQUNuQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsRUFBRTtBQUNiLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsYUFBYTtBQUN4QixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxFQUFFO0FBQ2IsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGFBQWE7QUFDeEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLFlBQVcsU0FBUztBQUNwQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsRUFBRTtBQUNiLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQixpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLGtCQUFrQixFQUFFO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGFBQWE7QUFDeEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLGtCQUFpQixRQUFRLE9BQU8sU0FBUyxFQUFFO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsMkJBQTBCLGdCQUFnQixTQUFTLEdBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsT0FBTSxPQUFPLFNBQVMsRUFBRTtBQUN4QixPQUFNLE9BQU8sU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBLG9CQUFtQixTQUFTLEdBQUcsU0FBUztBQUN4QztBQUNBLGtDQUFpQyxZQUFZLEVBQUU7QUFDL0MsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDdnRFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1RBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMEMsaUNBQWlDO0FBQzNFLHlCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOzs7Ozs7O0FDN0VBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSw4QkFBNkIsZ0JBQWdCO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7Ozs7Ozs7QUNyR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyR0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1DQUFrQyw4QkFBOEI7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNULE1BQUs7O0FBRUwsb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWlELHFCQUFxQjtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3BrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIOzs7Ozs7OztBQ3hMQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDZCQUE0QixVQUFVOzs7Ozs7OztBQ2xMdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWlCLFNBQVM7QUFDMUIsNkJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3pNQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsY0FBYztBQUN6QixZQUFXLE9BQU87QUFDbEIsYUFBWSxNQUFNO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNwSkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0EsOEJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFpQixXQUFXO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQy9NQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYSxPQUFPO0FBQ3BCLGVBQWMsT0FBTztBQUNyQixnQkFBZSwyQ0FBMkM7QUFDMUQsZ0JBQWUsK0JBQStCO0FBQzlDLGdCQUFlLDJCQUEyQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFjLDBCQUEwQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGVBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOzs7Ozs7O0FDaFNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFlBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ2xIQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEZBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7Ozs7OztBQ3ZDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTJCOztBQUUzQjtBQUNBO0FBQ0Esd0JBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7QUFDQTs7Ozs7OztBQzVCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOzs7Ozs7O0FDakdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDs7Ozs7OztBQzlCQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ25LQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoSkE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLHFCQUFvQjtBQUNwQiwwQkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUE4QyxxREFBcUQ7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW1ELFlBQVk7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlEQUFnRCxXQUFXO0FBQzNEO0FBQ0EsdURBQXNELFlBQVk7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBb0UsNEJBQTRCO0FBQ2hHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1RkFBc0YsZUFBZTtBQUNyRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFpRDtBQUNqRCwwQkFBeUI7QUFDekI7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7O0FBRWI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQ3Q4QkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtFQUE4RSxlQUFlOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQ3BDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrREFBOEQsdURBQXVEO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0ZBQWlGO0FBQ2pGO0FBQ0E7O0FBRUE7O0FBRUEseURBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlqQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQThELHVEQUF1RDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXVDLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DLHNDQUFzQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBaUI7O0FBRWpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckIsa0JBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTCxFQUFDOzs7Ozs7O0FDdlNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBcUMsTUFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF1QywwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1GQUFrRjtBQUNsRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQyIsImZpbGUiOiJkaXZhLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJqcXVlcnlcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiZGl2YVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiZGl2YVwiXSA9IGZhY3Rvcnkocm9vdFtcImpRdWVyeVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXykge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAyNjI3OGY3MDUyZWUzYTdmYjMzMSIsInZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xuXG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9hdXRvc2Nyb2xsJykpO1xuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvY2FudmFzJykpO1xuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvZG93bmxvYWQnKSk7XG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9oaWdobGlnaHQnKSk7XG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9paWlmLWhpZ2hsaWdodCcpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2lpaWYtbWV0YWRhdGEnKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9yZWdpc3Rlci1idWlsdGluLXBsdWdpbnMuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIEV2ZW50cyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnRzJyk7XG52YXIgUGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL3BsdWdpbi1yZWdpc3RyeScpO1xuXG52YXIgZGl2YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAgIEV2ZW50czogbmV3IEV2ZW50cygpLFxuXG4gICAgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICBQbHVnaW5SZWdpc3RyeS5yZWdpc3RlcihwbHVnaW4pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgRGl2YSBpbnN0YW5jZSBhdCB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICAgKiBAcmV0dXJucyB7RGl2YX1cbiAgICAgKi9cbiAgICBjcmVhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgaWYgKGRpdmEuZmluZChlbGVtZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGl2YSBpcyBhbHJlYWR5IGluaXRpYWxpemVkIG9uICcgKyByZXByRWxlbShlbGVtZW50KSk7XG5cbiAgICAgICAgdmFyICRlbGVtID0gJChlbGVtZW50KTtcbiAgICAgICAgJGVsZW0uZGl2YShvcHRpb25zKTtcblxuICAgICAgICByZXR1cm4gJGVsZW0uZGF0YSgnZGl2YScpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIERpdmEgaW5zdGFuY2UgYXR0YWNoZWQgdG8gdGhlXG4gICAgICogZWxlbWVudCwgaWYgYW55LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RGl2YXxudWxsfVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChlbGVtZW50KVxuICAgIHtcbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCkuZGF0YSgnZGl2YScpIHx8IG51bGw7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcmVwckVsZW0oZWxlbSlcbntcbiAgICB2YXIgaWQgPSBlbGVtLmlkID8gJyMnICsgZWxlbS5pZCA6IGVsZW0uaWQ7XG4gICAgdmFyIGNsYXNzZXMgPSBlbGVtLmNsYXNzTmFtZSA/ICcuJyArIGVsZW0uY2xhc3NOYW1lLnNwbGl0KC9cXHMrL2cpLmpvaW4oJy4nKSA6ICcnO1xuXG4gICAgcmV0dXJuIChpZCA/IGlkIDogZWxlbS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICsgY2xhc3Nlcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2RpdmEtZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX187XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwiLFwiY29tbW9uanNcIjpcImpxdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqcXVlcnlcIn1cbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG5cbi8qKlxuICogICAgICBFdmVudHMuIFB1Yi9TdWIgc3lzdGVtIGZvciBMb29zZWx5IENvdXBsZWQgbG9naWMuXG4gKiAgICAgIEJhc2VkIG9uIFBldGVyIEhpZ2dpbnMnIHBvcnQgZnJvbSBEb2pvIHRvIGpRdWVyeVxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vcGhpZ2dpbnM0Mi9ibG9vZHktanF1ZXJ5LXBsdWdpbnMvYmxvYi9tYXN0ZXIvcHVic3ViLmpzXG4gKlxuICogICAgICBSZS1hZGFwdGVkIHRvIHZhbmlsbGEgSmF2YXNjcmlwdFxuICpcbiAqICAgICAgQGNsYXNzIEV2ZW50c1xuICovXG5mdW5jdGlvbiBFdmVudHMoKVxue1xuICAgIHRoaXMuX2NhY2hlID0ge307XG59XG5cbi8qKlxuICogICAgICBkaXZhLkV2ZW50cy5wdWJsaXNoXG4gKiAgICAgIGUuZy46IGRpdmEuRXZlbnRzLnB1Ymxpc2goXCJQYWdlRGlkTG9hZFwiLCBbcGFnZUluZGV4LCBmaWxlbmFtZSwgcGFnZVNlbGVjdG9yXSwgdGhpcyk7XG4gKlxuICogICAgICBAY2xhc3MgRXZlbnRzXG4gKiAgICAgIEBtZXRob2QgcHVibGlzaFxuICogICAgICBAcGFyYW0gdG9waWMge1N0cmluZ31cbiAqICAgICAgQHBhcmFtIGFyZ3MgIHtBcnJheX1cbiAqICAgICAgQHBhcmFtIHNjb3BlIHtPYmplY3Q9fSBPcHRpb25hbCAtIFN1YnNjcmliZWQgZnVuY3Rpb25zIHdpbGwgYmUgZXhlY3V0ZWQgd2l0aCB0aGUgc3VwcGxpZWQgb2JqZWN0IGFzIGB0aGlzYC5cbiAqICAgICAgICAgIEl0IGlzIG5lY2Vzc2FyeSB0byBzdXBwbHkgdGhpcyBhcmd1bWVudCB3aXRoIHRoZSBzZWxmIHZhcmlhYmxlIHdoZW4gd2l0aGluIGEgRGl2YSBpbnN0YW5jZS5cbiAqICAgICAgICAgIFRoZSBzY29wZSBhcmd1bWVudCBpcyBtYXRjaGVkIHdpdGggdGhlIGluc3RhbmNlIElEIG9mIHN1YnNjcmliZXJzIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXlcbiAqICAgICAgICAgICAgICBzaG91bGQgYmUgZXhlY3V0ZWQuIChTZWUgaW5zdGFuY2VJRCBhcmd1bWVudCBvZiBzdWJzY3JpYmUuKVxuICovXG5FdmVudHMucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbiAodG9waWMsIGFyZ3MsIHNjb3BlKVxue1xuICAgIGlmICh0aGlzLl9jYWNoZVt0b3BpY10pXG4gICAge1xuICAgICAgICB2YXIgdGhpc1RvcGljID0gdGhpcy5fY2FjaGVbdG9waWNdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpc1RvcGljLmdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0aGlzVG9waWNHbG9iYWwgPSB0aGlzVG9waWMuZ2xvYmFsO1xuICAgICAgICAgICAgdmFyIGdsb2JhbENvdW50ID0gdGhpc1RvcGljR2xvYmFsLmxlbmd0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgZ2xvYmFsQ291bnQ7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzVG9waWNHbG9iYWxbaV0uYXBwbHkoc2NvcGUgfHwgbnVsbCwgYXJncyB8fCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2NvcGUgJiYgdHlwZW9mIHNjb3BlLmdldEluc3RhbmNlSWQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBnZXQgcHVibGlzaGVyIGluc3RhbmNlIElEIGZyb20gc2NvcGUgYXJnLCBjb21wYXJlLCBhbmQgZXhlY3V0ZSBpZiBtYXRjaFxuICAgICAgICAgICAgdmFyIGluc3RhbmNlSUQgPSBzY29wZS5nZXRJbnN0YW5jZUlkKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHRoaXNUb3BpY0luc3RhbmNlID0gdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdO1xuICAgICAgICAgICAgICAgIHZhciBzY29wZWRDb3VudCA9IHRoaXNUb3BpY0luc3RhbmNlLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgaiA8IHNjb3BlZENvdW50OyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzVG9waWNJbnN0YW5jZVtqXS5hcHBseShzY29wZSwgYXJncyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZVxuICogICAgICBlLmcuOiBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoXCJQYWdlRGlkTG9hZFwiLCBoaWdobGlnaHQsIHNldHRpbmdzLklEKVxuICpcbiAqICAgICAgQGNsYXNzIEV2ZW50c1xuICogICAgICBAbWV0aG9kIHN1YnNjcmliZVxuICogICAgICBAcGFyYW0gdG9waWMge1N0cmluZ31cbiAqICAgICAgQHBhcmFtIGNhbGxiYWNrIHtGdW5jdGlvbn1cbiAqICAgICAgQHBhcmFtIGluc3RhbmNlSUQge1N0cmluZz19IE9wdGlvbmFsIC0gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgSUQgb2YgYSBEaXZhIGluc3RhbmNlOyBpZiBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayBvbmx5IGZpcmVzIGZvciBldmVudHMgcHVibGlzaGVkIGZyb20gdGhhdCBpbnN0YW5jZS5cbiAqICAgICAgQHJldHVybiBFdmVudCBoYW5kbGVyIHtBcnJheX1cbiAqL1xuRXZlbnRzLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodG9waWMsIGNhbGxiYWNrLCBpbnN0YW5jZUlEKVxue1xuICAgIGlmICghdGhpcy5fY2FjaGVbdG9waWNdKVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FjaGVbdG9waWNdID0ge307XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZUlEID09PSAnc3RyaW5nJylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZVt0b3BpY10uZ2xvYmFsKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVt0b3BpY10uZ2xvYmFsID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZVt0b3BpY10uZ2xvYmFsLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGUgPSBpbnN0YW5jZUlEID8gW3RvcGljLCBjYWxsYmFjaywgaW5zdGFuY2VJRF0gOiBbdG9waWMsIGNhbGxiYWNrXTtcblxuICAgIHJldHVybiBoYW5kbGU7XG59O1xuXG4vKipcbiAqICAgICAgZGl2YS5FdmVudHMudW5zdWJzY3JpYmVcbiAqICAgICAgZS5nLjogdmFyIGhhbmRsZSA9IEV2ZW50cy5zdWJzY3JpYmUoXCJQYWdlRGlkTG9hZFwiLCBoaWdobGlnaHQpO1xuICogICAgICAgICAgICAgIEV2ZW50cy51bnN1YnNjcmliZShoYW5kbGUpO1xuICpcbiAqICAgICAgQGNsYXNzIEV2ZW50c1xuICogICAgICBAbWV0aG9kIHVuc3Vic2NyaWJlXG4gKiAgICAgIEBwYXJhbSBoYW5kbGUge0FycmF5fVxuICogICAgICBAcGFyYW0gY29tcGxldGVseSB7Qm9vbGVhbj19IC0gVW5zdWJzY3JpYmUgYWxsIGV2ZW50cyBmb3IgYSBnaXZlbiB0b3BpYy5cbiAqICAgICAgQHJldHVybiBzdWNjZXNzIHtCb29sZWFufVxuICovXG5FdmVudHMucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGhhbmRsZSwgY29tcGxldGVseSlcbntcbiAgICB2YXIgdCA9IGhhbmRsZVswXTtcblxuICAgIGlmICh0aGlzLl9jYWNoZVt0XSlcbiAgICB7XG4gICAgICAgIHZhciB0b3BpY0FycmF5O1xuICAgICAgICB2YXIgaW5zdGFuY2VJRCA9IGhhbmRsZS5sZW5ndGggPT09IDMgPyBoYW5kbGVbMl0gOiAnZ2xvYmFsJztcblxuICAgICAgICB0b3BpY0FycmF5ID0gdGhpcy5fY2FjaGVbdF1baW5zdGFuY2VJRF07XG5cbiAgICAgICAgaWYgKCF0b3BpY0FycmF5KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGxldGVseSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW3RdW2luc3RhbmNlSURdO1xuICAgICAgICAgICAgcmV0dXJuIHRvcGljQXJyYXkubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gdG9waWNBcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0b3BpY0FycmF5W2ldID09PSBoYW5kbGVbMV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVbdF1baW5zdGFuY2VJRF0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiAgICAgIGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlQWxsXG4gKiAgICAgIGUuZy46IGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlQWxsKCdnbG9iYWwnKTtcbiAqXG4gKiAgICAgIEBjbGFzcyBFdmVudHNcbiAqICAgICAgQHBhcmFtIGluc3RhbmNlSUQge1N0cmluZz19IE9wdGlvbmFsIC0gaW5zdGFuY2UgSUQgdG8gcmVtb3ZlIHN1YnNjcmliZXJzIGZyb20gb3IgJ2dsb2JhbCcgKGlmIG9taXR0ZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMgaW4gYWxsIHNjb3BlcyByZW1vdmVkKVxuICogICAgICBAbWV0aG9kIHVuc3Vic2NyaWJlQWxsXG4gKi9cbkV2ZW50cy5wcm90b3R5cGUudW5zdWJzY3JpYmVBbGwgPSBmdW5jdGlvbiAoaW5zdGFuY2VJRClcbntcbiAgICBpZiAoaW5zdGFuY2VJRClcbiAgICB7XG4gICAgICAgIHZhciB0b3BpY3MgPSBPYmplY3Qua2V5cyh0aGlzLl9jYWNoZSk7XG4gICAgICAgIHZhciBpID0gdG9waWNzLmxlbmd0aDtcbiAgICAgICAgdmFyIHRvcGljO1xuXG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvcGljID0gdG9waWNzW2ldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy91dGlscy9ldmVudHMuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBAbW9kdWxlXG4gKiBAcHJpdmF0ZVxuICogVGhlIGdsb2JhbCBwbHVnaW4gcmVnaXN0cnkuXG4gKi9cblxudmFyIHBsdWdpbnMgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICB9LFxuICAgIGdldEFsbDogZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW4tcmVnaXN0cnkuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbkRpdmEuSlMgYXV0b3Njcm9sbCBwbHVnaW5cbkF1dGhvcjogQW5kcmV3IEhvcndpdHpcblxuTGV0cyBEaXZhIHNjcm9sbCBpbiB0aGUgcHJpbWFyeSBkaXJlY3Rpb24gKGFzIGRldGVybWluZWQgYnlcbnNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgYXV0b21hdGljYWxseSBhdCBhIGdpdmVuL2NoYW5nZWFibGUgcmF0ZS5cblxuUmVsZXZhbnQgc2V0dGluZ3M6XG4gICAgLXNjcm9sbFNwZWVkOiBwaXhlbHMgcGVyIHNlY29uZCAoZGVmYXVsdHMgdG8gMTApXG4gICAgLWRpc2FibGVNYW51YWxTY3JvbGw6IGRpc2FibGVzIG1hbnVhbCBzY3JvbGwgd2hpbGUgYXV0b21hdGljIHNjcm9sbCBpcyBvbiAoZGVmYXVsdHMgdG8gZmFsc2UpXG4gICAgLWN1cnJlbnRseUF1dG9TY3JvbGxpbmc6IHdoZXRoZXIgb3Igbm90IGF1dG9zY3JvbGwgaXMgY3VycmVudGx5IG9uXG4gICAgLWF1dG9TY3JvbGxSZWZyZXNoOiBtcyBiZXR3ZWVuIHNjcm9sbGluZyBhY3Rpb25zXG4gICAgLWRpc2FibGVBdXRvc2Nyb2xsUHJlZnM6IGRpc2FibGVzIHRoZSBhdXRvc2Nyb2xsIHByZWZlcmVuY2VzIHBhbmVsXG5cblJlbGV2YW50IG1ldGhvZHM6XG4gICAgLXN0YXJ0U2Nyb2xsaW5nLCBzdG9wU2Nyb2xsaW5nLCB0b2dnbGVTY3JvbGxpbmdcbiAgICAtY2hhbmdlUmVmcmVzaCwgY2hhbmdlU2Nyb2xsU3BlZWQgKHNldHRlcnMgZm9yIHJlc3BlY3RpdmUgb3B0aW9ucylcbiAgICAtZGlzYWJsZU1hbnVhbFNjcm9sbCwgZW5hYmxlTWFudWFsU2Nyb2xsXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4uL2RpdmEnKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsc1BlclNjcm9sbDtcbiAgICAgICAgICAgICAgICB2YXIgZGlzYWJsZU1hbnVhbFNjcm9sbDtcbiAgICAgICAgICAgICAgICB2YXIgYXV0b1Njcm9sbFJlZnJlc2g7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRBdXRvUmVmcmVzaDtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU3BlZWQ7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsb2cxMCh4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubG9nKHgpIC8gTWF0aC5sb2coMTApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5zdGFydFNjcm9sbGluZyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiWW91IGFyZSB0cnlpbmcgdG8gc3RhcnQgYXV0b3Njcm9sbGluZywgYnV0IGl0IGlzIGFscmVhZHkgc2Nyb2xsaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtdG9nZ2xlXCIpLnRleHQoXCJUdXJuIG9mZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVNYW51YWxTY3JvbGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXN0YXJ0U2Nyb2xsaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3RhcnRTY3JvbGxpbmdJbnRlcnZhbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuYXV0b1Njcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsVG9wKGRpdmFTZXR0aW5ncy52aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoKSArIHBpeGVsc1BlclNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhdXRvU2Nyb2xsUmVmcmVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuYXV0b1Njcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsTGVmdChkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsTGVmdCgpICsgcGl4ZWxzUGVyU2Nyb2xsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGF1dG9TY3JvbGxSZWZyZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc3RvcFNjcm9sbGluZyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdSBhcmUgdHJ5aW5nIHRvIHN0b3AgYXV0b3Njcm9sbGluZywgYnV0IGl0IGlzIG5vdCBjdXJyZW50bHkgYWN0aXZlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtdG9nZ2xlXCIpLnRleHQoXCJUdXJuIG9uXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZU1hbnVhbFNjcm9sbClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmVuYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS50b2dnbGVTY3JvbGxpbmcgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc3RvcFNjcm9sbGluZygpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc3RhcnRTY3JvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVJlZnJlc2ggPSBmdW5jdGlvbihuZXdSZWZyZXNoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1Njcm9sbFJlZnJlc2ggPSBuZXdSZWZyZXNoO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQaXhlbHNQZXJTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVNjcm9sbFNwZWVkID0gZnVuY3Rpb24obmV3U3BlZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGxTcGVlZCA9IG5ld1NwZWVkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQaXhlbHNQZXJTY3JvbGwoKTtcblxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXBwc1wiKS52YWwobG9nMTAoc2Nyb2xsU3BlZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN0YXJ0U2Nyb2xsaW5nSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlUGl4ZWxzUGVyU2Nyb2xsID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1Njcm9sbFJlZnJlc2ggPSBkZWZhdWx0QXV0b1JlZnJlc2g7XG4gICAgICAgICAgICAgICAgICAgIHBpeGVsc1BlclNjcm9sbCA9IHNjcm9sbFNwZWVkIC8gKDEwMDAgLyBhdXRvU2Nyb2xsUmVmcmVzaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zaG91bGQgYmUgbWluaW11bSBvZiBvbmUgb3RoZXJ3aXNlIGl0IHdvbid0IGNoYW5nZSB0aGUgYWN0dWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIC8vdXNlciBjYW4gY2hhbmdlIGF1dG9zY3JvbGxyZWZyZXNoIG9yIHNjcm9sbHNwZWVkOyB0aGlzIG1heSBvdmVyd3JpdGUgYXV0b1Njcm9sbFJlZnJlc2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpeGVsc1BlclNjcm9sbCA8IDEpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gYXV0b1Njcm9sbFJlZnJlc2ggKiAoMSAvIHBpeGVsc1BlclNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbHNQZXJTY3JvbGwgPSBzY3JvbGxTcGVlZCAvICgxMDAwIC8gYXV0b1Njcm9sbFJlZnJlc2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlTWFudWFsU2Nyb2xsID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZU1hbnVhbFNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmRpc2FibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmVuYWJsZU1hbnVhbFNjcm9sbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVNYW51YWxTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZW5hYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICBkaXNhYmxlTWFudWFsU2Nyb2xsID0gZGl2YVNldHRpbmdzLmRpc2FibGVNYW51YWxTY3JvbGwgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgYXV0b1Njcm9sbFJlZnJlc2ggPSBkaXZhU2V0dGluZ3MuYXV0b1Njcm9sbFJlZnJlc2ggfHwgNTA7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEF1dG9SZWZyZXNoID0gYXV0b1Njcm9sbFJlZnJlc2g7XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuY2hhbmdlU2Nyb2xsU3BlZWQoKGRpdmFTZXR0aW5ncy5zY3JvbGxTcGVlZCB8fCAxMCkpO1xuXG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IDMyKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UudG9nZ2xlU2Nyb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICghZGl2YVNldHRpbmdzLmRpc2FibGVBdXRvc2Nyb2xsUHJlZnMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2V0UG9zaXRpb24gPSBmdW5jdGlvbihpc0Z1bGxzY3JlZW4pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmdWxsc2NyZWVuVG9vbHMgPSAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICd0b29scycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b29sc01hcmdpbiA9IGZ1bGxzY3JlZW5Ub29scy5jc3MoJ3JpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0JzogdG9vbHNNYXJnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdtYXJnaW4tcmlnaHQnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wJzogZnVsbHNjcmVlblRvb2xzLm9mZnNldCgpLnRvcCArIGZ1bGxzY3JlZW5Ub29scy5vdXRlckhlaWdodCgpICsgMTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5qcU9iai5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAncmlnaHQnOiAkKHdpbmRvdykud2lkdGgoKSAtIChkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Qub2Zmc2V0KCkubGVmdCArIGRpdmFTZXR0aW5ncy52aWV3cG9ydE9iamVjdC5vdXRlcldpZHRoKCkpICsgZGl2YVNldHRpbmdzLnNjcm9sbGJhcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogJy42ZW0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmoub2Zmc2V0KHsndG9wJzogZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0Lm9mZnNldCgpLnRvcCArIDF9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ01vZGVEaWRTd2l0Y2gnLCBzZXRQb3NpdGlvbiwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBmdW5jdGlvbihzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b3Njcm9sbFByZWZzU3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiPGRpdiBpZD0nXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtcHJlZnMnIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMgZGl2YS1wb3B1cCc+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGI+QXV0b3Njcm9sbGluZyBvcHRpb25zOjwvYj48YnI+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2RpdmEtYXV0b3Njcm9sbC1wcmVmcy10ZXh0Jz5TcGVlZDo8L3NwYW4+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGlucHV0IHR5cGU9J3JhbmdlJyBpZD0nXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtcHBzJyBjbGFzcz0nZGl2YS1hdXRvc2Nyb2xsLXBwcyBkaXZhLWF1dG9zY3JvbGwtcHJlZnMtaW5wdXQnIHZhbHVlPSdcIiArIGxvZzEwKHNjcm9sbFNwZWVkKSArIFwiJyBtaW49JzAnIG1heD0nMycgc3RlcD0nMC4xJz48YnI+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPHNwYW4gY2xhc3M9J2RpdmEtYXV0b3Njcm9sbC1wcmVmcy10ZXh0Jz5BbGxvdyBtYW51YWwgc2Nyb2xsOjwvc3Bhbj5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8aW5wdXQgdHlwZT0nY2hlY2tib3gnIGlkPSdcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1tYW51YWwnIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtbWFudWFsIGRpdmEtYXV0b3Njcm9sbC1wcmVmcy1pbnB1dCcgY2hlY2tlZD0nY2hlY2tlZCc+PGJyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxidXR0b24gaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXRvZ2dsZScgY2xhc3M9J2RpdmEtYXV0b3Njcm9sbC1wcmVmcy10b2dnbGUgZGl2YS1hdXRvc2Nyb2xsLXByZWZzLWlucHV0Jz4gVHVybiBvbiA8L2J1dHRvbj5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjwvZGl2PlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwicGFnZS1uYXZcIikuYmVmb3JlKFwiPGRpdiBpZD0nXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtaWNvbicgY2xhc3M9J2RpdmEtYnV0dG9uIGRpdmEtYXV0b3Njcm9sbC1pY29uJyB0aXRsZT0nRXhwYW5kIGF1dG9zY3JvbGwgb3B0aW9ucyc+PC9kaXY+XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgJChcImJvZHlcIikucHJlcGVuZChhdXRvc2Nyb2xsUHJlZnNTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXBwc1wiKS5vbignY2hhbmdlJywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuY2hhbmdlU2Nyb2xsU3BlZWQoTWF0aC5wb3coMTAsIGUudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1tYW51YWxcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUudGFyZ2V0LmNoZWNrZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVNYW51YWxTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlTWFudWFsU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC10b2dnbGVcIikub24oJ2NsaWNrJywgZGl2YUluc3RhbmNlLnRvZ2dsZVNjcm9sbGluZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtaWNvblwiKS5vbignY2xpY2snLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqID0gJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1wcmVmc1wiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5qcU9iai5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKHsnZGlzcGxheSc6ICdibG9jayd9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbihkaXZhU2V0dGluZ3MuaW5GdWxsc2NyZWVuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5qcU9iai5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCBkaXZhU2V0dGluZ3MuSUQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnYXV0b3Njcm9sbCcsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdBdXRvbWF0aWNhbGx5IHNjcm9sbHMgcGFnZSBhbG9uZyBwcmltYXJ5IGF4aXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2F1dG9zY3JvbGwuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbkNvcHlyaWdodCAoQykgMjAxMS0yMDE2IGJ5IFdlbmR5IExpdSwgRXZhbiBNYWdvbmksIEFuZHJldyBIYW5raW5zb24sIEFuZHJldyBIb3J3aXR6LCBMYXVyZW50IFB1Z2luXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIGVsdCA9IHJlcXVpcmUoJy4vdXRpbHMvZWx0Jyk7XG52YXIgSGFzaFBhcmFtcyA9IHJlcXVpcmUoJy4vdXRpbHMvaGFzaC1wYXJhbXMnKTtcblxudmFyIEFjdGl2ZURpdmFDb250cm9sbGVyID0gcmVxdWlyZSgnLi9hY3RpdmUtZGl2YS1jb250cm9sbGVyJyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4vZGl2YS1nbG9iYWwnKTtcbnZhciBJbWFnZU1hbmlmZXN0ID0gcmVxdWlyZSgnLi9pbWFnZS1tYW5pZmVzdCcpO1xudmFyIGNyZWF0ZVRvb2xiYXIgPSByZXF1aXJlKCcuL3Rvb2xiYXInKTtcbnZhciBWaWV3ZXJDb3JlID0gcmVxdWlyZSgnLi92aWV3ZXItY29yZScpO1xuXG4vLyBTdGFydCB0aGUgYWN0aXZlIERpdmEgdHJhY2tlclxudmFyIGFjdGl2ZURpdmEgPSBuZXcgQWN0aXZlRGl2YUNvbnRyb2xsZXIoKTsgLy8ganNoaW50IGlnbm9yZTogbGluZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRpdmE7XG5cbi8vIHRoaXMgcGF0dGVybiB3YXMgdGFrZW4gZnJvbSBodHRwOi8vd3d3LnZpcmdlbnRlY2guY29tL2Jsb2cvMjAwOS8xMC9idWlsZGluZy1vYmplY3Qtb3JpZW50ZWQtanF1ZXJ5LXBsdWdpbi5odG1sXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgdmFyIERpdmEgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucylcbiAgICB7XG4gICAgICAgIC8vIEdsb2JhbCBpbnN0YW5jZSB2YXJpYWJsZXMgKHNldCB3YXkgZG93biBpbiBgaW5pdGApXG4gICAgICAgIHZhciBzZXR0aW5ncywgdmlld2VyU3RhdGUsIGRpdmFTdGF0ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vIFRoZXNlIGFyZSBlbGVtZW50cyB0aGF0IGNhbiBiZSBvdmVycmlkZGVuIHVwb24gaW5zdGFudGlhdGlvblxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0RETUFML2RpdmEuanMvd2lraS9TZXR0aW5ncyBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7XG4gICAgICAgICAgICBhZGFwdGl2ZVBhZGRpbmc6IDAuMDUsICAgICAgLy8gVGhlIHJhdGlvIG9mIHBhZGRpbmcgdG8gdGhlIHBhZ2UgZGltZW5zaW9uXG4gICAgICAgICAgICBhcnJvd1Njcm9sbEFtb3VudDogNDAsICAgICAgLy8gVGhlIGFtb3VudCAoaW4gcGl4ZWxzKSB0byBzY3JvbGwgYnkgd2hlbiB1c2luZyBhcnJvdyBrZXlzXG4gICAgICAgICAgICBibG9ja01vYmlsZU1vdmU6IGZhbHNlLCAgICAgLy8gUHJldmVudCBtb3Zpbmcgb3Igc2Nyb2xsaW5nIHRoZSBwYWdlIG9uIG1vYmlsZSBkZXZpY2VzXG4gICAgICAgICAgICBvYmplY3REYXRhOiAnJywgICAgICAgICAgICAgLy8gQSBJSUlGIE1hbmlmZXN0IG9yIGEgSlNPTiBmaWxlIGdlbmVyYXRlZCBieSBwcm9jZXNzLnB5IHRoYXQgcHJvdmlkZXMgdGhlIG9iamVjdCBkaW1lbnNpb24gZGF0YSwgb3IgYSBVUkwgcG9pbnRpbmcgdG8gc3VjaCBkYXRhIC0gKlJFUVVJUkVEKlxuICAgICAgICAgICAgZW5hYmxlQXV0b1RpdGxlOiB0cnVlLCAgICAgIC8vIFNob3dzIHRoZSB0aXRsZSB3aXRoaW4gYSBkaXYgb2YgaWQgZGl2YS10aXRsZVxuICAgICAgICAgICAgZW5hYmxlRmlsZW5hbWU6IHRydWUsICAgICAgIC8vIFVzZXMgZmlsZW5hbWVzIGFuZCBub3QgcGFnZSBudW1iZXJzIGZvciBsaW5rcyAoaT1ibV8wMDEudGlmLCBub3QgcD0xKVxuICAgICAgICAgICAgZW5hYmxlRnVsbHNjcmVlbjogdHJ1ZSwgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGZ1bGxzY3JlZW4gaWNvbiAobW9kZSBzdGlsbCBhdmFpbGFibGUpXG4gICAgICAgICAgICBlbmFibGVHb3RvUGFnZTogdHJ1ZSwgICAgICAgLy8gQSBcImdvIHRvIHBhZ2VcIiBqdW1wIGJveFxuICAgICAgICAgICAgZW5hYmxlR290b1N1Z2dlc3Rpb25zOiB0cnVlLCAvLyBDb250cm9scyB3aGV0aGVyIHN1Z2dlc3Rpb25zIGFyZSBzaG93biB1bmRlciB0aGUgaW5wdXQgZmllbGQgd2hlbiB0aGUgdXNlciBpcyB0eXBpbmcgaW4gdGhlICdnbyB0byBwYWdlJyBmb3JtXG4gICAgICAgICAgICBlbmFibGVHcmlkSWNvbjogdHJ1ZSwgICAgICAgLy8gQSBncmlkIHZpZXcgb2YgYWxsIHRoZSBwYWdlc1xuICAgICAgICAgICAgZW5hYmxlR3JpZENvbnRyb2xzOiAnYnV0dG9ucycsICAvLyBTcGVjaWZ5IGNvbnRyb2wgb2YgcGFnZXMgcGVyIGdyaWQgcm93IGluIEdyaWQgdmlldy4gUG9zc2libGUgdmFsdWVzOiAnYnV0dG9ucycgKCsvLSksICdzbGlkZXInLiBBbnkgb3RoZXIgdmFsdWUgZGlzYWJsZXMgdGhlIGNvbnRyb2xzLlxuICAgICAgICAgICAgZW5hYmxlSW1hZ2VUaXRsZXM6IHRydWUsICAgIC8vIEFkZHMgXCJQYWdlIHtufVwiIHRpdGxlIHRvIHBhZ2UgaW1hZ2VzIGlmIHRydWVcbiAgICAgICAgICAgIGVuYWJsZUtleVNjcm9sbDogdHJ1ZSwgICAgICAvLyBDYXB0dXJlcyBzY3JvbGxpbmcgdXNpbmcgdGhlIGFycm93IGFuZCBwYWdlIHVwL2Rvd24ga2V5cyByZWdhcmRsZXNzIG9mIHBhZ2UgZm9jdXMuIFdoZW4gb2ZmLCBkZWZlcnMgdG8gZGVmYXVsdCBicm93c2VyIHNjcm9sbGluZyBiZWhhdmlvci5cbiAgICAgICAgICAgIGVuYWJsZUxpbmtJY29uOiB0cnVlLCAgICAgICAvLyBDb250cm9scyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgbGluayBpY29uXG4gICAgICAgICAgICBlbmFibGVOb25QYWdlZFZpc2liaWxpdHlJY29uOiB0cnVlLCAvLyBDb250cm9scyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgaWNvbiB0byB0b2dnbGUgdGhlIHZpc2liaWxpdHkgb2Ygbm9uLXBhZ2VkIHBhZ2VzLiAoQXV0b21hdGljYWxseSBoaWRkZW4gaWYgbm8gJ25vbi1wYWdlZCcgcGFnZXMpLlxuICAgICAgICAgICAgZW5hYmxlU3BhY2VTY3JvbGw6IGZhbHNlLCAgIC8vIFNjcm9sbGluZyBkb3duIGJ5IHByZXNzaW5nIHRoZSBzcGFjZSBrZXlcbiAgICAgICAgICAgIGVuYWJsZVRvb2xiYXI6IHRydWUsICAgICAgICAvLyBFbmFibGVzIHRoZSB0b29sYmFyLiBOb3RlIHRoYXQgZGlzYWJsaW5nIHRoaXMgbWVhbnMgeW91IGhhdmUgdG8gaGFuZGxlIGFsbCBjb250cm9scyB5b3Vyc2VsZi5cbiAgICAgICAgICAgIGVuYWJsZVpvb21Db250cm9sczogJ2J1dHRvbnMnLCAvLyBTcGVjaWZ5IGNvbnRyb2xzIGZvciB6b29taW5nIGluIGFuZCBvdXQuIFBvc3NpYmxlIHZhbHVlczogJ2J1dHRvbnMnICgrLy0pLCAnc2xpZGVyJy4gQW55IG90aGVyIHZhbHVlIGRpc2FibGVzIHRoZSBjb250cm9scy5cbiAgICAgICAgICAgIGZpbGxQYXJlbnRIZWlnaHQ6IHRydWUsICAgICAvLyBVc2UgYSBmbGV4Ym94IGxheW91dCB0byBhbGxvdyBEaXZhIHRvIGZpbGwgaXRzIHBhcmVudCdzIGhlaWdodFxuICAgICAgICAgICAgZml4ZWRQYWRkaW5nOiAxMCwgICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIGFkYXB0aXZlIHBhZGRpbmcgaXMgc2V0IHRvIDBcbiAgICAgICAgICAgIGZpeGVkSGVpZ2h0R3JpZDogdHJ1ZSwgICAgICAvLyBTbyBlYWNoIHBhZ2UgaW4gZ3JpZCB2aWV3IGhhcyB0aGUgc2FtZSBoZWlnaHQgKG9ubHkgd2lkdGhzIGRpZmZlcilcbiAgICAgICAgICAgIGdvRGlyZWN0bHlUbzogMCwgICAgICAgICAgICAvLyBEZWZhdWx0IGluaXRpYWwgcGFnZSB0byBzaG93ICgwLWluZGV4ZWQpXG4gICAgICAgICAgICBoYXNoUGFyYW1TdWZmaXg6IG51bGwsICAgICAgLy8gVXNlZCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBkb2N1bWVudCB2aWV3ZXJzIG9uIGEgcGFnZVxuICAgICAgICAgICAgaWlwU2VydmVyVVJMOiAnJywgICAgICAgICAgIC8vIFRoZSBVUkwgdG8gdGhlIElJUEltYWdlIGluc3RhbGxhdGlvbiwgaW5jbHVkaW5nIHRoZSBgP0ZJRj1gIC0gKlJFUVVJUkVEKiwgdW5sZXNzIHVzaW5nIElJSUZcbiAgICAgICAgICAgIGluRnVsbHNjcmVlbjogZmFsc2UsICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byBsb2FkIGZ1bGxzY3JlZW4gbW9kZSBpbml0aWFsbHlcbiAgICAgICAgICAgIGluQm9va0xheW91dDogZmFsc2UsICAgICAgIC8vIFNldCB0byB0cnVlIHRvIHZpZXcgdGhlIGRvY3VtZW50IHdpdGggZmFjaW5nIHBhZ2VzIGluIGRvY3VtZW50IG1vZGVcbiAgICAgICAgICAgIGluR3JpZDogZmFsc2UsICAgICAgICAgICAgICAvLyBTZXQgdG8gdHJ1ZSB0byBsb2FkIGdyaWQgdmlldyBpbml0aWFsbHlcbiAgICAgICAgICAgIGltYWdlRGlyOiAnJywgICAgICAgICAgICAgICAvLyBJbWFnZSBkaXJlY3RvcnksIGVpdGhlciBhYnNvbHV0ZSBwYXRoIG9yIHJlbGF0aXZlIHRvIElJUCdzIEZJTEVTWVNURU1fUFJFRklYIC0gKlJFUVVJUkVEKiwgdW5sZXNzIHVzaW5nIElJSUZcbiAgICAgICAgICAgIG1heFBhZ2VzUGVyUm93OiA4LCAgICAgICAgICAvLyBNYXhpbXVtIG51bWJlciBvZiBwYWdlcyBwZXIgcm93IGluIGdyaWQgdmlld1xuICAgICAgICAgICAgbWF4Wm9vbUxldmVsOiAtMSwgICAgICAgICAgIC8vIE9wdGlvbmFsOyBkZWZhdWx0cyB0byB0aGUgbWF4IHpvb20gcmV0dXJuZWQgaW4gdGhlIEpTT04gcmVzcG9uc2VcbiAgICAgICAgICAgIG1pblBhZ2VzUGVyUm93OiAyLCAgICAgICAgICAvLyBNaW5pbXVtIHBhZ2VzIHBlciByb3cgaW4gZ3JpZCB2aWV3LiBSZWNvbW1lbmRlZCBkZWZhdWx0LlxuICAgICAgICAgICAgbWluWm9vbUxldmVsOiAwLCAgICAgICAgICAgIC8vIERlZmF1bHRzIHRvIDAgKHRoZSBtaW5pbXVtIHpvb20pXG4gICAgICAgICAgICBvbkdvdG9TdWJtaXQ6IG51bGwsICAgICAgICAgLy8gV2hlbiBzZXQgdG8gYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGEgcGFnZSBpbmRleCwgdGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGUgJ2dvIHRvIHBhZ2UnIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgICAgcGFnZUFsaWFzZXM6IHt9LCAgICAgICAgICAgIC8vIEFuIG9iamVjdCBtYXBwaW5nIHNwZWNpZmljIHBhZ2UgaW5kaWNlcyB0byBhbGlhc2VzIChoYXMgcHJpb3JpdHkgb3ZlciAncGFnZUFsaWFzRnVuY3Rpb24nXG4gICAgICAgICAgICBwYWdlQWxpYXNGdW5jdGlvbjogZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2U7fSwgIC8vIEEgZnVuY3Rpb24gbWFwcGluZyBwYWdlIGluZGljZXMgdG8gYW4gYWxpYXMuIElmIGZhbHNlIGlzIHJldHVybmVkLCBkZWZhdWx0IHBhZ2UgbnVtYmVyIGlzIGRpc3BsYXllZFxuICAgICAgICAgICAgcGFnZUxvYWRUaW1lb3V0OiAyMDAsICAgICAgIC8vIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgbG9hZGluZyBwYWdlc1xuICAgICAgICAgICAgcGFnZXNQZXJSb3c6IDUsICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IG51bWJlciBvZiBwYWdlcyBwZXIgcm93IGluIGdyaWQgdmlld1xuICAgICAgICAgICAgc2hvd05vblBhZ2VkUGFnZXM6IGZhbHNlLCAgIC8vIFdoZXRoZXIgcGFnZXMgdGFnZ2VkIGFzICdub24tcGFnZWQnIChpbiBJSUlGIG1hbmlmZXN0cyBvbmx5KSBzaG91bGQgYmUgdmlzaWJsZSBhZnRlciBpbml0aWFsIGxvYWRcbiAgICAgICAgICAgIHRocm9iYmVyVGltZW91dDogMTAwLCAgICAgICAvLyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHNob3dpbmcgdGhyb2JiZXJcbiAgICAgICAgICAgIHRpbGVIZWlnaHQ6IDI1NiwgICAgICAgICAgICAvLyBUaGUgaGVpZ2h0IG9mIGVhY2ggdGlsZSwgaW4gcGl4ZWxzOyB1c3VhbGx5IDI1NlxuICAgICAgICAgICAgdGlsZVdpZHRoOiAyNTYsICAgICAgICAgICAgIC8vIFRoZSB3aWR0aCBvZiBlYWNoIHRpbGUsIGluIHBpeGVsczsgdXN1YWxseSAyNTZcbiAgICAgICAgICAgIHRvb2xiYXJQYXJlbnRPYmplY3Q6IG51bGwsICAvLyBUaGUgdG9vbGJhciBwYXJlbnQgb2JqZWN0LlxuICAgICAgICAgICAgdmVydGljYWxseU9yaWVudGVkOiB0cnVlLCAgIC8vIERldGVybWluZXMgdmVydGljYWwgdnMuIGhvcml6b250YWwgb3JpZW50YXRpb25cbiAgICAgICAgICAgIHZpZXdwb3J0TWFyZ2luOiAyMDAsICAgICAgICAvLyBQcmV0ZW5kIHRpbGVzICsvLSAyMDBweCBhd2F5IGZyb20gdmlld3BvcnQgYXJlIGluXG4gICAgICAgICAgICB6b29tTGV2ZWw6IDIgICAgICAgICAgICAgICAgLy8gVGhlIGluaXRpYWwgem9vbSBsZXZlbCAodXNlZCB0byBzdG9yZSB0aGUgY3VycmVudCB6b29tIGxldmVsKVxuICAgICAgICB9LCBvcHRpb25zKTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBwYWdlIGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gZmlsZW5hbWU7IG11c3QgY2FsbGVkIGFmdGVyIHNldHRpbmcgc2V0dGluZ3MubWFuaWZlc3RcbiAgICAgICAgdmFyIGdldFBhZ2VJbmRleCA9IGZ1bmN0aW9uIChmaWxlbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldFBhZ2VJbmRleEZvck1hbmlmZXN0KHNldHRpbmdzLm1hbmlmZXN0LCBmaWxlbmFtZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFBhZ2VJbmRleEZvck1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBmaWxlbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbnAgPSBtYW5pZmVzdC5wYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChtYW5pZmVzdC5wYWdlc1tpXS5mID09PSBmaWxlbmFtZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgcGFnZSBpbmRleCBpcyB2YWxpZFxuICAgICAgICB2YXIgaXNQYWdlVmFsaWQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QuaXNQYWdlVmFsaWQocGFnZUluZGV4LCBzZXR0aW5ncy5zaG93Tm9uUGFnZWRQYWdlcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbG9hZFZpZXdlciA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZGl2YVN0YXRlLnZpZXdlckNvcmUucmVsb2FkKG5ld09wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHRoZSBjaGFuZ2UgdmlldyBpY29uIGlzIGNsaWNrZWRcbiAgICAgICAgdmFyIGNoYW5nZVZpZXcgPSBmdW5jdGlvbiAoZGVzdGluYXRpb25WaWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRlc3RpbmF0aW9uVmlldylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQm9va0xheW91dDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib29rJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3JpZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vdG9nZ2xlcyBiZXR3ZWVuIG9yaWVudGF0aW9uc1xuICAgICAgICB2YXIgdG9nZ2xlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdmVydGljYWxseU9yaWVudGVkID0gIXNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZDtcblxuICAgICAgICAgICAgLy9pZiBpbiBncmlkLCBzd2l0Y2ggb3V0IG9mIGdyaWRcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbGx5T3JpZW50ZWQ6IHZlcnRpY2FsbHlPcmllbnRlZCxcbiAgICAgICAgICAgICAgICBnb0RpcmVjdGx5VG86IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgdmVydGljYWxPZmZzZXQ6IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldFlPZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBkaXZhU3RhdGUudmlld2VyQ29yZS5nZXRYT2Zmc2V0KClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdmVydGljYWxseU9yaWVudGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHRoZSBmdWxsc2NyZWVuIGljb24gaXMgY2xpY2tlZFxuICAgICAgICB2YXIgdG9nZ2xlRnVsbHNjcmVlbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgaW5GdWxsc2NyZWVuOiAhc2V0dGluZ3MuaW5GdWxsc2NyZWVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdmlldztcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gJ2cnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2V0dGluZ3MuaW5Cb29rTGF5b3V0KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXcgPSAnYic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlldyA9ICdkJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKTtcbiAgICAgICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gbGF5b3V0LmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZpZXdwb3J0KTtcblxuICAgICAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICdmJzogc2V0dGluZ3MuaW5GdWxsc2NyZWVuLFxuICAgICAgICAgICAgICAgICd2JzogdmlldyxcbiAgICAgICAgICAgICAgICAneic6IHNldHRpbmdzLnpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICAnbic6IHNldHRpbmdzLnBhZ2VzUGVyUm93LFxuICAgICAgICAgICAgICAgICdpJzogc2V0dGluZ3MuZW5hYmxlRmlsZW5hbWUgPyBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1tzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4XS5mIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3AnOiBzZXR0aW5ncy5lbmFibGVGaWxlbmFtZSA/IGZhbHNlIDogc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCArIDEsXG4gICAgICAgICAgICAgICAgJ3knOiBwYWdlT2Zmc2V0ID8gcGFnZU9mZnNldC55IDogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3gnOiBwYWdlT2Zmc2V0ID8gcGFnZU9mZnNldC54IDogZmFsc2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0TG9hZE9wdGlvbnNGb3JTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgbWFuaWZlc3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIG1hbmlmZXN0ID0gbWFuaWZlc3QgfHwgc2V0dGluZ3MubWFuaWZlc3Q7XG5cbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gKCd2JyBpbiBzdGF0ZSkgPyBnZXRWaWV3U3RhdGUoc3RhdGUudikgOiB7fTtcblxuICAgICAgICAgICAgaWYgKCdmJyBpbiBzdGF0ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmluRnVsbHNjcmVlbiA9IHN0YXRlLmY7XG5cbiAgICAgICAgICAgIGlmICgneicgaW4gc3RhdGUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy56b29tTGV2ZWwgPSBzdGF0ZS56O1xuXG4gICAgICAgICAgICBpZiAoJ24nIGluIHN0YXRlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFnZXNQZXJSb3cgPSBzdGF0ZS5uO1xuXG4gICAgICAgICAgICAvLyBPbmx5IGNoYW5nZSBzcGVjaWZ5IHRoZSBwYWdlIGlmIHN0YXRlLmkgb3Igc3RhdGUucCBpcyB2YWxpZFxuICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IGdldFBhZ2VJbmRleEZvck1hbmlmZXN0KG1hbmlmZXN0LCBzdGF0ZS5pKTtcblxuICAgICAgICAgICAgaWYgKCEocGFnZUluZGV4ID49IDAgJiYgcGFnZUluZGV4IDwgbWFuaWZlc3QucGFnZXMubGVuZ3RoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwYWdlSW5kZXggPSBzdGF0ZS5wIC0gMTtcblxuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmx5IE5hTlxuICAgICAgICAgICAgICAgIGlmICghKHBhZ2VJbmRleCA+PSAwICYmIHBhZ2VJbmRleCA8IG1hbmlmZXN0LnBhZ2VzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VJbmRleCA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYWdlSW5kZXggIT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSBwYXJzZUludChzdGF0ZS54LCAxMCk7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnRpY2FsT2Zmc2V0ID0gcGFyc2VJbnQoc3RhdGUueSwgMTApO1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5nb0RpcmVjdGx5VG8gPSBwYWdlSW5kZXg7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID0gaG9yaXpvbnRhbE9mZnNldDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZlcnRpY2FsT2Zmc2V0ID0gdmVydGljYWxPZmZzZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRVUkxIYXNoID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGhhc2hQYXJhbXMgPSBnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGhhc2hTdHJpbmdCdWlsZGVyID0gW107XG4gICAgICAgICAgICB2YXIgcGFyYW07XG5cbiAgICAgICAgICAgIGZvciAocGFyYW0gaW4gaGFzaFBhcmFtcylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzaFBhcmFtc1twYXJhbV0gIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBoYXNoU3RyaW5nQnVpbGRlci5wdXNoKHBhcmFtICsgc2V0dGluZ3MuaGFzaFBhcmFtU3VmZml4ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGhhc2hQYXJhbXNbcGFyYW1dKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBoYXNoU3RyaW5nQnVpbGRlci5qb2luKCcmJyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgVVJMIHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgKHNvIGl0IHNob3VsZCBiZSBhbiBleGFjdCByZXBsaWNhKVxuICAgICAgICB2YXIgZ2V0Q3VycmVudFVSTCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0ICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyAnIycgKyBnZXRVUkxIYXNoKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFZpZXdTdGF0ZSA9IGZ1bmN0aW9uKHZpZXcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAodmlldylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNob3dFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnNob3dFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWpheEVycm9yID0gZnVuY3Rpb24oanF4aHIsIHN0YXR1cywgZXJyb3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFNob3cgYSBiYXNpYyBlcnJvciBtZXNzYWdlIHdpdGhpbiB0aGUgZG9jdW1lbnQgdmlld2VyIHBhbmVcblxuICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFsnSW52YWxpZCBvYmplY3REYXRhIHNldHRpbmcuIEVycm9yIGNvZGU6ICcgKyBqcXhoci5zdGF0dXMgKyAnICcgKyBlcnJvcl07XG5cbiAgICAgICAgICAgIC8vIERldGVjdCBhbmQgaGFuZGxlIENPUlMgZXJyb3JzXG4gICAgICAgICAgICB2YXIgZGF0YUhhc0Fic29sdXRlUGF0aCA9IHNldHRpbmdzLm9iamVjdERhdGEubGFzdEluZGV4T2YoJ2h0dHAnLCAwKSA9PT0gMDtcblxuICAgICAgICAgICAgaWYgKGRhdGFIYXNBYnNvbHV0ZVBhdGggJiYgZXJyb3IgPT09ICcnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBqc29uSG9zdCA9IHNldHRpbmdzLm9iamVjdERhdGEucmVwbGFjZSgvaHR0cHM/OlxcL1xcLy9pLCBcIlwiKS5zcGxpdCgvWy8/I10vKVswXTtcblxuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbi5ob3N0bmFtZSAhPT0ganNvbkhvc3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdCgncCcsICdBdHRlbXB0ZWQgdG8gYWNjZXNzIGNyb3NzLW9yaWdpbiBkYXRhIHdpdGhvdXQgQ09SUy4nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsdCgncCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1lvdSBtYXkgbmVlZCB0byB1cGRhdGUgeW91ciBzZXJ2ZXIgY29uZmlndXJhdGlvbiB0byBzdXBwb3J0IENPUlMuIEZvciBoZWxwLCBzZWUgdGhlICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWx0KCdhJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAnaHR0cHM6Ly9naXRodWIuY29tL0RETUFML2RpdmEuanMvd2lraS9JbnN0YWxsYXRpb24jYS1ub3RlLWFib3V0LWNyb3NzLXNpdGUtcmVxdWVzdHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6ICdfYmxhbmsnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ2Nyb3NzLXNpdGUgcmVxdWVzdCBkb2N1bWVudGF0aW9uLicpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaG93RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbG9hZE9iamVjdERhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2VEYXRhLCBoYXNoU3RhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBpc0lJSUYsIG1hbmlmZXN0O1xuXG4gICAgICAgICAgICAvLyBwYXJzZSBJSUlGIG1hbmlmZXN0IGlmIGl0IGlzIGFuIElJSUYgbWFuaWZlc3QuIFRPRE8gaW1wcm92ZSBJSUlGIGRldGVjdGlvbiBtZXRob2RcbiAgICAgICAgICAgIGlmIChyZXNwb25zZURhdGEuaGFzT3duUHJvcGVydHkoJ0Bjb250ZXh0JykgJiYgKHJlc3BvbnNlRGF0YVsnQGNvbnRleHQnXS5pbmRleE9mKCdpaWlmJykgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VEYXRhWydAY29udGV4dCddLmluZGV4T2YoJ3NoYXJlZC1jYW52YXMnKSAhPT0gLTEpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlzSUlJRiA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIE1hbmlmZXN0RGlkTG9hZCBldmVudFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBXaHkgaXMgdGhpcyB0cmlnZ2VyZWQgYmVmb3JlIHRoZSBtYW5pZmVzdCBpcyBwYXJzZWQ/IFNlZSBodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy9pc3N1ZXMvMzU3XG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaCgnTWFuaWZlc3REaWRMb2FkJywgW3Jlc3BvbnNlRGF0YV0sIHNlbGYpO1xuXG4gICAgICAgICAgICAgICAgbWFuaWZlc3QgPSBJbWFnZU1hbmlmZXN0LmZyb21JSUlGKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSUlQIHN1cHBvcnQgaXMgbm93IGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVc2FnZSBvZiBJSVAgbWFuaWZlc3RzIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHN3aXRjaGluZyB0byBJSUlGIG1hbmlmZXN0cy4gVmlzaXQgaHR0cDovL2lpaWYuaW8vIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcblxuICAgICAgICAgICAgICAgIGlzSUlJRiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG1hbmlmZXN0ID0gSW1hZ2VNYW5pZmVzdC5mcm9tTGVnYWN5TWFuaWZlc3QocmVzcG9uc2VEYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIGlpcFNlcnZlclVSTDogc2V0dGluZ3MuaWlwU2VydmVyVVJMLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZURpcjogc2V0dGluZ3MuaW1hZ2VEaXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGxvYWRPcHRpb25zID0gaGFzaFN0YXRlID8gZ2V0TG9hZE9wdGlvbnNGb3JTdGF0ZShoYXNoU3RhdGUsIG1hbmlmZXN0KSA6IHt9O1xuXG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5zZXRNYW5pZmVzdChtYW5pZmVzdCwgaXNJSUlGLCBsb2FkT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqIFBhcnNlIHRoZSBoYXNoIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IHVzZWQgYnkgZ2V0U3RhdGUgYW5kIHNldFN0YXRlICovXG4gICAgICAgIHZhciBnZXRIYXNoUGFyYW1TdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgICAgICBbJ2YnLCAndicsICd6JywgJ24nLCAnaScsICdwJywgJ3knLCAneCddLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IEhhc2hQYXJhbXMuZ2V0KHBhcmFtICsgc2V0dGluZ3MuaGFzaFBhcmFtU3VmZml4KTtcblxuICAgICAgICAgICAgICAgIC8vIGBmYWxzZWAgaXMgcmV0dXJuZWQgaWYgdGhlIHZhbHVlIGlzIG1pc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtwYXJhbV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEbyBzb21lIGF3a3dhcmQgc3BlY2lhbC1jYXNpbmcsIHNpbmNlIHRoaXMgZm9ybWF0IGlzIGtpbmQgb2Ygd2VpcmQuXG5cbiAgICAgICAgICAgIC8vIEZvciBpbkZ1bGxzY3JlZW4gKGYpLCB0cnVlIGFuZCBmYWxzZSBzdHJpbmdzIHNob3VsZCBiZSBpbnRlcnByZXRlZFxuICAgICAgICAgICAgLy8gYXMgYm9vbGVhbnMuXG4gICAgICAgICAgICBpZiAoc3RhdGUuZiA9PT0gJ3RydWUnKVxuICAgICAgICAgICAgICAgIHN0YXRlLmYgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuZiA9PT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICBzdGF0ZS5mID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtZXJpY2FsIHZhbHVlcyB0byBpbnRlZ2VycywgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIFsneicsICduJywgJ3AnLCAneCcsICd5J10uZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtIGluIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtwYXJhbV0gPSBwYXJzZUludChzdGF0ZVtwYXJhbV0sIDEwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNoZWNrTG9hZGVkID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZpZXdlclN0YXRlLmxvYWRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgdmlld2VyIGlzIG5vdCBjb21wbGV0ZWx5IGluaXRpYWxpemVkLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIGl0IGlzIHN0aWxsIGRvd25sb2FkaW5nIGRhdGEuIFRvIGZpeCB0aGlzLCBvbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBpZiB0aGUgaXNSZWFkeSgpIG1ldGhvZCByZXR1cm5zIHRydWUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gZmlsbCB0aGUgaGVpZ2h0LCB1c2UgYSB3cmFwcGVyIGRpdiBkaXNwbGF5ZWQgdXNpbmcgYSBmbGV4Ym94IGxheW91dFxuICAgICAgICAgICAgdmFyIHdyYXBwZXJFbGVtZW50ID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZGl2YS13cmFwcGVyXCIgKyAob3B0aW9ucy5maWxsUGFyZW50SGVpZ2h0ID8gXCIgZGl2YS13cmFwcGVyLWZsZXhib3hcIiA6IFwiXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICAgICAgb3B0aW9ucy50b29sYmFyUGFyZW50T2JqZWN0ID0gb3B0aW9ucy50b29sYmFyUGFyZW50T2JqZWN0IHx8ICQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgdmlld2VyQ29yZSA9IG5ldyBWaWV3ZXJDb3JlKHdyYXBwZXJFbGVtZW50LCBvcHRpb25zLCBzZWxmKTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUgPSB2aWV3ZXJDb3JlLmdldEludGVybmFsU3RhdGUoKTtcbiAgICAgICAgICAgIHNldHRpbmdzID0gdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIElEIHRvIHRoZSB3cmFwcGVyIGVsZW1lbnQgbm93IHRoYXQgdGhlIElEIGhhcyBiZWVuIGdlbmVyYXRlZCBieSB0aGUgdmlld2VyIGNvcmVcbiAgICAgICAgICAgIHdyYXBwZXJFbGVtZW50LmlkID0gc2V0dGluZ3MuSUQgKyAnd3JhcHBlcic7XG5cbiAgICAgICAgICAgIGRpdmFTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB2aWV3ZXJDb3JlOiB2aWV3ZXJDb3JlLFxuICAgICAgICAgICAgICAgIHRvb2xiYXI6IHNldHRpbmdzLmVuYWJsZVRvb2xiYXIgPyBjcmVhdGVUb29sYmFyKHNlbGYpIDogbnVsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhhc2hTdGF0ZSA9IGdldEhhc2hQYXJhbVN0YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub2JqZWN0RGF0YSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXIgZXhlY3V0aW9uIHVudGlsIGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2FkT2JqZWN0RGF0YShzZXR0aW5ncy5vYmplY3REYXRhLCBoYXNoU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0ID0gJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZXR0aW5ncy5vYmplY3REYXRhLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGFqYXhFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZE9iamVjdERhdGEocmVzcG9uc2VEYXRhLCBoYXNoU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgcGVuZGluZyByZXF1ZXN0IHNvIHRoYXQgaXQgY2FuIGJlIGNhbmNlbGxlZCBpbiB0aGUgZXZlbnQgdGhhdCBEaXZhIG5lZWRzIHRvIGJlIGRlc3Ryb3llZFxuICAgICAgICAgICAgICAgIHZpZXdlckNvcmUuc2V0UGVuZGluZ01hbmlmZXN0UmVxdWVzdChwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBQVUJMSUMgRlVOQ1RJT05TXG4gICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICovXG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgdGl0bGUgb2YgdGhlIGRvY3VtZW50LCBiYXNlZCBvbiB0aGUgZGlyZWN0b3J5IG5hbWVcbiAgICAgICAgdGhpcy5nZXRJdGVtVGl0bGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QuaXRlbVRpdGxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdvIHRvIGEgcGFydGljdWxhciBwYWdlIGJ5IGl0cyBwYWdlIG51bWJlciAod2l0aCBpbmRleGluZyBzdGFydGluZyBhdCAxKVxuICAgICAgICAgICAgLy94QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJsZWZ0XCIsIFwicmlnaHRcIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBhbmNob3JlZCB0byB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIGRpdmEtb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgLy95QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJ0b3BcIiwgXCJib3R0b21cIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyBzYW1lIHByb2Nlc3MgYXMgeEFuY2hvci5cbiAgICAgICAgLy8gcmV0dXJucyBUcnVlIGlmIHRoZSBwYWdlIG51bWJlciBwYXNzZWQgaXMgdmFsaWQ7IGZhbHNlIGlmIGl0IGlzIG5vdC5cbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5TnVtYmVyID0gZnVuY3Rpb24gKHBhZ2VOdW1iZXIsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIGdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhcnNlSW50KHBhZ2VOdW1iZXIsIDEwKSAtIDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgocGFnZUluZGV4LCB4QW5jaG9yLCB5QW5jaG9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHbyB0byBhIHBhcnRpY3VsYXIgcGFnZSAod2l0aCBpbmRleGluZyBzdGFydGluZyBhdCAwKVxuICAgICAgICAgICAgLy94QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJsZWZ0XCIsIFwicmlnaHRcIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBhbmNob3JlZCB0byB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIGRpdmEtb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgLy95QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJ0b3BcIiwgXCJib3R0b21cIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyBzYW1lIHByb2Nlc3MgYXMgeEFuY2hvci5cbiAgICAgICAgLy8gcmV0dXJucyBUcnVlIGlmIHRoZSBwYWdlIGluZGV4IGlzIHZhbGlkOyBmYWxzZSBpZiBpdCBpcyBub3QuXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeUluZGV4ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgeEFuY2hvciwgeUFuY2hvcilcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZUluZGV4ID0gcGFyc2VJbnQocGFnZUluZGV4LCAxMCk7XG4gICAgICAgICAgICBpZiAoaXNQYWdlVmFsaWQocGFnZUluZGV4KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgeE9mZnNldCA9IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldFhPZmZzZXQocGFnZUluZGV4LCB4QW5jaG9yKTtcbiAgICAgICAgICAgICAgICB2YXIgeU9mZnNldCA9IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldFlPZmZzZXQocGFnZUluZGV4LCB5QW5jaG9yKTtcblxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmdvdG8ocGFnZUluZGV4LCB5T2Zmc2V0LCB4T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE51bWJlck9mUGFnZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrTG9hZGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubnVtUGFnZXM7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHBhZ2UgZGltZW5zaW9ucyBpbiB0aGUgY3VycmVudCB2aWV3IGFuZCB6b29tIGxldmVsXG4gICAgICAgIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrTG9hZGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXZhU3RhdGUudmlld2VyQ29yZS5nZXRDdXJyZW50TGF5b3V0KCkuZ2V0UGFnZURpbWVuc2lvbnMocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIGEgZ2l2ZW4gcGFnZSBpbmRleCBhdCBhIGdpdmVuIHpvb20gbGV2ZWxcbiAgICAgICAgdGhpcy5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsID0gZnVuY3Rpb24gKHBhZ2VJZHgsIHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjaGVja0xvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHpvb21MZXZlbCA+IHNldHRpbmdzLm1heFpvb21MZXZlbClcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBzZXR0aW5ncy5tYXhab29tTGV2ZWw7XG5cbiAgICAgICAgICAgIHZhciBwZyA9IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3BhcnNlSW50KHBhZ2VJZHgsIDEwKV07XG4gICAgICAgICAgICB2YXIgcGdBdFpvb20gPSBwZy5kW3BhcnNlSW50KHpvb21MZXZlbCwgMTApXTtcbiAgICAgICAgICAgIHJldHVybiB7J3dpZHRoJzogcGdBdFpvb20udywgJ2hlaWdodCc6IHBnQXRab29tLmh9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgYSBnaXZlbiBwYWdlIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgcGFnZSBpbmRleCB3aWxsIGJlIHVzZWQgaWYgbm8gcGFnZUluZGV4IGlzIHNwZWNpZmllZFxuICAgICAgICAvLyBBbHNvIHdvcmtzIGluIEdyaWQgdmlld1xuICAgICAgICB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50Wm9vbUxldmVsID0gZnVuY3Rpb24ocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlSW5kZXggPSBpc1BhZ2VWYWxpZChwYWdlSW5kZXgpID8gcGFnZUluZGV4IDogc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleDtcblxuICAgICAgICAgICAgaWYgKCFpc1BhZ2VWYWxpZChwYWdlSW5kZXgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQYWdlIEluZGV4Jyk7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXZhU3RhdGUudmlld2VyQ29yZS5nZXRDdXJyZW50TGF5b3V0KCkuZ2V0UGFnZURpbWVuc2lvbnMocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHBhZ2UgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICAvLyBBbHNvIHdvcmtzIGluIEdyaWQgdmlld1xuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlRGltZW5zaW9uc0F0Q3VycmVudFpvb21MZXZlbCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50Wm9vbUxldmVsKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5sb2FkZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UGFnZUluZGV4ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXg7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UGFnZUZpbGVuYW1lID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3NldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhdLmY7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UGFnZU51bWJlciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIGdldEN1cnJlbnRQYWdlSW5kZXgoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4ICsgMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBmaWxlbmFtZXMgaW4gdGhlIGRvY3VtZW50XG4gICAgICAgIHRoaXMuZ2V0RmlsZW5hbWVzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGZpbGVuYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldHRpbmdzLm51bVBhZ2VzOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWVzW2ldID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbaV0uZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpbGVuYW1lcztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgICAgdGhpcy5nZXRab29tTGV2ZWwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muem9vbUxldmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGdldHMgdGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGVudGlyZSBkb2N1bWVudFxuICAgICAgICB0aGlzLmdldE1heFpvb21MZXZlbCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYXhab29tTGV2ZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0cyB0aGUgbWF4IHpvb20gbGV2ZWwgZm9yIGEgZ2l2ZW4gcGFnZVxuICAgICAgICB0aGlzLmdldE1heFpvb21MZXZlbEZvclBhZ2UgPSBmdW5jdGlvbiAocGFnZUlkeClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjaGVja0xvYWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1twYWdlSWR4XS5tO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWluWm9vbUxldmVsID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1pblpvb21MZXZlbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIHpvb20gbGV2ZWwgKHdpbGwgY2hlY2sgZm9yIHZhbGlkaXR5IGZpcnN0KVxuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIHRoZSB6b29tIGxldmVsIGlzIGludmFsaWQsIHRydWUgb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMuc2V0Wm9vbUxldmVsID0gZnVuY3Rpb24gKHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkaXZhU3RhdGUudmlld2VyQ29yZS56b29tKHpvb21MZXZlbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRHcmlkUGFnZXNQZXJSb3cgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPKHdhYmFpbik6IEFkZCB0ZXN0IGNhc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhZ2VzUGVyUm93O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2V0R3JpZFBhZ2VzUGVyUm93ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPKHdhYmFpbik6IEFkZCB0ZXN0IGNhc2VcbiAgICAgICAgICAgIGlmICghZGl2YVN0YXRlLnZpZXdlckNvcmUuaXNWYWxpZE9wdGlvbigncGFnZXNQZXJSb3cnLCBuZXdWYWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICBpbkdyaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFnZXNQZXJSb3c6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIGluLiBXaWxsIHJldHVybiBmYWxzZSBpZiBpdCdzIGF0IHRoZSBtYXhpbXVtIHpvb21cbiAgICAgICAgdGhpcy56b29tSW4gPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRab29tTGV2ZWwoc2V0dGluZ3Muem9vbUxldmVsICsgMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gWm9vbSBvdXQuIFdpbGwgcmV0dXJuIGZhbHNlIGlmIGl0J3MgYXQgdGhlIG1pbmltdW0gem9vbVxuICAgICAgICB0aGlzLnpvb21PdXQgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRab29tTGV2ZWwoc2V0dGluZ3Muem9vbUxldmVsIC0gMSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc29tZXRoaW5nIChlLmcuIGEgaGlnaGxpZ2h0IGJveCBvbiBhIHBhcnRpY3VsYXIgcGFnZSkgaXMgdmlzaWJsZVxuICAgICAgICB0aGlzLmlzUmVnaW9uSW5WaWV3cG9ydCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGxlZnRPZmZzZXQsIHRvcE9mZnNldCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldEN1cnJlbnRMYXlvdXQoKTtcblxuICAgICAgICAgICAgaWYgKCFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gbGF5b3V0LmdldFBhZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgICAgICAgICAgdmFyIHRvcCA9IG9mZnNldC50b3AgKyB0b3BPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0ICsgbGVmdE9mZnNldDtcblxuICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnZpZXdwb3J0LmludGVyc2VjdHNSZWdpb24oe1xuICAgICAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogdG9wICsgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyB3aWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9QdWJsaWMgd3JhcHBlciBmb3IgaXNQYWdlVmlzaWJsZVxuICAgICAgICAvL0RldGVybWluZXMgaWYgYSBwYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgdmlld3BvcnRcbiAgICAgICAgdGhpcy5pc1BhZ2VJblZpZXdwb3J0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnJlbmRlcmVyLmlzUGFnZVZpc2libGUocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1B1YmxpYyB3cmFwcGVyIGZvciBpc1BhZ2VMb2FkZWRcbiAgICAgICAgLy9EZXRlcm1pbmVzIGlmIGEgcGFnZSBpcyBjdXJyZW50bHkgaW4gdGhlIERPTVxuICAgICAgICB0aGlzLmlzUGFnZUxvYWRlZCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIGlzUGFnZUluVmlld3BvcnQocGFnZUluZGV4KSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGFnZUluVmlld3BvcnQocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbHNjcmVlbk1vZGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB0b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU2hvdy9IaWRlIG5vbi1wYWdlZCBwYWdlc1xuICAgICAgICB0aGlzLnRvZ2dsZU5vblBhZ2VkUGFnZXNWaXNpYmlsaXR5ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHsgc2hvd05vblBhZ2VkUGFnZXM6ICFzZXR0aW5ncy5zaG93Tm9uUGFnZWRQYWdlcyB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTaG93IG5vbi1wYWdlZCBwYWdlc1xuICAgICAgICB0aGlzLnNob3dOb25QYWdlZFBhZ2VzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHsgc2hvd05vblBhZ2VkUGFnZXM6IHRydWUgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSGlkZSBub24tcGFnZWQgcGFnZXNcbiAgICAgICAgdGhpcy5oaWRlTm9uUGFnZWRQYWdlcyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7IHNob3dOb25QYWdlZFBhZ2VzOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDbG9zZSB0b29sYmFyIHBvcHVwc1xuICAgICAgICB0aGlzLmNsb3NlUG9wdXBzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnRvb2xiYXIuY2xvc2VQb3B1cHMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFbnRlciBmdWxsc2NyZWVuIG1vZGUgaWYgY3VycmVudGx5IG5vdCBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgLy8gUmV0dXJucyBmYWxzZSBpZiBpbiBmdWxsc2NyZWVuIG1vZGUgaW5pdGlhbGx5LCB0cnVlIG90aGVyd2lzZVxuICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgd29yayBldmVuIGlmIGVuYWJsZUZ1bGxzY3JlZW4gaXMgc2V0IHRvIGZhbHNlXG4gICAgICAgIHRoaXMuZW50ZXJGdWxsc2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExlYXZlIGZ1bGxzY3JlZW4gbW9kZSBpZiBjdXJyZW50bHkgaW4gZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBpbiBmdWxsc2NyZWVuIG1vZGUgaW50aXRpYWxseSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMubGVhdmVGdWxsc2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pc0luRnVsbHNjcmVlbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5pbkZ1bGxzY3JlZW47XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hhbmdlIHZpZXdzLiBUYWtlcyAnZG9jdW1lbnQnLCAnYm9vaycsIG9yICdncmlkJyB0byBzcGVjaWZ5IHdoaWNoIHZpZXcgdG8gc3dpdGNoIGludG9cbiAgICAgICAgdGhpcy5jaGFuZ2VWaWV3ID0gZnVuY3Rpb24oZGVzdGluYXRpb25WaWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gY2hhbmdlVmlldyhkZXN0aW5hdGlvblZpZXcpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEVudGVyIGdyaWQgdmlldyBpZiBjdXJyZW50bHkgbm90IGluIGdyaWQgdmlld1xuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIGluIGdyaWQgdmlldyBpbml0aWFsbHksIHRydWUgb3RoZXJ3aXNlXG4gICAgICAgIHRoaXMuZW50ZXJHcmlkVmlldyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZVZpZXcoJ2dyaWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExlYXZlIGdyaWQgdmlldyBpZiBjdXJyZW50bHkgaW4gZ3JpZCB2aWV3XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBpbiBncmlkIHZpZXcgaW5pdGlhbGx5LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5sZWF2ZUdyaWRWaWV3ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWxvYWRWaWV3ZXIoeyBpbkdyaWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSnVtcCB0byBhIHBhZ2UgYmFzZWQgb24gaXRzIGZpbGVuYW1lXG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBzdWNjZXNzZnVsIGFuZCBmYWxzZSBpZiB0aGUgZmlsZW5hbWUgaXMgaW52YWxpZFxuICAgICAgICB0aGlzLmdvdG9QYWdlQnlOYW1lID0gZnVuY3Rpb24gKGZpbGVuYW1lLCB4QW5jaG9yLCB5QW5jaG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gZ2V0UGFnZUluZGV4KGZpbGVuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeUxhYmVsID0gZnVuY3Rpb24gKGxhYmVsLCB4QW5jaG9yLCB5QW5jaG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFnZXMgPSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYWdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocGFnZXNbaV0ubC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobGFiZWwudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ290b1BhZ2VCeUluZGV4KGksIHhBbmNob3IsIHlBbmNob3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBubyBsYWJlbCB3YXMgZm91bmQsIHRyeSB0byBwYXJzZSBhIHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gcGFyc2VJbnQobGFiZWwsIDEwKSAtIDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgocGFnZUluZGV4LCB4QW5jaG9yLCB5QW5jaG9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIHBhZ2UgaW5kZXggKDAtYmFzZWQpIGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiBmaWxlbmFtZVxuICAgICAgICAvLyBJZiB0aGUgcGFnZSBpbmRleCBkb2Vzbid0IGV4aXN0LCB0aGlzIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgIHRoaXMuZ2V0UGFnZUluZGV4ID0gZnVuY3Rpb24gKGZpbGVuYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFnZUluZGV4KGZpbGVuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgVVJMIChleHBvc2VzIHRoZSBwcml2YXRlIG1ldGhvZClcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50VVJMID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldEN1cnJlbnRVUkwoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBpZiBhIHBhZ2UgaW5kZXggaXMgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgdGhpcy5pc1BhZ2VJbmRleFZhbGlkID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGlzUGFnZVZhbGlkKHBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBoYXNoIHBhcnQgb25seSBvZiB0aGUgY3VycmVudCBVUkwgKHdpdGhvdXQgdGhlIGxlYWRpbmcgIylcbiAgICAgICAgdGhpcy5nZXRVUkxIYXNoID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGdldFVSTEhhc2goKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhpcyBkaXZhIGluc3RhbmNlIChmb3Igc2V0U3RhdGUpXG4gICAgICAgIHRoaXMuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RhdGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBbGlnbiB0aGlzIGRpdmEgaW5zdGFuY2Ugd2l0aCBhIHN0YXRlIG9iamVjdCAoYXMgcmV0dXJuZWQgYnkgZ2V0U3RhdGUpXG4gICAgICAgIHRoaXMuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcihnZXRMb2FkT3B0aW9uc0ZvclN0YXRlKHN0YXRlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZSBzZWxlY3RvciBmb3IgdGhpcyBpbnN0YW5jZSwgc2luY2UgaXQncyBhdXRvLWdlbmVyYXRlZC5cbiAgICAgICAgdGhpcy5nZXRJbnN0YW5jZVNlbGVjdG9yID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnNlbGVjdG9yO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgaW5zdGFuY2UgSUQgLS0gZXNzZW50aWFsbHkgdGhlIHNlbGVjdG9yIHdpdGhvdXQgdGhlIGxlYWRpbmcgJyMnLlxuICAgICAgICB0aGlzLmdldEluc3RhbmNlSWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuSUQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgVHJhbnNsYXRlcyBhIG1lYXN1cmVtZW50IGZyb20gdGhlIHpvb20gbGV2ZWwgb24gdGhlIGxhcmdlc3Qgc2l6ZVxuICAgICAgICAgICAgdG8gb25lIG9uIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuXG5cbiAgICAgICAgICAgIEZvciBleGFtcGxlLCBhIHBvaW50IDEwMDAgb24gYW4gaW1hZ2UgdGhhdCBpcyBvbiB6b29tIGxldmVsIDIgb2YgNVxuICAgICAgICAgICAgdHJhbnNsYXRlcyB0byBhIHBvc2l0aW9uIG9mIDExMS4xMTEuLi4gKDEwMDAgLyAoNSAtIDIpXjIpLlxuXG4gICAgICAgICAgICBXb3JrcyBmb3IgYSBzaW5nbGUgcGl4ZWwgY28tb3JkaW5hdGUgb3IgYSBkaW1lbnNpb24gKGUuZy4sIHRyYW5zbGF0ZXMgYSBib3hcbiAgICAgICAgICAgIHRoYXQgaXMgMTAwMCBwaXhlbHMgd2lkZSBvbiB0aGUgb3JpZ2luYWwgdG8gb25lIHRoYXQgaXMgMTExLjExMSBwaXhlbHMgd2lkZVxuICAgICAgICAgICAgb24gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21EaWZmZXJlbmNlID0gc2V0dGluZ3MubWF4Wm9vbUxldmVsIC0gc2V0dGluZ3Muem9vbUxldmVsO1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uIC8gTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBUcmFuc2xhdGVzIGEgbWVhc3VyZW1lbnQgZnJvbSB0aGUgY3VycmVudCB6b29tIGxldmVsIHRvIHRoZSBwb3NpdGlvbiBvbiB0aGVcbiAgICAgICAgICAgIGxhcmdlc3Qgem9vbSBsZXZlbC5cblxuICAgICAgICAgICAgV29ya3MgZm9yIGEgc2luZ2xlIHBpeGVsIGNvLW9yZGluYXRlIG9yIGEgZGltZW5zaW9uIChlLmcuLCB0cmFuc2xhdGVzIGEgYm94XG4gICAgICAgICAgICB0aGF0IGlzIDExMS4xMTEgcGl4ZWxzIHdpZGUgb24gdGhlIGN1cnJlbnQgaW1hZ2UgdG8gb25lIHRoYXQgaXMgMTAwMCBwaXhlbHMgd2lkZVxuICAgICAgICAgICAgb24gdGhlIGN1cnJlbnQgem9vbSBsZXZlbCkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNsYXRlVG9NYXhab29tTGV2ZWwgPSBmdW5jdGlvbiAocG9zaXRpb24pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB6b29tRGlmZmVyZW5jZSA9IHNldHRpbmdzLm1heFpvb21MZXZlbCAtIHNldHRpbmdzLnpvb21MZXZlbDtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZGlmZmVyZW5jZSwgaXQncyBhIGJveCBvbiB0aGUgbWF4IHpvb20gbGV2ZWwgYW5kXG4gICAgICAgICAgICAvLyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIHBvc2l0aW9uLlxuICAgICAgICAgICAgaWYgKHpvb21EaWZmZXJlbmNlID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcblxuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uICogTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJlLWVuYWJsZXMgZG9jdW1lbnQgZHJhZ2dpbmcsIHNjcm9sbGluZyAoYnkga2V5Ym9hcmQgaWYgc2V0KSwgYW5kIHpvb21pbmcgYnkgZG91YmxlLWNsaWNraW5nXG4gICAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsYWJsZSA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnZpZXdlckNvcmUuZW5hYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERpc2FibGVzIGRvY3VtZW50IGRyYWdnaW5nLCBzY3JvbGxpbmcgKGJ5IGtleWJvYXJkIGlmIHNldCksIGFuZCB6b29taW5nIGJ5IGRvdWJsZS1jbGlja2luZ1xuICAgICAgICB0aGlzLmRpc2FibGVTY3JvbGxhYmxlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnZpZXdlckNvcmUuZGlzYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL0NoYW5nZXMgYmV0d2VlbiBob3Jpem9udGFsIGxheW91dCBhbmQgdmVydGljYWwgbGF5b3V0LiBSZXR1cm5zIHRydWUgaWYgZG9jdW1lbnQgaXMgbm93IHZlcnRpY2FsbHkgb3JpZW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgdGhpcy50b2dnbGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0b2dnbGVPcmllbnRhdGlvbigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBub3J0aHdlc3QgY29ybmVycyBvZiBkaXZhLWlubmVyIGFuZCBwYWdlIGluZGV4XG4gICAgICAgIHRoaXMuZ2V0UGFnZU9mZnNldCA9IGZ1bmN0aW9uKHBhZ2VJbmRleCwgb3B0aW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldFBhZ2VSZWdpb24ocGFnZUluZGV4LCBvcHRpb25zKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHJlZ2lvbi50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVnaW9uLmxlZnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9zaG9ydGN1dCB0byBnZXRQYWdlT2Zmc2V0IGZvciBjdXJyZW50IHBhZ2VcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UGFnZU9mZnNldCA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZU9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1JldHVybnMgdGhlIHBhZ2UgZGltZW5zaW9ucyBvZiBnaXZlbiBwYWdlIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgICAgdGhpcy5nZXRQYWdlRGltZW5zaW9uc0F0Q3VycmVudEdyaWRMZXZlbCA9IGZ1bmN0aW9uKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgZ2V0UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwocGFnZUluZGV4KSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50Wm9vbUxldmVsKHBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIEdpdmVuIGEgcGFnZVggYW5kIHBhZ2VZIHZhbHVlIChhcyBjb3VsZCBiZSByZXRyZWl2ZWQgZnJvbSBhIGpRdWVyeSBldmVudCBvYmplY3QpLFxuICAgICAgICAgICAgICAgIHJldHVybnMgZWl0aGVyIHRoZSBwYWdlIHZpc2libGUgYXQgdGhhdCAoeCx5KSBwb3NpdGlvbiBvciAtMSBpZiBubyBwYWdlIGlzLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFBhZ2VJbmRleEZvclBhZ2VYWVZhbHVlcyA9IGZ1bmN0aW9uKHBhZ2VYLCBwYWdlWSlcbiAgICAgICAge1xuICAgICAgICAgICAgLy9nZXQgdGhlIGZvdXIgZWRnZXMgb2YgdGhlIG91dGVyIGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBvdXRlck9mZnNldCA9IHZpZXdlclN0YXRlLm91dGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBvdXRlclRvcCA9IG91dGVyT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgIHZhciBvdXRlckxlZnQgPSBvdXRlck9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgdmFyIG91dGVyQm90dG9tID0gb3V0ZXJPZmZzZXQuYm90dG9tO1xuICAgICAgICAgICAgdmFyIG91dGVyUmlnaHQgPSBvdXRlck9mZnNldC5yaWdodDtcblxuICAgICAgICAgICAgLy9pZiB0aGUgY2xpY2tlZCBwb3NpdGlvbiB3YXMgb3V0c2lkZSB0aGUgZGl2YS1vdXRlciBvYmplY3QsIGl0IHdhcyBub3Qgb24gYSB2aXNpYmxlIHBvcnRpb24gb2YgYSBwYWdlXG4gICAgICAgICAgICBpZiAocGFnZVggPCBvdXRlckxlZnQgfHwgcGFnZVggPiBvdXRlclJpZ2h0KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VZIDwgb3V0ZXJUb3AgfHwgcGFnZVkgPiBvdXRlckJvdHRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cbiAgICAgICAgICAgIC8vbmF2aWdhdGUgdGhyb3VnaCBhbGwgZGl2YSBwYWdlIG9iamVjdHNcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2RpdmEtcGFnZScpO1xuICAgICAgICAgICAgdmFyIGN1clBhZ2VJZHggPSBwYWdlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoY3VyUGFnZUlkeC0tKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vZ2V0IHRoZSBvZmZzZXQgZm9yIGVhY2ggcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjdXJQYWdlID0gcGFnZXNbY3VyUGFnZUlkeF07XG4gICAgICAgICAgICAgICAgdmFyIGN1ck9mZnNldCA9IGN1clBhZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHRoaXMgcG9pbnQgaXMgb3V0c2lkZSB0aGUgaG9yaXpvbnRhbCBib3VuZGFyaWVzIG9mIHRoZSBwYWdlLCBjb250aW51ZVxuICAgICAgICAgICAgICAgIGlmIChwYWdlWCA8IGN1ck9mZnNldC5sZWZ0IHx8IHBhZ2VYID4gY3VyT2Zmc2V0LnJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8vc2FtZSB3aXRoIHZlcnRpY2FsIGJvdW5kYXJpZXNcbiAgICAgICAgICAgICAgICBpZiAocGFnZVkgPCBjdXJPZmZzZXQudG9wIHx8IHBhZ2VZID4gY3VyT2Zmc2V0LmJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHdlIG1hZGUgaXQgdGhyb3VnaCB0aGUgYWJvdmUgdHdvLCB3ZSBmb3VuZCB0aGUgcGFnZSB3ZSdyZSBsb29raW5nIGZvclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJQYWdlLmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIHdlIG1hZGUgaXQgdGhyb3VnaCB0aGF0IGVudGlyZSB3aGlsZSBsb29wLCB3ZSBkaWRuJ3QgY2xpY2sgb24gYSBwYWdlXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBVUkwgZm9yIHRoZSBpbWFnZSBvZiB0aGUgcGFnZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFRoZVxuICAgICAgICAgKiBvcHRpb25hbCBzaXplIHBhcmFtZXRlciBzdXBwb3J0cyBzZXR0aW5nIHRoZSBpbWFnZSB3aWR0aCBvciBoZWlnaHRcbiAgICAgICAgICogKGRlZmF1bHQgaXMgZnVsbC1zaXplZCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFBhZ2VJbWFnZVVSTCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNpemUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5nZXRQYWdlSW1hZ2VVUkwocGFnZUluZGV4LCBzaXplKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1ByZXR0eSBzZWxmLWV4cGxhbmF0b3J5LlxuICAgICAgICB0aGlzLmlzVmVydGljYWxseU9yaWVudGVkID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuY2hhbmdlT2JqZWN0ID0gZnVuY3Rpb24ob2JqZWN0RGF0YSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5jbGVhcigpO1xuXG4gICAgICAgICAgICBpZiAodmlld2VyU3RhdGUucmVuZGVyZXIpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLm9iamVjdERhdGEgPSBvYmplY3REYXRhO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdERhdGEgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRPYmplY3REYXRhKG9iamVjdERhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS50aHJvYmJlclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3Rocm9iYmVyJykuc2hvdygpO1xuICAgICAgICAgICAgfSwgc2V0dGluZ3MudGhyb2JiZXJUaW1lb3V0KTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB1cmw6IHNldHRpbmdzLm9iamVjdERhdGEsXG4gICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogYWpheEVycm9yLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZURhdGEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2FkT2JqZWN0RGF0YShyZXNwb25zZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pc0FjdGl2ZURpdmEgPSB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERlc3Ryb3lzIHRoaXMgaW5zdGFuY2UsIHRlbGxzIHBsdWdpbnMgdG8gZG8gdGhlIHNhbWUgKGZvciB0ZXN0aW5nKVxuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5kZXN0cm95KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gXCJTZWNyZXRseVwiIGV4cG9zZSB0aGUgcGFnZSBvdmVybGF5IEFQSSBmb3IgdGhlIGhpZ2hsaWdodCBwbHVnaW5cbiAgICAgICAgdGhpcy5fX2FkZFBhZ2VPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmFkZFBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX19yZW1vdmVQYWdlT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5yZW1vdmVQYWdlT3ZlcmxheShvdmVybGF5KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKioqKiBQYWdlIEFsaWFzIEZ1bmN0aW9ucyAqKioqL1xuICAgICAgICAvKlxuICAgICAgICAgTWFpbiBmdW5jdGlvbi4gV2lsbCByZXR1cm4gdGhlIGZpcnN0IG9mIHRoZXNlIHRocmVlIHRoYXRcbiAgICAgICAgIHJlc29sdmVzIHRvIGJvb2xlYW4gdHJ1ZTpcbiAgICAgICAgIC1FeHBsaWNpdCBhbGlhcyBhcyBkZWZpbmVkIGluIHBhZ2VBbGlhc2VzXG4gICAgICAgICAtUmVzdWx0IG9mIHBhZ2VBbGlhc0Z1bmN0aW9uXG4gICAgICAgICAtb3JpZ2luYWxQYWdlSW5kZXggKyAxICh0byBzaW11bGF0ZSB0aGUgb3JpZ2luYWwgbWFwcGluZylcblxuICAgICAgICAgRWxzZSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEFsaWFzRm9yUGFnZUluZGV4ID0gZnVuY3Rpb24ob3JpZ2luYWxQYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBwYXJzZUludChvcmlnaW5hbFBhZ2VJbmRleCwgMTApO1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnBhZ2VBbGlhc2VzW3BhZ2VJbmRleF0gfHwgc2V0dGluZ3MucGFnZUFsaWFzRnVuY3Rpb24ocGFnZUluZGV4KSB8fCBwYWdlSW5kZXggKyAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICBSZXR1cm5zIHRoZSBmaXJzdCBwYWdlIGluZGV4IGZvdW5kIGZvciBhIGdpdmVuIGFsaWFzZWQgbnVtYmVyIG9yIGZhbHNlIGlmIG5vdCBmb3VuZC5cbiAgICAgICAgIFRoaXMgbWF5IGNhdXNlIGlzc3VlcyBpZiBhIHNwZWNpZmljIGFsaWFzIGlzIGZvdW5kIGZvciBtdWx0aXBsZSBwYWdlIGluZGljZXM7IHVzZSBnZXRQYWdlSW5kaWNlc0ZvckFsaWFzIGFuZCByZWltcGxlbWVudCBmdW5jdGlvbnMgYXMgbmVjZXNzYXJ5IGlmIHRoaXMgaXMgdGhlIGNhc2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFBhZ2VJbmRleEZvckFsaWFzID0gZnVuY3Rpb24oYWxpYXNlZE51bWJlcilcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCBzZXR0aW5ncy5udW1QYWdlczsgaWR4KyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5nZXRBbGlhc0ZvclBhZ2VJbmRleChpZHgpID09PSBhbGlhc2VkTnVtYmVyKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9SZXR1cm5zIGFycmF5IG9mIHBhZ2UgaW5kaWNlcyBmb3IgYSBnaXZlbiBhbGlhc2VkIG51bWJlci4gUmV0dXJucyBhbiBlbXB0eSBhcnJheSBpZiBub25lIGFyZSBmb3VuZC5cbiAgICAgICAgdGhpcy5nZXRQYWdlSW5kaWNlc0ZvckFsaWFzID0gZnVuY3Rpb24oYWxpYXNlZE51bWJlcilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGluZGV4QXJyID0gW107XG4gICAgICAgICAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IHNldHRpbmdzLm51bVBhZ2VzOyBpZHgrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdldEFsaWFzRm9yUGFnZUluZGV4KGlkeCkgPT09IGFsaWFzZWROdW1iZXIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbmRleEFyci5wdXNoKGlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluZGV4QXJyO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLy9NYXBzIHRoZSBjdXJyZW50IHBhZ2UgaW5kZXggdG8gZ2V0QWxpYXNGb3JQYWdlSW5kZXhcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50QWxpYXNlZFBhZ2VJbmRleCA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxpYXNGb3JQYWdlSW5kZXgoc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9XcmFwcGVyIGZvciBnb3RvUGFnZUJ5SW5kZXgsIGtlZXBpbmcgdGhlIGFsaWFzZWQgbnVtYmVycyBpbiBtaW5kXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeUFsaWFzZWROdW1iZXIgPSBmdW5jdGlvbihhbGlhc2VkTnVtYmVyLCB4QW5jaG9yLCB5QW5jaG9yKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgodGhpcy5nZXRQYWdlSW5kZXhGb3JBbGlhcyhhbGlhc2VkTnVtYmVyKSwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgaW5pdCBmdW5jdGlvbiB3aGVuIHRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgICAgIGluaXQoKTtcbiAgICB9O1xuXG4gICAgJC5mbi5kaXZhID0gZnVuY3Rpb24gKG9wdGlvbnMpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkaXZhUGFyZW50ID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHBsdWdpbiBpbnN0YW5jZVxuICAgICAgICAgICAgaWYgKGRpdmFQYXJlbnQuZGF0YSgnZGl2YScpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIGVsZW1lbnQgaXMgbm90IGluIHRoZSBET00sIHNpbmNlIGl0IGNhdXNlcyBzb21lIHByb2JsZW1zXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXZhIGNvdWxkIG5vdCBiZSBpbml0aWFsaXplZCBiZWNhdXNlIHRoaXMgZWxlbWVudCBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIERPTScpO1xuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIGluc3RhbnRpYXRlIHRoZSBkb2N1bWVudCB2aWV3ZXJcbiAgICAgICAgICAgIHZhciBkaXZhID0gbmV3IERpdmEodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBkaXZhUGFyZW50LmRhdGEoJ2RpdmEnLCBkaXZhKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9kaXZhLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZWx0O1xubW9kdWxlLmV4cG9ydHMuc2V0QXR0cmlidXRlcyA9IHNldERPTUF0dHJpYnV0ZXM7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgRE9NIGVsZW1lbnQsIHNldCBhdHRyaWJ1dGVzIG9uIGl0LCBhbmRcbiAqIGFwcGVuZCBjaGlsZHJlbi4gQWxsIGFyZ3VtZW50cyB3aGljaCBhcmUgbm90IG9mIHByaW1pdGl2ZSB0eXBlLCBhcmUgbm90XG4gKiBhcnJheXMsIGFuZCBhcmUgbm90IERPTSBub2RlcyBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGUgaGFzaGVzIGFuZCBhcmVcbiAqIGhhbmRsZWQgYXMgZGVzY3JpYmVkIGZvciBzZXRET01BdHRyaWJ1dGVzLiBDaGlsZHJlbiBjYW4gZWl0aGVyIGJlIGEgRE9NXG4gKiBub2RlIG9yIGEgcHJpbWl0aXZlIHZhbHVlLCB3aGljaCBpcyBjb252ZXJ0ZWQgdG8gYSB0ZXh0IG5vZGUuIEFycmF5cyBhcmVcbiAqIGhhbmRsZWQgcmVjdXJzaXZlbHkuIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogSW5zcGlyZWQgYnkgdGhlIFByb3NlTWlycm9yIGhlbHBlciBvZiB0aGUgc2FtZSBuYW1lLlxuICovXG5mdW5jdGlvbiBlbHQodGFnKVxue1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB3aGlsZSAoYXJncy5sZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBoYW5kbGVFbHRDb25zdHJ1Y3RvckFyZyhlbCwgYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsdENvbnN0cnVjdG9yQXJnKGVsLCBhcmcpXG57XG4gICAgaWYgKGFyZyA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJylcbiAgICB7XG4gICAgICAgIC8vIENvZXJjZSB0byBzdHJpbmdcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXJnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlKVxuICAgIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpXG4gICAge1xuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGFyZy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaGFuZGxlRWx0Q29uc3RydWN0b3JBcmcoZWwsIGFyZ1tpXSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHNldERPTUF0dHJpYnV0ZXMoZWwsIGFyZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGEgRE9NIGVsZW1lbnQuIFRoZSBgc3R5bGVgIHByb3BlcnR5IGlzIHNwZWNpYWwtY2FzZWQgdG9cbiAqIGFjY2VwdCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdob3NlIG93biBhdHRyaWJ1dGVzIGFyZSBhc3NpZ25lZCB0b1xuICogZWwuc3R5bGUuXG4gKi9cbmZ1bmN0aW9uIHNldERPTUF0dHJpYnV0ZXMoZWwsIGF0dHJpYnV0ZXMpXG57XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyaWJ1dGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKHByb3AgPT09ICdzdHlsZScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFN0eWxlKGVsLCBhdHRyaWJ1dGVzLnN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoZWwsIHN0eWxlKVxue1xuICAgIGlmICghc3R5bGUpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKVxuICAgIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY3NzUHJvcCBpbiBzdHlsZSlcbiAgICB7XG4gICAgICAgIGlmICghc3R5bGUuaGFzT3duUHJvcGVydHkoY3NzUHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBlbC5zdHlsZVtjc3NQcm9wXSA9IHN0eWxlW2Nzc1Byb3BdO1xuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3V0aWxzL2VsdC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cy5nZXQgPSBnZXRIYXNoUGFyYW07XG5tb2R1bGUuZXhwb3J0cy51cGRhdGUgPSB1cGRhdGVIYXNoUGFyYW07XG5cbi8vIEZvciBnZXR0aW5nIHRoZSAja2V5IHZhbHVlcyBmcm9tIHRoZSBVUkwuIEZvciBzcGVjaWZ5aW5nIGEgcGFnZSBhbmQgem9vbSBsZXZlbFxuLy8gTG9vayBpbnRvIGNhY2hpbmcsIGJlY2F1c2Ugd2Ugb25seSBuZWVkIHRvIGdldCB0aGlzIGR1cmluZyB0aGUgaW5pdGlhbCBsb2FkXG4vLyBBbHRob3VnaCBmb3IgdGhlIHRlc3RzIEkgZ3Vlc3Mgd2Ugd291bGQgbmVlZCB0byBvdmVycmlkZSBjYWNoaW5nIHNvbWVob3dcbmZ1bmN0aW9uIGdldEhhc2hQYXJhbShrZXkpIHtcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIGlmIChoYXNoICE9PSAnJykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdGhhdCBsb29rcyBsaWtlIGVpdGhlciAma2V5PSBvciAja2V5PVxuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IChoYXNoLmluZGV4T2YoJyYnICsga2V5ICsgJz0nKSA+IDApID8gaGFzaC5pbmRleE9mKCcmJyArIGtleSArICc9JykgOiBoYXNoLmluZGV4T2YoJyMnICsga2V5ICsgJz0nKTtcblxuICAgICAgICAvLyBJZiBzdGFydEluZGV4IGlzIHN0aWxsIC0xLCBpdCBtZWFucyBpdCBjYW4ndCBmaW5kIGVpdGhlclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxlbmd0aCBvZiB0aGUga2V5IHBsdXMgdGhlICYgYW5kID1cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggKz0ga2V5Lmxlbmd0aCArIDI7XG5cbiAgICAgICAgICAgIC8vIEVpdGhlciB0byB0aGUgbmV4dCBhbXBlcnNhbmQgb3IgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBoYXNoLmluZGV4T2YoJyYnLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2guc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhpcyBoYXNoIHBhcmFtIGlzIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaGFzaC5zdWJzdHJpbmcoc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGtleSBkb2Vzbid0IGhhdmUgYSB2YWx1ZSBJIHRoaW5rXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBjYW4ndCBmaW5kIHRoZSBrZXlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBoYXNoIHBhcmFtcyBqdXN0IHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIYXNoUGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgIC8vIEZpcnN0IG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55IHdvcmsgYXQgYWxsXG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRIYXNoUGFyYW0oa2V5KTtcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAvLyBJcyB0aGUga2V5IGFscmVhZHkgaW4gdGhlIFVSTD9cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGluIHRoZSBVUkwuIEp1c3QgZ2V0IHJpZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gKGhhc2guaW5kZXhPZignJicgKyBrZXkgKyAnPScpID4gMCkgPyBoYXNoLmluZGV4T2YoJyYnICsga2V5ICsgJz0nKSA6IGhhc2guaW5kZXhPZignIycgKyBrZXkgKyAnPScpO1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGtleS5sZW5ndGggKyAyICsgb3JpZ2luYWxWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAvLyAjIGlmIGl0J3MgdGhlIGZpcnN0LCAmIG90aGVyd2lzZVxuICAgICAgICAgICAgdmFyIHN0YXJ0VGhpbmcgPSAoc3RhcnRJbmRleCA9PT0gMCkgPyAnIycgOiAnJic7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShoYXNoLnN1YnN0cmluZygwLCBzdGFydEluZGV4KSArIHN0YXJ0VGhpbmcgKyBrZXkgKyAnPScgKyB2YWx1ZSArIGhhc2guc3Vic3RyaW5nKGVuZEluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdCdzIG5vdCBwcmVzZW50IC0gYWRkIGl0XG4gICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnIycgKyBrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBpdFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhhc2ggKyAnJicgKyBrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy91dGlscy9oYXNoLXBhcmFtcy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8vVXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgRGl2YSB3YXMgbGFzdCBjbGlja2VkIG9yIHdoaWNoIERpdmEgd2FzIGxhc3QgY2xpY2tlZCB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZVxudmFyIEFjdGl2ZURpdmFDb250cm9sbGVyID0gKGZ1bmN0aW9uICgkKVxue1xuICAgIHJldHVybiBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGFjdGl2ZTtcblxuICAgICAgICAvL2dsb2JhbCBjbGljayBsaXN0ZW5lclxuICAgICAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVBY3RpdmUoJChlLnRhcmdldCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL3BhcmFtZXRlciBzaG91bGQgYWxyZWFkeSBiZSBhIGpRdWVyeSBzZWxlY3RvclxuICAgICAgICB2YXIgdXBkYXRlQWN0aXZlID0gZnVuY3Rpb24gKHRhcmdldClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5lYXJlc3RPdXRlcjtcblxuICAgICAgICAgICAgLy90aGVzZSB3aWxsIGZpbmQgMCBvciAxIG9iamVjdHMsIG5ldmVyIG1vcmVcbiAgICAgICAgICAgIHZhciBmaW5kT3V0ZXIgPSB0YXJnZXQuZmluZCgnLmRpdmEtb3V0ZXInKTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0T3V0ZXIgPSB0YXJnZXQuY2xvc2VzdCgnLmRpdmEtb3V0ZXInKTtcbiAgICAgICAgICAgIHZhciBvdXRlcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkaXZhLW91dGVyJyk7XG4gICAgICAgICAgICB2YXIgb3V0ZXJMZW4gPSBvdXRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGlkeDtcblxuICAgICAgICAgICAgLy9jbGlja2VkIG9uIHNvbWV0aGluZyB0aGF0IHdhcyBub3QgZWl0aGVyIGEgcGFyZW50IG9yIHNpYmxpbmcgb2YgYSBkaXZhLW91dGVyXG4gICAgICAgICAgICBpZiAoZmluZE91dGVyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmVhcmVzdE91dGVyID0gZmluZE91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jbGlja2VkIG9uIHNvbWV0aGluZyB0aGF0IHdhcyBhIGNoaWxkIG9mIGEgZGl2YS1vdXRlclxuICAgICAgICAgICAgZWxzZSBpZiAoY2xvc2VzdE91dGVyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmVhcmVzdE91dGVyID0gY2xvc2VzdE91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jbGlja2VkIG9uIHNvbWV0aGluZyB0aGF0IHdhcyBub3QgaW4gYW55IERpdmEgdHJlZVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vZGVhY3RpdmF0ZSBldmVyeXRoaW5nIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IG91dGVyTGVuOyBpZHgrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQob3V0ZXJzW2lkeF0ucGFyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50KS5kYXRhKCdkaXZhJykuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgd2UgZm91bmQgb25lLCBhY3RpdmF0ZSBpdC4uLlxuICAgICAgICAgICAgbmVhcmVzdE91dGVyLnBhcmVudCgpLnBhcmVudCgpLmRhdGEoJ2RpdmEnKS5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgYWN0aXZlID0gbmVhcmVzdE91dGVyLnBhcmVudCgpO1xuXG4gICAgICAgICAgICAvLy4uLmFuZCBkZWFjdGl2YXRlIGFsbCB0aGUgb3RoZXJzXG4gICAgICAgICAgICBvdXRlcnMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkaXZhLW91dGVyJyk7XG4gICAgICAgICAgICBmb3IoaWR4ID0gMDsgaWR4IDwgb3V0ZXJMZW47IGlkeCsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vZ2V0QXR0cmlidXRlIHRvIGF0dHIgLSBjb21wYXJpbmcgRE9NIGVsZW1lbnQgdG8galF1ZXJ5IGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAob3V0ZXJzW2lkeF0uZ2V0QXR0cmlidXRlKCdpZCcpICE9IG5lYXJlc3RPdXRlci5hdHRyKCdpZCcpKVxuICAgICAgICAgICAgICAgICAgICAkKG91dGVyc1tpZHhdLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkuZGF0YSgnZGl2YScpLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvL3B1YmxpYyBhY2Nlc3NvciBpbiBjYXNlLiBXaWxsIHJldHVybiBhIGpRdWVyeSBzZWxlY3Rvci5cbiAgICAgICAgdGhpcy5nZXRBY3RpdmUgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgICAgIH07XG4gICAgfTtcbn0pKGpRdWVyeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQWN0aXZlRGl2YUNvbnRyb2xsZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9hY3RpdmUtZGl2YS1jb250cm9sbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgdW51c2VkOiB0cnVlICovXG5cbnZhciBwYXJzZUlJSUZNYW5pZmVzdCA9IHJlcXVpcmUoJy4vcGFyc2UtaWlpZi1tYW5pZmVzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlTWFuaWZlc3Q7XG5cbmZ1bmN0aW9uIEltYWdlTWFuaWZlc3QoZGF0YSwgdXJsQWRhcHRlcilcbntcbiAgICAvLyBTYXZlIGFsbCB0aGUgZGF0YSB3ZSBuZWVkXG4gICAgdGhpcy5wYWdlcyA9IGRhdGEucGdzO1xuICAgIHRoaXMubWF4Wm9vbSA9IGRhdGEubWF4X3pvb207XG4gICAgdGhpcy5tYXhSYXRpbyA9IGRhdGEuZGltcy5tYXhfcmF0aW87XG4gICAgdGhpcy5taW5SYXRpbyA9IGRhdGEuZGltcy5taW5fcmF0aW87XG4gICAgdGhpcy5pdGVtVGl0bGUgPSBkYXRhLml0ZW1fdGl0bGU7XG5cbiAgICAvLyBPbmx5IGdpdmVuIGZvciBJSUlGIG1hbmlmZXN0c1xuICAgIHRoaXMucGFnZWQgPSAhIWRhdGEucGFnZWQ7XG5cbiAgICAvLyBUaGVzZSBhcmUgYXJyYXlzLCB0aGUgaW5kZXggY29ycmVzcG9uZGluZyB0byB0aGUgem9vbSBsZXZlbFxuICAgIHRoaXMuX21heFdpZHRocyA9IGRhdGEuZGltcy5tYXhfdztcbiAgICB0aGlzLl9tYXhIZWlnaHRzID0gZGF0YS5kaW1zLm1heF9oO1xuICAgIHRoaXMuX2F2ZXJhZ2VXaWR0aHMgPSBkYXRhLmRpbXMuYV93aWQ7XG4gICAgdGhpcy5fYXZlcmFnZUhlaWdodHMgPSBkYXRhLmRpbXMuYV9oZWk7XG4gICAgdGhpcy5fdG90YWxIZWlnaHRzID0gZGF0YS5kaW1zLnRfaGVpO1xuICAgIHRoaXMuX3RvdGFsV2lkdGhzID0gZGF0YS5kaW1zLnRfd2lkO1xuXG4gICAgdGhpcy5fdXJsQWRhcHRlciA9IHVybEFkYXB0ZXI7XG59XG5cbkltYWdlTWFuaWZlc3QuZnJvbUlJSUYgPSBmdW5jdGlvbiAoaWlpZk1hbmlmZXN0KVxue1xuICAgIHZhciBkYXRhID0gcGFyc2VJSUlGTWFuaWZlc3QoaWlpZk1hbmlmZXN0KTtcbiAgICByZXR1cm4gbmV3IEltYWdlTWFuaWZlc3QoZGF0YSwgbmV3IElJSUZTb3VyY2VBZGFwdGVyKCkpO1xufTtcblxuSW1hZ2VNYW5pZmVzdC5mcm9tTGVnYWN5TWFuaWZlc3QgPSBmdW5jdGlvbiAoZGF0YSwgY29uZmlnKVxue1xuICAgIC8vIEZvciBJSVAgbWFuaWZlc3RzLCB1c2UgdGhlIHBhZ2UgbnVtYmVyIChpbmRleGVkIHN0YXJ0aW5nIGZyb20gMSkgYXMgYSBsYWJlbCBmb3IgZWFjaCBwYWdlXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEucGdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBkYXRhLnBnc1tpXS5sID0gKGkgKyAxKS50b1N0cmluZygpO1xuXG4gICAgcmV0dXJuIG5ldyBJbWFnZU1hbmlmZXN0KGRhdGEsIG5ldyBMZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIoY29uZmlnKSk7XG59O1xuXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5pc1BhZ2VWYWxpZCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNob3dOb25QYWdlZFBhZ2VzKVxue1xuICAgIGlmICghc2hvd05vblBhZ2VkUGFnZXMgJiYgdGhpcy5wYWdlZCAmJiAhdGhpcy5wYWdlc1twYWdlSW5kZXhdLnBhZ2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcGFnZUluZGV4ID49IDAgJiYgcGFnZUluZGV4IDwgdGhpcy5wYWdlcy5sZW5ndGg7XG59O1xuXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRNYXhQYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgdmFyIG1heERpbXMgPSB0aGlzLnBhZ2VzW3BhZ2VJbmRleF0uZFt0aGlzLm1heFpvb21dO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBtYXhEaW1zLmgsXG4gICAgICAgIHdpZHRoOiBtYXhEaW1zLndcbiAgICB9O1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0UGFnZURpbWVuc2lvbnNBdFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHpvb21MZXZlbClcbntcbiAgICB2YXIgbWF4RGltcyA9IHRoaXMucGFnZXNbcGFnZUluZGV4XS5kW3RoaXMubWF4Wm9vbV07XG5cbiAgICB2YXIgc2NhbGVSYXRpbyA9IGdldFNjYWxlUmF0aW8odGhpcy5tYXhab29tLCB6b29tTGV2ZWwpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBtYXhEaW1zLmggKiBzY2FsZVJhdGlvLFxuICAgICAgICB3aWR0aDogbWF4RGltcy53ICogc2NhbGVSYXRpb1xuICAgIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBVUkwgZm9yIHRoZSBpbWFnZSBvZiB0aGUgZ2l2ZW4gcGFnZS4gVGhlIG9wdGlvbmFsIHNpemVcbiAqIHBhcmFtZXRlciBzdXBwb3J0cyBzZXR0aW5nIHRoZSBpbWFnZSB3aWR0aCBvciBoZWlnaHQgKGRlZmF1bHQgaXNcbiAqIGZ1bGwtc2l6ZWQpLlxuICovXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VVUkwgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzaXplKVxue1xuICAgIHJldHVybiB0aGlzLl91cmxBZGFwdGVyLmdldFBhZ2VJbWFnZVVSTCh0aGlzLCBwYWdlSW5kZXgsIHNpemUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGlsZSBvYmplY3RzIGZvciB0aGUgc3BlY2lmaWVkIHBhZ2UgYW5kIGludGVnZXIgem9vbSBsZXZlbFxuICovXG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VUaWxlcyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHpvb21MZXZlbCwgdGlsZURpbWVuc2lvbnMpXG57XG4gICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VJbmRleF07XG5cbiAgICBpZiAoIWlzRmluaXRlKHpvb21MZXZlbCkgfHwgem9vbUxldmVsICUgMSAhPT0gMClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWm9vbSBsZXZlbCBtdXN0IGJlIGFuIGludGVnZXI6ICcgKyB6b29tTGV2ZWwpO1xuXG4gICAgdmFyIHJvd3MgPSBNYXRoLmNlaWwocGFnZS5kW3pvb21MZXZlbF0uaCAvIHRpbGVEaW1lbnNpb25zLmhlaWdodCk7XG4gICAgdmFyIGNvbHMgPSBNYXRoLmNlaWwocGFnZS5kW3pvb21MZXZlbF0udyAvIHRpbGVEaW1lbnNpb25zLndpZHRoKTtcblxuICAgIHZhciB0aWxlcyA9IFtdO1xuXG4gICAgdmFyIHJvdywgY29sLCB1cmw7XG5cbiAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHJvd3M7IHJvdysrKVxuICAgIHtcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCBjb2xzOyBjb2wrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsID0gdGhpcy5fdXJsQWRhcHRlci5nZXRUaWxlSW1hZ2VVUkwodGhpcywgcGFnZUluZGV4LCB7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgcm93Q291bnQ6IHJvd3MsXG4gICAgICAgICAgICAgICAgY29sQ291bnQ6IGNvbHMsXG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgdGlsZURpbWVuc2lvbnM6IHRpbGVEaW1lbnNpb25zXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gRklYTUU6IERpbWVuc2lvbnMgc2hvdWxkIGFjY291bnQgZm9yIHBhcnRpYWwgdGlsZXMgKGUuZy4gdGhlXG4gICAgICAgICAgICAvLyBsYXN0IHJvdyBhbmQgY29sdW1uIGluIGEgdGlsZWQgaW1hZ2UpXG4gICAgICAgICAgICB0aWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWw6IHpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGlsZURpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGlsZURpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvdyAqIHRpbGVEaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sICogdGlsZURpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHpvb21MZXZlbDogem9vbUxldmVsLFxuICAgICAgICByb3dzOiByb3dzLFxuICAgICAgICBjb2xzOiBjb2xzLFxuICAgICAgICB0aWxlczogdGlsZXNcbiAgICB9O1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0TWF4V2lkdGggPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX21heFdpZHRocycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0TWF4SGVpZ2h0ID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ19tYXhIZWlnaHRzJyk7XG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRBdmVyYWdlV2lkdGggPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX2F2ZXJhZ2VXaWR0aHMnKTtcbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldEF2ZXJhZ2VIZWlnaHQgPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX2F2ZXJhZ2VIZWlnaHRzJyk7XG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRUb3RhbFdpZHRoID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ190b3RhbFdpZHRocycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0VG90YWxIZWlnaHQgPSB6b29tZWRQcm9wZXJ0eUdldHRlcignX3RvdGFsSGVpZ2h0cycpO1xuXG5mdW5jdGlvbiB6b29tZWRQcm9wZXJ0eUdldHRlcihwcml2YXRlTmFtZSlcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKHpvb21MZXZlbClcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVOYW1lXVt6b29tTGV2ZWxdO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlUmF0aW8oc291cmNlWm9vbUxldmVsLCB0YXJnZXRab29tTGV2ZWwpXG57XG4gICAgcmV0dXJuIDEgLyBNYXRoLnBvdygyLCBzb3VyY2Vab29tTGV2ZWwgLSB0YXJnZXRab29tTGV2ZWwpO1xufVxuXG5mdW5jdGlvbiBJSUlGU291cmNlQWRhcHRlcigpXG57XG4gICAgLy8gTm8tb3Bcbn1cblxuSUlJRlNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFBhZ2VJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBzaXplKVxue1xuICAgIHZhciBkaW1lbnM7XG5cbiAgICBpZiAoIXNpemUgfHwgKHNpemUud2lkdGggPT0gbnVsbCAmJiBzaXplLmhlaWdodCA9PSBudWxsKSlcbiAgICAgICAgZGltZW5zID0gJ2Z1bGwnO1xuICAgIGVsc2VcbiAgICAgICAgZGltZW5zID0gKHNpemUud2lkdGggPT0gbnVsbCA/ICcnIDogc2l6ZS53aWR0aCkgKyAnLCcgKyAoc2l6ZS5oZWlnaHQgPT0gbnVsbCA/ICcnIDogc2l6ZS5oZWlnaHQpO1xuXG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuICAgIHZhciBxdWFsaXR5ID0gKHBhZ2UuYXBpID4gMS4xKSA/ICdkZWZhdWx0JyA6ICduYXRpdmUnO1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSShwYWdlLnVybCArICdmdWxsLycgKyBkaW1lbnMgKyAnLzAvJyArIHF1YWxpdHkgKyAnLmpwZycpO1xufTtcblxuSUlJRlNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFRpbGVJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBwYXJhbXMpXG57XG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgdmFyIGhlaWdodCwgd2lkdGg7XG5cbiAgICBpZiAocGFyYW1zLnJvdyA9PT0gcGFyYW1zLnJvd0NvdW50IC0gMSlcbiAgICAgICAgaGVpZ2h0ID0gcGFnZS5kW3BhcmFtcy56b29tTGV2ZWxdLmggLSAocGFyYW1zLnJvd0NvdW50IC0gMSkgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMuaGVpZ2h0O1xuICAgIGVsc2VcbiAgICAgICAgaGVpZ2h0ID0gcGFyYW1zLnRpbGVEaW1lbnNpb25zLmhlaWdodDtcblxuICAgIGlmIChwYXJhbXMuY29sID09PSBwYXJhbXMuY29sQ291bnQgLSAxKVxuICAgICAgICB3aWR0aCA9IHBhZ2UuZFtwYXJhbXMuem9vbUxldmVsXS53IC0gKHBhcmFtcy5jb2xDb3VudCAtIDEpICogcGFyYW1zLnRpbGVEaW1lbnNpb25zLndpZHRoO1xuICAgIGVsc2VcbiAgICAgICAgd2lkdGggPSBwYXJhbXMudGlsZURpbWVuc2lvbnMud2lkdGg7XG5cbiAgICB2YXIgem9vbURpZmZlcmVuY2UgPSBNYXRoLnBvdygyLCBtYW5pZmVzdC5tYXhab29tIC0gcGFyYW1zLnpvb21MZXZlbCk7XG5cbiAgICB2YXIgeCA9IHBhcmFtcy5jb2wgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMud2lkdGggKiB6b29tRGlmZmVyZW5jZTtcbiAgICB2YXIgeSA9IHBhcmFtcy5yb3cgKiBwYXJhbXMudGlsZURpbWVuc2lvbnMuaGVpZ2h0ICogem9vbURpZmZlcmVuY2U7XG5cbiAgICBpZiAocGFnZS5oYXNPd25Qcm9wZXJ0eSgneG9mZnNldCcpKVxuICAgIHtcbiAgICAgICAgeCArPSBwYWdlLnhvZmZzZXQ7XG4gICAgICAgIHkgKz0gcGFnZS55b2Zmc2V0O1xuICAgIH1cblxuICAgIHZhciByZWdpb24gPSBbeCwgeSwgd2lkdGggKiB6b29tRGlmZmVyZW5jZSwgaGVpZ2h0ICogem9vbURpZmZlcmVuY2VdLmpvaW4oJywnKTtcblxuICAgIHZhciBxdWFsaXR5ID0gKHBhZ2UuYXBpID4gMS4xKSA/ICdkZWZhdWx0JyA6ICduYXRpdmUnO1xuXG4gICAgcmV0dXJuIGVuY29kZVVSSShwYWdlLnVybCArIHJlZ2lvbiArICcvJyArIHdpZHRoICsgJywnICsgaGVpZ2h0ICsgJy8wLycgKyBxdWFsaXR5ICsgJy5qcGcnKTtcbn07XG5cbmZ1bmN0aW9uIExlZ2FjeU1hbmlmZXN0U291cmNlQWRhcHRlcihjb25maWcpXG57XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xufVxuXG5MZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFBhZ2VJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBzaXplKVxue1xuICAgIC8vIFdpdGhvdXQgd2lkdGggb3IgaGVpZ2h0IHNwZWNpZmllZCwgSUlQSW1hZ2UgZGVmYXVsdHMgdG8gZnVsbC1zaXplXG4gICAgdmFyIGRpbWVucyA9ICcnO1xuXG4gICAgaWYgKHNpemUpXG4gICAge1xuICAgICAgICBpZiAoc2l6ZS53aWR0aCAhPSBudWxsKVxuICAgICAgICAgICAgZGltZW5zICs9ICcmV0lEPScgKyBzaXplLndpZHRoO1xuXG4gICAgICAgIGlmIChzaXplLmhlaWdodCAhPSBudWxsKVxuICAgICAgICAgICAgZGltZW5zICs9ICcmSEVJPScgKyBzaXplLmhlaWdodDtcbiAgICB9XG5cbiAgICB2YXIgZmlsZW5hbWUgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdLmY7XG5cbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmlpcFNlcnZlclVSTCArIFwiP0ZJRj1cIiArIHRoaXMuX2NvbmZpZy5pbWFnZURpciArICcvJyArIGZpbGVuYW1lICsgZGltZW5zICsgJyZDVlQ9SlBFRyc7XG59O1xuXG5MZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIucHJvdG90eXBlLmdldFRpbGVJbWFnZVVSTCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgcGFnZUluZGV4LCBwYXJhbXMpXG57XG4gICAgdmFyIHBhZ2UgPSBtYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdO1xuICAgIHZhciByZXF1ZXN0ZWRab29tTGV2ZWwgPSBwYXJhbXMuem9vbUxldmVsICsgcGFnZS5tIC0gbWFuaWZlc3QubWF4Wm9vbTtcbiAgICB2YXIgaW5kZXggPSAocGFyYW1zLnJvdyAqIHBhcmFtcy5jb2xDb3VudCkgKyBwYXJhbXMuY29sO1xuICAgIHZhciBqdGwgPSByZXF1ZXN0ZWRab29tTGV2ZWwgKyAnLCcgKyBpbmRleDtcblxuICAgIHJldHVybiBlbmNvZGVVUkkodGhpcy5fY29uZmlnLmlpcFNlcnZlclVSTCArIFwiP0ZJRj1cIiArIHRoaXMuX2NvbmZpZy5pbWFnZURpciArICcvJyArIHBhZ2UuZiArICcmSlRMPScgKyBqdGwgKyAnJkNWVD1KUEVHJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvaW1hZ2UtbWFuaWZlc3QuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGpzaGludCB1bnVzZWQ6IHRydWUgKi9cblwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VJSUlGTWFuaWZlc3Q7XG5cbnZhciBnZXRNYXhab29tTGV2ZWwgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICB2YXIgbGFyZ2VzdERpbWVuc2lvbiA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2coKGxhcmdlc3REaW1lbnNpb24gKyAxKSAvICgyNTYgKyAxKSkgLyBNYXRoLmxvZygyKSk7XG59O1xuXG52YXIgaW5jb3Jwb3JhdGVab29tID0gZnVuY3Rpb24gKGltYWdlRGltZW5zaW9uLCB6b29tRGlmZmVyZW5jZSlcbntcbiAgICByZXR1cm4gaW1hZ2VEaW1lbnNpb24gLyAoTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpKTtcbn07XG5cbnZhciBnZXRPdGhlckltYWdlRGF0YSA9IGZ1bmN0aW9uKG90aGVySW1hZ2VzLCBsb3dlc3RNYXhab29tLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KVxue1xuICAgIHJldHVybiBvdGhlckltYWdlcy5tYXAoXG4gICAgICAgIGZ1bmN0aW9uIChpdG0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3ID0gaXRtLndpZHRoIHx8IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSBpdG0uaGVpZ2h0IHx8IGNhbnZhc0hlaWdodDtcblxuICAgICAgICAgICAgdmFyIGRpbXMgPSBuZXcgQXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsb3dlc3RNYXhab29tICsgMTsgaisrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpbXNbal0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGg6IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKGgsIGxvd2VzdE1heFpvb20gLSBqKSksXG4gICAgICAgICAgICAgICAgICAgIHc6IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKHcsIGxvd2VzdE1heFpvb20gLSBqKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaXRtLmxhYmVsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgZGltczogZGltc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIElJSUYgUHJlc2VudGF0aW9uIEFQSSBNYW5pZmVzdCBhbmQgY29udmVydHMgaXQgaW50byBhIERpdmEuanMtZm9ybWF0IG9iamVjdFxuICogKFNlZSBodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL0RldmVsb3BtZW50LW5vdGVzI2RhdGEtcmVjZWl2ZWQtdGhyb3VnaC1hamF4LXJlcXVlc3QpXG4gKiAoVGhpcyBpcyBhIGNsaWVudC1zaWRlIHJlLWltcGxlbWVudGF0aW9uIG9mIGdlbmVyYXRlX2pzb24ucHkpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hbmlmZXN0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHZhbGlkIElJSUYgbWFuaWZlc3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRpdmFTZXJ2aWNlQmxvY2sgLSB0aGUgZGF0YSBuZWVkZWQgYnkgRGl2YSB0byBzaG93IGEgdmlldyBvZiBhIHNpbmdsZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBwYXJzZUlJSUZNYW5pZmVzdChtYW5pZmVzdClcbntcbiAgICB2YXIgc2VxdWVuY2UgPSBtYW5pZmVzdC5zZXF1ZW5jZXNbMF07XG4gICAgdmFyIGNhbnZhc2VzID0gc2VxdWVuY2UuY2FudmFzZXM7XG4gICAgdmFyIG51bUNhbnZhc2VzID0gY2FudmFzZXMubGVuZ3RoO1xuXG4gICAgdmFyIHBhZ2VzID0gbmV3IEFycmF5KGNhbnZhc2VzLmxlbmd0aCk7XG5cbiAgICB2YXIgdGhpc0NhbnZhcywgdGhpc1Jlc291cmNlLCB0aGlzSW1hZ2UsIG90aGVySW1hZ2VzLCBjb250ZXh0LCB1cmwsIGluZm8sIGltYWdlQVBJVmVyc2lvbixcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgY2FudmFzLCBsYWJlbCwgaW1hZ2VMYWJlbCwgem9vbURpbWVuc2lvbnMsIHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsLFxuICAgICAgICBoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWw7XG5cbiAgICB2YXIgbG93ZXN0TWF4Wm9vbSA9IDEwMDtcbiAgICB2YXIgbWF4UmF0aW8gPSAwO1xuICAgIHZhciBtaW5SYXRpbyA9IDEwMDtcblxuICAgIC8vIHF1aWNrbHkgZGV0ZXJtaW5lIHRoZSBsb3dlc3QgcG9zc2libGUgbWF4IHpvb20gbGV2ZWwgKGkuZS4sIHRoZSB1cHBlciBib3VuZCBmb3IgaW1hZ2VzKSBhY3Jvc3MgYWxsIGNhbnZhc2VzLlxuICAgIC8vIHdoaWxlIHdlJ3JlIGhlcmUsIGNvbXB1dGUgdGhlIGdsb2JhbCByYXRpb3MgYXMgd2VsbC5cbiAgICBmb3IgKHZhciB6ID0gMDsgeiA8IG51bUNhbnZhc2VzOyB6KyspXG4gICAge1xuICAgICAgICB2YXIgYyA9IGNhbnZhc2VzW3pdO1xuICAgICAgICB2YXIgdyA9IGMud2lkdGg7XG4gICAgICAgIHZhciBoID0gYy5oZWlnaHQ7XG4gICAgICAgIHZhciBteiA9IGdldE1heFpvb21MZXZlbCh3LCBoKTtcbiAgICAgICAgdmFyIHJhdGlvID0gdyAvIGg7XG4gICAgICAgIG1heFJhdGlvID0gTWF0aC5tYXgocmF0aW8sIG1heFJhdGlvKTtcbiAgICAgICAgbWluUmF0aW8gPSBNYXRoLm1pbihyYXRpbywgbWluUmF0aW8pO1xuXG4gICAgICAgIGxvd2VzdE1heFpvb20gPSBNYXRoLm1pbihsb3dlc3RNYXhab29tLCBteik7XG4gICAgfVxuXG4gICAgLy8gVWludDhBcnJheXMgYXJlIHByZS1pbml0aWFsaXplZCB3aXRoIHplcm9lcy5cbiAgICB2YXIgdG90YWxXaWR0aHMgPSBuZXcgVWludDhBcnJheShsb3dlc3RNYXhab29tICsgMSk7XG4gICAgdmFyIHRvdGFsSGVpZ2h0cyA9IG5ldyBVaW50OEFycmF5KGxvd2VzdE1heFpvb20gKyAxKTtcbiAgICB2YXIgbWF4V2lkdGhzID0gbmV3IFVpbnQ4QXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpO1xuICAgIHZhciBtYXhIZWlnaHRzID0gbmV3IFVpbnQ4QXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1DYW52YXNlczsgaSsrKVxuICAgIHtcbiAgICAgICAgdGhpc0NhbnZhcyA9IGNhbnZhc2VzW2ldO1xuICAgICAgICBjYW52YXMgPSB0aGlzQ2FudmFzWydAaWQnXTtcbiAgICAgICAgbGFiZWwgPSB0aGlzQ2FudmFzLmxhYmVsO1xuICAgICAgICB0aGlzUmVzb3VyY2UgPSB0aGlzQ2FudmFzLmltYWdlc1swXS5yZXNvdXJjZTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiBhIGNhbnZhcyBoYXMgbXVsdGlwbGUgaW1hZ2VzIGl0IHdpbGwgYmUgZW5jb2RlZFxuICAgICAgICAgKiB3aXRoIGEgcmVzb3VyY2UgdHlwZSBvZiBcIm9hOkNob2ljZVwiLiBUaGUgcHJpbWFyeSBpbWFnZSB3aWxsIGJlIGF2YWlsYWJsZVxuICAgICAgICAgKiBvbiB0aGUgJ2RlZmF1bHQnIGtleSwgd2l0aCBvdGhlciBpbWFnZXMgYXZhaWxhYmxlIHVuZGVyICdpdGVtLidcbiAgICAgICAgICogKi9cbiAgICAgICAgaWYgKHRoaXNSZXNvdXJjZVsnQHR5cGUnXSA9PT0gXCJvYTpDaG9pY2VcIilcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpc0ltYWdlID0gdGhpc1Jlc291cmNlLmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzSW1hZ2UgPSB0aGlzUmVzb3VyY2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQcmlvcml0aXplIHRoZSBjYW52YXMgaGVpZ2h0IC8gd2lkdGggZmlyc3QsIHNpbmNlIGltYWdlcyBtYXkgbm90IGhhdmUgaC93XG4gICAgICAgIHdpZHRoID0gdGhpc0NhbnZhcy53aWR0aCB8fCB0aGlzSW1hZ2Uud2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRoaXNDYW52YXMuaGVpZ2h0IHx8IHRoaXNJbWFnZS5oZWlnaHQ7XG4gICAgICAgIG1heFpvb20gPSBnZXRNYXhab29tTGV2ZWwod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgaWYgKHRoaXNSZXNvdXJjZS5pdGVtKVxuICAgICAgICB7XG4gICAgICAgICAgICBvdGhlckltYWdlcyA9IGdldE90aGVySW1hZ2VEYXRhKHRoaXNSZXNvdXJjZS5pdGVtLCBsb3dlc3RNYXhab29tLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGltYWdlTGFiZWwgPSB0aGlzSW1hZ2UubGFiZWwgfHwgbnVsbDtcblxuICAgICAgICBpbmZvID0gcGFyc2VJbWFnZUluZm8odGhpc0ltYWdlKTtcbiAgICAgICAgdXJsID0gaW5mby51cmwuc2xpY2UoLTEpID09PSAnLycgPyBpbmZvLnVybCArICcvJyA6IGluZm8udXJsOyAgLy8gYXBwZW5kIHRyYWlsaW5nIHNsYXNoIHRvIHVybCBpZiBpdCdzIG5vdCB0aGVyZS5cblxuICAgICAgICBjb250ZXh0ID0gdGhpc0ltYWdlLnNlcnZpY2VbJ0Bjb250ZXh0J107XG5cbiAgICAgICAgaWYgKGNvbnRleHQgPT09ICdodHRwOi8vaWlpZi5pby9hcGkvaW1hZ2UvMi9jb250ZXh0Lmpzb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUFQSVZlcnNpb24gPSAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRleHQgPT09ICdodHRwOi8vbGlicmFyeS5zdGFuZm9yZC5lZHUvaWlpZi9pbWFnZS1hcGkvMS4xL2NvbnRleHQuanNvbicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlQVBJVmVyc2lvbiA9IDEuMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGltYWdlQVBJVmVyc2lvbiA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvb21EaW1lbnNpb25zID0gbmV3IEFycmF5KGxvd2VzdE1heFpvb20gKyAxKTtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsb3dlc3RNYXhab29tICsgMTsgaysrKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aEF0Q3VycmVudFpvb21MZXZlbCA9IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKHdpZHRoLCBsb3dlc3RNYXhab29tIC0gaykpO1xuICAgICAgICAgICAgaGVpZ2h0QXRDdXJyZW50Wm9vbUxldmVsID0gTWF0aC5mbG9vcihpbmNvcnBvcmF0ZVpvb20oaGVpZ2h0LCBsb3dlc3RNYXhab29tIC0gaykpO1xuICAgICAgICAgICAgem9vbURpbWVuc2lvbnNba10gPSB7XG4gICAgICAgICAgICAgICAgaDogaGVpZ2h0QXRDdXJyZW50Wm9vbUxldmVsLFxuICAgICAgICAgICAgICAgIHc6IHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0b3RhbFdpZHRoc1trXSArPSB3aWR0aEF0Q3VycmVudFpvb21MZXZlbDtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0c1trXSArPSBoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWw7XG4gICAgICAgICAgICBtYXhXaWR0aHNba10gPSBNYXRoLm1heCh3aWR0aEF0Q3VycmVudFpvb21MZXZlbCwgbWF4V2lkdGhzW2tdKTtcbiAgICAgICAgICAgIG1heEhlaWdodHNba10gPSBNYXRoLm1heChoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWwsIG1heEhlaWdodHNba10pXG4gICAgICAgIH1cblxuICAgICAgICBwYWdlc1tpXSA9IHtcbiAgICAgICAgICAgIGQ6IHpvb21EaW1lbnNpb25zLFxuICAgICAgICAgICAgbTogbWF4Wm9vbSxcbiAgICAgICAgICAgIGw6IGxhYmVsLCAgICAgICAgIC8vIGNhbnZhcyBsYWJlbCAoJ3BhZ2UgMSwgcGFnZSAyJywgZXRjLilcbiAgICAgICAgICAgIGlsOiBpbWFnZUxhYmVsLCAgIC8vIGRlZmF1bHQgaW1hZ2UgbGFiZWwgKCdwcmltYXJ5IGltYWdlJywgJ1VWIGxpZ2h0JywgZXRjLilcbiAgICAgICAgICAgIGY6IHVybCxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgYXBpOiBpbWFnZUFQSVZlcnNpb24sXG4gICAgICAgICAgICBwYWdlZDogdGhpc0NhbnZhcy52aWV3aW5nSGludCAhPT0gJ25vbi1wYWdlZCcsXG4gICAgICAgICAgICBmYWNpbmdQYWdlczogdGhpc0NhbnZhcy52aWV3aW5nSGludCA9PT0gJ2ZhY2luZy1wYWdlcycsXG4gICAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICAgIG90aGVySW1hZ2VzOiBvdGhlckltYWdlcyxcbiAgICAgICAgICAgIHhvZmZzZXQ6IGluZm8ueCB8fCBudWxsLFxuICAgICAgICAgICAgeW9mZnNldDogaW5mby55IHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXZlcmFnZVdpZHRocyA9IG5ldyBBcnJheShsb3dlc3RNYXhab29tICsgMSkuZmlsbCgwKTtcbiAgICB2YXIgYXZlcmFnZUhlaWdodHMgPSBuZXcgQXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpLmZpbGwoMCk7XG4gICAgZm9yICh2YXIgYSA9IDA7IGEgPCBsb3dlc3RNYXhab29tICsgMTsgYSsrKVxuICAgIHtcbiAgICAgICAgYXZlcmFnZVdpZHRoc1thXSA9IHRvdGFsV2lkdGhzW2FdIC8gbnVtQ2FudmFzZXM7XG4gICAgICAgIGF2ZXJhZ2VIZWlnaHRzW2FdID0gdG90YWxIZWlnaHRzW2FdIC8gbnVtQ2FudmFzZXM7XG4gICAgfVxuXG4gICAgdmFyIGRpbXMgPSB7XG4gICAgICAgIGFfd2lkOiBhdmVyYWdlV2lkdGhzLFxuICAgICAgICBhX2hlaTogYXZlcmFnZUhlaWdodHMsXG4gICAgICAgIG1heF93OiBtYXhXaWR0aHMsXG4gICAgICAgIG1heF9oOiBtYXhIZWlnaHRzLFxuICAgICAgICBtYXhfcmF0aW86IG1heFJhdGlvLFxuICAgICAgICBtaW5fcmF0aW86IG1pblJhdGlvLFxuICAgICAgICB0X2hlaTogdG90YWxIZWlnaHRzLFxuICAgICAgICB0X3dpZDogdG90YWxXaWR0aHNcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbV90aXRsZTogbWFuaWZlc3QubGFiZWwsXG4gICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgIG1heF96b29tOiBsb3dlc3RNYXhab29tLFxuICAgICAgICBwZ3M6IHBhZ2VzLFxuICAgICAgICBwYWdlczogbWFuaWZlc3Qudmlld2luZ0hpbnQgPT09ICdwYWdlZCcgfHwgc2VxdWVuY2Uudmlld2luZ0hpbnQgPT09ICdwYWdlZCdcbiAgICB9O1xufVxuXG4vKipcbiAqIFRha2VzIGluIGEgcmVzb3VyY2UgYmxvY2sgZnJvbSBhIGNhbnZhcyBhbmQgb3V0cHV0cyB0aGUgZm9sbG93aW5nIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGF0IHJlc291cmNlOlxuICogLSBJbWFnZSBVUkxcbiAqIC0gSW1hZ2UgcmVnaW9uIHRvIGJlIGRpc3BsYXllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNvdXJjZSAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlc291cmNlIGJsb2NrIG9mIGEgY2FudmFzIHNlY3Rpb24gaW4gYSBJSUlGIG1hbmlmZXN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBpbWFnZUluZm8gLSBhbiBvYmplY3QgY29udGFpbmluZyBpbWFnZSBVUkwgYW5kIHJlZ2lvblxuICovXG5mdW5jdGlvbiBwYXJzZUltYWdlSW5mbyhyZXNvdXJjZSlcbntcbiAgICB2YXIgdXJsID0gcmVzb3VyY2VbJ0BpZCddO1xuICAgIHZhciBmcmFnbWVudFJlZ2V4ID0gLyN4eXdoPShbMC05XSssWzAtOV0rLFswLTldKyxbMC05XSspLztcbiAgICB2YXIgeHl3aCA9ICcnO1xuICAgIHZhciBzdHJpcFVSTCA9IHRydWU7XG5cbiAgICBpZiAoL1xcLyhbMC05XSssWzAtOV0rLFswLTldKyxbMC05XSspXFwvLy50ZXN0KHVybCkpXG4gICAge1xuICAgICAgICAvLyBpZiByZXNvdXJjZSBpbiBpbWFnZSBBUEkgZm9ybWF0LCBleHRyYWN0IHJlZ2lvbiB4LHksdyxoIGZyb20gVVJMIChhZnRlciA0dGggc2xhc2ggZnJvbSBsYXN0KVxuICAgICAgICAvLyBtYXRjaGVzIGNvb3JkaW5hdGVzIGluIFVSTHMgb2YgdGhlIGZvcm0gaHR0cDovL3d3dy5leGFtcGxlLm9yZy9paWlmL2Jvb2sxLXBhZ2UxLzQwLDUwLDEyMDAsMTgwMC9mdWxsLzAvZGVmYXVsdC5qcGdcbiAgICAgICAgdmFyIHVybEFycmF5ID0gdXJsLnNwbGl0KCcvJyk7XG4gICAgICAgIHh5d2ggPSB1cmxBcnJheVt1cmxBcnJheS5sZW5ndGggLSA0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZnJhZ21lbnRSZWdleC50ZXN0KHVybCkpXG4gICAge1xuICAgICAgICAvLyBtYXRjaGVzIGNvb3JkaW5hdGVzIG9mIHRoZSBzdHlsZSBodHRwOi8vd3d3LmV4YW1wbGUub3JnL2lpaWYvYm9vazEvY2FudmFzL3AxI3h5d2g9NTAsNTAsMzIwLDI0MFxuICAgICAgICB2YXIgcmVzdWx0ID0gZnJhZ21lbnRSZWdleC5leGVjKHVybCk7XG4gICAgICAgIHh5d2ggPSByZXN1bHRbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc291cmNlLnNlcnZpY2UgJiYgcmVzb3VyY2Uuc2VydmljZVsnQGlkJ10pXG4gICAge1xuICAgICAgICAvLyBhc3N1bWUgY2FudmFzIHNpemUgYmFzZWQgb24gaW1hZ2Ugc2l6ZVxuICAgICAgICB1cmwgPSByZXNvdXJjZS5zZXJ2aWNlWydAaWQnXTtcbiAgICAgICAgLy8gdGhpcyBVUkwgZXhjbHVkZXMgcmVnaW9uIHBhcmFtZXRlcnMgc28gd2UgZG9uJ3QgbmVlZCB0byByZW1vdmUgdGhlbVxuICAgICAgICBzdHJpcFVSTCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJpcFVSTClcbiAgICB7XG4gICAgICAgIC8vIGV4dHJhY3QgVVJMIHVwIHRvIGlkZW50aWZpZXIgKHdlIGVsaW1pbmF0ZSB0aGUgbGFzdCA1IHBhcmFtZXRlcnM6IC9yZWdpb24vc2l6ZS9yb3RhdGlvbi9xdWFsaXR5LmZvcm1hdClcbiAgICAgICAgdXJsID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgLTQpLmpvaW4oJy8nKTtcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VJbmZvID0ge1xuICAgICAgICB1cmw6IHVybFxuICAgIH07XG5cbiAgICBpZiAoeHl3aC5sZW5ndGgpXG4gICAge1xuICAgICAgICAvLyBwYXJzZSBpbnRvIHNlcGFyYXRlIGNvbXBvbmVudHNcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB4eXdoLnNwbGl0KCcsJyk7XG4gICAgICAgIGltYWdlSW5mby54ID0gcGFyc2VJbnQoZGltZW5zaW9uc1swXSwgMTApO1xuICAgICAgICBpbWFnZUluZm8ueSA9IHBhcnNlSW50KGRpbWVuc2lvbnNbMV0sIDEwKTtcbiAgICAgICAgaW1hZ2VJbmZvLncgPSBwYXJzZUludChkaW1lbnNpb25zWzJdLCAxMCk7XG4gICAgICAgIGltYWdlSW5mby5oID0gcGFyc2VJbnQoZGltZW5zaW9uc1szXSwgMTApO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZUluZm87XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGFyc2UtaWlpZi1tYW5pZmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIGRpdmEgPSByZXF1aXJlKCcuL2RpdmEtZ2xvYmFsJyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb29sYmFyO1xuXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFyKHZpZXdlcilcbntcbiAgICB2YXIgc2V0dGluZ3MgPSB2aWV3ZXIuZ2V0U2V0dGluZ3MoKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFRlbXBvcmFyaWx5IGNvcGllZCBmcm9tIHdpdGhpbiBEaXZhXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICAvKiogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc3Vic2NyaWJlIHRvIGEgRGl2YSBldmVudCAqL1xuICAgIHZhciBzdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGVzIGEgdG9vbGJhciBidXR0b25cbiAgICB2YXIgY3JlYXRlQnV0dG9uRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGxhYmVsLCBjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBidXR0b24gPSBlbHQoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgbmFtZSxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS0nICsgbmFtZSArICcgZGl2YS1idXR0b24nLFxuICAgICAgICAgICAgdGl0bGU6IGxhYmVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9O1xuXG4gICAgLy8gSGlnaGVyLWxldmVsIGZ1bmN0aW9uIGZvciBjcmVhdG9ycyBvZiB6b29tIGFuZCBncmlkIGNvbnRyb2xzXG4gICAgdmFyIGdldFJlc29sdXRpb25Db250cm9sQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWcpXG4gICAge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzW2NvbmZpZy5jb250cm9sbGVyU2V0dGluZ10pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2xpZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMgPSBjb25maWcuY3JlYXRlU2xpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9ucyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzID0gY29uZmlnLmNyZWF0ZUJ1dHRvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY29udHJvbHMsXG4gICAgICAgICAgICAgICAgY29uZmlnLmNyZWF0ZUxhYmVsKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVXcmFwcGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkID09PSBjb25maWcuc2hvd0luR3JpZClcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdEaWRTd2l0Y2gnLCB1cGRhdGVXcmFwcGVyKTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnT2JqZWN0RGlkTG9hZCcsIHVwZGF0ZVdyYXBwZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdXBkYXRlV3JhcHBlcigpO1xuXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gWm9vbSBjb250cm9sc1xuICAgIHZhciBjcmVhdGVab29tQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZVpvb21Db250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IGZhbHNlLFxuXG4gICAgICAgIGNyZWF0ZVNsaWRlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVTbGlkZXIoJ3pvb20tc2xpZGVyJywge1xuICAgICAgICAgICAgICAgIHN0ZXA6IDAuMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluWm9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignY2hhbmdlJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0VmFsdWUgIT09IHNldHRpbmdzLnpvb21MZXZlbClcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlU2xpZGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muem9vbUxldmVsICE9PSAkZWxlbS52YWwoKSlcbiAgICAgICAgICAgICAgICAgICAgJGVsZW0udmFsKHNldHRpbmdzLnpvb21MZXZlbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1pvb21MZXZlbERpZENoYW5nZScsIHVwZGF0ZVNsaWRlcik7XG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsdC5zZXRBdHRyaWJ1dGVzKGVsZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBzZXR0aW5ncy5taW5ab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCdXR0b25zOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KCdzcGFuJyxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLW91dC1idXR0b24nLCAnWm9vbSBPdXQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRab29tTGV2ZWwoc2V0dGluZ3Muem9vbUxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGFiZWw6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gY3JlYXRlTGFiZWwoJ2RpdmEtem9vbS1sYWJlbCcsICd6b29tLWxhYmVsJywgJ1pvb20gbGV2ZWw6ICcsICd6b29tLWxldmVsJywgc2V0dGluZ3Muem9vbUxldmVsKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3BhbiA9ICQoZWxlbSkuZmluZChzZXR0aW5ncy5zZWxlY3RvciArICd6b29tLWxldmVsJylbMF07XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3Bhbi50ZXh0Q29udGVudCA9IHNldHRpbmdzLnpvb21MZXZlbC50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3Vic2NyaWJlKCdab29tTGV2ZWxEaWRDaGFuZ2UnLCB1cGRhdGVUZXh0KTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnVmlld2VyRGlkTG9hZCcsIHVwZGF0ZVRleHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gR3JpZCBjb250cm9sc1xuICAgIHZhciBjcmVhdGVHcmlkQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZUdyaWRDb250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IHRydWUsXG5cbiAgICAgICAgY3JlYXRlU2xpZGVyOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGNyZWF0ZVNsaWRlcignZ3JpZC1zbGlkZXInLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzLnBhZ2VzUGVyUm93LFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluUGFnZXNQZXJSb3csXG4gICAgICAgICAgICAgICAgbWF4OiBzZXR0aW5ncy5tYXhQYWdlc1BlclJvd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignaW5wdXQnLCBmdW5jdGlvbigpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQoZWxlbS52YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coaW50VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KGVsZW0udmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50VmFsdWUgIT09IHNldHRpbmdzLnBhZ2VzUGVyUm93KVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXIuc2V0R3JpZFBhZ2VzUGVyUm93KGludFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW4gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYWdlc1BlclJvdyAhPT0gJGVsZW0udmFsKCkpXG4gICAgICAgICAgICAgICAgICAgICRlbGVtLnZhbChzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQnV0dG9uczogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY3JlYXRlQnV0dG9uRWxlbWVudCgnZ3JpZC1vdXQtYnV0dG9uJywgJ1pvb20gT3V0JywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCdncmlkLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgKyAxKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYWJlbDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVMYWJlbCgnZGl2YS1ncmlkLWxhYmVsJywgJ2dyaWQtbGFiZWwnLCAnUGFnZXMgcGVyIHJvdzogJywgJ3BhZ2VzLXBlci1yb3cnLCBzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB2YXIgdGV4dFNwYW4gPSAkKGVsZW0pLmZpbmQoc2V0dGluZ3Muc2VsZWN0b3IgKyAncGFnZXMtcGVyLXJvdycpWzBdO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHRTcGFuLnRleHRDb250ZW50ID0gc2V0dGluZ3MucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjcmVhdGVWaWV3TWVudSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciB2aWV3T3B0aW9uc0xpc3QgPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndmlldy1vcHRpb25zJykpO1xuXG4gICAgICAgIHZhciBjaGFuZ2VWaWV3QnV0dG9uID0gY3JlYXRlQnV0dG9uRWxlbWVudCgndmlldy1pY29uJywgJ0NoYW5nZSB2aWV3JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLnRvZ2dsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKGRvY3VtZW50KS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQodmlld09wdGlvbnNMaXN0KTtcblxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuaXMoZXZlbnQudGFyZ2V0KSAmJiBjb250YWluZXIuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSAwICYmIGV2ZW50LnRhcmdldC5pZCAhPT0gc2V0dGluZ3MuSUQgKyAndmlldy1pY29uJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VsZWN0VmlldyA9IGZ1bmN0aW9uICh2aWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIuY2hhbmdlVmlldyh2aWV3KTtcblxuICAgICAgICAgICAgLy9oaWRlIHZpZXcgbWVudVxuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLmhpZGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlVmlld01lbnUgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2aWV3SWNvbkNsYXNzZXMgPSAnIGRpdmEtdmlldy1pY29uIGRpdmEtYnV0dG9uJztcblxuICAgICAgICAgICAgLy8gZGlzcGxheSB0aGUgaWNvbiBvZiB0aGUgbW9kZSB3ZSdyZSBjdXJyZW50bHkgaW4gKD8pXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24uY2xhc3NOYW1lID0gJ2RpdmEtZ3JpZC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmluQm9va0xheW91dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VWaWV3QnV0dG9uLmNsYXNzTmFtZSA9ICdkaXZhLWJvb2staWNvbicgKyB2aWV3SWNvbkNsYXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVmlld0J1dHRvbi5jbGFzc05hbWUgPSAnZGl2YS1kb2N1bWVudC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZpZXdPcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGVuIGRpc3BsYXkgZG9jdW1lbnQsIGJvb2ssIGFuZCBncmlkIGJ1dHRvbnMgaW4gdGhhdCBvcmRlciwgZXhjbHVkaW5nIHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQgfHwgc2V0dGluZ3MuaW5Cb29rTGF5b3V0KVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2RvY3VtZW50LWljb24nLCAnRG9jdW1lbnQgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnZG9jdW1lbnQnKSkpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkIHx8ICFzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICAgICAgdmlld09wdGlvbnMuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uRWxlbWVudCgnYm9vay1pY29uJywgJ0Jvb2sgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnYm9vaycpKSk7XG5cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2dyaWQtaWNvbicsICdHcmlkIFZpZXcnLCBzZWxlY3RWaWV3LmJpbmQobnVsbCwgJ2dyaWQnKSkpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIG1lbnVcbiAgICAgICAgICAgIHdoaWxlICh2aWV3T3B0aW9uc0xpc3QuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3QucmVtb3ZlQ2hpbGQodmlld09wdGlvbnNMaXN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgbmV3IG1lbnVcbiAgICAgICAgICAgIHZpZXdPcHRpb25zTGlzdC5hcHBlbmRDaGlsZCh2aWV3T3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdWaWV3RGlkU3dpdGNoJywgdXBkYXRlVmlld01lbnUpO1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVWaWV3TWVudSk7XG5cbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd2aWV3LW1lbnUnKSxcbiAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24sXG4gICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3RcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNsaWRlciA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICByZXR1cm4gZWx0KCdpbnB1dCcsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIG5hbWUsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIG5hbWUgKyAnIGRpdmEtc2xpZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdyYW5nZSdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMYWJlbCA9IGZ1bmN0aW9uKG5hbWUsIGlkLCBsYWJlbCwgaW5uZXJOYW1lLCBpbm5lclZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBuYW1lICsgJyBkaXZhLWxhYmVsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlubmVyTmFtZVxuICAgICAgICAgICAgICAgIH0sIGlubmVyVmFsdWUpXG4gICAgICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhZ2VOYXZpZ2F0aW9uQ29udHJvbHMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gR28gdG8gcGFnZSBmb3JtXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IHNldHRpbmdzLmVuYWJsZUdvdG9QYWdlID8gY3JlYXRlR290b1BhZ2VGb3JtKCkgOiBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCBlbGVtQXR0cnMoJ3BhZ2UtbmF2JyksXG4gICAgICAgICAgICBjcmVhdGVQYWdlTGFiZWwoKSwgLy8gJ1BhZ2UgeCBvZiB5JyBsYWJlbFxuICAgICAgICAgICAgZ290b0Zvcm1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdvdG9QYWdlRm9ybSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ290b1BhZ2VJbnB1dCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLWlucHV0JyxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1pbnB1dCBkaXZhLWdvdG8tcGFnZS1pbnB1dCcsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnb3RvUGFnZVN1Ym1pdCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLXN1Ym1pdCcsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtYnV0dG9uIGRpdmEtYnV0dG9uLXRleHQnLFxuICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgICB2YWx1ZTogJ0dvJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5wdXRTdWdnZXN0aW9ucyA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdpbnB1dC1zdWdnZXN0aW9ucycsXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLWlucHV0LXN1Z2dlc3Rpb25zJ1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IGVsdCgnZm9ybScsIHtcbiAgICAgICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtZ290by1mb3JtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQsXG4gICAgICAgICAgICBnb3RvUGFnZVN1Ym1pdCxcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAkKGdvdG9Gb3JtKS5vbignc3VibWl0JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRlc2lyZWRQYWdlTGFiZWwgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub25Hb3RvU3VibWl0ICYmIHR5cGVvZiBzZXR0aW5ncy5vbkdvdG9TdWJtaXQgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gc2V0dGluZ3Mub25Hb3RvU3VibWl0KGRlc2lyZWRQYWdlTGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIk5vIHBhZ2UgY291bGQgYmUgZm91bmQgd2l0aCB0aGF0IGxhYmVsIG9yIHBhZ2UgbnVtYmVyXCIpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIC8vIERlZmF1bHQgaWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGluIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlMYWJlbChkZXNpcmVkUGFnZUxhYmVsKSlcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJObyBwYWdlIGNvdWxkIGJlIGZvdW5kIHdpdGggdGhhdCBsYWJlbCBvciBwYWdlIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgcmVsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZ290b1BhZ2VJbnB1dCkub24oJ2lucHV0IGZvY3VzJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5pbm5lckhUTUwgPSAnJzsgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBzdWdnZXN0aW9uc1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIG51bVN1Z2dlc3Rpb25zID0gMDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVHb3RvU3VnZ2VzdGlvbnMgJiYgdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbiAmJiBudW1TdWdnZXN0aW9ucyA8IDEwOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXNbaV0ubC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0lucHV0U3VnZ2VzdGlvbiA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtaW5wdXQtc3VnZ2VzdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzW2ldLmxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuYXBwZW5kQ2hpbGQobmV3SW5wdXRTdWdnZXN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtU3VnZ2VzdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNob3cgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobnVtU3VnZ2VzdGlvbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWw7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgLy8gJ0VudGVyJyBrZXlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBnb3RvUGFnZUlucHV0LnZhbHVlID0gYWN0aXZlLnRleHQoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzgpIC8vIFVwIGFycm93IGtleVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWwgPSBlbC5wcmV2KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZFbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmRpdmEtaW5wdXQtc3VnZ2VzdGlvbjpsYXN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gNDApIC8vIERvd24gYXJyb3cga2V5XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWwgPSAkKCcuYWN0aXZlJywgaW5wdXRTdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IGVsLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAkKCcuZGl2YS1pbnB1dC1zdWdnZXN0aW9uOmZpcnN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChpbnB1dFN1Z2dlc3Rpb25zKS5vbignbW91c2Vkb3duJywgJy5kaXZhLWlucHV0LXN1Z2dlc3Rpb24nLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQudmFsdWUgPSB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgJChnb3RvUGFnZUlucHV0KS50cmlnZ2VyKCdzdWJtaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbignYmx1cicsIGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEhpZGUgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdvdG9Gb3JtO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFnZUxhYmVsID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gQ3VycmVudCBwYWdlXG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IGVsdCgnc3BhbicsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdjdXJyZW50LXBhZ2UnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cGRhdGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlLnRleHRDb250ZW50ID0gdmlld2VyLmdldEN1cnJlbnRBbGlhc2VkUGFnZUluZGV4KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdWaXNpYmxlUGFnZURpZENoYW5nZScsIHVwZGF0ZUN1cnJlbnRQYWdlKTtcbiAgICAgICAgc3Vic2NyaWJlKCdWaWV3ZXJEaWRMb2FkJywgdXBkYXRlQ3VycmVudFBhZ2UpO1xuXG4gICAgICAgIC8vIE51bWJlciBvZiBwYWdlc1xuICAgICAgICB2YXIgbnVtUGFnZXMgPSBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnbnVtLXBhZ2VzJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXBkYXRlTnVtUGFnZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBudW1QYWdlcy50ZXh0Q29udGVudCA9IHNldHRpbmdzLm51bVBhZ2VzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmliZSgnTnVtYmVyT2ZQYWdlc0RpZENoYW5nZScsIHVwZGF0ZU51bVBhZ2VzKTtcbiAgICAgICAgc3Vic2NyaWJlKCdPYmplY3REaWRMb2FkJywgdXBkYXRlTnVtUGFnZXMpO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLXBhZ2UtbGFiZWwgZGl2YS1sYWJlbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnUGFnZSAnLCBjdXJyZW50UGFnZSwgJyBvZiAnLCBudW1QYWdlc1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVG9vbGJhckJ1dHRvbkdyb3VwID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBidXR0b25zID0gW2NyZWF0ZVZpZXdNZW51KCldO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVMaW5rSWNvbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVMaW5rSWNvbigpKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlTm9uUGFnZWRWaXNpYmlsaXR5SWNvbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVUb2dnbGVOb25QYWdlZEJ1dHRvbigpKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlRnVsbHNjcmVlbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVGdWxsc2NyZWVuQnV0dG9uKCkpO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCBlbGVtQXR0cnMoJ3Rvb2xiYXItYnV0dG9uLWdyb3VwJyksIGJ1dHRvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTGlua0ljb24gPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVCdXR0b25FbGVtZW50KCdsaW5rLWljb24nLCAnTGluayB0byB0aGlzIHBhZ2UnKTtcbiAgICAgICAgdmFyIGxpbmtJY29uID0gJChlbGVtKTtcblxuICAgICAgICBsaW5rSWNvbi5vbignY2xpY2snLCBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCdib2R5JykucHJlcGVuZChcbiAgICAgICAgICAgICAgICBlbHQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtcG9wdXAgZGl2YS1saW5rLXBvcHVwJ1xuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZWx0KCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdsaW5rLXBvcHVwLWlucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1pbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmlld2VyLmdldEN1cnJlbnRVUkwoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCcpLmFkZENsYXNzKCdpbi1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0c1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gbGlua0ljb24ub2Zmc2V0KCkubGVmdCAtIDIyMiArIGxpbmtJY29uLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gbGlua0ljb24ub2Zmc2V0KCkudG9wICsgbGlua0ljb24ub3V0ZXJIZWlnaHQoKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2xpbmstcG9wdXAnKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAndG9wJzogdG9wT2Zmc2V0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0T2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXRjaCBvbm1vdXNldXAgZXZlbnRzIG91dHNpZGUgb2YgdGhpcyBkaXZcbiAgICAgICAgICAgICQoJ2JvZHknKS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SUQgPSBldmVudC50YXJnZXQuaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SUQgIT09IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAnICYmIHRhcmdldElEICE9PSBzZXR0aW5ncy5JRCArICdsaW5rLXBvcHVwLWlucHV0JylcbiAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdsaW5rLXBvcHVwJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWxzbyBkZWxldGUgaXQgdXBvbiBzY3JvbGwgYW5kIHBhZ2UgdXAvZG93biBrZXkgZXZlbnRzXG4gICAgICAgICAgICAvLyBGSVhNRSh3YWJhaW4pOiBUaGlzIGlzIGFnZ3Jlc3NpdmVcbiAgICAgICAgICAgIHNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2xpbmstcG9wdXAgaW5wdXQnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQodGhpcykuZm9jdXMoKS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRnVsbHNjcmVlbkJ1dHRvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnV0dG9uRWxlbWVudCgnZnVsbHNjcmVlbi1pY29uJywgJ1RvZ2dsZSBmdWxsc2NyZWVuIG1vZGUnLCBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIudG9nZ2xlRnVsbHNjcmVlbk1vZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUb2dnbGVOb25QYWdlZEJ1dHRvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJ3RvZ2dsZS1ub25wYWdlZC1pY29uJyArICh2aWV3ZXIuZ2V0U2V0dGluZ3MoKS5zaG93Tm9uUGFnZWRQYWdlcyA/ICctYWN0aXZlJyA6ICcnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9nZ2xlTm9uUGFnZWRCdXR0b24gPSBjcmVhdGVCdXR0b25FbGVtZW50KGdldENsYXNzTmFtZSgpLCAnVG9nZ2xlIHZpc2liaWxpdHkgb2Ygbm9uLXBhZ2VkIHBhZ2VzJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIudG9nZ2xlTm9uUGFnZWRQYWdlc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIHZhciBuZXdDbGFzc05hbWUgPSAnZGl2YS0nICsgZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2RpdmEtdG9nZ2xlLW5vbnBhZ2VkLWljb24oLWFjdGl2ZSk/LywgbmV3Q2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZU5vblBhZ2VkQnV0dG9uVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubWFuaWZlc3QucGFnZWQgJiYgIXBhZ2VzW2ldLnBhZ2VkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgYnV0dG9uLCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLXBhZ2VkIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlTm9uUGFnZWRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBub24tcGFnZWQgcGFnZXMgd2VyZSBmb3VuZCwgaGlkZSB0aGUgYnV0dG9uXG4gICAgICAgICAgICB0b2dnbGVOb25QYWdlZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVOb25QYWdlZEJ1dHRvblZpc2liaWxpdHkpO1xuXG4gICAgICAgIHJldHVybiB0b2dnbGVOb25QYWdlZEJ1dHRvbjtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlcyBhbGwgc3RhdHVzIHVwZGF0aW5nIGV0YyAoYm90aCBmdWxsc2NyZWVuIGFuZCBub3QpXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGxlZnRUb29scyA9IFtjcmVhdGVab29tQ29udHJvbHMoKSwgY3JlYXRlR3JpZENvbnRyb2xzKCldO1xuICAgICAgICB2YXIgcmlnaHRUb29scyA9IFtjcmVhdGVQYWdlTmF2aWdhdGlvbkNvbnRyb2xzKCksIGNyZWF0ZVRvb2xiYXJCdXR0b25Hcm91cCgpXTtcblxuICAgICAgICB2YXIgdG9vbHMgPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndG9vbHMnKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0b29scy1sZWZ0JyksIGxlZnRUb29scyksXG4gICAgICAgICAgICBlbHQoJ2RpdicsIGVsZW1BdHRycygndG9vbHMtcmlnaHQnKSwgcmlnaHRUb29scylcbiAgICAgICAgKTtcblxuICAgICAgICBzZXR0aW5ncy50b29sYmFyUGFyZW50T2JqZWN0LnByZXBlbmQodG9vbHMpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBlbnRyeSB0byBhbmQgZXhpdCBmcm9tIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICB2YXIgc3dpdGNoTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b29sc1JpZ2h0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNldHRpbmdzLklEICsgJ3Rvb2xzLXJpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgcGFnZU5hdkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZXR0aW5ncy5JRCArICdwYWdlLW5hdicpO1xuXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBMZWF2aW5nIGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAkKHRvb2xzKS5yZW1vdmVDbGFzcygnZGl2YS1mdWxsc2NyZWVuLXRvb2xzJyk7XG5cbiAgICAgICAgICAgICAgICAvL21vdmUgSUQtcGFnZS1uYXYgdG8gYmVnaW5uaW5nIG9mIHRvb2xzIHJpZ2h0XG4gICAgICAgICAgICAgICAgdG9vbHNSaWdodEVsZW1lbnQucmVtb3ZlQ2hpbGQocGFnZU5hdkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRvb2xzUmlnaHRFbGVtZW50Lmluc2VydEJlZm9yZShwYWdlTmF2RWxlbWVudCwgdG9vbHNSaWdodEVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRW50ZXJpbmcgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICQodG9vbHMpLmFkZENsYXNzKCdkaXZhLWZ1bGxzY3JlZW4tdG9vbHMnKTtcblxuICAgICAgICAgICAgICAgIC8vbW92ZSBJRC1wYWdlLW5hdiB0byBlbmQgb2YgdG9vbHMgcmlnaHRcbiAgICAgICAgICAgICAgICB0b29sc1JpZ2h0RWxlbWVudC5yZW1vdmVDaGlsZChwYWdlTmF2RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdG9vbHNSaWdodEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZU5hdkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmliZSgnTW9kZURpZFN3aXRjaCcsIHN3aXRjaE1vZGUpO1xuICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBzd2l0Y2hNb2RlKTtcblxuICAgICAgICB2YXIgdG9vbGJhciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRvb2xzLFxuICAgICAgICAgICAgY2xvc2VQb3B1cHM6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJCgnLmRpdmEtcG9wdXAnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW5pdCgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdG9vbGJhci5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxucmVxdWlyZSgnLi91dGlscy9qcXVlcnktZXh0ZW5zaW9ucycpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcbnZhciBnZXRTY3JvbGxiYXJXaWR0aCA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aCcpO1xuXG52YXIgZ2VzdHVyZUV2ZW50cyA9IHJlcXVpcmUoJy4vZ2VzdHVyZS1ldmVudHMnKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xudmFyIERvY3VtZW50SGFuZGxlciA9IHJlcXVpcmUoJy4vZG9jdW1lbnQtaGFuZGxlcicpO1xudmFyIEdyaWRIYW5kbGVyID0gcmVxdWlyZSgnLi9ncmlkLWhhbmRsZXInKTtcbnZhciBQYWdlT3ZlcmxheU1hbmFnZXIgPSByZXF1aXJlKCcuL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyJyk7XG52YXIgUGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL3BsdWdpbi1yZWdpc3RyeScpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIGdldFBhZ2VMYXlvdXRzID0gcmVxdWlyZSgnLi9wYWdlLWxheW91dHMnKTtcbnZhciBjcmVhdGVTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKCcuL3NldHRpbmdzLXZpZXcnKTtcbnZhciBWYWxpZGF0aW9uUnVubmVyID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uLXJ1bm5lcicpO1xudmFyIFZpZXdwb3J0ID0gcmVxdWlyZSgnLi92aWV3cG9ydCcpO1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOlZpZXdlckNvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3ZXJDb3JlO1xuXG4vLyBEZWZpbmUgdmFsaWRhdGlvbnNcbnZhciBvcHRpb25zVmFsaWRhdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBrZXk6ICdnb0RpcmVjdGx5VG8nLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlLCBzZXR0aW5ncylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluUGFnZXNQZXJSb3cnLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFBhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSwgc2V0dGluZ3MubWluUGFnZXNQZXJSb3cpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ3BhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblBhZ2VzUGVyUm93IHx8IHZhbHVlID4gc2V0dGluZ3MubWF4UGFnZXNQZXJSb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1heFBhZ2VzUGVyUm93O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFpvb21MZXZlbCcsXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUsIHNldHRpbmdzLCBjb25maWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoaXMgdmFsdWUgaXNuJ3QgcmVhbGx5IGFuIGVycm9yLCBpdCBqdXN0IGRlcGVuZHMgb24gdGhlXG4gICAgICAgICAgICAvLyBzb3VyY2UgbWFuaWZlc3RcbiAgICAgICAgICAgIGNvbmZpZy5zdXBwcmVzc1dhcm5pbmcoKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb207XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluWm9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ2hhbmdlcyBiYXNlZCBvbiB0aGUgbWFuaWZlc3QgdmFsdWUgc2hvdWxkbid0IHRyaWdnZXIgYVxuICAgICAgICAgICAgLy8gd2FybmluZ1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiBzZXR0aW5ncy5tYXhab29tTGV2ZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnem9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblpvb21MZXZlbCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1heFpvb21MZXZlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICB9XG4gICAgfVxuXTtcblxuZnVuY3Rpb24gVmlld2VyQ29yZShlbGVtZW50LCBvcHRpb25zLCBwdWJsaWNJbnN0YW5jZSlcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhcmVudE9iamVjdCA9ICQoZWxlbWVudCk7XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCBiZWNhdXNlIG9mIHRoZSB3YXkgdGhleSBhcmUgdXNlZCBieSB0aGUgc2NyaXB0XG4gICAgLy8gTWFueSBvZiB0aGVzZSBhcmUgZGVjbGFyZWQgd2l0aCBhcmJpdHJhcnkgdmFsdWVzIHRoYXQgYXJlIGNoYW5nZWQgbGF0ZXIgb25cbiAgICB2YXIgdmlld2VyU3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRQYWdlSW5kZXg6IDAsICAgICAgICAvLyBUaGUgY3VycmVudCBwYWdlIGluIHRoZSB2aWV3cG9ydCAoY2VudGVyLW1vc3QgcGFnZSlcbiAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogMCwgICAgICAgIC8vIERpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YSBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICBob3Jpem9udGFsUGFkZGluZzogMCwgICAgICAgLy8gRWl0aGVyIHRoZSBmaXhlZCBwYWRkaW5nIG9yIGFkYXB0aXZlIHBhZGRpbmdcbiAgICAgICAgSUQ6IG51bGwsICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmaXggb2YgdGhlIElEcyBvZiB0aGUgZWxlbWVudHMgKHVzdWFsbHkgMS1kaXZhLSlcbiAgICAgICAgaW5pdGlhbEtleVNjcm9sbDogZmFsc2UsICAgIC8vIEhvbGRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIGVuYWJsZUtleVNjcm9sbFxuICAgICAgICBpbml0aWFsU3BhY2VTY3JvbGw6IGZhbHNlLCAgLy8gSG9sZHMgdGhlIGluaXRpYWwgc3RhdGUgb2YgZW5hYmxlU3BhY2VTY3JvbGxcbiAgICAgICAgaW5uZXJFbGVtZW50OiBudWxsLCAgICAgICAgIC8vIFRoZSBuYXRpdmUgLmRpdmEtb3V0ZXIgRE9NIG9iamVjdFxuICAgICAgICBpbm5lck9iamVjdDoge30sICAgICAgICAgICAgLy8gJChzZXR0aW5ncy5JRCArICdpbm5lcicpLCBmb3Igc2VsZWN0aW5nIHRoZSAuZGl2YS1pbm5lciBlbGVtZW50XG4gICAgICAgIGlzQWN0aXZlRGl2YTogdHJ1ZSwgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IG11bHRpcGxlIGRpdmEgcGFuZXMgZXhpc3Qgb24gdGhlIHNhbWUgcGFnZSwgdGhpcyBzaG91bGQgaGF2ZSBldmVudHMgZnVubmVsZWQgdG8gaXQuXG4gICAgICAgIGlzSUlJRjogZmFsc2UsICAgICAgICAgICAgICAvLyBTcGVjaWZpZXMgd2hldGhlciBvYmplY3REYXRhIGlzIGluIERpdmEgbmF0aXZlIG9yIElJSUYgTWFuaWZlc3QgZm9ybWF0XG4gICAgICAgIGlzU2Nyb2xsYWJsZTogdHJ1ZSwgICAgICAgICAvLyBVc2VkIGluIGVuYWJsZS9kaXNhYmxlU2Nyb2xsYWJsZSBwdWJsaWMgbWV0aG9kc1xuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLCAgICAgICAgICAgLy8gRmxhZyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgem9vbWluZyBpcyBzdGlsbCBpbiBwcm9ncmVzcywgZm9yIGhhbmRsZVpvb21cbiAgICAgICAgbG9hZGVkOiBmYWxzZSwgICAgICAgICAgICAgIC8vIEEgZmxhZyBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICAgIG1hbmlmZXN0OiBudWxsLFxuICAgICAgICBtb2JpbGVXZWJraXQ6IGZhbHNlLCAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIG9uIGEgdG91Y2ggZGV2aWNlIChpUGFkL2lQb2QvaVBob25lL0FuZHJvaWQpXG4gICAgICAgIG51bVBhZ2VzOiAwLCAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgcGFnZXMgaW4gdGhlIGFycmF5XG4gICAgICAgIG9sZFpvb21MZXZlbDogLTEsICAgICAgICAgICAvLyBIb2xkcyB0aGUgcHJldmlvdXMgem9vbSBsZXZlbCBhZnRlciB6b29taW5nIGluIG9yIG91dFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBvdXRlckVsZW1lbnQ6IG51bGwsICAgICAgICAgLy8gVGhlIG5hdGl2ZSAuZGl2YS1vdXRlciBET00gb2JqZWN0XG4gICAgICAgIG91dGVyT2JqZWN0OiB7fSwgICAgICAgICAgICAvLyAkKHNldHRpbmdzLklEICsgJ291dGVyJyksIGZvciBzZWxlY3RpbmcgdGhlIC5kaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgICAgcGFnZU92ZXJsYXlzOiBuZXcgUGFnZU92ZXJsYXlNYW5hZ2VyKCksXG4gICAgICAgIHBhZ2VUb29sczogW10sICAgICAgICAgICAgICAvLyBUaGUgcGx1Z2lucyB3aGljaCBhcmUgZW5hYmxlZCBhcyBwYWdlIHRvb2xzXG4gICAgICAgIHBhcmVudE9iamVjdDogcGFyZW50T2JqZWN0LCAvLyBKUXVlcnkgb2JqZWN0IHJlZmVyZW5jaW5nIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0OiBudWxsLCAvLyBSZWZlcmVuY2UgdG8gdGhlIHhociByZXF1ZXN0IHJldHJpZXZpbmcgdGhlIG1hbmlmZXN0LiBVc2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdCBvbiBkZXN0cm95KClcbiAgICAgICAgcGx1Z2luczogW10sICAgICAgICAgICAgICAgIC8vIEZpbGxlZCB3aXRoIHRoZSBlbmFibGVkIHBsdWdpbnMgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHJlc2l6ZVRpbWVyOiAtMSwgICAgICAgICAgICAvLyBIb2xkcyB0aGUgSUQgb2YgdGhlIHRpbWVvdXQgdXNlZCB3aGVuIHJlc2l6aW5nIHRoZSB3aW5kb3cgKGZvciBjbGVhcmluZylcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGg6IDAsICAgICAgICAgIC8vIFNldCB0byB0aGUgYWN0dWFsIHNjcm9sbGJhciB3aWR0aCBpbiBpbml0KClcbiAgICAgICAgc2VsZWN0b3I6ICcnLCAgICAgICAgICAgICAgIC8vIFVzZXMgdGhlIGdlbmVyYXRlZCBJRCBwcmVmaXggdG8gZWFzaWx5IHNlbGVjdCBlbGVtZW50c1xuICAgICAgICB0aHJvYmJlclRpbWVvdXRJRDogLTEsICAgICAgLy8gSG9sZHMgdGhlIElEIG9mIHRoZSB0aHJvYmJlciBsb2FkaW5nIHRpbWVvdXRcbiAgICAgICAgdG9vbGJhcjogbnVsbCwgICAgICAgICAgICAgIC8vIEhvbGRzIGFuIG9iamVjdCB3aXRoIHNvbWUgdG9vbGJhci1yZWxhdGVkIGZ1bmN0aW9uc1xuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogMCwgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBkaXZhIGVsZW1lbnQgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIHZlcnRpY2FsUGFkZGluZzogMCwgICAgICAgICAvLyBFaXRoZXIgdGhlIGZpeGVkIHBhZGRpbmcgb3IgYWRhcHRpdmUgcGFkZGluZ1xuICAgICAgICB2aWV3SGFuZGxlcjogbnVsbCxcbiAgICAgICAgdmlld3BvcnQ6IG51bGwsICAgICAgICAgICAgIC8vIE9iamVjdCBjYWNoaW5nIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudDogbnVsbCxcbiAgICAgICAgdmlld3BvcnRPYmplY3Q6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIHNldHRpbmdzID0gY3JlYXRlU2V0dGluZ3NWaWV3KFtvcHRpb25zLCB2aWV3ZXJTdGF0ZV0pO1xuXG4gICAgLy8gQWxpYXNlcyBmb3IgY29tcGF0aWJpbHR5XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbEhlaWdodDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdpZHRoIG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbFdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnZpZXdwb3J0LndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9uc1ZhbGlkYXRvciA9IG5ldyBWYWxpZGF0aW9uUnVubmVyKHtcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdtYW5pZmVzdCcsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLm1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcblxuICAgICAgICB2YWxpZGF0aW9uczogb3B0aW9uc1ZhbGlkYXRpb25zXG4gICAgfSk7XG5cbiAgICB2YXIgaXNWYWxpZE9wdGlvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNWYWxpZGF0b3IuaXNWYWxpZChrZXksIHZhbHVlLCB2aWV3ZXJTdGF0ZS5vcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UGFnZURhdGEgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhdHRyaWJ1dGUpXG4gICAge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XS5kW3NldHRpbmdzLnpvb21MZXZlbF1bYXR0cmlidXRlXTtcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgc29tZSBzZXR0aW5ncyBhbmQgZW1wdHkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGNsZWFyVmlld2VyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IDA7XG5cbiAgICAgICAgLy8gQ2xlYXIgYWxsIHRoZSB0aW1lb3V0cyB0byBwcmV2ZW50IHVuZGVzaXJlZCBwYWdlcyBmcm9tIGxvYWRpbmdcbiAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNldHRpbmdzIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gTG9hZCB0aGUgdmlld2VyLFxuICAgICAqIGZpcmUgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBjaGFuZ2VkIG9wdGlvbnMuXG4gICAgICovXG4gICAgdmFyIHJlbG9hZFZpZXdlciA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIHF1ZXVlZEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zVmFsaWRhdG9yLmdldFZhbGlkYXRlZE9wdGlvbnMoc2V0dGluZ3MsIG5ld09wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgem9vbSBsZXZlbCBpZiB2YWxpZCBhbmQgZmlyZSBhIFpvb21MZXZlbERpZENoYW5nZSBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnem9vbUxldmVsJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9sZFpvb21MZXZlbCA9IHNldHRpbmdzLnpvb21MZXZlbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3T3B0aW9ucy56b29tTGV2ZWw7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3T3B0aW9ucy56b29tTGV2ZWxdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgcGFnZXMgcGVyIHJvdyBpZiB2YWxpZCBhbmQgZmlyZSBhbiBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAncGFnZXNQZXJSb3cnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5wYWdlc1BlclJvdyA9IG5ld09wdGlvbnMucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJHcmlkUm93TnVtYmVyRGlkQ2hhbmdlXCIsIG5ld09wdGlvbnMucGFnZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB2ZXJ0aWNhbGx5T3JpZW50ZWQgKG5vIGV2ZW50IGZpcmVkKVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAndmVydGljYWxseU9yaWVudGVkJykpXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLnZlcnRpY2FsbHlPcmllbnRlZCA9IG5ld09wdGlvbnMudmVydGljYWxseU9yaWVudGVkO1xuXG4gICAgICAgIC8vIFNob3cvSGlkZSBub24tcGFnZWQgcGFnZXNcbiAgICAgICAgaWYgKGhhc0NoYW5nZWRPcHRpb24obmV3T3B0aW9ucywgJ3Nob3dOb25QYWdlZFBhZ2VzJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuc2hvd05vblBhZ2VkUGFnZXMgPSBuZXdPcHRpb25zLnNob3dOb25QYWdlZFBhZ2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHBhZ2UgcG9zaXRpb24gKG5vIGV2ZW50IGZpcmVkIGhlcmUpXG4gICAgICAgIGlmICgnZ29EaXJlY3RseVRvJyBpbiBuZXdPcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmdvRGlyZWN0bHlUbyA9IG5ld09wdGlvbnMuZ29EaXJlY3RseVRvO1xuXG4gICAgICAgICAgICBpZiAoJ3ZlcnRpY2FsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0ID0gbmV3T3B0aW9ucy52ZXJ0aWNhbE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKCdob3Jpem9udGFsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBuZXdPcHRpb25zLmhvcml6b250YWxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgdG8gcmVtYWluIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkdyaWQnKSB8fCBoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkJvb2tMYXlvdXQnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCdpbkdyaWQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkdyaWQgPSBuZXdPcHRpb25zLmluR3JpZDtcblxuICAgICAgICAgICAgaWYgKCdpbkJvb2tMYXlvdXQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkJvb2tMYXlvdXQgPSBuZXdPcHRpb25zLmluQm9va0xheW91dDtcblxuICAgICAgICAgICAgcXVldWVkRXZlbnRzLnB1c2goW1wiVmlld0RpZFN3aXRjaFwiLCBzZXR0aW5ncy5pbkdyaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHByZXBhcmVNb2RlQ2hhbmdlKCkgZGVwZW5kcyBvbiBpbkdyaWQgYW5kIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsT2Zmc2V0IChmb3Igbm93KVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnaW5GdWxsc2NyZWVuJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuaW5GdWxsc2NyZWVuID0gbmV3T3B0aW9ucy5pbkZ1bGxzY3JlZW47XG4gICAgICAgICAgICBwcmVwYXJlTW9kZUNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHF1ZXVlZEV2ZW50cy5wdXNoKFtcIk1vZGVEaWRTd2l0Y2hcIiwgc2V0dGluZ3MuaW5GdWxsc2NyZWVuXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgICAgICB1cGRhdGVWaWV3SGFuZGxlckFuZFJlbmRlcmluZygpO1xuXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5yZW5kZXJlcilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhlIHVzYWdlIG9mIHBhZGRpbmcgdmFyaWFibGVzIGlzIHN0aWxsIHJlYWxseVxuICAgICAgICAgICAgLy8gbWVzc3kgYW5kIGluY29uc2lzdGVudFxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHBhZ2VMYXlvdXRzOiBnZXRQYWdlTGF5b3V0cyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgcGFkZGluZzogZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIG1heFpvb21MZXZlbDogc2V0dGluZ3MuaW5HcmlkID8gbnVsbCA6IHZpZXdlclN0YXRlLm1hbmlmZXN0Lm1heFpvb20sXG4gICAgICAgICAgICAgICAgdmVydGljYWxseU9yaWVudGVkOiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgfHwgc2V0dGluZ3MuaW5HcmlkLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiBzZXR0aW5ncy5pbkdyaWQgPyBudWxsIDogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmdvRGlyZWN0bHlUbyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZVByb3ZpZGVyID0gZ2V0Q3VycmVudFNvdXJjZVByb3ZpZGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gT2JqZWN0LmtleXMocmVuZGVyZXJDb25maWcpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgIT09ICdwYWdlTGF5b3V0cycgJiYga2V5ICE9PSAncGFkZGluZyc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyZXJDb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWxvYWQgd2l0aCAlcycsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sb2FkKHJlbmRlcmVyQ29uZmlnLCB2aWV3cG9ydFBvc2l0aW9uLCBzb3VyY2VQcm92aWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1zKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaGFzQ2hhbmdlZE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4ga2V5IGluIG9wdGlvbnMgJiYgb3B0aW9uc1trZXldICE9PSBzZXR0aW5nc1trZXldO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGVzIHN3aXRjaGluZyBpbiBhbmQgb3V0IG9mIGZ1bGxzY3JlZW4gbW9kZVxuICAgIHZhciBwcmVwYXJlTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBjbGFzc2VzXG4gICAgICAgIHZhciBjaGFuZ2VDbGFzcyA9IG9wdGlvbnMuaW5GdWxsc2NyZWVuID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHZpZXdlclN0YXRlLm91dGVyT2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsc2NyZWVuJyk7XG4gICAgICAgICQoJ2JvZHknKVtjaGFuZ2VDbGFzc10oJ2RpdmEtaGlkZS1zY3JvbGxiYXInKTtcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsLXdpZHRoJyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IERpdmEncyBpbnRlcm5hbCBwYW5lbCBzaXplLCBrZWVwaW5nIHRoZSBvbGQgdmFsdWVzXG4gICAgICAgIHZhciBzdG9yZWRIZWlnaHQgPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgdmFyIHN0b3JlZFdpZHRoID0gc2V0dGluZ3MucGFuZWxXaWR0aDtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIG9yaWdpbmFsIGxvYWQsIHRoZSBvZmZzZXRzIG1hdHRlciwgYW5kIHRoZSBwb3NpdGlvbiBpc24ndCBiZWluZyBjaGFuZ2VkLi4uXG4gICAgICAgIGlmICghdmlld2VyU3RhdGUubG9hZGVkICYmICFzZXR0aW5ncy5pbkdyaWQgJiYgISgndmVydGljYWxPZmZzZXQnIGluIG9wdGlvbnMpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2dldCB0aGUgdXBkYXRlZCBwYW5lbCBzaXplXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2V0dGluZ3MucGFuZWxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBzZXR0aW5ncy5wYW5lbFdpZHRoO1xuXG4gICAgICAgICAgICAvL2FuZCByZS1jZW50ZXIgdGhlIG5ldyBwYW5lbCBvbiB0aGUgc2FtZSBwb2ludFxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgKz0gKChzdG9yZWRIZWlnaHQgLSBuZXdIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0ICs9ICgoc3RvcmVkV2lkdGggLSBuZXdXaWR0aCkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdHVybiBvbi9vZmYgZXNjYXBlIGtleSBsaXN0ZW5lclxuICAgICAgICBpZiAob3B0aW9ucy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBoYW5kbGVyIGFuZCB0aGUgdmlldyByZW5kZXJpbmcgZm9yIHRoZSBjdXJyZW50IHZpZXdcbiAgICB2YXIgdXBkYXRlVmlld0hhbmRsZXJBbmRSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIEhhbmRsZXIgPSBzZXR0aW5ncy5pbkdyaWQgPyBHcmlkSGFuZGxlciA6IERvY3VtZW50SGFuZGxlcjtcblxuICAgICAgICBpZiAodmlld2VyU3RhdGUudmlld0hhbmRsZXIgJiYgISh2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciBpbnN0YW5jZW9mIEhhbmRsZXIpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnZpZXdIYW5kbGVyKVxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIgPSBuZXcgSGFuZGxlcihzZWxmKTtcblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgaW5pdGlhbGl6ZVJlbmRlcmVyKCk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgcHJvYmFibHkgYmUgZG9uZSB1cG9uIFZpZXdlckNvcmUgaW5pdGlhbGl6YXRpb25cbiAgICB2YXIgaW5pdGlhbGl6ZVJlbmRlcmVyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjb21wYXRFcnJvcnMgPSBSZW5kZXJlci5nZXRDb21wYXRpYmlsaXR5RXJyb3JzKCk7XG5cbiAgICAgICAgaWYgKGNvbXBhdEVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgc2hvd0Vycm9yKGNvbXBhdEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogdmlld2VyU3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAgICAgb3V0ZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5vdXRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5uZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBob29rcyA9IHtcbiAgICAgICAgICAgICAgICBvblZpZXdXaWxsTG9hZDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld1dpbGxMb2FkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRMb2FkOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZExvYWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uVmlld0RpZFVwZGF0ZTogZnVuY3Rpb24gKHBhZ2VzLCB0YXJnZXRQYWdlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZFVwZGF0ZShwYWdlcywgdGFyZ2V0UGFnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhZ2VXaWxsTG9hZDogZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2goJ1BhZ2VXaWxsTG9hZCcsIHBhZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIob3B0aW9ucywgaG9va3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRDdXJyZW50U291cmNlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyaWRTb3VyY2VQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBnZXRBbGxab29tTGV2ZWxzRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2dyaWRTb3VyY2VQcm92aWRlci5nZXRCZXN0Wm9vbUxldmVsRm9yUGFnZShwYWdlKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRCZXN0Wm9vbUxldmVsRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVVJMKHBhZ2UuaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlLmRpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbDogMSwgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsOiAxLCAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZS5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBncmlkU291cmNlUHJvdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlsZURpbWVucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXR0aW5ncy50aWxlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLnRpbGVIZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0QmVzdFpvb21MZXZlbEZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5nZXRQYWdlSW1hZ2VUaWxlcyhwYWdlLmluZGV4LCBNYXRoLmNlaWwoc2V0dGluZ3Muem9vbUxldmVsKSwgdGlsZURpbWVucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QWxsWm9vbUxldmVsc0ZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBsZXZlbENvdW50ID0gdmlld2VyU3RhdGUubWFuaWZlc3QubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsZXZlbD0wOyBsZXZlbCA8PSBsZXZlbENvdW50OyBsZXZlbCsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzLnB1c2goc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVGlsZXMocGFnZS5pbmRleCwgbGV2ZWwsIHRpbGVEaW1lbnMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFBhZGRpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcsIGxlZnRQYWRkaW5nO1xuICAgICAgICB2YXIgZG9jVlBhZGRpbmcsIGRvY0hQYWRkaW5nO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRvY1ZQYWRkaW5nID0gc2V0dGluZ3MuZml4ZWRQYWRkaW5nO1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IGxlZnRQYWRkaW5nID0gZG9jSFBhZGRpbmcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA6IDA7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IDAgOiB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICAgICAgZG9jVlBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyAwIDogdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgZG9jSFBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGRvY1ZQYWRkaW5nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZG9jVlBhZGRpbmcsXG4gICAgICAgICAgICAgICAgbGVmdDogZG9jSFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGRvY0hQYWRkaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wUGFkZGluZyxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBhZ2VPdmVybGF5cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5wYWdlT3ZlcmxheXMudXBkYXRlT3ZlcmxheXModmlld2VyU3RhdGUucmVuZGVyZXIuZ2V0UmVuZGVyZWRQYWdlcygpKTtcbiAgICB9O1xuXG4gICAgLy9TaG9ydGN1dCBmb3IgY2xvc2luZyBmdWxsc2NyZWVuIHdpdGggdGhlIGVzY2FwZSBrZXlcbiAgICB2YXIgZXNjYXBlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSlcbiAgICB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgaW5GdWxsc2NyZWVuOiAhc2V0dGluZ3MuaW5GdWxsc2NyZWVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYWxsZWQgdG8gaGFuZGxlIGFueSB6b29tIGxldmVsXG4gICAgdmFyIGhhbmRsZVpvb20gPSBmdW5jdGlvbiAobmV3Wm9vbUxldmVsLCBmb2NhbFBvaW50KVxuICAgIHtcbiAgICAgICAgLy8gSWYgdGhlIHpvb20gbGV2ZWwgcHJvdmlkZWQgaXMgaW52YWxpZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICghaXNWYWxpZE9wdGlvbignem9vbUxldmVsJywgbmV3Wm9vbUxldmVsKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBJZiBubyBmb2NhbCBwb2ludCB3YXMgZ2l2ZW4sIHpvb20gb24gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgaWYgKGZvY2FsUG9pbnQgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyU3RhdGUudmlld3BvcnQ7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlZ2lvbiA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlUmVnaW9uKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICBmb2NhbFBvaW50ID0ge1xuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICh2aWV3cG9ydC53aWR0aCAvIDIpIC0gKGN1cnJlbnRSZWdpb24ubGVmdCAtIHZpZXdwb3J0LmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICh2aWV3cG9ydC5oZWlnaHQgLyAyKSAtIChjdXJyZW50UmVnaW9uLnRvcCAtIHZpZXdwb3J0LnRvcClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2VSZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihmb2NhbFBvaW50LmFuY2hvclBhZ2UpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGN1cnNvciBjb29yZGluYXRlcyB0byBjZW50ZXIgb2Ygdmlld3BvcnRcbiAgICAgICAgdmFyIGZvY2FsWFRvQ2VudGVyID0gKHBhZ2VSZWdpb24ubGVmdCArIGZvY2FsUG9pbnQub2Zmc2V0LmxlZnQpIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC5sZWZ0ICsgKHNldHRpbmdzLnZpZXdwb3J0LndpZHRoIC8gMikpO1xuICAgICAgICB2YXIgZm9jYWxZVG9DZW50ZXIgPSAocGFnZVJlZ2lvbi50b3AgKyBmb2NhbFBvaW50Lm9mZnNldC50b3ApIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC50b3AgKyAoc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21SYXRpbyA9IE1hdGgucG93KDIsIHpvb21MZXZlbCAtIGluaXRpYWxab29tTGV2ZWwpO1xuXG4gICAgICAgICAgICAvL1RPRE8oamVyb21lcGwpOiBDYWxjdWxhdGUgcG9zaXRpb24gZnJvbSBwYWdlIHRvcCBsZWZ0IHRvIHZpZXdwb3J0IHRvcCBsZWZ0XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaG9yaXpvbnRhbC92ZXJ0aWNhbE9mZnNldDogZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXIgdG8gcGFnZSB1cHBlciBsZWZ0IGNvcm5lclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSAoZm9jYWxQb2ludC5vZmZzZXQubGVmdCAqIHpvb21SYXRpbykgLSBmb2NhbFhUb0NlbnRlcjtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IChmb2NhbFBvaW50Lm9mZnNldC50b3AgKiB6b29tUmF0aW8pIC0gZm9jYWxZVG9DZW50ZXI7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgYW5jaG9yUGFnZTogZm9jYWxQb2ludC5hbmNob3JQYWdlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRpYWxab29tTGV2ZWwgPSB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3Wm9vbUxldmVsO1xuXG4gICAgICAgIHZhciBlbmRQb3NpdGlvbiA9IGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKG5ld1pvb21MZXZlbCk7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gZW5kUG9zaXRpb24uYW5jaG9yUGFnZTtcbiAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgPSBlbmRQb3NpdGlvbi52ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldCA9IGVuZFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQ7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIudHJhbnNpdGlvblZpZXdwb3J0UG9zaXRpb24oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogaW5pdGlhbFpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ld1pvb21MZXZlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBhcmFtZXRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHBhcmFtZXRlcnMuem9vbUxldmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGluZm8pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Quc2Nyb2xsKHNjcm9sbEZ1bmN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmludGVycnVwdGVkKVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBuZXdab29tTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2xpZGVyXG4gICAgICAgIHB1Ymxpc2goXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3Wm9vbUxldmVsKTtcblxuICAgICAgICAvLyBXaGlsZSB6b29taW5nLCBkb24ndCB1cGRhdGUgc2Nyb2xsIG9mZnNldHMgYmFzZWQgb24gdGhlIHNjYWxlZCB2ZXJzaW9uIG9mIGRpdmEtaW5uZXJcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Qub2ZmKCdzY3JvbGwnKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgR2V0cyB0aGUgWS1vZmZzZXQgZm9yIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBzcGVjaWZpYyBwYWdlXG4gICAgIEFjY2VwdGFibGUgdmFsdWVzIGZvciBcImFuY2hvclwiOlxuICAgICBcInRvcFwiIChkZWZhdWx0KSAtIHdpbGwgYW5jaG9yIHRvcCBvZiB0aGUgcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBkaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgXCJib3R0b21cIiAtIHRvcCwgcy90b3AvYm90dG9tXG4gICAgIFwiY2VudGVyXCIgLSB3aWxsIGNlbnRlciB0aGUgcGFnZSBvbiB0aGUgZGl2YSBlbGVtZW50XG4gICAgIFJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YS1vdXRlciBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZSBmb3IgdGhlIHNwZWNpZmllZCBhbmNob3JcbiAgICAgKi9cbiAgICB2YXIgZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGFuY2hvcilcbiAgICB7XG4gICAgICAgIHBhZ2VJbmRleCA9ICh0eXBlb2YocGFnZUluZGV4KSA9PT0gXCJ1bmRlZmluZWRcIiA/IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggOiBwYWdlSW5kZXgpO1xuXG4gICAgICAgIGlmIChhbmNob3IgPT09IFwiY2VudGVyXCIgfHwgYW5jaG9yID09PSBcImNlbnRyZVwiKSAvL2hvdyB5b3UgY2FuIHRlbGwgYW4gQW1lcmljYW4gY29kZWQgdGhpc1xuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcImJvdHRvbVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLSBzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1NhbWUgYXMgZ2V0WU9mZnNldCB3aXRoIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIgYXMgYWNjZXB0YWJsZSB2YWx1ZXMgaW5zdGVhZCBvZiBcInRvcFwiIGFuZCBcImJvdHRvbVwiXG4gICAgdmFyIGdldFhPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhbmNob3IpXG4gICAge1xuICAgICAgICBwYWdlSW5kZXggPSAodHlwZW9mKHBhZ2VJbmRleCkgPT09IFwidW5kZWZpbmVkXCIgPyBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4IDogcGFnZUluZGV4KTtcblxuICAgICAgICBpZiAoYW5jaG9yID09PSBcImxlZnRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcInJpZ2h0XCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChnZXRQYWdlRGF0YShwYWdlSW5kZXgsIFwid1wiKSAtIHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcIndcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlcyBwYW5lbEhlaWdodC9wYW5lbFdpZHRoIG9uIHJlc2l6ZVxuICAgIHZhciB1cGRhdGVQYW5lbFNpemUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgc2hvdWxkIHJlYWxseSBvbmx5IGJlIGNhbGxlZCBhZnRlciBpbml0aWFsIGxvYWRcbiAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nb3RvKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0LCB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlT2Zmc2V0cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG5cbiAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbE9mZnNldCA9IHBhZ2VPZmZzZXQueTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCaW5kIG1vdXNlIGV2ZW50cyAoZHJhZyB0byBzY3JvbGwsIGRvdWJsZS1jbGljaylcbiAgICB2YXIgYmluZE1vdXNlRXZlbnRzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gU2V0IGRyYWcgc2Nyb2xsIG9uIGZpcnN0IGRlc2NlbmRhbnQgb2YgY2xhc3MgZHJhZ2dlciBvbiBib3RoIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHZpZXdlclN0YXRlLmlubmVyT2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZUNsaWNrKHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LCBmdW5jdGlvbiAoZXZlbnQsIGNvb3JkcylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVidWcoJ0RvdWJsZSBjbGljayBhdCAlcywgJXMnLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5vbkRvdWJsZUNsaWNrKGV2ZW50LCBjb29yZHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdXBkYXRlUGFuZWxTaXplKCk7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcHJldmlvdXNseS1zZXQgcmVzaXplIHRpbWVvdXRzXG4gICAgICAgIGNsZWFyVGltZW91dCh2aWV3ZXJTdGF0ZS5yZXNpemVUaW1lcik7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0LmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZpZXdwb3J0KTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZ29EaXJlY3RseVRvOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogcGFnZU9mZnNldC55LFxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBwYWdlT2Zmc2V0LnhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICBnb0RpcmVjdGx5VG86IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9O1xuXG4gICAgLy8gQmluZCB0b3VjaCBhbmQgb3JpZW50YXRpb24gY2hhbmdlIGV2ZW50c1xuICAgIHZhciBiaW5kVG91Y2hFdmVudHMgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICAvLyBCbG9jayB0aGUgdXNlciBmcm9tIG1vdmluZyB0aGUgd2luZG93IG9ubHkgaWYgaXQncyBub3QgaW50ZWdyYXRlZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYmxvY2tNb2JpbGVNb3ZlKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCdib2R5JykuYmluZCgndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlID0gZXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvdWNoIGV2ZW50cyBmb3Igc3dpcGluZyBpbiB0aGUgdmlld3BvcnQgdG8gc2Nyb2xsIHBhZ2VzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmtpbmV0aWMoe1xuICAgICAgICAgICAgdHJpZ2dlckhhcmR3YXJlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdlc3R1cmVFdmVudHMub25QaW5jaCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMsIHN0YXJ0LCBlbmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdQaW5jaCAlcyBhdCAlcywgJXMnLCBlbmQgLSBzdGFydCwgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIub25QaW5jaChldmVudCwgY29vcmRzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZVRhcCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdEb3VibGUgdGFwIGF0ICVzLCAlcycsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uRG91YmxlQ2xpY2soZXZlbnQsIGNvb3Jkcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGhlIHNjcm9sbFxuICAgIHZhciBzY3JvbGxGdW5jdGlvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcHJldmlvdXNUb3BTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBwcmV2aW91c0xlZnRTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5sZWZ0O1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBuZXdTY3JvbGxMZWZ0ID0gdmlld2VyU3RhdGUudmlld3BvcnQubGVmdDtcblxuICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkIHx8IHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ld1Njcm9sbFRvcCAtIHByZXZpb3VzVG9wU2Nyb2xsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXdTY3JvbGxMZWZ0IC0gcHJldmlvdXNMZWZ0U2Nyb2xsO1xuXG4gICAgICAgIC8vZ2l2ZSBhZGp1c3QgdGhlIGRpcmVjdGlvbiB3ZSBjYXJlIGFib3V0XG4gICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmFkanVzdChkaXJlY3Rpb24pO1xuXG4gICAgICAgIHZhciBwcmltYXJ5U2Nyb2xsID0gKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCB8fCBzZXR0aW5ncy5pbkdyaWQpID8gbmV3U2Nyb2xsVG9wIDogbmV3U2Nyb2xsTGVmdDtcblxuICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsXCIsIHByaW1hcnlTY3JvbGwpO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsRG93blwiLCBwcmltYXJ5U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsVXBcIiwgcHJpbWFyeVNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgfTtcblxuICAgIC8vIEJpbmRzIG1vc3Qgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIChzb21lIG1vcmUgaW4gY3JlYXRlVG9vbGJhcilcbiAgICB2YXIgaGFuZGxlRXZlbnRzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3Vyc29yIGZvciBkcmFnZ2luZ1xuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5tb3VzZWRvd24oZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QuYWRkQ2xhc3MoJ2RpdmEtZ3JhYmJpbmcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QubW91c2V1cChmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5yZW1vdmVDbGFzcygnZGl2YS1ncmFiYmluZycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiaW5kTW91c2VFdmVudHMoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdC5zY3JvbGwoc2Nyb2xsRnVuY3Rpb24pO1xuXG4gICAgICAgIHZhciB1cEFycm93S2V5ID0gMzgsXG4gICAgICAgICAgICBkb3duQXJyb3dLZXkgPSA0MCxcbiAgICAgICAgICAgIGxlZnRBcnJvd0tleSA9IDM3LFxuICAgICAgICAgICAgcmlnaHRBcnJvd0tleSA9IDM5LFxuICAgICAgICAgICAgc3BhY2VLZXkgPSAzMixcbiAgICAgICAgICAgIHBhZ2VVcEtleSA9IDMzLFxuICAgICAgICAgICAgcGFnZURvd25LZXkgPSAzNCxcbiAgICAgICAgICAgIGhvbWVLZXkgPSAzNixcbiAgICAgICAgICAgIGVuZEtleSA9IDM1O1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSBrZXkgcHJlc3NlcyBpbiBkb2N1bWVudFxuICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5ZG93bi5kaXZhJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3BhY2Ugb3IgcGFnZSBkb3duIC0gZ28gdG8gdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5lbmFibGVTcGFjZVNjcm9sbCAmJiAhZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpIHx8IChzZXR0aW5ncy5lbmFibGVLZXlTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gcGFnZURvd25LZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZUtleVNjcm9sbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGVhbCBrZXlib2FyZCBzaG9ydGN1dHMgKG1ldGFLZXkgPSBjb21tYW5kIFtPUyBYXSwgc3VwZXIgW1dpbi9MaW51eF0pXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHBhZ2VVcEtleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgdXAgLSBnbyB0byB0aGUgcHJldmlvdXMgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQudG9wIC09IHNldHRpbmdzLnBhbmVsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdXBBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwIGFycm93IC0gc2Nyb2xsIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgLT0gc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkb3duQXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3duIGFycm93IC0gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGxlZnRBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYXJyb3cgLSBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCAtPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIHJpZ2h0QXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBhcnJvdyAtIHNjcm9sbCByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb21lIGtleSAtIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZW5kS2V5OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGtleSAtIGdvIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBvbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSB2YWx1ZSBiZWluZyBub3JtYWxpemVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LmxlZnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRUZXJtaW5hdGUnLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5ZG93bi5kaXZhJyk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICBiaW5kVG91Y2hFdmVudHMoKTtcblxuICAgICAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6aW5nIGV2ZW50c1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICAvLyBIYW5kbGUgb3JpZW50YXRpb24gY2hhbmdlIHNlcGFyYXRlbHlcbiAgICAgICAgaWYgKCdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24oKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBzZXR0aW5ncy5JRCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1BhbmVsU2l6ZURpZENoYW5nZScsIHVwZGF0ZVBhbmVsU2l6ZSwgc2V0dGluZ3MuSUQpO1xuXG4gICAgICAgIC8vIENsZWFyIHBhZ2UgYW5kIHJlc2l6ZSB0aW1lb3V0cyB3aGVuIHRoZSB2aWV3ZXIgaXMgZGVzdHJveWVkXG4gICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgfSwgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gQWRkIGFsbCB0aGUgcGx1Z2lucyB0aGF0IGhhdmUgbm90IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCB0b1xuICAgICAgICAvLyBzZXR0aW5ncy5wbHVnaW5zXG4gICAgICAgIFBsdWdpblJlZ2lzdHJ5LmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBsdWdpblByb3Blck5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgcGx1Z2luLnBsdWdpbk5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NbJ2VuYWJsZScgKyBwbHVnaW5Qcm9wZXJOYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBpbml0IGZ1bmN0aW9uIGFuZCBjaGVjayByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZW5hYmxlUGx1Z2luID0gcGx1Z2luLmluaXQoc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGludCByZXR1cm5zIGZhbHNlLCBjb25zaWRlciB0aGUgcGx1Z2luIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVQbHVnaW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGFnZVRvb2xzIGJhciBpZiBoYW5kbGVDbGljayBpcyBzZXQgdG8gYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmhhbmRsZUNsaWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucGFnZVRvb2xzLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gc2V0dGluZ3MucGx1Z2lucyBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNob3dUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS50aHJvYmJlclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICd0aHJvYmJlcicpLnNob3coKTtcbiAgICAgICAgfSwgc2V0dGluZ3MudGhyb2JiZXJUaW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdmFyIGhpZGVUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBDbGVhciB0aGUgdGltZW91dCwgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldFxuICAgICAgICBjbGVhclRpbWVvdXQodmlld2VyU3RhdGUudGhyb2JiZXJUaW1lb3V0SUQpO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIHRocm9iYmVyIGlmIGl0IGhhcyBhbHJlYWR5IGV4ZWN1dGVkXG4gICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5oaWRlKCk7XG4gICAgfTtcblxuICAgIHZhciBzaG93RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdlcnJvcicpLCBbXG4gICAgICAgICAgICBlbHQoJ2J1dHRvbicsIGVsZW1BdHRycygnZXJyb3ItY2xvc2UnLCB7J2FyaWEtbGFiZWwnOiAnQ2xvc2UgZGlhbG9nJ30pKSxcbiAgICAgICAgICAgIGVsdCgncCcsXG4gICAgICAgICAgICAgICAgZWx0KCdzdHJvbmcnLCAnRXJyb3InKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgbWVzc2FnZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QuYXBwZW5kKGVycm9yRWxlbWVudCk7XG5cbiAgICAgICAgLy9iaW5kIGRpYWxvZyBjbG9zZSBidXR0b25cbiAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdlcnJvci1jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZXJyb3JFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgaXNJSUlGLCBsb2FkT3B0aW9ucylcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbiAgICAgICAgLy8gRklYTUU6IGlzIGlzSUlJRiBldmVuIG5lZWRlZD9cbiAgICAgICAgdmlld2VyU3RhdGUuaXNJSUlGID0gaXNJSUlGO1xuXG4gICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgIC8vIENvbnZlbmllbmNlIHZhbHVlXG4gICAgICAgIHZpZXdlclN0YXRlLm51bVBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgIG9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGUodmlld2VyU3RhdGUub3B0aW9ucyk7XG5cbiAgICAgICAgcHVibGlzaCgnTnVtYmVyT2ZQYWdlc0RpZENoYW5nZScsIHNldHRpbmdzLm51bVBhZ2VzKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlQXV0b1RpdGxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoJChzZXR0aW5ncy5zZWxlY3RvciArICd0aXRsZScpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3RpdGxlJykuaHRtbChzZXR0aW5ncy5tYW5pZmVzdC5pdGVtVGl0bGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBhcmVudE9iamVjdC5wcmVwZW5kKGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0aXRsZScpLCBbc2V0dGluZ3MubWFuaWZlc3QuaXRlbVRpdGxlXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBpbnRlci1wYWdlIHBhZGRpbmcgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGF2ZXJhZ2Ugem9vbSBsZXZlbFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWRhcHRpdmVQYWRkaW5nID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmZsb29yKChzZXR0aW5ncy5taW5ab29tTGV2ZWwgKyBzZXR0aW5ncy5tYXhab29tTGV2ZWwpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHBhcnNlSW50KHNldHRpbmdzLm1hbmlmZXN0LmdldEF2ZXJhZ2VXaWR0aCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nID0gcGFyc2VJbnQoc2V0dGluZ3MubWFuaWZlc3QuZ2V0QXZlcmFnZUhlaWdodCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSXQncyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMDsgdXNlIGZpeGVkUGFkZGluZyBpbnN0ZWFkXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGljYWwgcGFkZGluZyBpcyBhdCBsZWFzdCA0MCwgaWYgcGx1Z2luIGljb25zIGFyZSBlbmFibGVkXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5wYWdlVG9vbHMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbFBhZGRpbmcgPSBNYXRoLm1heCg0MCwgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRldGVjdCBhIHZpZXdpbmdIaW50IG9mICdwYWdlZCcgaW4gdGhlIG1hbmlmZXN0IG9yIHNlcXVlbmNlLCBlbmFibGUgYm9vayB2aWV3IGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmluQm9va0xheW91dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbHVnaW4gc2V0dXAgaG9va3Mgc2hvdWxkIGJlIGJvdW5kIHRvIHRoZSBPYmplY3REaWRMb2FkIGV2ZW50XG4gICAgICAgIHB1Ymxpc2goJ09iamVjdERpZExvYWQnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSBkb2N1bWVudCBwYW5lbCBkaW1lbnNpb25zXG4gICAgICAgIHVwZGF0ZVBhbmVsU2l6ZSgpO1xuXG4gICAgICAgIHZhciBuZWVkc1hDb29yZCwgbmVlZHNZQ29vcmQ7XG5cbiAgICAgICAgdmFyIGFuY2hvcmVkVmVydGljYWxseSA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jaG9yZWRIb3Jpem9udGFsbHkgPSBmYWxzZTtcblxuICAgICAgICBpZiAobG9hZE9wdGlvbnMuZ29EaXJlY3RseVRvID09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbyA9IHNldHRpbmdzLmdvRGlyZWN0bHlUbztcbiAgICAgICAgICAgIG5lZWRzWENvb3JkID0gbmVlZHNZQ29vcmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgbmVlZHNYQ29vcmQgPSBsb2FkT3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID09IG51bGwgfHwgaXNOYU4obG9hZE9wdGlvbnMuaG9yaXpvbnRhbE9mZnNldCk7XG4gICAgICAgICAgICBuZWVkc1lDb29yZCA9IGxvYWRPcHRpb25zLnZlcnRpY2FsT2Zmc2V0ID09IG51bGwgfHwgaXNOYU4obG9hZE9wdGlvbnMudmVydGljYWxPZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIGZvciB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgb2Zmc2V0c1xuICAgICAgICBpZiAobmVlZHNYQ29vcmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBXaGF0IGlmIGluQm9va0xheW91dC92ZXJ0aWNhbGx5T3JpZW50ZWQgaXMgY2hhbmdlZCBieSBsb2FkT3B0aW9ucz9cbiAgICAgICAgICAgIGlmIChsb2FkT3B0aW9ucy5nb0RpcmVjdGx5VG8gPT09IDAgJiYgc2V0dGluZ3MuaW5Cb29rTGF5b3V0ICYmIHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpbiBib29rIGxheW91dCwgY2VudGVyIHRoZSBmaXJzdCBvcGVuaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBsb2FkT3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID0gdmlld2VyU3RhdGUuaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYW5jaG9yZWRIb3Jpem9udGFsbHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxvYWRPcHRpb25zLmhvcml6b250YWxPZmZzZXQgPSBnZXRYT2Zmc2V0KGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbywgXCJjZW50ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNZQ29vcmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFuY2hvcmVkVmVydGljYWxseSA9IHRydWU7XG4gICAgICAgICAgICBsb2FkT3B0aW9ucy52ZXJ0aWNhbE9mZnNldCA9IGdldFlPZmZzZXQobG9hZE9wdGlvbnMuZ29EaXJlY3RseVRvLCBcInRvcFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbG9hZFZpZXdlcihsb2FkT3B0aW9ucyk7XG5cbiAgICAgICAgLy9wcmVwIGRpbWVuc2lvbnMgb25lIGxhc3QgdGltZSBub3cgdGhhdCBwYWdlcyBoYXZlIGxvYWRlZFxuICAgICAgICB1cGRhdGVQYW5lbFNpemUoKTtcblxuICAgICAgICAvLyBGSVhNRTogVGhpcyBpcyBhIGhhY2sgdG8gZW5zdXJlIHRoYXQgdGhlIG91dGVyRWxlbWVudCBzY3JvbGxiYXJzIGFyZSB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgICAgaWYgKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlubmVyRWxlbWVudC5zdHlsZS5taW5XaWR0aCA9IHNldHRpbmdzLnBhbmVsV2lkdGggKyAncHgnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnQuc3R5bGUubWluSGVpZ2h0ID0gc2V0dGluZ3MucGFuZWxIZWlnaHQgKyAncHgnO1xuXG4gICAgICAgIC8vIEZJWE1FOiBJZiB0aGUgcGFnZSB3YXMgc3VwcG9zZWQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgd2UgbmVlZCB0b1xuICAgICAgICAvLyByZWNhbGN1bGF0ZSBpdCB0byB0YWtlIGludG8gYWNjb3VudCB0aGUgc2Nyb2xsYmFyc1xuICAgICAgICBpZiAoYW5jaG9yZWRWZXJ0aWNhbGx5IHx8IGFuY2hvcmVkSG9yaXpvbnRhbGx5KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yZWRWZXJ0aWNhbGx5KVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0ID0gZ2V0WU9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCBcInRvcFwiKTtcblxuICAgICAgICAgICAgaWYgKGFuY2hvcmVkSG9yaXpvbnRhbGx5KVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBnZXRYT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIFwiY2VudGVyXCIpO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nb3RvKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0LCB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpZ25hbCB0aGF0IGV2ZXJ5dGhpbmcgc2hvdWxkIGJlIHNldCB1cCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICAgIHZpZXdlclN0YXRlLmxvYWRlZCA9IHRydWU7XG5cbiAgICAgICAgcHVibGlzaChcIlZpZXdlckRpZExvYWRcIiwgc2V0dGluZ3MpO1xuICAgIH07XG5cbiAgICB2YXIgcHVibGlzaCA9IGZ1bmN0aW9uIChldmVudClcbiAgICB7XG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaChldmVudCwgYXJncywgcHVibGljSW5zdGFuY2UpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBGaXJzdCBmaWd1cmUgb3V0IHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyIGluIHRoaXMgYnJvd3NlclxuICAgICAgICAvLyBUT0RPKHdhYmFpbik6IENhY2hlIHRoaXMgc29tZXdoZXJlIGVsc2VcbiAgICAgICAgLy8gT25seSBzb21lIG9mIHRoZSBwbHVnaW5zIHJlbHkgb24gdGhpcyBub3dcbiAgICAgICAgdmlld2VyU3RhdGUuc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aCgpO1xuXG4gICAgICAgIC8vIElmIHdpbmRvdy5vcmllbnRhdGlvbiBpcyBkZWZpbmVkLCB0aGVuIGl0J3MgcHJvYmFibHkgbW9iaWxlV2Via2l0XG4gICAgICAgIHZpZXdlclN0YXRlLm1vYmlsZVdlYmtpdCA9IHdpbmRvdy5vcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFuIElEIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBwcmVmaXggZm9yIGFsbCB0aGUgb3RoZXIgSURzXG4gICAgICAgIHZhciBpZE51bWJlciA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgdmlld2VyU3RhdGUuSUQgPSAnZGl2YS0nICsgaWROdW1iZXIgKyAnLSc7XG4gICAgICAgIHZpZXdlclN0YXRlLnNlbGVjdG9yID0gJyMnICsgc2V0dGluZ3MuSUQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuaGFzaFBhcmFtU3VmZml4ID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPbWl0IHRoZSBzdWZmaXggZnJvbSB0aGUgZmlyc3QgaW5zdGFuY2VcbiAgICAgICAgICAgIGlmIChpZE51bWJlciA9PT0gMSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhhc2hQYXJhbVN1ZmZpeCA9ICcnO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGFzaFBhcmFtU3VmZml4ID0gaWROdW1iZXIgKyAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW5uZXIgYW5kIG91dGVyIHBhbmVsc1xuICAgICAgICB2YXIgaW5uZXJFbGVtID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ2lubmVyJywgeyBjbGFzczogJ2RpdmEtaW5uZXIgZGl2YS1kcmFnZ2VyJyB9KSk7XG4gICAgICAgIHZhciB2aWV3cG9ydEVsZW0gPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndmlld3BvcnQnKSwgaW5uZXJFbGVtKTtcbiAgICAgICAgdmFyIG91dGVyRWxlbSA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdvdXRlcicpLFxuICAgICAgICAgICAgdmlld3BvcnRFbGVtLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ3Rocm9iYmVyJykpKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnQgPSBpbm5lckVsZW07XG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudCA9IHZpZXdwb3J0RWxlbTtcbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJFbGVtZW50ID0gb3V0ZXJFbGVtO1xuXG4gICAgICAgIHZpZXdlclN0YXRlLmlubmVyT2JqZWN0ID0gJChpbm5lckVsZW0pO1xuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCA9ICQodmlld3BvcnRFbGVtKTtcbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QgPSAkKG91dGVyRWxlbSk7XG5cbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0LmFwcGVuZChvdXRlckVsZW0pO1xuXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0ID0gbmV3IFZpZXdwb3J0KHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudCwge1xuICAgICAgICAgICAgaW50ZXJzZWN0aW9uVG9sZXJhbmNlOiBzZXR0aW5ncy52aWV3cG9ydE1hcmdpblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEbyBhbGwgdGhlIHBsdWdpbiBpbml0aWFsaXNhdGlvblxuICAgICAgICBpbml0UGx1Z2lucygpO1xuXG4gICAgICAgIGhhbmRsZUV2ZW50cygpO1xuXG4gICAgICAgIC8vIFNob3cgdGhlIHRocm9iYmVyIHdoaWxlIHdhaXRpbmcgZm9yIHRoZSBtYW5pZmVzdCB0byBsb2FkXG4gICAgICAgIHNob3dUaHJvYmJlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9O1xuXG4gICAgLy8gVGVtcG9yYXJ5IGFjY2Vzc29yIGZvciB0aGUgc3RhdGUgb2YgdGhlIHZpZXdlciBjb3JlXG4gICAgLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggYSBtb3JlIHJlc3RyaWN0ZWQgdmlldyBvZiB3aGF0ZXZlciBuZWVkc1xuICAgIC8vIGJlIGV4cG9zZWQgdGhyb3VnaCBzZXR0aW5ncyBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICAgIHRoaXMuZ2V0SW50ZXJuYWxTdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdmlld2VyU3RhdGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0luc3RhbmNlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VUb29scyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUucGFnZVRvb2xzO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEN1cnJlbnRMYXlvdXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnJlbmRlcmVyID8gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0IDogbnVsbDtcbiAgICB9O1xuXG4gICAgLyoqIEdldCBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgZGltZW5zaW9ucyAqL1xuICAgIHRoaXMuZ2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyU3RhdGUudmlld3BvcnQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogdmlld3BvcnQudG9wLFxuICAgICAgICAgICAgbGVmdDogdmlld3BvcnQubGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogdmlld3BvcnQuYm90dG9tLFxuICAgICAgICAgICAgcmlnaHQ6IHZpZXdwb3J0LnJpZ2h0LFxuXG4gICAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLmFkZFBhZ2VPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5wYWdlT3ZlcmxheXMuYWRkT3ZlcmxheShvdmVybGF5KTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVQYWdlT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUucGFnZU92ZXJsYXlzLnJlbW92ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZVJlZ2lvbiA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0O1xuICAgICAgICB2YXIgcmVnaW9uID0gbGF5b3V0LmdldFBhZ2VSZWdpb24ocGFnZUluZGV4LCBvcHRpb25zKTtcblxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmluY29ycG9yYXRlVmlld3BvcnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzZWNvbmRhcnlEaW0gPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICAgICAgICAgIGlmICh2aWV3ZXJTdGF0ZS52aWV3cG9ydFtzZWNvbmRhcnlEaW1dID4gbGF5b3V0LmRpbWVuc2lvbnNbc2Vjb25kYXJ5RGltXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jT2Zmc2V0ID0gKHZpZXdlclN0YXRlLnZpZXdwb3J0W3NlY29uZGFyeURpbV0gLSBsYXlvdXQuZGltZW5zaW9uc1tzZWNvbmRhcnlEaW1dKSAvIDI7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogcmVnaW9uLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcmVnaW9uLmJvdHRvbSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogcmVnaW9uLmxlZnQgKyBkb2NPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodDogcmVnaW9uLnJpZ2h0ICsgZG9jT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJlZ2lvbi50b3AgKyBkb2NPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJlZ2lvbi5ib3R0b20gKyBkb2NPZmZzZXQsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlZ2lvbi5yaWdodFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWdpb247XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UGFnZVBvc2l0aW9uQXRWaWV3cG9ydE9mZnNldCA9IGZ1bmN0aW9uIChjb29yZHMpXG4gICAge1xuICAgICAgICB2YXIgZG9jQ29vcmRzID0ge1xuICAgICAgICAgICAgbGVmdDogY29vcmRzLmxlZnQgKyB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wICsgdmlld2VyU3RhdGUudmlld3BvcnQudG9wXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbmRlcmVkUGFnZXMgPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nZXRSZW5kZXJlZFBhZ2VzKCk7XG4gICAgICAgIHZhciBwYWdlQ291bnQgPSByZW5kZXJlZFBhZ2VzLmxlbmd0aDtcblxuICAgICAgICAvLyBGaW5kIHRoZSBwYWdlIG9uIHdoaWNoIHRoZSBjb29yZHMgb2NjdXJcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgcGFnZUNvdW50OyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSByZW5kZXJlZFBhZ2VzW2ldO1xuICAgICAgICAgICAgdmFyIHJlZ2lvbiA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChyZWdpb24ubGVmdCA8PSBkb2NDb29yZHMubGVmdCAmJiByZWdpb24ucmlnaHQgPj0gZG9jQ29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICByZWdpb24udG9wIDw9IGRvY0Nvb3Jkcy50b3AgJiYgcmVnaW9uLmJvdHRvbSA+PSBkb2NDb29yZHMudG9wKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBkb2NDb29yZHMubGVmdCAtIHJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBkb2NDb29yZHMudG9wIC0gcmVnaW9uLnRvcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gRklYTUU6IFdvdWxkIGJlIGJldHRlciB0byB1c2UgdGhlIGNsb3Nlc3QgcGFnZSBvciBzb21ldGhpbmdcbiAgICAgICAgdmFyIGN1cnJlbnRSZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5jaG9yUGFnZTogc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCxcbiAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgIGxlZnQ6IGRvY0Nvb3Jkcy5sZWZ0IC0gY3VycmVudFJlZ2lvbi5sZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogZG9jQ29vcmRzLnRvcCAtIGN1cnJlbnRSZWdpb24udG9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIHRoaXMuc2V0TWFuaWZlc3QgPSBmdW5jdGlvbiAobWFuaWZlc3QsIGlzSUlJRiwgbG9hZE9wdGlvbnMpXG4gICAge1xuICAgICAgICBzZXRNYW5pZmVzdChtYW5pZmVzdCwgaXNJSUlGLCBsb2FkT3B0aW9ucyB8fCB7fSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBnaXZlbiBpbmRleCwgZmlyaW5nIFZpc2libGVQYWdlRGlkQ2hhbmdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUluZGV4XG4gICAgICovXG4gICAgdGhpcy5zZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuY3VycmVudFBhZ2VJbmRleCAhPT0gcGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5jdXJyZW50UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgICAgcHVibGlzaChcIlZpc2libGVQYWdlRGlkQ2hhbmdlXCIsIHBhZ2VJbmRleCwgdGhpcy5nZXRQYWdlTmFtZShwYWdlSW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VOYW1lID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5tYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdLmY7XG4gICAgfTtcblxuICAgIHRoaXMucmVsb2FkID0gZnVuY3Rpb24gKG5ld09wdGlvbnMpXG4gICAge1xuICAgICAgICByZWxvYWRWaWV3ZXIobmV3T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbSA9IGZ1bmN0aW9uICh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpXG4gICAge1xuICAgICAgICByZXR1cm4gaGFuZGxlWm9vbSh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZVNjcm9sbGFibGUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVLZXlTY3JvbGwgPSB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IHZpZXdlclN0YXRlLmluaXRpYWxTcGFjZVNjcm9sbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzU2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsYWJsZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuaXNTY3JvbGxhYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBibG9jayBkcmFnZ2luZy9kb3VibGUtY2xpY2sgem9vbWluZ1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLmlubmVyT2JqZWN0Lmhhc0NsYXNzKCdkaXZhLWRyYWdnZXInKSlcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC51bmJpbmQoJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdkYmxjbGljaycpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdjb250ZXh0bWVudScpO1xuXG4gICAgICAgICAgICAvLyBkaXNhYmxlIGFsbCBvdGhlciBzY3JvbGxpbmcgYWN0aW9uc1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICAgIC8vIGJsb2NrIHNjcm9sbGluZyBrZXlzIGJlaGF2aW9yLCByZXNwZWN0aW5nIGluaXRpYWwgc2Nyb2xsIHNldHRpbmdzXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5pdGlhbFNwYWNlU2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGw7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmVuYWJsZUtleVNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmlzVmFsaWRPcHRpb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkT3B0aW9uKGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB0aGlzLnNob3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU6IE5vdCB0b3RhbGx5IHN1cmUgaXQgbWFrZXMgc2Vuc2UgdG8gYWx3YXlzIGRvIHRoYXQgaGVyZVxuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2YXIgZXJyb3JFbGVtZW50ID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ2Vycm9yJyksIFtcbiAgICAgICAgICAgIGVsdCgnYnV0dG9uJywgZWxlbUF0dHJzKCdlcnJvci1jbG9zZScsIHsnYXJpYS1sYWJlbCc6ICdDbG9zZSBkaWFsb2cnfSkpLFxuICAgICAgICAgICAgZWx0KCdwJyxcbiAgICAgICAgICAgICAgICBlbHQoJ3N0cm9uZycsICdFcnJvcicpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBtZXNzYWdlKVxuICAgICAgICBdKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5vdXRlck9iamVjdC5hcHBlbmQoZXJyb3JFbGVtZW50KTtcblxuICAgICAgICAvL2JpbmQgZGlhbG9nIGNsb3NlIGJ1dHRvblxuICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2Vycm9yLWNsb3NlJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBlcnJvckVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlcnJvckVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRYT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgeEFuY2hvcilcbiAgICB7XG4gICAgICAgIHJldHVybiBnZXRYT2Zmc2V0KHBhZ2VJbmRleCwgeEFuY2hvcik7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHlBbmNob3IpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0WU9mZnNldChwYWdlSW5kZXgsIHlBbmNob3IpO1xuICAgIH07XG5cbiAgICB0aGlzLnB1Ymxpc2ggPSBwdWJsaXNoO1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBmdW5jdGlvbiAocGVuZGluZ01hbmlmZXN0UmVxdWVzdClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0O1xuICAgIH07XG5cbiAgICAvLyBEZXN0cm95cyB0aGlzIGluc3RhbmNlLCB0ZWxscyBwbHVnaW5zIHRvIGRvIHRoZSBzYW1lIChmb3IgdGVzdGluZylcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gVXNlZnVsIGV2ZW50IHRvIGFjY2VzcyBlbGVtZW50cyBpbiBkaXZhIGJlZm9yZSB0aGV5IGdldCBkZXN0cm95ZWQuIFVzZWQgYnkgdGhlIGhpZ2hsaWdodCBwbHVnaW4uXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlcldpbGxUZXJtaW5hdGUnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3QgcmV0cmlldmluZyBhIG1hbmlmZXN0XG4gICAgICAgIGlmIChzZXR0aW5ncy5wZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KVxuICAgICAgICAgICAgc2V0dGluZ3MucGVuZGluZ01hbmlmZXN0UmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIGhpZGUtc2Nyb2xsYmFyIGNsYXNzIGZyb20gdGhlIGJvZHlcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdkaXZhLWhpZGUtc2Nyb2xsYmFyJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgdGhlIHBhcmVudCBjb250YWluZXIgYW5kIHJlbW92ZSBhbnkgZGl2YS1yZWxhdGVkIGRhdGFcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0LnBhcmVudCgpLmVtcHR5KCkucmVtb3ZlRGF0YSgnZGl2YScpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgYWRkaXRpb25hbCBzdHlsaW5nIG9uIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBzZXR0aW5ncy5wYXJlbnRPYmplY3QucGFyZW50KCkucmVtb3ZlQXR0cignc3R5bGUnKS5yZW1vdmVBdHRyKCdjbGFzcycpO1xuXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIHNldHRpbmdzKTtcblxuICAgICAgICAvLyBDbGVhciB0aGUgRXZlbnRzIGNhY2hlXG4gICAgICAgIGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlQWxsKHNldHRpbmdzLklEKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCB0aGUgaW5pdCBmdW5jdGlvbiB3aGVuIHRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgaW5pdCgpO1xufVxuXG5nZW5lcmF0ZUlkLmNvdW50ZXIgPSAxO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiBnZW5lcmF0ZUlkLmNvdW50ZXIrKztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3ZpZXdlci1jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IFRoaXMgaXMgYSB2ZW5kb3JlZCBkZXBlbmRlbmN5ICovXG4vKlxuICogalF1ZXJ5IGRyYWdzY3JvbGxhYmxlIFBsdWdpblxuICogdmVyc2lvbjogMS4wICgyNS1KdW4tMjAwOSlcbiAqIENvcHlyaWdodCAoYykgMjAwOSBNaXF1ZWwgSGVycmVyYVxuICogaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9wcm9qZWN0L0RyYWdzY3JvbGxhYmxlXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiAgIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuICpcbiAqL1xuKGZ1bmN0aW9uICgkKSB7IC8vIHNlY3VyZSAkIGpRdWVyeSBhbGlhc1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYWJpbGl0eSB0byBtYW5hZ2UgZWxlbWVudHMgc2Nyb2xsIGJ5IGRyYWdnaW5nXG4gICAgICogb25lIG9yIG1vcmUgb2YgaXRzIGRlc2NlbmRhbnQgZWxlbWVudHMuIE9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICogYWxsb3cgdG8gc3BlY2lmaWNhbGx5IHNlbGVjdCB3aGljaCBpbm5lciBlbGVtZW50cyB3aWxsXG4gICAgICogcmVzcG9uZCB0byB0aGUgZHJhZyBldmVudHMuXG4gICAgICpcbiAgICAgKiBvcHRpb25zIHByb3BlcnRpZXM6XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIGRyYWdTZWxlY3RvciAgICAgICAgIHwganF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIGVhY2ggd3JhcHBlZCBlbGVtZW50XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgdG8gZmluZCB3aGljaCB3aWxsIGJlIHRoZSBkcmFnZ2luZyBlbGVtZW50cy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0cyB0byAnPjpmaXJzdCcgd2hpY2ggaXMgdGhlIGZpcnN0IGNoaWxkIG9mXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgc2Nyb2xsYWJsZSBlbGVtZW50XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIGFjY2VwdFByb3BhZ2F0ZWRFdmVudHwgV2lsbCB0aGUgZHJhZ2dpbmcgZWxlbWVudCBhY2NlcHQgcHJvcGFnYXRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGV2ZW50cz8gZGVmYXVsdCBpcyB5ZXMsIGEgcHJvcGFnYXRlZCBtb3VzZSBldmVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IG9uIGEgaW5uZXIgZWxlbWVudCB3aWxsIGJlIGFjY2VwdGVkIGFuZCBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBvcmlnaW5hdGVkIG9uIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGRyYWdnYWJsZSBlbGVtZW50cyB3aWxsIGJlIHByb2Nlc3NlZC5cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgcHJldmVudERlZmF1bHQgICAgICAgfCBQcmV2ZW50cyB0aGUgZXZlbnQgdG8gcHJvcGFnYXRlIGZ1cnRoZXIgZWZmZWN0aXZleVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGRpc3NhYmxpbmcgb3RoZXIgZGVmYXVsdCBhY3Rpb25zLiBEZWZhdWx0cyB0byB0cnVlXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKiAgdXNhZ2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgVG8gYWRkIHRoZSBzY3JvbGwgYnkgZHJhZyB0byB0aGUgZWxlbWVudCBpZD12aWV3cG9ydCB3aGVuIGRyYWdnaW5nIGl0c1xuICAgICAqICBmaXJzdCBjaGlsZCBhY2NlcHRpbmcgYW55IHByb3BhZ2F0ZWQgZXZlbnRzXG4gICAgICogICQoJyN2aWV3cG9ydCcpLmRyYWdzY3JvbGxhYmxlKCk7XG4gICAgICpcbiAgICAgKiAgVG8gYWRkIHRoZSBzY3JvbGwgYnkgZHJhZyBhYmlsaXR5IHRvIGFueSBlbGVtZW50IGRpdiBvZiBjbGFzcyB2aWV3cG9ydFxuICAgICAqICB3aGVuIGRyYWdnaW5nIGl0cyBmaXJzdCBkZXNjZW5kYW50IG9mIGNsYXNzIGRyYWdNZSByZXNwb25kaW5nIG9ubHkgdG9cbiAgICAgKiAgZXZjZW50cyBvcmlnaW5hdGVkIG9uIHRoZSAnLmRyYWdNZScgZWxlbWVudHMuXG4gICAgICogICQoJ2Rpdi52aWV3cG9ydCcpLmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6Jy5kcmFnTWU6Zmlyc3QnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRQcm9wYWdhdGVkRXZlbnQ6IGZhbHNlfSk7XG4gICAgICpcbiAgICAgKiAgTm90aWNlIHRoYXQgc29tZSAndmlld3BvcnRzJyBjb3VsZCBiZSBuZXN0ZWQgd2l0aGluIG90aGVycyBidXQgZXZlbnRzXG4gICAgICogIHdvdWxkIG5vdCBpbnRlcmZlcmUgYXMgYWNjZXB0UHJvcGFnYXRlZEV2ZW50IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqL1xuICAgICQuZm4uZHJhZ3Njcm9sbGFibGUgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRyYWdTZWxlY3RvcjonPjpmaXJzdCcsXG4gICAgICAgICAgICAgICAgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgICB9LG9wdGlvbnMgfHwge30pO1xuXG5cbiAgICAgICAgdmFyIGRyYWdzY3JvbGw9IHtcbiAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNlZG93biwgbGVmdCBjbGljaywgY2hlY2sgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ghPTEgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFldmVudC5kYXRhLmFjY2VwdFByb3BhZ2F0ZWRFdmVudCAmJiBldmVudC50YXJnZXQgIT0gdGhpcykpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBjb29yZGluYXRlcyB3aWxsIGJlIHRoZSBsYXN0IHdoZW4gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmxhc3RDb29yZCA9IHtsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFl9O1xuXG4gICAgICAgICAgICAgICAgJC5ldmVudC5hZGQoIGRvY3VtZW50LCBcIm1vdXNldXBcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ3Njcm9sbC5tb3VzZVVwSGFuZGxlciwgZXZlbnQuZGF0YSApO1xuICAgICAgICAgICAgICAgICQuZXZlbnQuYWRkKCBkb2N1bWVudCwgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ3Njcm9sbC5tb3VzZU1vdmVIYW5kbGVyLCBldmVudC5kYXRhICk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZU1vdmVIYW5kbGVyIDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gVXNlciBpcyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIC8vIEhvdyBtdWNoIGRpZCB0aGUgbW91c2UgbW92ZT9cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSB7bGVmdDogKGV2ZW50LmNsaWVudFggLSBldmVudC5kYXRhLmxhc3RDb29yZC5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAoZXZlbnQuY2xpZW50WSAtIGV2ZW50LmRhdGEubGFzdENvb3JkLnRvcCl9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gcmVsYXRpdmUgdG8gd2hhdCBldmVyIHRoZSBzY3JvbGwgaXMgbm93XG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5zY3JvbGxhYmxlLnNjcm9sbExlZnQoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0KCkgLSBkZWx0YS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLnNjcm9sbGFibGUuc2Nyb2xsVG9wKFxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnNjcm9sbGFibGUuc2Nyb2xsVG9wKCkgLSBkZWx0YS50b3ApO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5sYXN0Q29vcmQ9e2xlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WX07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyIDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gU3RvcCBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnJlbW92ZSggZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGRyYWdzY3JvbGwubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgJC5ldmVudC5yZW1vdmUoIGRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ3Njcm9sbC5tb3VzZVVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGluaXRpYWwgZXZlbnRzXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgb2JqZWN0IGRhdGEgZm9yIGVhY2ggc2Nyb2xsYWJsZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtzY3JvbGxhYmxlIDogJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBhY2NlcHRQcm9wYWdhdGVkRXZlbnQgOiBzZXR0aW5ncy5hY2NlcHRQcm9wYWdhdGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgOiBzZXR0aW5ncy5wcmV2ZW50RGVmYXVsdCB9O1xuICAgICAgICAgICAgLy8gU2V0IG1vdXNlIGluaXRpYXRpbmcgZXZlbnQgb24gdGhlIGRlc2lyZWQgZGVzY2VuZGFudFxuICAgICAgICAgICAgJCh0aGlzKS5maW5kKHNldHRpbmdzLmRyYWdTZWxlY3RvcikuXG4gICAgICAgICAgICBiaW5kKCdtb3VzZWRvd24nLCBkYXRhLCBkcmFnc2Nyb2xsLm1vdXNlRG93bkhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9OyAvL2VuZCBwbHVnaW4gZHJhZ3Njcm9sbGFibGVcblxufSkoIGpRdWVyeSApOyAvLyBjb25maW5lIHNjb3BlXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IFRoaXMgaXMgYSB2ZW5kb3JlZCBkZXBlbmRlbmN5ICovXG4vKipcbiBqUXVlcnkua2luZXRpYyB2Mi4yLjFcbiBEYXZlIFRheWxvciBodHRwOi8vZGF2ZXRheWxzLm1lXG5cbiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiBAcHJlc2VydmUgQ29weXJpZ2h0IChjKSAyMDEyIERhdmUgVGF5bG9yIGh0dHA6Ly9kYXZldGF5bHMubWVcbiAqL1xuKGZ1bmN0aW9uICgkKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgQUNUSVZFX0NMQVNTID0gJ2tpbmV0aWMtYWN0aXZlJztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpbiBhIGNyb3NzIGJyb3dzZXIgd2F5LlxuICAgICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAgICovXG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXtcblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKCBmdW5jdGlvbiAoKXtcblxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2ssIC8qIERPTUVsZW1lbnQgRWxlbWVudCAqLyBlbGVtZW50KXtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICB9KCkpO1xuXG4gICAgfVxuXG4gICAgLy8gYWRkIHRvdWNoIGNoZWNrZXIgdG8galF1ZXJ5LnN1cHBvcnRcbiAgICAkLnN1cHBvcnQgPSAkLnN1cHBvcnQgfHwge307XG4gICAgJC5leHRlbmQoJC5zdXBwb3J0LCB7XG4gICAgICAgIHRvdWNoOiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnRcbiAgICB9KTtcblxuXG4gICAgLy8gS0lORVRJQyBDTEFTUyBERUZJTklUSU9OXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgdmFyIEtpbmV0aWMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmVsICAgICAgID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy4kZWwgICAgICA9ICQoZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5faW5pdEVsZW1lbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEtpbmV0aWMuREFUQV9LRVkgPSAna2luZXRpYyc7XG4gICAgS2luZXRpYy5ERUZBVUxUUyA9IHtcbiAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgIGRlY2VsZXJhdGU6IHRydWUsXG4gICAgICAgIHRyaWdnZXJIYXJkd2FyZTogZmFsc2UsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgeTogdHJ1ZSxcbiAgICAgICAgeDogdHJ1ZSxcbiAgICAgICAgc2xvd2Rvd246IDAuOSxcbiAgICAgICAgbWF4dmVsb2NpdHk6IDQwLFxuICAgICAgICB0aHJvdHRsZUZQUzogNjAsXG4gICAgICAgIGludmVydDogZmFsc2UsXG4gICAgICAgIG1vdmluZ0NsYXNzOiB7XG4gICAgICAgICAgICB1cDogJ2tpbmV0aWMtbW92aW5nLXVwJyxcbiAgICAgICAgICAgIGRvd246ICdraW5ldGljLW1vdmluZy1kb3duJyxcbiAgICAgICAgICAgIGxlZnQ6ICdraW5ldGljLW1vdmluZy1sZWZ0JyxcbiAgICAgICAgICAgIHJpZ2h0OiAna2luZXRpYy1tb3ZpbmctcmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIGRlY2VsZXJhdGluZ0NsYXNzOiB7XG4gICAgICAgICAgICB1cDogJ2tpbmV0aWMtZGVjZWxlcmF0aW5nLXVwJyxcbiAgICAgICAgICAgIGRvd246ICdraW5ldGljLWRlY2VsZXJhdGluZy1kb3duJyxcbiAgICAgICAgICAgIGxlZnQ6ICdraW5ldGljLWRlY2VsZXJhdGluZy1sZWZ0JyxcbiAgICAgICAgICAgIHJpZ2h0OiAna2luZXRpYy1kZWNlbGVyYXRpbmctcmlnaHQnXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBQdWJsaWMgZnVuY3Rpb25zXG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChvcHRpb25zKXtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9ICQuZXh0ZW5kKHRoaXMuc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gb3B0aW9ucy52ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IG9wdGlvbnMudmVsb2NpdHlZIHx8IHRoaXMudmVsb2NpdHlZO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW92ZSgpO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSB0cnVlO1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RvcHBlZCkpe1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdG9wcGVkLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuX2RldGFjaExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLiRlbFxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKEFDVElWRV9DTEFTUylcbiAgICAgICAgICAgIC5jc3MoJ2N1cnNvcicsICcnKTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIGlmICh0aGlzLiRlbC5oYXNDbGFzcyhBQ1RJVkVfQ0xBU1MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoTGlzdGVuZXJzKHRoaXMuJGVsKTtcbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAgIC5hZGRDbGFzcyhBQ1RJVkVfQ0xBU1MpXG4gICAgICAgICAgICAuY3NzKCdjdXJzb3InLCB0aGlzLnNldHRpbmdzLmN1cnNvcik7XG4gICAgfTtcblxuXG4gICAgLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5faW5pdEVsZW1lbnRzID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKEFDVElWRV9DTEFTUyk7XG5cbiAgICAgICAgJC5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgeHBvczogbnVsbCxcbiAgICAgICAgICAgIHByZXZYUG9zOiBmYWxzZSxcbiAgICAgICAgICAgIHlwb3M6IG51bGwsXG4gICAgICAgICAgICBwcmV2WVBvczogZmFsc2UsXG4gICAgICAgICAgICBtb3VzZURvd246IGZhbHNlLFxuICAgICAgICAgICAgdGhyb3R0bGVUaW1lb3V0OiAxMDAwIC8gdGhpcy5zZXR0aW5ncy50aHJvdHRsZUZQUyxcbiAgICAgICAgICAgIGxhc3RNb3ZlOiBudWxsLFxuICAgICAgICAgICAgZWxlbWVudEZvY3VzZWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gMDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgcmVzZXQgZXZlcnl0aGluZyB3aGVuIG1vdXNlIHVwXG4gICAgICAgICQoZG9jdW1lbnQpXG4gICAgICAgICAgICAubW91c2V1cCgkLnByb3h5KHRoaXMuX3Jlc2V0TW91c2UsIHRoaXMpKVxuICAgICAgICAgICAgLmNsaWNrKCQucHJveHkodGhpcy5fcmVzZXRNb3VzZSwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgICAgICB0aGlzLiRlbC5jc3MoJ2N1cnNvcicsIHRoaXMuc2V0dGluZ3MuY3Vyc29yKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmlnZ2VySGFyZHdhcmUpe1xuICAgICAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoMCwwLDApJyxcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC1wZXJzcGVjdGl2ZSc6ICcxMDAwJyxcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIHRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkpe1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRocmVzaG9sZCA9IHNlbGYuX3RocmVzaG9sZChlLnRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N0YXJ0KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3VjaE1vdmU6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duKXtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSBlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXRtb3ZlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXREb3duOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRocmVzaG9sZCA9IHNlbGYuX3RocmVzaG9sZChlLnRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N0YXJ0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50Rm9jdXNlZCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUgPT09ICdJTUcnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dEVuZDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl91c2VUYXJnZXQoZS50YXJnZXQsIGUpKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudEZvY3VzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRNb3ZlOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXRtb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2VsZi5zZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHRpbmdzLm1vdmVkLmNhbGwoc2VsZiwgc2VsZi5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dENsaWNrOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlbGYudmVsb2NpdHkpID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRyYWcgYW5kIGRyb3AgaW1hZ2VzIGluIGllXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdXNlVGFyZ2V0KGUudGFyZ2V0LCBlKSAmJiBzZWxmLmVsZW1lbnRGb2N1c2VkKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nXG4gICAgICAgICAgICBzZWxlY3RTdGFydDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2VsZi5zZXR0aW5ncy5zZWxlY3RTdGFydCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zZXR0aW5ncy5zZWxlY3RTdGFydC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5fdXNlVGFyZ2V0KGUudGFyZ2V0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaExpc3RlbmVycyh0aGlzLiRlbCwgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2lucHV0bW92ZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKXtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcy4kZWw7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxhc3RNb3ZlIHx8IG5ldyBEYXRlKCkgPiBuZXcgRGF0ZSh0aGlzLmxhc3RNb3ZlLmdldFRpbWUoKSArIHRoaXMudGhyb3R0bGVUaW1lb3V0KSl7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3ZlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubW91c2VEb3duICYmICh0aGlzLnhwb3MgfHwgdGhpcy55cG9zKSl7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkWCA9IChjbGllbnRYIC0gdGhpcy54cG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZWRZID0gKGNsaWVudFkgLSB0aGlzLnlwb3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZFggKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkWSAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGhpcy50aHJlc2hvbGQgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkID0gTWF0aC5zcXJ0KG1vdmVkWCAqIG1vdmVkWCArIG1vdmVkWSAqIG1vdmVkWSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGhyZXNob2xkID4gbW92ZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJlc2hvbGQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRGb2N1c2VkKXtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVsZW1lbnRGb2N1c2VkKS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjZWxlcmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5WSA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0KHRoaXMuc2V0dGluZ3MueCA/IHNjcm9sbExlZnQgLSBtb3ZlZFggOiBzY3JvbGxMZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCh0aGlzLnNldHRpbmdzLnkgPyBzY3JvbGxUb3AgLSBtb3ZlZFkgOiBzY3JvbGxUb3ApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2WFBvcyA9IHRoaXMueHBvcztcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZZUG9zID0gdGhpcy55cG9zO1xuICAgICAgICAgICAgICAgIHRoaXMueHBvcyA9IGNsaWVudFg7XG4gICAgICAgICAgICAgICAgdGhpcy55cG9zID0gY2xpZW50WTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVZlbG9jaXRpZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRNb3ZlQ2xhc3Nlcyh0aGlzLnNldHRpbmdzLm1vdmluZ0NsYXNzKTtcblxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vdmVkLmNhbGwodGhpcywgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9jYWxjdWxhdGVWZWxvY2l0aWVzID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLl9jYXBWZWxvY2l0eSh0aGlzLnByZXZYUG9zIC0gdGhpcy54cG9zLCB0aGlzLnNldHRpbmdzLm1heHZlbG9jaXR5KTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSB0aGlzLl9jYXBWZWxvY2l0eSh0aGlzLnByZXZZUG9zIC0gdGhpcy55cG9zLCB0aGlzLnNldHRpbmdzLm1heHZlbG9jaXR5KTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaW52ZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ICo9IC0xO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgKj0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBpZiAodGhpcy54cG9zICYmIHRoaXMucHJldlhQb3MgJiYgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID09PSBmYWxzZSl7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVmVsb2NpdGllcygpO1xuICAgICAgICAgICAgdGhpcy54cG9zID0gdGhpcy5wcmV2WFBvcyA9IHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX3VzZVRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KXtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLmZpbHRlclRhcmdldCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZmlsdGVyVGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBldmVudCkgIT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fdGhyZXNob2xkID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQpe1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MudGhyZXNob2xkKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50aHJlc2hvbGQuY2FsbCh0aGlzLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50aHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKXtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5wcmV2WFBvcyA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gdGhpcy5wcmV2WVBvcyA9IDA7XG4gICAgICAgIHRoaXMueHBvcyA9IGNsaWVudFg7XG4gICAgICAgIHRoaXMueXBvcyA9IGNsaWVudFk7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9yZXNldE1vdXNlID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMueHBvcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlwb3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2RlY2VsZXJhdGVWZWxvY2l0eSA9IGZ1bmN0aW9uICh2ZWxvY2l0eSwgc2xvd2Rvd24pe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmFicyh2ZWxvY2l0eSkpID09PSAwID8gMCAvLyBpcyB2ZWxvY2l0eSBsZXNzIHRoYW4gMT9cbiAgICAgICAgICAgIDogdmVsb2NpdHkgKiBzbG93ZG93bjsgLy8gcmVkdWNlIHNsb3dkb3duXG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9jYXBWZWxvY2l0eSA9IGZ1bmN0aW9uICh2ZWxvY2l0eSwgbWF4KXtcbiAgICAgICAgdmFyIG5ld1ZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IDApe1xuICAgICAgICAgICAgaWYgKHZlbG9jaXR5ID4gbWF4KXtcbiAgICAgICAgICAgICAgICBuZXdWZWxvY2l0eSA9IG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eSA8ICgwIC0gbWF4KSl7XG4gICAgICAgICAgICAgICAgbmV3VmVsb2NpdHkgPSAoMCAtIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZlbG9jaXR5O1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fc2V0TW92ZUNsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcyl7XG4gICAgICAgIC8vIEZJWE1FOiBjb25zaWRlciBpZiB3ZSB3YW50IHRvIGFwcGx5IFBMICM0NCwgdGhpcyBzaG91bGQgbm90IHJlbW92ZVxuICAgICAgICAvLyBjbGFzc2VzIHdlIGhhdmUgbm90IGRlZmluZWQgb24gdGhlIGVsZW1lbnQhXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuXG4gICAgICAgICR0aGlzLnJlbW92ZUNsYXNzKHNldHRpbmdzLm1vdmluZ0NsYXNzLnVwKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLm1vdmluZ0NsYXNzLmRvd24pXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MubW92aW5nQ2xhc3MubGVmdClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5tb3ZpbmdDbGFzcy5yaWdodClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcy51cClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcy5kb3duKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLmRlY2VsZXJhdGluZ0NsYXNzLmxlZnQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MuZGVjZWxlcmF0aW5nQ2xhc3MucmlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5ID4gMCl7XG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhjbGFzc2VzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eSA8IDApe1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoY2xhc3Nlcy5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eVkgPiAwKXtcbiAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKGNsYXNzZXMuZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHlZIDwgMCl7XG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhjbGFzc2VzLnVwKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gZG8gdGhlIGFjdHVhbCBraW5ldGljIG1vdmVtZW50XG4gICAgS2luZXRpYy5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuX2dldFNjcm9sbGVyKCk7XG4gICAgICAgIHZhciBzY3JvbGxlciA9ICRzY3JvbGxlclswXTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzO1xuXG4gICAgICAgIC8vIHNldCBzY3JvbGxMZWZ0XG4gICAgICAgIGlmIChzZXR0aW5ncy54ICYmIHNjcm9sbGVyLnNjcm9sbFdpZHRoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQodGhpcy5zY3JvbGxMZWZ0KCkgKyB0aGlzLnZlbG9jaXR5KTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbG9jaXR5KSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBzZXR0aW5ncy5kZWNlbGVyYXRlID9cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVjZWxlcmF0ZVZlbG9jaXR5KHRoaXMudmVsb2NpdHksIHNldHRpbmdzLnNsb3dkb3duKSA6IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBzY3JvbGxUb3BcbiAgICAgICAgaWYgKHNldHRpbmdzLnkgJiYgc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0ID4gMCl7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCh0aGlzLnNjcm9sbFRvcCgpICsgdGhpcy52ZWxvY2l0eVkpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHlZKSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHlZID0gc2V0dGluZ3MuZGVjZWxlcmF0ZSA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlY2VsZXJhdGVWZWxvY2l0eSh0aGlzLnZlbG9jaXR5WSwgc2V0dGluZ3Muc2xvd2Rvd24pIDogdGhpcy52ZWxvY2l0eVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9zZXRNb3ZlQ2xhc3NlcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcyk7XG5cbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgc2V0dGluZ3MubW92ZWQuY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eSkgPiAwIHx8IE1hdGguYWJzKHRoaXMudmVsb2NpdHlZKSA+IDApe1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aWNrIGZvciBuZXh0IG1vdmVtZW50XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZ2V0IGN1cnJlbnQgc2Nyb2xsZXIgdG8gYXBwbHkgcG9zaXRpb25pbmcgdG9cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fZ2V0U2Nyb2xsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgJHNjcm9sbGVyID0gdGhpcy4kZWw7XG4gICAgICAgIGlmICh0aGlzLiRlbC5pcygnYm9keScpIHx8IHRoaXMuJGVsLmlzKCdodG1sJykpe1xuICAgICAgICAgICAgJHNjcm9sbGVyID0gJCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkc2Nyb2xsZXI7XG4gICAgfTtcblxuICAgIC8vIHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgS2luZXRpYy5wcm90b3R5cGUuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKGxlZnQpe1xuICAgICAgICB2YXIgJHNjcm9sbGVyID0gdGhpcy5fZ2V0U2Nyb2xsZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAkc2Nyb2xsZXIuc2Nyb2xsTGVmdChsZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjcm9sbGVyLnNjcm9sbExlZnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS2luZXRpYy5wcm90b3R5cGUuc2Nyb2xsVG9wID0gZnVuY3Rpb24odG9wKXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuX2dldFNjcm9sbGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG9wID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAkc2Nyb2xsZXIuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkc2Nyb2xsZXIuc2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2F0dGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcblxuICAgICAgICBpZiAoJC5zdXBwb3J0LnRvdWNoKXtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAuYmluZCgndG91Y2hlbmQnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5tb3VzZWRvd24oc2V0dGluZ3MuZXZlbnRzLmlucHV0RG93bilcbiAgICAgICAgICAgIC5tb3VzZXVwKHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgIC5tb3VzZW1vdmUoc2V0dGluZ3MuZXZlbnRzLmlucHV0TW92ZSk7XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5jbGljayhzZXR0aW5ncy5ldmVudHMuaW5wdXRDbGljaylcbiAgICAgICAgICAgIC5zY3JvbGwoc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC5iaW5kKCdzZWxlY3RzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5zZWxlY3RTdGFydClcbiAgICAgICAgICAgIC5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2RldGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgaWYgKCQuc3VwcG9ydC50b3VjaCl7XG4gICAgICAgICAgICAkdGhpc1xuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaGVuZCcsIHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaG1vdmUnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAudW5iaW5kKCdtb3VzZWRvd24nLCBzZXR0aW5ncy5ldmVudHMuaW5wdXREb3duKVxuICAgICAgICAgICAgLnVuYmluZCgnbW91c2V1cCcsIHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgIC51bmJpbmQoJ21vdXNlbW92ZScsIHNldHRpbmdzLmV2ZW50cy5pbnB1dE1vdmUpO1xuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAudW5iaW5kKCdjbGljaycsIHNldHRpbmdzLmV2ZW50cy5pbnB1dENsaWNrKVxuICAgICAgICAgICAgLnVuYmluZCgnc2Nyb2xsJywgc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC51bmJpbmQoJ3NlbGVjdHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnNlbGVjdFN0YXJ0KVxuICAgICAgICAgICAgLnVuYmluZCgnZHJhZ3N0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLmRyYWdTdGFydCk7XG4gICAgfTtcblxuXG4gICAgLy8gRVhQT1NFIEtJTkVUSUMgQ09OU1RSVUNUT1JcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICQuS2luZXRpYyA9IEtpbmV0aWM7XG5cbiAgICAvLyBLSU5FVElDIFBMVUdJTiBERUZJTklUSU9OXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICQuZm4ua2luZXRpYyA9IGZ1bmN0aW9uIChvcHRpb24sIGNhbGxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzICAgID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9ICR0aGlzLmRhdGEoS2luZXRpYy5EQVRBX0tFWSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyAgPSAkLmV4dGVuZCh7fSwgS2luZXRpYy5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb24pO1xuXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YShLaW5ldGljLkRBVEFfS0VZLCAoaW5zdGFuY2UgPSBuZXcgS2luZXRpYyh0aGlzLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtvcHRpb25dKGNhbGxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9O1xuXG59KGpRdWVyeSkpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIFdlIHNob3VsZCBtYXliZSBiZSB0ZXN0aW5nIHRoaXMsIGJ1dCByZWFsaXN0aWNhbGx5IHRoYXQgd291bGQgbWVhbiBtYWludGFpbmluZyBhIHJlYWwgZm9yayAqL1xuXG4vLyBqUXVlcnkua2luZXRpYyBjb3JlIG1vZGlmaWNhdGlvbnMgZm9yIGRpdmEuanMgKGNvbXBhdGlibGUgd2l0aCBqUXVlcnkua2luZXRpYyAyLjIuMSlcbi8vIHVzZSBqUXVlcnkua2luZXRpYyBmb3IgdG91Y2ggaGFuZGxlcnMgb25seSBzaW5jZSB3ZSBhcmUgdXNpbmcgZHJhZ3Njcm9sbGFibGUgZm9yIG1vdXNlIGhhbmRsZXJzXG4vLyAgICAtIChraW5ldGljIHByb3ZpZGVzIGluZXJ0aWFsIHNjcm9sbGluZyBbZWFzZSBpbnRvIHN0b3BwZWQgc3RhdGUgb24gcmVsZWFzZV0gZm9yIHRvdWNoIGV2ZW50cyBhbmQgZHJhZ3Njcm9sbGFibGVcbi8vICAgICAgYWxsb3dzIG5vbi1pbmVydGlhbCBzY3JvbGxpbmcgd2hpY2ggd2UgbGlrZSBmb3IgbWljZSlcblxuKGZ1bmN0aW9uKCQpXG57XG4gICAgJC5LaW5ldGljLnByb3RvdHlwZS5fYXR0YWNoTGlzdGVuZXJzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gYXR0YWNoIG9ubHkgdG91Y2ggbGlzdGVuZXJzXG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgICAgIGlmICgkLnN1cHBvcnQudG91Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAuYmluZCgndG91Y2hlbmQnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5jbGljayhzZXR0aW5ncy5ldmVudHMuaW5wdXRDbGljaylcbiAgICAgICAgICAgIC5zY3JvbGwoc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC5iaW5kKCdzZWxlY3RzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5zZWxlY3RTdGFydClcbiAgICAgICAgICAgIC5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xuXG4gICAgJC5LaW5ldGljLnByb3RvdHlwZS5fZGV0YWNoTGlzdGVuZXJzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gZGV0YWNoIG9ubHkgdG91Y2ggbGlzdGVuZXJzXG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgICAgIGlmICgkLnN1cHBvcnQudG91Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLnVuYmluZCgndG91Y2hzdGFydCcsIHNldHRpbmdzLmV2ZW50cy50b3VjaFN0YXJ0KVxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNoZW5kJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0RW5kKVxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC51bmJpbmQoJ2NsaWNrJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0Q2xpY2spXG4gICAgICAgICAgICAudW5iaW5kKCdzY3JvbGwnLCBzZXR0aW5ncy5ldmVudHMuc2Nyb2xsKVxuICAgICAgICAgICAgLnVuYmluZCgnc2VsZWN0c3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuc2VsZWN0U3RhcnQpXG4gICAgICAgICAgICAudW5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3V0aWxzL2pxdWVyeS1leHRlbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBGcm9tIGh0dHA6Ly93d3cuYWxleGFuZHJlLWdvbWVzLmNvbS8/cD0xMTUsIG1vZGlmaWVkIHNsaWdodGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBpbm5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xuXG4gICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIG91dGVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIG91dGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMjAwcHgnO1xuICAgIG91dGVyLnN0eWxlLmhlaWdodCA9ICcxNTBweCc7XG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcblxuICAgIHZhciB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgdmFyIHcyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgaWYgKHcxID09IHcyKSB7XG4gICAgICAgIHcyID0gb3V0ZXIuY2xpZW50V2lkdGg7IC8vIGZvciBJRSBpIHRoaW5rXG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgcmV0dXJuIHcxIC0gdzI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICBvblBpbmNoOiBvblBpbmNoLFxuICAgIG9uRG91YmxlVGFwOiBvbkRvdWJsZVRhcFxufTtcblxudmFyIERPVUJMRV9DTElDS19USU1FT1VUID0gNTAwO1xuXG52YXIgRE9VQkxFX1RBUF9ESVNUQU5DRV9USFJFU0hPTEQgPSA1MDtcbnZhciBET1VCTEVfVEFQX1RJTUVPVVQgPSAyNTA7XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZWxlbSwgY2FsbGJhY2spXG57XG4gICAgZWxlbS5vbignZGJsY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNvbnRyb2wga2V5IGZvciBtYWNzIChpbiBjb25qdW5jdGlvbiB3aXRoIGRvdWJsZS1jbGlja2luZylcbiAgICAvLyBGSVhNRTogRG9lcyBhIGNsaWNrIGdldCBoYW5kbGVkIHdpdGggY3RybCBwcmVzc2VkIG9uIG5vbi1NYWNzP1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9DTElDS19USU1FT1VUKTtcblxuICAgIGVsZW0ub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRyYWNrZXIuaXNUcmlnZ2VyZWQoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci50cmlnZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25QaW5jaChlbGVtLCBjYWxsYmFjaylcbntcbiAgICB2YXIgc3RhcnREaXN0YW5jZSA9IDA7XG5cbiAgICBlbGVtLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZShcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbS5vbigndG91Y2htb3ZlJywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICB2YXIgbW92ZURpc3RhbmNlID0gZGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG91Y2hlc1sxXS5jbGllbnRZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgem9vbURlbHRhID0gbW92ZURpc3RhbmNlIC0gc3RhcnREaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpvb21EZWx0YSkgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaENlbnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVg6ICh0b3VjaGVzWzBdLmNsaWVudFggKyB0b3VjaGVzWzFdLmNsaWVudFgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6ICh0b3VjaGVzWzBdLmNsaWVudFkgKyB0b3VjaGVzWzFdLmNsaWVudFkpIC8gMlxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgZ2V0UmVsYXRpdmVPZmZzZXQoZXZlbnQuY3VycmVudFRhcmdldCwgdG91Y2hDZW50ZXIpLCBzdGFydERpc3RhbmNlLCBtb3ZlRGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRG91YmxlVGFwKGVsZW0sIGNhbGxiYWNrKVxue1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9UQVBfVElNRU9VVCk7XG4gICAgdmFyIGZpcnN0VGFwID0gbnVsbDtcblxuICAgIGVsZW0ub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgLy8gUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGZpcmluZ1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0cmFja2VyLmlzVHJpZ2dlcmVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyYWNrZXIucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gRG91YmxldGFwIGhhcyBvY2N1cnJlZFxuICAgICAgICAgICAgdmFyIHNlY29uZFRhcCA9IHtcbiAgICAgICAgICAgICAgICBwYWdlWDogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBldmVudC5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIGZpcnN0IHRhcCBpcyBjbG9zZSB0byBzZWNvbmQgdGFwIChwcmV2ZW50cyBpbnRlcmZlcmVuY2Ugd2l0aCBzY2FsZSBldmVudClcbiAgICAgICAgICAgIHZhciB0YXBEaXN0YW5jZSA9IGRpc3RhbmNlKGZpcnN0VGFwLnBhZ2VYLCBmaXJzdFRhcC5wYWdlWSwgc2Vjb25kVGFwLnBhZ2VYLCBzZWNvbmRUYXAucGFnZVkpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3VsZCBnaXZlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdGhhbiBzZWNvbmRUYXAgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0YXBEaXN0YW5jZSA8IERPVUJMRV9UQVBfRElTVEFOQ0VfVEhSRVNIT0xEKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBzZWNvbmRUYXApKTtcblxuICAgICAgICAgICAgZmlyc3RUYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmlyc3RUYXAgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBQeXRoYWdvcmVhbiB0aGVvcmVtIHRvIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzICh1c2VkIGZvclxuLy8gY2FsY3VsYXRpbmcgZmluZ2VyIGRpc3RhbmNlIGZvciBkb3VibGUtdGFwIGFuZCBwaW5jaC16b29tKVxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xufVxuXG4vLyBVdGlsaXR5IHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiB0cmlnZ2VyZWQgdHdpY2Vcbi8vIGR1cmluZyBhIGEgZ2l2ZW4gZHVyYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZURvdWJsZUV2ZW50VHJhY2tlcih0aW1lb3V0RHVyYXRpb24pXG57XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0VGltZW91dCgpO1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBpc1RyaWdnZXJlZDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzZXRUaW1lb3V0KClcbiAgICB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVPZmZzZXQoZWxlbSwgcGFnZUNvb3JkcylcbntcbiAgICB2YXIgYm91bmRzID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBhZ2VDb29yZHMucGFnZVggLSBib3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBwYWdlQ29vcmRzLnBhZ2VZIC0gYm91bmRzLnRvcFxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9nZXN0dXJlLWV2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1heEJ5ID0gcmVxdWlyZSgnbG9kYXNoLm1heGJ5Jyk7XG52YXIgUGFnZVRvb2xzT3ZlcmxheSA9IHJlcXVpcmUoJy4vcGFnZS10b29scy1vdmVybGF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRIYW5kbGVyO1xuXG5mdW5jdGlvbiBEb2N1bWVudEhhbmRsZXIodmlld2VyQ29yZSlcbntcbiAgICB0aGlzLl92aWV3ZXJDb3JlID0gdmlld2VyQ29yZTtcbiAgICB0aGlzLl92aWV3ZXJTdGF0ZSA9IHZpZXdlckNvcmUuZ2V0SW50ZXJuYWxTdGF0ZSgpO1xuICAgIHRoaXMuX292ZXJsYXlzID0gW107XG5cbiAgICBpZiAodmlld2VyQ29yZS5nZXRQYWdlVG9vbHMoKS5sZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgbnVtUGFnZXMgPSB2aWV3ZXJDb3JlLmdldFNldHRpbmdzKCkubnVtUGFnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbnVtUGFnZXM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgUGFnZVRvb2xzT3ZlcmxheShpLCB2aWV3ZXJDb3JlKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlzLnB1c2gob3ZlcmxheSk7XG4gICAgICAgICAgICB2aWV3ZXJDb3JlLmFkZFBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBVU0VSIEVWRU5UU1xuRG9jdW1lbnRIYW5kbGVyLnByb3RvdHlwZS5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMpXG57XG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuICAgIHZhciBuZXdab29tTGV2ZWwgPSBldmVudC5jdHJsS2V5ID8gc2V0dGluZ3Muem9vbUxldmVsIC0gMSA6IHNldHRpbmdzLnpvb21MZXZlbCArIDE7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl92aWV3ZXJDb3JlLmdldFBhZ2VQb3NpdGlvbkF0Vmlld3BvcnRPZmZzZXQoY29vcmRzKTtcblxuICAgIHRoaXMuX3ZpZXdlckNvcmUuem9vbShuZXdab29tTGV2ZWwsIHBvc2l0aW9uKTtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCwgY29vcmRzLCBzdGFydERpc3RhbmNlLCBlbmREaXN0YW5jZSlcbntcbiAgICAvLyBGSVhNRTogRG8gdGhpcyBjaGVjayBpbiBhIHdheSB3aGljaCBpcyBsZXNzIHNwYWdoZXR0aSBjb2RlLXlcbiAgICB2YXIgdmlld2VyU3RhdGUgPSB0aGlzLl92aWV3ZXJDb3JlLmdldEludGVybmFsU3RhdGUoKTtcbiAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFNldHRpbmdzKCk7XG5cbiAgICB2YXIgbmV3Wm9vbUxldmVsID0gTWF0aC5sb2coTWF0aC5wb3coMiwgc2V0dGluZ3Muem9vbUxldmVsKSAqIGVuZERpc3RhbmNlIC8gKHN0YXJ0RGlzdGFuY2UgKiBNYXRoLmxvZygyKSkpIC8gTWF0aC5sb2coMik7XG4gICAgbmV3Wm9vbUxldmVsID0gTWF0aC5tYXgoc2V0dGluZ3MubWluWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpO1xuICAgIG5ld1pvb21MZXZlbCA9IE1hdGgubWluKHNldHRpbmdzLm1heFpvb21MZXZlbCwgbmV3Wm9vbUxldmVsKTtcblxuICAgIGlmIChuZXdab29tTGV2ZWwgPT09IHNldHRpbmdzLnpvb21MZXZlbClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fdmlld2VyQ29yZS5nZXRQYWdlUG9zaXRpb25BdFZpZXdwb3J0T2Zmc2V0KGNvb3Jkcyk7XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5fdmlld2VyQ29yZS5nZXRDdXJyZW50TGF5b3V0KCk7XG4gICAgdmFyIGNlbnRlck9mZnNldCA9IGxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChwb3NpdGlvbi5hbmNob3JQYWdlLCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG4gICAgdmFyIHNjYWxlUmF0aW8gPSAxIC8gTWF0aC5wb3coMiwgc2V0dGluZ3Muem9vbUxldmVsIC0gbmV3Wm9vbUxldmVsKTtcblxuICAgIHRoaXMuX3ZpZXdlckNvcmUucmVsb2FkKHtcbiAgICAgICAgem9vbUxldmVsOiBuZXdab29tTGV2ZWwsXG4gICAgICAgIGdvRGlyZWN0bHlUbzogcG9zaXRpb24uYW5jaG9yUGFnZSxcbiAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogKGNlbnRlck9mZnNldC54IC0gcG9zaXRpb24ub2Zmc2V0LmxlZnQpICsgcG9zaXRpb24ub2Zmc2V0LmxlZnQgKiBzY2FsZVJhdGlvLFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogKGNlbnRlck9mZnNldC55IC0gcG9zaXRpb24ub2Zmc2V0LnRvcCkgKyBwb3NpdGlvbi5vZmZzZXQudG9wICogc2NhbGVSYXRpb1xuICAgIH0pO1xufTtcblxuLy8gVklFVyBFVkVOVFNcbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25WaWV3V2lsbExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaCgnRG9jdW1lbnRXaWxsTG9hZCcsIHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKSk7XG59O1xuXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLm9uVmlld0RpZExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIFRPRE86IFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSB0byBoYW5kbGUgY2hhbmdlcyBvbiB2aWV3IHVwZGF0ZSwgbm90XG4gICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgdGhpcy5faGFuZGxlWm9vbUxldmVsQ2hhbmdlKCk7XG5cbiAgICB2YXIgY3VycmVudFBhZ2VJbmRleCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5jdXJyZW50UGFnZUluZGV4O1xuICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZU5hbWUoY3VycmVudFBhZ2VJbmRleCk7XG4gICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiRG9jdW1lbnREaWRMb2FkXCIsIGN1cnJlbnRQYWdlSW5kZXgsIGZpbGVOYW1lKTtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25WaWV3RGlkVXBkYXRlID0gZnVuY3Rpb24gKHJlbmRlcmVkUGFnZXMsIHRhcmdldFBhZ2UpXG57XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gKHRhcmdldFBhZ2UgIT09IG51bGwpID9cbiAgICAgICAgdGFyZ2V0UGFnZSA6XG4gICAgICAgIGdldENlbnRlcm1vc3RQYWdlKHJlbmRlcmVkUGFnZXMsIHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpLCB0aGlzLl92aWV3ZXJDb3JlLmdldFZpZXdwb3J0KCkpO1xuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBjdXJyZW50IHBhZ2UgaWYgdGhlcmUgaXMgbm8gcGFnZSBpbiB0aGUgdmlld3BvcnRcbiAgICAvLyBGSVhNRTogV291bGQgYmUgYmV0dGVyIHRvIGZhbGwgYmFjayB0byB0aGUgcGFnZSBjbG9zZXN0IHRvIHRoZSB2aWV3cG9ydFxuICAgIGlmIChjdXJyZW50UGFnZSAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5zZXRDdXJyZW50UGFnZShjdXJyZW50UGFnZSk7XG5cbiAgICBpZiAodGFyZ2V0UGFnZSAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkSnVtcFwiLCB0YXJnZXRQYWdlKTtcblxuICAgIHRoaXMuX2hhbmRsZVpvb21MZXZlbENoYW5nZSgpO1xufTtcblxuRG9jdW1lbnRIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlWm9vbUxldmVsQ2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdmlld2VyU3RhdGUgPSB0aGlzLl92aWV3ZXJTdGF0ZTtcbiAgICB2YXIgem9vbUxldmVsID0gdmlld2VyU3RhdGUub3B0aW9ucy56b29tTGV2ZWw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgaW5pdGlhbCBsb2FkLCB0cmlnZ2VyIHRoZSB6b29tIGV2ZW50c1xuICAgIGlmICh2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgIT09IHpvb21MZXZlbCAmJiB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPj0gMClcbiAgICB7XG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPCB6b29tTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIlZpZXdlckRpZFpvb21JblwiLCB6b29tTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkWm9vbU91dFwiLCB6b29tTGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkWm9vbVwiLCB6b29tTGV2ZWwpO1xuICAgIH1cblxuICAgIHZpZXdlclN0YXRlLm9sZFpvb21MZXZlbCA9IHpvb21MZXZlbDtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fb3ZlcmxheXMuZm9yRWFjaChmdW5jdGlvbiAob3ZlcmxheSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucmVtb3ZlUGFnZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDZW50ZXJtb3N0UGFnZShyZW5kZXJlZFBhZ2VzLCBsYXlvdXQsIHZpZXdwb3J0KVxue1xuICAgIHZhciBjZW50ZXJZID0gdmlld3BvcnQudG9wICsgKHZpZXdwb3J0LmhlaWdodCAvIDIpO1xuICAgIHZhciBjZW50ZXJYID0gdmlld3BvcnQubGVmdCArICh2aWV3cG9ydC53aWR0aCAvIDIpO1xuXG4gICAgLy8gRmluZCB0aGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSB2aWV3cG9ydCBjZW50ZXIgdG8gYSBwYWdlLlxuICAgIC8vIENvbXB1dGUgbWludXMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXIgdG8gdGhlIHBhZ2UncyBib3JkZXIuXG4gICAgLy8gaHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzQ0NDgzL2hvdy1kby1pLWNhbGN1bGF0ZS1kaXN0YW5jZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWFuLWF4aXMtYWxpZ25lZC1yZWN0YW5nbGVcbiAgICB2YXIgY2VudGVyUGFnZSA9IG1heEJ5KHJlbmRlcmVkUGFnZXMsIGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZGltcyA9IGxheW91dC5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpO1xuICAgICAgICB2YXIgaW1hZ2VPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgsIHtleGNsdWRlUGFkZGluZzogZmFsc2V9KTtcblxuICAgICAgICB2YXIgbWlkWCA9IGltYWdlT2Zmc2V0LmxlZnQgKyAoZGltcy5oZWlnaHQgLyAyKTtcbiAgICAgICAgdmFyIG1pZFkgPSBpbWFnZU9mZnNldC50b3AgKyAoZGltcy53aWR0aCAvIDIpO1xuXG4gICAgICAgIHZhciBkeCA9IE1hdGgubWF4KE1hdGguYWJzKGNlbnRlclggLSBtaWRYKSAtIChkaW1zLndpZHRoIC8gMiksIDApO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLm1heChNYXRoLmFicyhjZW50ZXJZIC0gbWlkWSkgLSAoZGltcy5oZWlnaHQgLyAyKSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIC0oZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNlbnRlclBhZ2UgIT0gbnVsbCA/IGNlbnRlclBhZ2UgOiBudWxsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvZG9jdW1lbnQtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xudmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICkpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBnZXRUYWcob3RoZXIpO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLmFkZChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IFVOT1JERVJFRF9DT01QQVJFX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgcmVzdWx0LFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0ID8gb2JqZWN0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDIgfVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDIgfVxuICovXG5mdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXhCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gubWF4YnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlVG9vbHNPdmVybGF5O1xuXG5mdW5jdGlvbiBQYWdlVG9vbHNPdmVybGF5KHBhZ2VJbmRleCwgdmlld2VyQ29yZSlcbntcbiAgICB0aGlzLnBhZ2UgPSBwYWdlSW5kZXg7XG5cbiAgICB0aGlzLl92aWV3ZXJDb3JlID0gdmlld2VyQ29yZTtcblxuICAgIHRoaXMuX2lubmVyRWxlbWVudCA9IHZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5pbm5lckVsZW1lbnQ7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbSA9IG51bGw7XG59XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGFnZVRvb2xzRWxlbSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5faW5pdGlhbGl6ZVBhZ2VUb29sQnV0dG9ucygpO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0gPSBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scy13cmFwcGVyJ30sXG4gICAgICAgICAgICBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scyd9LCBidXR0b25zKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHRoaXMuX2lubmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wYWdlVG9vbHNFbGVtKTtcbn07XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLl9pbml0aWFsaXplUGFnZVRvb2xCdXR0b25zID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBDYWxsYmFjayBwYXJhbWV0ZXJzXG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICB2YXIgcGFnZUluZGV4ID0gdGhpcy5wYWdlO1xuXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVRvb2xzKCkubWFwKGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICAvLyBJZiB0aGUgdGl0bGUgdGV4dCBpcyB1bmRlZmluZWQsIHVzZSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gICAgICAgIHZhciB0aXRsZVRleHQgPSBwbHVnaW4udGl0bGVUZXh0IHx8IHBsdWdpbi5wbHVnaW5OYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwbHVnaW4ucGx1Z2luTmFtZS5zdWJzdHJpbmcoMSkgKyBcIiBwbHVnaW5cIjtcblxuICAgICAgICB2YXIgYnV0dG9uID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIHBsdWdpbi5wbHVnaW5OYW1lICsgJy1pY29uJyxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZVRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBwbHVnaW4uaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCwgc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlLCBwYWdlSW5kZXgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZpcmluZyBvZiBlbXVsYXRlZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHBsdWdpbi5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50LCBzZXR0aW5ncywgcHVibGljSW5zdGFuY2UsIHBhZ2VJbmRleCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH0sIHRoaXMpO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5uZXJFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3BhZ2VUb29sc0VsZW0pO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHBvcyA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVJlZ2lvbih0aGlzLnBhZ2UsIHtcbiAgICAgICAgZXhjbHVkZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGluY29ycG9yYXRlVmlld3BvcnQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0uc3R5bGUudG9wID0gcG9zLnRvcCArICdweCc7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbS5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyAncHgnO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtdG9vbHMtb3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1heEJ5ID0gcmVxdWlyZSgnbG9kYXNoLm1heGJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZEhhbmRsZXI7XG5cbmZ1bmN0aW9uIEdyaWRIYW5kbGVyKHZpZXdlckNvcmUpXG57XG4gICAgdGhpcy5fdmlld2VyQ29yZSA9IHZpZXdlckNvcmU7XG59XG5cbi8vIFVTRVIgRVZFTlRTXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25Eb3VibGVDbGljayA9IGZ1bmN0aW9uIChldmVudCwgY29vcmRzKVxue1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVBvc2l0aW9uQXRWaWV3cG9ydE9mZnNldChjb29yZHMpO1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Vmlld3BvcnQoKTtcbiAgICB2YXIgcGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQocG9zaXRpb24uYW5jaG9yUGFnZSwgdmlld3BvcnQpO1xuXG4gICAgdGhpcy5fdmlld2VyQ29yZS5yZWxvYWQoe1xuICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICBnb0RpcmVjdGx5VG86IHBvc2l0aW9uLmFuY2hvclBhZ2UsXG4gICAgICAgIGhvcml6b250YWxPZmZzZXQ6IHBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0LnggKyBwb3NpdGlvbi5vZmZzZXQubGVmdCxcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IHBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0LnkgKyBwb3NpdGlvbi5vZmZzZXQudG9wXG4gICAgfSk7XG59O1xuXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25QaW5jaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fdmlld2VyQ29yZS5yZWxvYWQoeyBpbkdyaWQ6IGZhbHNlIH0pO1xufTtcblxuLy8gVklFVyBFVkVOVFNcbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdXaWxsTG9hZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUUod2FiYWluKTogU2hvdWxkIHNvbWV0aGluZyBoYXBwZW4gaGVyZT9cbiAgICAvKiBOby1vcCAqL1xufTtcblxuR3JpZEhhbmRsZXIucHJvdG90eXBlLm9uVmlld0RpZExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIEZJWE1FKHdhYmFpbik6IFNob3VsZCBzb21ldGhpbmcgaGFwcGVuIGhlcmU/XG4gICAgLyogTm8tb3AgKi9cbn07XG5cbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdEaWRVcGRhdGUgPSBmdW5jdGlvbiAocmVuZGVyZWRQYWdlcywgdGFyZ2V0UGFnZSlcbntcbiAgICBpZiAodGFyZ2V0UGFnZSAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUuc2V0Q3VycmVudFBhZ2UodGFyZ2V0UGFnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWxlY3QgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBmaXJzdCByb3cgaWYgaXQgaXMgZnVsbHkgdmlzaWJsZSwgb3IgZnJvbVxuICAgIC8vIHRoZSBzZWNvbmQgcm93IGlmIGl0IGlzIGZ1bGx5IHZpc2libGUsIG9yIGZyb20gdGhlIGNlbnRlcm1vc3Qgcm93IG90aGVyd2lzZS5cbiAgICAvLyBJZiB0aGUgY3VycmVudCBwYWdlIGlzIGluIHRoYXQgZ3JvdXAgdGhlbiBkb24ndCBjaGFuZ2UgaXQuIE90aGVyd2lzZSwgc2V0XG4gICAgLy8gdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgZ3JvdXAncyBmaXJzdCBwYWdlLlxuXG4gICAgdmFyIGxheW91dCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICByZW5kZXJlZFBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIHZhciBncm91cCA9IGxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpLmdyb3VwO1xuICAgICAgICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCB8fCBncm91cCAhPT0gZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXSlcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICB9KTtcblxuICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Vmlld3BvcnQoKTtcbiAgICB2YXIgY2hvc2VuR3JvdXA7XG5cbiAgICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMSB8fCBncm91cHNbMF0ucmVnaW9uLnRvcCA+PSB2aWV3cG9ydC50b3ApXG4gICAgICAgIGNob3Nlbkdyb3VwID0gZ3JvdXBzWzBdO1xuICAgIGVsc2UgaWYgKGdyb3Vwc1sxXS5yZWdpb24uYm90dG9tIDw9IHZpZXdwb3J0LmJvdHRvbSlcbiAgICAgICAgY2hvc2VuR3JvdXAgPSBncm91cHNbMV07XG4gICAgZWxzZVxuICAgICAgICBjaG9zZW5Hcm91cCA9IGdldENlbnRlcm1vc3RHcm91cChncm91cHMsIHZpZXdwb3J0KTtcblxuICAgIHZhciBjdXJyZW50UGFnZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5jdXJyZW50UGFnZUluZGV4O1xuXG4gICAgdmFyIGhhc0N1cnJlbnRQYWdlID0gY2hvc2VuR3JvdXAucGFnZXMuc29tZShmdW5jdGlvbiAocGFnZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBwYWdlLmluZGV4ID09PSBjdXJyZW50UGFnZTtcbiAgICB9KTtcblxuICAgIGlmICghaGFzQ3VycmVudFBhZ2UpXG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUuc2V0Q3VycmVudFBhZ2UoY2hvc2VuR3JvdXAucGFnZXNbMF0uaW5kZXgpO1xufTtcblxuR3JpZEhhbmRsZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIE5vLW9wXG59O1xuXG5mdW5jdGlvbiBnZXRDZW50ZXJtb3N0R3JvdXAoZ3JvdXBzLCB2aWV3cG9ydClcbntcbiAgICB2YXIgdmlld3BvcnRNaWRkbGUgPSB2aWV3cG9ydC50b3AgKyB2aWV3cG9ydC5oZWlnaHQgLyAyO1xuXG4gICAgcmV0dXJuIG1heEJ5KGdyb3VwcywgZnVuY3Rpb24gKGdyb3VwKVxuICAgIHtcbiAgICAgICAgdmFyIGdyb3VwTWlkZGxlID0gZ3JvdXAucmVnaW9uLnRvcCArIGdyb3VwLmRpbWVuc2lvbnMuaGVpZ2h0IC8gMjtcbiAgICAgICAgcmV0dXJuIC1NYXRoLmFicyh2aWV3cG9ydE1pZGRsZSAtIGdyb3VwTWlkZGxlKTtcbiAgICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2dyaWQtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBQYWdlT3ZlcmxheU1hbmFnZXI7XG5cbi8qKlxuICogTWFuYWdlcyBhIGNvbGxlY3Rpb24gb2YgcGFnZSBvdmVybGF5cywgd2hpY2ggaW1wbGVtZW50IGEgbG93LWxldmVsXG4gKiBBUEkgZm9yIHN5bmNocm9uaXppbmcgSFRNTCBwYWdlcyB0byB0aGUgY2FudmFzLiBFYWNoIG92ZXJsYXkgbmVlZHNcbiAqIHRvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3RvY29sOlxuICpcbiAqICAgbW91bnQoKTogQ2FsbGVkIHdoZW4gYSBwYWdlIGlzIGZpcnN0IHJlbmRlcmVkXG4gKiAgIHJlZnJlc2goKTogQ2FsbGVkIHdoZW4gYSBwYWdlIGlzIG1vdmVkXG4gKiAgIHVubW91bnQoKTogQ2FsbGVkIHdoZW4gYSBwcmV2aW91c2x5IHJlbmRlcmVkIHBhZ2UgaGFzIHN0b3BwZWQgYmVpbmcgcmVuZGVyZWRcbiAqXG4gKiBAY2xhc3NcbiAqL1xuXG5mdW5jdGlvbiBQYWdlT3ZlcmxheU1hbmFnZXIoKVxue1xuICAgIHRoaXMuX3BhZ2VzID0ge307XG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcyA9IFtdO1xuICAgIHRoaXMuX3JlbmRlcmVkUGFnZU1hcCA9IHt9O1xufVxuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLmFkZE92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbntcbiAgICB2YXIgb3ZlcmxheXNCeVBhZ2UgPSB0aGlzLl9wYWdlc1tvdmVybGF5LnBhZ2VdIHx8ICh0aGlzLl9wYWdlc1tvdmVybGF5LnBhZ2VdID0gW10pO1xuXG4gICAgb3ZlcmxheXNCeVBhZ2UucHVzaChvdmVybGF5KTtcblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZFBhZ2VNYXBbb3ZlcmxheS5wYWdlXSlcbiAgICAgICAgb3ZlcmxheS5tb3VudCgpO1xufTtcblxuUGFnZU92ZXJsYXlNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG57XG4gICAgdmFyIHBhZ2UgPSBvdmVybGF5LnBhZ2U7XG4gICAgdmFyIG92ZXJsYXlzQnlQYWdlID0gdGhpcy5fcGFnZXNbcGFnZV07XG5cbiAgICBpZiAoIW92ZXJsYXlzQnlQYWdlKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgb3ZlcmxheUluZGV4ID0gb3ZlcmxheXNCeVBhZ2UuaW5kZXhPZihvdmVybGF5KTtcblxuICAgIGlmIChvdmVybGF5SW5kZXggPT09IC0xKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyZWRQYWdlTWFwW3BhZ2VdKVxuICAgICAgICBvdmVybGF5c0J5UGFnZVtvdmVybGF5SW5kZXhdLnVubW91bnQoKTtcblxuICAgIG92ZXJsYXlzQnlQYWdlLnNwbGljZShvdmVybGF5SW5kZXgsIDEpO1xuXG4gICAgaWYgKG92ZXJsYXlzQnlQYWdlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BhZ2VzW3BhZ2VdO1xufTtcblxuUGFnZU92ZXJsYXlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVPdmVybGF5cyA9IGZ1bmN0aW9uIChyZW5kZXJlZFBhZ2VzKVxue1xuICAgIHZhciBwcmV2aW91c2x5UmVuZGVyZWQgPSB0aGlzLl9yZW5kZXJlZFBhZ2VzO1xuICAgIHZhciBuZXdSZW5kZXJlZE1hcCA9IHt9O1xuXG4gICAgcmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBuZXdSZW5kZXJlZE1hcFtwYWdlSW5kZXhdID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVkUGFnZU1hcFtwYWdlSW5kZXhdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlZFBhZ2VNYXBbcGFnZUluZGV4XSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuX2ludm9rZU9uT3ZlcmxheXMocGFnZUluZGV4LCBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5Lm1vdW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgcHJldmlvdXNseVJlbmRlcmVkLmZvckVhY2goZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIGlmIChuZXdSZW5kZXJlZE1hcFtwYWdlSW5kZXhdKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbk92ZXJsYXlzKHBhZ2VJbmRleCwgZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZW5kZXJlZFBhZ2VNYXBbcGFnZUluZGV4XTtcblxuICAgICAgICAgICAgdGhpcy5faW52b2tlT25PdmVybGF5cyhwYWdlSW5kZXgsIGZ1bmN0aW9uIChvdmVybGF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkudW5tb3VudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3JlbmRlcmVkUGFnZXMgPSByZW5kZXJlZFBhZ2VzO1xufTtcblxuUGFnZU92ZXJsYXlNYW5hZ2VyLnByb3RvdHlwZS5faW52b2tlT25PdmVybGF5cyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGZ1bmMpXG57XG4gICAgdmFyIG92ZXJsYXlzID0gdGhpcy5fcGFnZXNbcGFnZUluZGV4XTtcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIG92ZXJsYXlzLmZvckVhY2goZnVuYywgdGhpcyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGFnZS1vdmVybGF5LW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpSZW5kZXJlcicpO1xudmFyIGRlYnVnUGFpbnRzID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpSZW5kZXJlcjpwYWludHMnKTtcblxudmFyIGVsdCA9IHJlcXVpcmUoJy4vdXRpbHMvZWx0Jyk7XG5cbnZhciBDb21wb3NpdGVJbWFnZSA9IHJlcXVpcmUoJy4vY29tcG9zaXRlLWltYWdlJyk7XG52YXIgRG9jdW1lbnRMYXlvdXQgPSByZXF1aXJlKCcuL2RvY3VtZW50LWxheW91dCcpO1xudmFyIEltYWdlQ2FjaGUgPSByZXF1aXJlKCcuL2ltYWdlLWNhY2hlJyk7XG52YXIgSW1hZ2VSZXF1ZXN0SGFuZGxlciA9IHJlcXVpcmUoJy4vaW1hZ2UtcmVxdWVzdC1oYW5kbGVyJyk7XG52YXIgSW50ZXJwb2xhdGVBbmltYXRpb24gPSByZXF1aXJlKCcuL2ludGVycG9sYXRlLWFuaW1hdGlvbicpO1xuXG52YXIgUkVRVUVTVF9ERUJPVU5DRV9JTlRFUlZBTCA9IDI1MDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyO1xuXG5mdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zLCBob29rcylcbntcbiAgICB0aGlzLl92aWV3cG9ydCA9IG9wdGlvbnMudmlld3BvcnQ7XG4gICAgdGhpcy5fb3V0ZXJFbGVtZW50ID0gb3B0aW9ucy5vdXRlckVsZW1lbnQ7XG4gICAgdGhpcy5fZG9jdW1lbnRFbGVtZW50ID0gb3B0aW9ucy5pbm5lckVsZW1lbnQ7XG5cbiAgICB0aGlzLl9ob29rcyA9IGhvb2tzIHx8IHt9O1xuXG4gICAgdGhpcy5fY2FudmFzID0gZWx0KCdjYW52YXMnLCB7IGNsYXNzOiAnZGl2YS12aWV3ZXItY2FudmFzJyB9KTtcbiAgICB0aGlzLl9jdHggPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHRoaXMubGF5b3V0ID0gbnVsbDtcblxuICAgIHRoaXMuX3NvdXJjZVJlc29sdmVyID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzID0gbnVsbDtcbiAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIHRoaXMuX3pvb21MZXZlbCA9IG51bGw7XG4gICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzID0gbnVsbDtcbiAgICB0aGlzLl9yZW5kZXJlZFRpbGVzID0gbnVsbDtcbiAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogV2hhdCBsZXZlbCBzaG91bGQgdGhpcyBiZSBtYWludGFpbmVkIGF0P1xuICAgIC8vIERpdmEgZ2xvYmFsP1xuICAgIHRoaXMuX2NhY2hlID0gbmV3IEltYWdlQ2FjaGUoKTtcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMgPSB7fTtcbn1cblxuUmVuZGVyZXIuZ2V0Q29tcGF0aWJpbGl0eUVycm9ycyA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ1lvdXIgYnJvd3NlciBsYWNrcyBzdXBwb3J0IGZvciB0aGUgJywgZWx0KCdwcmUnLCAnY2FudmFzJyksXG4gICAgICAgICcgZWxlbWVudC4gUGxlYXNlIHVwZ3JhZGUgeW91ciBicm93c2VyLidcbiAgICBdO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY29uZmlnLCB2aWV3cG9ydFBvc2l0aW9uLCBzb3VyY2VSZXNvbHZlcilcbntcbiAgICB0aGlzLl9jbGVhckFuaW1hdGlvbigpO1xuXG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld1dpbGxMb2FkKVxuICAgICAgICB0aGlzLl9ob29rcy5vblZpZXdXaWxsTG9hZCgpO1xuXG4gICAgdGhpcy5fc291cmNlUmVzb2x2ZXIgPSBzb3VyY2VSZXNvbHZlcjtcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzID0ge307XG4gICAgdGhpcy5fc2V0TGF5b3V0VG9ab29tTGV2ZWwodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwpO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogUmVtb3ZlIHRoaXMgd2hlbiB0aGVyZSdzIG1vcmUgY29uZmlkZW5jZSB0aGUgY2hlY2sgc2hvdWxkbid0IGJlIG5lZWRlZFxuICAgIGlmICghdGhpcy5sYXlvdXQuZ2V0UGFnZUluZm8odmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhZ2U6ICcgKyB2aWV3cG9ydFBvc2l0aW9uLmFuY2hvclBhZ2UpO1xuXG4gICAgaWYgKHRoaXMuX2NhbnZhcy53aWR0aCAhPT0gdGhpcy5fdmlld3BvcnQud2lkdGggfHwgdGhpcy5fY2FudmFzLmhlaWdodCAhPT0gdGhpcy5fdmlld3BvcnQuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgZGVidWcoJ0NhbnZhcyBkaW1lbnNpb24gY2hhbmdlOiAoJXMsICVzKSAtPiAoJXMsICVzKScsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdwb3J0LndpZHRoLCB0aGlzLl92aWV3cG9ydC5oZWlnaHQpO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuX3ZpZXdwb3J0LndpZHRoO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gdGhpcy5fdmlld3BvcnQuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdSZWxvYWQsIG5vIHNpemUgY2hhbmdlJyk7XG4gICAgfVxuXG4gICAgLy8gRklYTUU6IFdoYXQgaG9va3Mgc2hvdWxkIGJlIGNhbGxlZCBoZXJlP1xuICAgIHRoaXMuZ290byh2aWV3cG9ydFBvc2l0aW9uLmFuY2hvclBhZ2UsIHZpZXdwb3J0UG9zaXRpb24udmVydGljYWxPZmZzZXQsIHZpZXdwb3J0UG9zaXRpb24uaG9yaXpvbnRhbE9mZnNldCk7XG5cbiAgICBpZiAodGhpcy5fY2FudmFzLnBhcmVudE5vZGUgIT09IHRoaXMuX291dGVyRWxlbWVudClcbiAgICAgICAgdGhpcy5fb3V0ZXJFbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLl9jYW52YXMsIHRoaXMuX291dGVyRWxlbWVudC5maXJzdENoaWxkKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblZpZXdEaWRMb2FkKVxuICAgICAgICB0aGlzLl9ob29rcy5vblZpZXdEaWRMb2FkKCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX3NldFZpZXdwb3J0UG9zaXRpb24gPSBmdW5jdGlvbiAodmlld3BvcnRQb3NpdGlvbilcbntcbiAgICBpZiAodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwgIT09IHRoaXMuX3pvb21MZXZlbClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl96b29tTGV2ZWwgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY3VycmVudCB2aWV3IGlzIG5vdCB6b29tYWJsZScpO1xuICAgICAgICBlbHNlIGlmICh2aWV3cG9ydFBvc2l0aW9uLnpvb21MZXZlbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjdXJyZW50IHZpZXcgcmVxdWlyZXMgYSB6b29tIGxldmVsJyk7XG5cbiAgICAgICAgdGhpcy5fc2V0TGF5b3V0VG9ab29tTGV2ZWwodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwpO1xuICAgIH1cblxuICAgIHRoaXMuX2dvdG8odmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlLCB2aWV3cG9ydFBvc2l0aW9uLnZlcnRpY2FsT2Zmc2V0LCB2aWV3cG9ydFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9zZXRMYXlvdXRUb1pvb21MZXZlbCA9IGZ1bmN0aW9uICh6b29tTGV2ZWwpXG57XG4gICAgdGhpcy5sYXlvdXQgPSBuZXcgRG9jdW1lbnRMYXlvdXQodGhpcy5fY29uZmlnLCB6b29tTGV2ZWwpO1xuICAgIHRoaXMuX3pvb21MZXZlbCA9IHpvb21MZXZlbDtcblxuICAgIGVsdC5zZXRBdHRyaWJ1dGVzKHRoaXMuX2RvY3VtZW50RWxlbWVudCwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmxheW91dC5kaW1lbnNpb25zLmhlaWdodCArICdweCcsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy5sYXlvdXQuZGltZW5zaW9ucy53aWR0aCArICdweCdcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fdmlld3BvcnQuc2V0SW5uZXJEaW1lbnNpb25zKHRoaXMubGF5b3V0LmRpbWVuc2lvbnMpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmFkanVzdCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIHRoaXMuX3JlbmRlcihkaXJlY3Rpb24pO1xuXG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSh0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIG51bGwpO1xuICAgIH1cbn07XG5cbi8vIEZJWE1FKHdhYmFpbik6IFJlbW92ZSB0aGUgZGlyZWN0aW9uIGFyZ3VtZW50IGlmIGl0IGRvZXNuJ3QgZW5kIHVwIGJlaW5nIG5lZWRlZC5cblJlbmRlcmVyLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKGRpcmVjdGlvbikgLy8ganNoaW50IGlnbm9yZTpsaW5lXG57XG4gICAgdmFyIG5ld1JlbmRlcmVkUGFnZXMgPSBbXTtcbiAgICB0aGlzLmxheW91dC5wYWdlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl92aWV3cG9ydC5pbnRlcnNlY3RzUmVnaW9uKGdyb3VwLnJlZ2lvbikpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHZpc2libGVQYWdlcyA9IGdyb3VwLnBhZ2VzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGFnZVZpc2libGUocGFnZS5pbmRleCk7XG4gICAgICAgICAgICB9LCB0aGlzKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocGFnZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFnZS5pbmRleDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIG5ld1JlbmRlcmVkUGFnZXMucHVzaC5hcHBseShuZXdSZW5kZXJlZFBhZ2VzLCB2aXNpYmxlUGFnZXMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuX3BhaW50T3V0bGluZShuZXdSZW5kZXJlZFBhZ2VzKTtcblxuICAgIG5ld1JlbmRlcmVkUGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wb3NpdGVJbWFnZXNbcGFnZUluZGV4XSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpO1xuICAgICAgICAgICAgdmFyIHpvb21MZXZlbHMgPSB0aGlzLl9zb3VyY2VSZXNvbHZlci5nZXRBbGxab29tTGV2ZWxzRm9yUGFnZShwYWdlKTtcbiAgICAgICAgICAgIHZhciBjb21wb3NpdGUgPSBuZXcgQ29tcG9zaXRlSW1hZ2Uoem9vbUxldmVscyk7XG4gICAgICAgICAgICBjb21wb3NpdGUudXBkYXRlRnJvbUNhY2hlKHRoaXMuX2NhY2hlKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdID0gY29tcG9zaXRlO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9pbml0aWF0ZVRpbGVSZXF1ZXN0cyhuZXdSZW5kZXJlZFBhZ2VzKTtcblxuICAgIHZhciBjaGFuZ2VzID0gZmluZENoYW5nZXModGhpcy5fcmVuZGVyZWRQYWdlcyB8fCBbXSwgbmV3UmVuZGVyZWRQYWdlcyk7XG5cbiAgICBjaGFuZ2VzLnJlbW92ZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcyA9IG5ld1JlbmRlcmVkUGFnZXM7XG4gICAgdGhpcy5fcGFpbnQoKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblBhZ2VXaWxsTG9hZClcbiAgICB7XG4gICAgICAgIGNoYW5nZXMuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9ob29rcy5vblBhZ2VXaWxsTG9hZChwYWdlSW5kZXgpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX3BhaW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBkZWJ1ZygnUmVwYWludGluZycpO1xuXG4gICAgdmFyIHJlbmRlcmVkVGlsZXMgPSBbXTtcblxuICAgIHRoaXMuX3JlbmRlcmVkUGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF0uZ2V0VGlsZXModGhpcy5fem9vbUxldmVsKS5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzY2FsZWQgPSBnZXRTY2FsZWRUaWxlUmVjb3JkKHNvdXJjZSwgdGhpcy5fem9vbUxldmVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVZpc2libGUocGFnZUluZGV4LCBzY2FsZWQpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkVGlsZXMucHVzaChzb3VyY2UudXJsKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3VGlsZShwYWdlSW5kZXgsIHNjYWxlZCwgdGhpcy5fY2FjaGUuZ2V0KHNvdXJjZS51cmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZTtcblxuICAgIHZhciBjaGFuZ2VzID0gZmluZENoYW5nZXModGhpcy5fcmVuZGVyZWRUaWxlcyB8fCBbXSwgcmVuZGVyZWRUaWxlcyk7XG5cbiAgICBjaGFuZ2VzLmFkZGVkLmZvckVhY2goZnVuY3Rpb24gKHVybClcbiAgICB7XG4gICAgICAgIGNhY2hlLmFjcXVpcmUodXJsKTtcbiAgICB9KTtcblxuICAgIGNoYW5nZXMucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpXG4gICAge1xuICAgICAgICBjYWNoZS5yZWxlYXNlKHVybCk7XG4gICAgfSk7XG5cbiAgICBpZiAoY2hhbmdlcy5yZW1vdmVkKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU6IFNob3VsZCBvbmx5IG5lZWQgdG8gdXBkYXRlIHRoZSBjb21wb3NpdGUgaW1hZ2VzXG4gICAgICAgIC8vIGZvciB3aGljaCB0aWxlcyB3ZXJlIHJlbW92ZWRcbiAgICAgICAgdGhpcy5fcmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdLnVwZGF0ZUZyb21DYWNoZSh0aGlzLl9jYWNoZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkVGlsZXMgPSByZW5kZXJlZFRpbGVzO1xufTtcblxuLy8gUGFpbnQgYSBwYWdlIG91dGxpbmUgd2hpbGUgdGhlIHRpbGVzIGFyZSBsb2FkaW5nLlxuUmVuZGVyZXIucHJvdG90eXBlLl9wYWludE91dGxpbmUgPSBmdW5jdGlvbiAocGFnZXMpXG57XG4gICAgcGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5sYXlvdXQuZ2V0UGFnZUluZm8ocGFnZUluZGV4KTtcbiAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSB0aGlzLl9nZXRJbWFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGUgZG9jdW1lbnQgaXMgZHJhd24gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgdmFyIHZpZXdwb3J0UGFkZGluZ1ggPSBNYXRoLm1heCgwLCAodGhpcy5fdmlld3BvcnQud2lkdGggLSB0aGlzLmxheW91dC5kaW1lbnNpb25zLndpZHRoKSAvIDIpO1xuICAgICAgICB2YXIgdmlld3BvcnRQYWRkaW5nWSA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC5oZWlnaHQgLSB0aGlzLmxheW91dC5kaW1lbnNpb25zLmhlaWdodCkgLyAyKTtcblxuICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXRYID0gcGFnZU9mZnNldC5sZWZ0IC0gdGhpcy5fdmlld3BvcnQubGVmdCArIHZpZXdwb3J0UGFkZGluZ1g7XG4gICAgICAgIHZhciB2aWV3cG9ydE9mZnNldFkgPSBwYWdlT2Zmc2V0LnRvcCAtIHRoaXMuX3ZpZXdwb3J0LnRvcCArIHZpZXdwb3J0UGFkZGluZ1k7XG5cbiAgICAgICAgdmFyIGRlc3RYT2Zmc2V0ID0gdmlld3BvcnRPZmZzZXRYIDwgMCA/IC12aWV3cG9ydE9mZnNldFggOiAwO1xuICAgICAgICB2YXIgZGVzdFlPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFkgPCAwID8gLXZpZXdwb3J0T2Zmc2V0WSA6IDA7XG5cbiAgICAgICAgdmFyIGNhbnZhc1ggPSBNYXRoLm1heCgwLCB2aWV3cG9ydE9mZnNldFgpO1xuICAgICAgICB2YXIgY2FudmFzWSA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WSk7XG5cbiAgICAgICAgdmFyIGRlc3RXaWR0aCA9IHBhZ2VJbmZvLmRpbWVuc2lvbnMud2lkdGggLSBkZXN0WE9mZnNldDtcbiAgICAgICAgdmFyIGRlc3RIZWlnaHQgPSBwYWdlSW5mby5kaW1lbnNpb25zLmhlaWdodCAtIGRlc3RZT2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICcjQUFBJztcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gZ2V0IGEgMXB4IHdpZGUgbGluZSB1c2luZyBzdHJva2VzLCB3ZSBuZWVkIHRvIHN0YXJ0IGF0IGEgJ2hhbGYgcGl4ZWwnXG4gICAgICAgIHRoaXMuX2N0eC5zdHJva2VSZWN0KGNhbnZhc1ggKyAwLjUsIGNhbnZhc1kgKyAwLjUsIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG4vLyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgc2VudCBhbGwgdmlzaWJsZSBwYWdlcyBhdCBvbmNlIGJlY2F1c2UgaXQgd2lsbCBpbml0aWF0ZVxuLy8gYWxsIGltYWdlIHJlcXVlc3RzIGFuZCBjYW5jZWwgYW55IHJlbWFpbmluZyBpbWFnZSByZXF1ZXN0cy4gSW4gdGhlIGNhc2UgdGhhdFxuLy8gYSByZXF1ZXN0IGlzIG9uZ29pbmcgYW5kIHRoZSB0aWxlIGlzIHN0aWxsIHZpc2libGUgaW4gdGhlIHZpZXdwb3J0LCB0aGUgb2xkIHJlcXVlc3Rcbi8vIGlzIGtlcHQgYWN0aXZlIGluc3RlYWQgb2YgcmVzdGFydGluZyBpdC4gVGhlIGltYWdlIHJlcXVlc3RzIGFyZSBnaXZlbiBhIHRpbWVvdXRcbi8vIGJlZm9yZSBsb2FkaW5nIGluIG9yZGVyIHRvIGRlYm91bmNlIHRoZW0gYW5kIGhhdmUgYSBzbWFsbCByZWFjdGlvbiB0aW1lXG4vLyB0byBjYW5jZWwgdGhlbSBhbmQgYXZvaWQgdXNlbGVzcyByZXF1ZXN0cy5cblJlbmRlcmVyLnByb3RvdHlwZS5faW5pdGlhdGVUaWxlUmVxdWVzdHMgPSBmdW5jdGlvbihwYWdlcylcbntcbiAgICAvLyBPbmx5IHJlcXVlc3RzIGluIHRoaXMgb2JqZWN0IGFyZSBrZXB0IGFsaXZlLCBzaW5jZSBhbGwgb3RoZXJzIGFyZSBub3QgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgbmV3UGVuZGluZ1JlcXVlc3RzID0ge307XG5cbiAgICAvLyBVc2VkIGxhdGVyIGFzIGEgY2xvc3VyZSB0byBpbml0aWF0ZSB0aGUgaW1hZ2UgcmVxdWVzdHMgd2l0aCB0aGUgcmlnaHQgc291cmNlIGFuZCBwYWdlSW5kZXhcbiAgICB2YXIgaW5pdGlhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHNvdXJjZSwgcGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGNvbXBvc2l0ZSA9IHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgICAgIG5ld1BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXSA9IG5ldyBJbWFnZVJlcXVlc3RIYW5kbGVyKHtcbiAgICAgICAgICAgIHVybDogc291cmNlLnVybCxcbiAgICAgICAgICAgIHRpbWVvdXRUaW1lOiBSRVFVRVNUX0RFQk9VTkNFX0lOVEVSVkFMLFxuICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24gKGltZylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLnB1dChzb3VyY2UudXJsLCBpbWcpO1xuXG4gICAgICAgICAgICAgICAgLy8gQXdrd2FyZCB3YXkgdG8gY2hlY2sgZm9yIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRlID09PSB0aGlzLl9jb21wb3NpdGVJbWFnZXNbcGFnZUluZGV4XSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2l0ZS51cGRhdGVXaXRoTG9hZGVkVXJscyhbc291cmNlLnVybF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlKHBhZ2VJbmRleCwgc291cmNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhaW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnUGFpbnRzKCdQYWdlICVzLCB0aWxlICVzIG5vIGxvbmdlciB2aXNpYmxlIG9uIGltYWdlIGxvYWQnLCBwYWdlSW5kZXgsIHNvdXJjZS51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvdWxkIG1ha2UgYSBsaW1pdGVkIG51bWJlciBvZiByZXRyaWVzLCBldGMuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgIHtcbiAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhZ2VzW2ldO1xuICAgICAgICB2YXIgdGlsZXMgPSB0aGlzLl9zb3VyY2VSZXNvbHZlci5nZXRCZXN0Wm9vbUxldmVsRm9yUGFnZSh0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpKS50aWxlcztcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpbGVzLmxlbmd0aDsgaisrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGlsZXNbal07XG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGUuaGFzKHNvdXJjZS51cmwpIHx8ICF0aGlzLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlKHBhZ2VJbmRleCwgc291cmNlKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGEgbmV3IHJlcXVlc3QgaWYgdGhlIHRpbGUgaXMgYWxyZWFkeSBiZWluZyBsb2FkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmV3UGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdID0gdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIGNsb3N1cmUgc2luY2UgdGhlIGxvYWQgYW5kIGVycm9yIG1ldGhvZHMgYXJlIGdvaW5nIHRvIGJlIGNhbGxlZCBsYXRlciBhbmRcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8ga2VlcCB0aGUgcmlnaHQgcmVmZXJlbmNlIHRvIHRoZSBzb3VyY2UgYW5kIHRoZSBwYWdlIGluZGV4XG4gICAgICAgICAgICBpbml0aWF0ZVJlcXVlc3Qoc291cmNlLCBwYWdlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdXJsIGluIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cylcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3VybF0uYWJvcnQoKTtcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMgPSBuZXdQZW5kaW5nUmVxdWVzdHM7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2RyYXdUaWxlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2NhbGVkVGlsZSwgaW1nKVxue1xuICAgIHZhciB0aWxlT2Zmc2V0ID0gdGhpcy5fZ2V0VGlsZVRvRG9jdW1lbnRPZmZzZXQocGFnZUluZGV4LCBzY2FsZWRUaWxlKTtcblxuICAgIC8vIEVuc3VyZSB0aGUgZG9jdW1lbnQgaXMgZHJhd24gdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nWCA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC53aWR0aCAtIHRoaXMubGF5b3V0LmRpbWVuc2lvbnMud2lkdGgpIC8gMik7XG4gICAgdmFyIHZpZXdwb3J0UGFkZGluZ1kgPSBNYXRoLm1heCgwLCAodGhpcy5fdmlld3BvcnQuaGVpZ2h0IC0gdGhpcy5sYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQpIC8gMik7XG5cbiAgICB2YXIgdmlld3BvcnRPZmZzZXRYID0gdGlsZU9mZnNldC5sZWZ0IC0gdGhpcy5fdmlld3BvcnQubGVmdCArIHZpZXdwb3J0UGFkZGluZ1g7XG4gICAgdmFyIHZpZXdwb3J0T2Zmc2V0WSA9IHRpbGVPZmZzZXQudG9wIC0gdGhpcy5fdmlld3BvcnQudG9wICsgdmlld3BvcnRQYWRkaW5nWTtcblxuICAgIHZhciBkZXN0WE9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0WCA8IDAgPyAtdmlld3BvcnRPZmZzZXRYIDogMDtcbiAgICB2YXIgZGVzdFlPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFkgPCAwID8gLXZpZXdwb3J0T2Zmc2V0WSA6IDA7XG5cbiAgICB2YXIgc291cmNlWE9mZnNldCA9IGRlc3RYT2Zmc2V0IC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuICAgIHZhciBzb3VyY2VZT2Zmc2V0ID0gZGVzdFlPZmZzZXQgLyBzY2FsZWRUaWxlLnNjYWxlUmF0aW87XG5cbiAgICB2YXIgY2FudmFzWCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WCk7XG4gICAgdmFyIGNhbnZhc1kgPSBNYXRoLm1heCgwLCB2aWV3cG9ydE9mZnNldFkpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIHNwZWNpZmllZCBkaW1lbnNpb25zIGFyZSBubyBncmVhdGVyIHRoYW4gdGhlIGFjdHVhbFxuICAgIC8vIHNpemUgb2YgdGhlIGltYWdlLiBTYWZhcmkgd29uJ3QgZGlzcGxheSB0aGUgdGlsZSBpZiB0aGV5IGFyZS5cbiAgICB2YXIgZGVzdFdpZHRoID0gTWF0aC5taW4oc2NhbGVkVGlsZS5kaW1lbnNpb25zLndpZHRoLCBpbWcud2lkdGggKiBzY2FsZWRUaWxlLnNjYWxlUmF0aW8pIC0gZGVzdFhPZmZzZXQ7XG4gICAgdmFyIGRlc3RIZWlnaHQgPSBNYXRoLm1pbihzY2FsZWRUaWxlLmRpbWVuc2lvbnMuaGVpZ2h0LCBpbWcuaGVpZ2h0ICogc2NhbGVkVGlsZS5zY2FsZVJhdGlvKSAtIGRlc3RZT2Zmc2V0O1xuXG4gICAgdmFyIHNvdXJjZVdpZHRoID0gZGVzdFdpZHRoIC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuICAgIHZhciBzb3VyY2VIZWlnaHQgPSBkZXN0SGVpZ2h0IC8gc2NhbGVkVGlsZS5zY2FsZVJhdGlvO1xuXG4gICAgaWYgKGRlYnVnUGFpbnRzLmVuYWJsZWQpIHtcbiAgICAgICAgZGVidWdQYWludHMoJ0RyYXdpbmcgcGFnZSAlcywgdGlsZSAlc3ggKCVzLCAlcykgZnJvbSAlcywgJXMgdG8gdmlld3BvcnQgYXQgJXMsICVzLCBzY2FsZSAlcyUlJyxcbiAgICAgICAgICAgIHBhZ2VJbmRleCxcbiAgICAgICAgICAgIHNjYWxlZFRpbGUuc291cmNlWm9vbUxldmVsLCBzY2FsZWRUaWxlLnJvdywgc2NhbGVkVGlsZS5jb2wsXG4gICAgICAgICAgICBzb3VyY2VYT2Zmc2V0LCBzb3VyY2VZT2Zmc2V0LFxuICAgICAgICAgICAgY2FudmFzWCwgY2FudmFzWSxcbiAgICAgICAgICAgIE1hdGgucm91bmQoc2NhbGVkVGlsZS5zY2FsZVJhdGlvICogMTAwKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3R4LmRyYXdJbWFnZShcbiAgICAgICAgaW1nLFxuICAgICAgICBzb3VyY2VYT2Zmc2V0LCBzb3VyY2VZT2Zmc2V0LFxuICAgICAgICBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0LFxuICAgICAgICBjYW52YXNYLCBjYW52YXNZLFxuICAgICAgICBkZXN0V2lkdGgsIGRlc3RIZWlnaHQpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9pc1RpbGVGb3JTb3VyY2VWaXNpYmxlID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdGlsZVNvdXJjZSlcbntcbiAgICByZXR1cm4gdGhpcy5faXNUaWxlVmlzaWJsZShwYWdlSW5kZXgsIGdldFNjYWxlZFRpbGVSZWNvcmQodGlsZVNvdXJjZSwgdGhpcy5fem9vbUxldmVsKSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2lzVGlsZVZpc2libGUgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzY2FsZWRUaWxlKVxue1xuICAgIHZhciB0aWxlT2Zmc2V0ID0gdGhpcy5fZ2V0VGlsZVRvRG9jdW1lbnRPZmZzZXQocGFnZUluZGV4LCBzY2FsZWRUaWxlKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgY2hlY2sgaXMgaW5zdWZmaWNpZW50IGR1cmluZyBhIHpvb20gdHJhbnNpdGlvblxuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydC5pbnRlcnNlY3RzUmVnaW9uKHtcbiAgICAgICAgdG9wOiB0aWxlT2Zmc2V0LnRvcCxcbiAgICAgICAgYm90dG9tOiB0aWxlT2Zmc2V0LnRvcCArIHNjYWxlZFRpbGUuZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgIGxlZnQ6IHRpbGVPZmZzZXQubGVmdCxcbiAgICAgICAgcmlnaHQ6IHRpbGVPZmZzZXQubGVmdCArIHNjYWxlZFRpbGUuZGltZW5zaW9ucy53aWR0aFxuICAgIH0pO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9nZXRUaWxlVG9Eb2N1bWVudE9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNjYWxlZFRpbGUpXG57XG4gICAgdmFyIGltYWdlT2Zmc2V0ID0gdGhpcy5fZ2V0SW1hZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogaW1hZ2VPZmZzZXQudG9wICsgc2NhbGVkVGlsZS5vZmZzZXQudG9wLFxuICAgICAgICBsZWZ0OiBpbWFnZU9mZnNldC5sZWZ0ICsgc2NhbGVkVGlsZS5vZmZzZXQubGVmdFxuICAgIH07XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2dldEltYWdlT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICByZXR1cm4gdGhpcy5sYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgsIHtleGNsdWRlUGFkZGluZzogdHJ1ZX0pO1xufTtcblxuLy8gVE9ETzogVXBkYXRlIHNpZ25hdHVyZVxuUmVuZGVyZXIucHJvdG90eXBlLmdvdG8gPSBmdW5jdGlvbiAocGFnZUluZGV4LCB2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldClcbntcbiAgICB0aGlzLl9jbGVhckFuaW1hdGlvbigpO1xuICAgIHRoaXMuX2dvdG8ocGFnZUluZGV4LCB2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldCk7XG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZSh0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIHBhZ2VJbmRleCk7XG4gICAgfVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9nb3RvID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdmVydGljYWxPZmZzZXQsIGhvcml6b250YWxPZmZzZXQpXG57XG4gICAgLy8gRklYTUUod2FiYWluKTogTW92ZSB0aGlzIGxvZ2ljIHRvIHRoZSB2aWV3ZXJcbiAgICB2YXIgcGFnZU9mZnNldCA9IHRoaXMubGF5b3V0LmdldFBhZ2VPZmZzZXQocGFnZUluZGV4KTtcblxuICAgIHZhciBkZXNpcmVkVmVydGljYWxDZW50ZXIgPSBwYWdlT2Zmc2V0LnRvcCArIHZlcnRpY2FsT2Zmc2V0O1xuICAgIHZhciB0b3AgPSBkZXNpcmVkVmVydGljYWxDZW50ZXIgLSBwYXJzZUludCh0aGlzLl92aWV3cG9ydC5oZWlnaHQgLyAyLCAxMCk7XG5cbiAgICB2YXIgZGVzaXJlZEhvcml6b250YWxDZW50ZXIgPSBwYWdlT2Zmc2V0LmxlZnQgKyBob3Jpem9udGFsT2Zmc2V0O1xuICAgIHZhciBsZWZ0ID0gZGVzaXJlZEhvcml6b250YWxDZW50ZXIgLSBwYXJzZUludCh0aGlzLl92aWV3cG9ydC53aWR0aCAvIDIsIDEwKTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0LnRvcCA9IHRvcDtcbiAgICB0aGlzLl92aWV3cG9ydC5sZWZ0ID0gbGVmdDtcblxuICAgIHRoaXMuX3JlbmRlcigwKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50cmFuc2l0aW9uVmlld3BvcnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKVxue1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uKCk7XG5cbiAgICB2YXIgZ2V0UG9zaXRpb24gPSBvcHRpb25zLmdldFBvc2l0aW9uO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBvblZpZXdEaWRUcmFuc2l0aW9uID0gdGhpcy5faG9va3Mub25WaWV3RGlkVHJhbnNpdGlvbjtcblxuICAgIHRoaXMuX2FuaW1hdGlvbiA9IEludGVycG9sYXRlQW5pbWF0aW9uLmFuaW1hdGUoe1xuICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcbiAgICAgICAgcGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHZhbHVlcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogRG8gaW1hZ2UgcHJlbG9hZGluZywgd29yayB3aXRoIHRoYXRcbiAgICAgICAgICAgIHNlbGYuX3NldFZpZXdwb3J0UG9zaXRpb24oZ2V0UG9zaXRpb24odmFsdWVzKSk7XG5cbiAgICAgICAgICAgIGlmIChvblZpZXdEaWRUcmFuc2l0aW9uKVxuICAgICAgICAgICAgICAgIG9uVmlld0RpZFRyYW5zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FbmQ6IGZ1bmN0aW9uIChpbmZvKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vbkVuZClcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uRW5kKGluZm8pO1xuXG4gICAgICAgICAgICBpZiAoc2VsZi5faG9va3Mub25WaWV3RGlkVXBkYXRlICYmICFpbmZvLmludGVycnVwdGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNlbGYuX2hvb2tzLm9uVmlld0RpZFVwZGF0ZShzZWxmLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCksIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2NsZWFyQW5pbWF0aW9uID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uKVxuICAgIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xuICAgIH1cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5wcmVsb2FkID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBUT0RPXG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaXNQYWdlVmlzaWJsZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgaWYgKCF0aGlzLmxheW91dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHBhZ2UgPSB0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpO1xuXG4gICAgaWYgKCFwYWdlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQuaW50ZXJzZWN0c1JlZ2lvbih0aGlzLmxheW91dC5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCkpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmdldFJlbmRlcmVkUGFnZXMgPSBmdW5jdGlvbiAoKVxue1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJlZFBhZ2VzLnNsaWNlKCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IEkgZG9uJ3Qga25vdyBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgZG8gdGhpc1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAocmVxKVxuICAgIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbcmVxXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tyZXFdO1xuXG4gICAgICAgIGhhbmRsZXIuYWJvcnQoKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhcyk7XG59O1xuXG5mdW5jdGlvbiBnZXRTY2FsZWRUaWxlUmVjb3JkKHNvdXJjZSwgc2NhbGVGYWN0b3IpXG57XG4gICAgdmFyIHNjYWxlUmF0aW87XG5cbiAgICBpZiAoc2NhbGVGYWN0b3IgPT09IG51bGwpXG4gICAgICAgIHNjYWxlUmF0aW8gPSAxO1xuICAgIGVsc2VcbiAgICAgICAgc2NhbGVSYXRpbyA9IE1hdGgucG93KDIsIHNjYWxlRmFjdG9yIC0gc291cmNlLnpvb21MZXZlbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2Vab29tTGV2ZWw6IHNvdXJjZS56b29tTGV2ZWwsXG4gICAgICAgIHNjYWxlUmF0aW86IHNjYWxlUmF0aW8sXG4gICAgICAgIHJvdzogc291cmNlLnJvdyxcbiAgICAgICAgY29sOiBzb3VyY2UuY29sLFxuICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICB3aWR0aDogc291cmNlLmRpbWVuc2lvbnMud2lkdGggKiBzY2FsZVJhdGlvLFxuICAgICAgICAgICAgaGVpZ2h0OiBzb3VyY2UuZGltZW5zaW9ucy5oZWlnaHQgKiBzY2FsZVJhdGlvXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgbGVmdDogc291cmNlLm9mZnNldC5sZWZ0ICogc2NhbGVSYXRpbyxcbiAgICAgICAgICAgIHRvcDogc291cmNlLm9mZnNldC50b3AgKiBzY2FsZVJhdGlvXG4gICAgICAgIH0sXG4gICAgICAgIHVybDogc291cmNlLnVybFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGFuZ2VzKG9sZEFycmF5LCBuZXdBcnJheSlcbntcbiAgICBpZiAob2xkQXJyYXkgPT09IG5ld0FycmF5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZGVkOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZWQ6IFtdXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlbW92ZWQgPSBvbGRBcnJheS5maWx0ZXIoZnVuY3Rpb24gKG9sZEVudHJ5KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ld0FycmF5LmluZGV4T2Yob2xkRW50cnkpID09PSAtMTtcbiAgICB9KTtcblxuICAgIHZhciBhZGRlZCA9IG5ld0FycmF5LmZpbHRlcihmdW5jdGlvbiAobmV3RW50cnkpXG4gICAge1xuICAgICAgICByZXR1cm4gb2xkQXJyYXkuaW5kZXhPZihuZXdFbnRyeSkgPT09IC0xO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICByZW1vdmVkOiByZW1vdmVkXG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3JlbmRlcmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LnByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudCAmJiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93ICYmIHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVidWcvc3JjL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9zcmMvZGVidWcuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDBcbnZhciBtID0gcyAqIDYwXG52YXIgaCA9IG0gKiA2MFxudmFyIGQgPSBoICogMjRcbnZhciB5ID0gZCAqIDM2NS4yNVxuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbFxuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/XG5cdFx0XHRmbXRMb25nKHZhbCkgOlxuXHRcdFx0Zm10U2hvcnQodmFsKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcigndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICsgSlNPTi5zdHJpbmdpZnkodmFsKSlcbn1cblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cilcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSlcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHlcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkXG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoXG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtXG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzXG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJ1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJ1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJ1xuICB9XG4gIGlmIChtcyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJ1xuICB9XG4gIHJldHVybiBtcyArICdtcydcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcydcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikge1xuICAgIHJldHVyblxuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZVxuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncydcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9tcy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBDb21wb3NpdGVJbWFnZTtcblxuLyoqXG4gKiBAY2xhc3MgQ29tcG9zaXRlSW1hZ2VcbiAqIEBwcml2YXRlXG4gKlxuICogVXRpbGl0eSBjbGFzcyB0byBjb21wb3NpdGUgdGlsZXMgaW50byBhIGNvbXBsZXRlIGltYWdlXG4gKiBhbmQgdHJhY2sgdGhlIHJlbmRlcmVkIHN0YXRlIG9mIGFuIGltYWdlIGFzIG5ldyB0aWxlc1xuICogbG9hZC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSBsZXZlbHMge0FycmF5LjxBcnJheS48VGlsZT4+fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0ZUltYWdlKGxldmVscylcbntcbiAgICB0aGlzLl9sZXZlbHMgPSBsZXZlbHM7ICAvLyBBc3N1bWUgbGV2ZWxzIHNvcnRlZCBoaWdoLXJlcyBmaXJzdFxuICAgIHZhciB1cmxzVG9UaWxlcyA9IHRoaXMuX3VybHNUb1RpbGVzID0ge307XG5cbiAgICBsZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpXG4gICAge1xuICAgICAgICBsZXZlbC50aWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICB1cmxzVG9UaWxlc1t0aWxlLnVybF0gPSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiBsZXZlbC56b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgcm93OiB0aWxlLnJvdyxcbiAgICAgICAgICAgICAgICBjb2w6IHRpbGUuY29sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuY2xlYXIoKTtcbn1cblxuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgbG9hZGVkQnlMZXZlbCA9IHRoaXMuX2xvYWRlZEJ5TGV2ZWwgPSB7fTtcblxuICAgIHRoaXMuX2xldmVscy5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbClcbiAgICB7XG4gICAgICAgIGxvYWRlZEJ5TGV2ZWxbbGV2ZWwuem9vbUxldmVsXSA9IG5ldyBUaWxlQ292ZXJhZ2VNYXAobGV2ZWwucm93cywgbGV2ZWwuY29scyk7XG4gICAgfSk7XG59O1xuXG5Db21wb3NpdGVJbWFnZS5wcm90b3R5cGUuZ2V0VGlsZXMgPSBmdW5jdGlvbiAoYmFzZVpvb21MZXZlbClcbntcbiAgICB2YXIgdG9SZW5kZXJCeUxldmVsID0gW107XG4gICAgdmFyIGhpZ2hlc3Rab29tTGV2ZWwgPSB0aGlzLl9sZXZlbHNbMF0uem9vbUxldmVsO1xuICAgIHZhciBjb3ZlcmVkID0gbmV3IFRpbGVDb3ZlcmFnZU1hcCh0aGlzLl9sZXZlbHNbMF0ucm93cywgdGhpcy5fbGV2ZWxzWzBdLmNvbHMpO1xuXG4gICAgdmFyIGJlc3RMZXZlbEluZGV4O1xuXG4gICAgLy8gRGVmYXVsdCB0byB0aGUgbG93ZXN0IHpvb20gbGV2ZWxcbiAgICBpZiAoYmFzZVpvb21MZXZlbCA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIGJlc3RMZXZlbEluZGV4ID0gMDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIGNlaWxMZXZlbCA9IE1hdGguY2VpbChiYXNlWm9vbUxldmVsKTtcbiAgICAgICAgYmVzdExldmVsSW5kZXggPSBmaW5kSW5kZXgodGhpcy5fbGV2ZWxzLCBmdW5jdGlvbiAobGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbC56b29tTGV2ZWwgPD0gY2VpbExldmVsO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8vIFRoZSBiZXN0IGxldmVsLCBmb2xsb3dlZCBieSBoaWdoZXItcmVzIGxldmVscyBpbiBhc2NlbmRpbmcgb3JkZXIgb2YgcmVzb2x1dGlvbixcbiAgICAvLyBmb2xsb3dlZCBieSBsb3dlci1yZXMgbGV2ZWxzIGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcmVzb2x1dGlvblxuICAgIHZhciBsZXZlbHNCeVByZWZlcmVuY2UgPSB0aGlzLl9sZXZlbHMuc2xpY2UoMCwgYmVzdExldmVsSW5kZXggKyAxKS5yZXZlcnNlKClcbiAgICAgICAgLmNvbmNhdCh0aGlzLl9sZXZlbHMuc2xpY2UoYmVzdExldmVsSW5kZXggKyAxKSk7XG5cbiAgICBsZXZlbHNCeVByZWZlcmVuY2UuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpXG4gICAge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5fbG9hZGVkQnlMZXZlbFtsZXZlbC56b29tTGV2ZWxdO1xuXG4gICAgICAgIHZhciBhZGRpdGlvbmFsVGlsZXMgPSBsZXZlbC50aWxlcy5maWx0ZXIoZnVuY3Rpb24gKHRpbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBsb2FkZWQuaXNMb2FkZWQodGlsZS5yb3csIHRpbGUuY29sKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlsdGVyIG91dCBlbnRpcmVseSBjb3ZlcmVkIHRpbGVzXG5cbiAgICAgICAgLy8gRklYTUU6IElzIGl0IGJldHRlciB0byBkcmF3IGFsbCBvZiBhIHBhcnRpYWxseSBjb3ZlcmVkIHRpbGUsXG4gICAgICAgIC8vIHdpdGggc29tZSBvZiBpdCB1bHRpbWF0ZWx5IGNvdmVyZWQsIG9yIHRvIHBpY2sgb3V0IHRoZSByZWdpb25cbiAgICAgICAgLy8gd2hpY2ggbmVlZHMgdG8gYmUgZHJhd24/XG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy9pc3N1ZXMvMzU4XG5cbiAgICAgICAgdmFyIHNjYWxlUmF0aW8gPSBNYXRoLnBvdygyLCBoaWdoZXN0Wm9vbUxldmVsIC0gbGV2ZWwuem9vbUxldmVsKTtcblxuICAgICAgICBhZGRpdGlvbmFsVGlsZXMgPSBhZGRpdGlvbmFsVGlsZXMuZmlsdGVyKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaXNOZWVkZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGhpZ2hSZXNSb3cgPSB0aWxlLnJvdyAqIHNjYWxlUmF0aW87XG4gICAgICAgICAgICB2YXIgaGlnaFJlc0NvbCA9IHRpbGUuY29sICogc2NhbGVSYXRpbztcblxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgc2NhbGVSYXRpbzsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGo9MDsgaiA8IHNjYWxlUmF0aW87IGorKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY292ZXJlZC5pc0xvYWRlZChoaWdoUmVzUm93ICsgaSwgaGlnaFJlc0NvbCArIGopKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc05lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkLnNldChoaWdoUmVzUm93ICsgaSwgaGlnaFJlc0NvbCArIGosIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaXNOZWVkZWQ7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRvUmVuZGVyQnlMZXZlbC5wdXNoKGFkZGl0aW9uYWxUaWxlcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICAvLyBMZXNzLXByZWZlcnJlZCB0aWxlcyBzaG91bGQgY29tZSBmaXJzdFxuICAgIHRvUmVuZGVyQnlMZXZlbC5yZXZlcnNlKCk7XG5cbiAgICB2YXIgdGlsZXMgPSBbXTtcblxuICAgIHRvUmVuZGVyQnlMZXZlbC5mb3JFYWNoKGZ1bmN0aW9uIChieUxldmVsKVxuICAgIHtcbiAgICAgICAgdGlsZXMucHVzaC5hcHBseSh0aWxlcywgYnlMZXZlbCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGlsZXM7XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgY29tcG9zaXRlIGltYWdlIHRvIHRha2UgaW50byBhY2NvdW50IGFsbCB0aGUgVVJMc1xuICogbG9hZGVkIGluIGFuIGltYWdlIGNhY2hlLlxuICpcbiAqIEBwYXJhbSBjYWNoZSB7SW1hZ2VDYWNoZX1cbiAqL1xuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLnVwZGF0ZUZyb21DYWNoZSA9IGZ1bmN0aW9uIChjYWNoZSlcbntcbiAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICB0aGlzLl9sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpXG4gICAge1xuICAgICAgICB2YXIgbG9hZGVkID0gdGhpcy5fbG9hZGVkQnlMZXZlbFtsZXZlbC56b29tTGV2ZWxdO1xuXG4gICAgICAgIGxldmVsLnRpbGVzLmZvckVhY2goZnVuY3Rpb24gKHRpbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXModGlsZS51cmwpKVxuICAgICAgICAgICAgICAgIGxvYWRlZC5zZXQodGlsZS5yb3csIHRpbGUuY29sLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5Db21wb3NpdGVJbWFnZS5wcm90b3R5cGUudXBkYXRlV2l0aExvYWRlZFVybHMgPSBmdW5jdGlvbiAodXJscylcbntcbiAgICB1cmxzLmZvckVhY2goZnVuY3Rpb24gKHVybClcbiAgICB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX3VybHNUb1RpbGVzW3VybF07XG4gICAgICAgIHRoaXMuX2xvYWRlZEJ5TGV2ZWxbZW50cnkuem9vbUxldmVsXS5zZXQoZW50cnkucm93LCBlbnRyeS5jb2wsIHRydWUpO1xuICAgIH0sIHRoaXMpO1xufTtcblxuZnVuY3Rpb24gVGlsZUNvdmVyYWdlTWFwKHJvd3MsIGNvbHMpXG57XG4gICAgdGhpcy5fcm93cyA9IHJvd3M7XG4gICAgdGhpcy5fY29scyA9IGNvbHM7XG5cbiAgICB0aGlzLl9tYXAgPSBmaWxsKHJvd3MpLm1hcChmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZpbGwoY29scywgZmFsc2UpO1xuICAgIH0pO1xufVxuXG5UaWxlQ292ZXJhZ2VNYXAucHJvdG90eXBlLmlzTG9hZGVkID0gZnVuY3Rpb24gKHJvdywgY29sKVxue1xuICAgIC8vIFJldHVybiB0cnVlIGZvciBvdXQgb2YgYm91bmRzIHRpbGVzIGJlY2F1c2UgdGhleVxuICAgIC8vIGRvbid0IG5lZWQgdG8gbG9hZC4gKFVuZm9ydHVuYXRlbHkgdGhpcyB3aWxsIGFsc29cbiAgICAvLyBtYXNrIGxvZ2ljYWwgZXJyb3JzLilcbiAgICBpZiAocm93ID49IHRoaXMuX3Jvd3MgfHwgY29sID49IHRoaXMuX2NvbHMpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXMuX21hcFtyb3ddW2NvbF07XG59O1xuXG5UaWxlQ292ZXJhZ2VNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyb3csIGNvbCwgdmFsdWUpXG57XG4gICAgdGhpcy5fbWFwW3Jvd11bY29sXSA9IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gZmlsbChjb3VudCwgdmFsdWUpXG57XG4gICAgdmFyIGFyciA9IG5ldyBBcnJheShjb3VudCk7XG5cbiAgICBmb3IgKHZhciBpPTA7IGkgPCBjb3VudDsgaSsrKVxuICAgICAgICBhcnJbaV0gPSB2YWx1ZTtcblxuICAgIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKVxue1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaV0sIGkpKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvY29tcG9zaXRlLWltYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IERvY3VtZW50TGF5b3V0O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBwYWdlIGxheW91dHMsIGFzIGdlbmVyYXRlZCBieSBwYWdlLWxheW91dHMsIGludG8gYW5cbiAqIG9iamVjdCB3aGljaCBjb21wdXRlcyBsYXlvdXQgaW5mb3JtYXRpb24gZm9yIHRoZSBkb2N1bWVudCBhc1xuICogYSB3aG9sZS5cbiAqL1xuZnVuY3Rpb24gRG9jdW1lbnRMYXlvdXQoY29uZmlnLCB6b29tTGV2ZWwpXG57XG4gICAgdmFyIGNvbXB1dGVkTGF5b3V0ID0gZ2V0Q29tcHV0ZWRMYXlvdXQoY29uZmlnLCB6b29tTGV2ZWwpO1xuXG4gICAgdGhpcy5kaW1lbnNpb25zID0gY29tcHV0ZWRMYXlvdXQuZGltZW5zaW9ucztcbiAgICB0aGlzLnBhZ2VHcm91cHMgPSBjb21wdXRlZExheW91dC5wYWdlR3JvdXBzO1xuICAgIHRoaXMuX3BhZ2VMb29rdXAgPSBnZXRQYWdlTG9va3VwKGNvbXB1dGVkTGF5b3V0LnBhZ2VHcm91cHMpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhZ2VJbmZvXG4gKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXhcbiAqIEBwcm9wZXJ0eSB7e2luZGV4LCBkaW1lbnNpb25zLCBwYWdlcywgcmVnaW9uLCBwYWRkaW5nfX0gZ3JvdXBcbiAqIEBwcm9wZXJ0eSB7e2hlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyfX0gZGltZW5zaW9uc1xuICogQHByb3BlcnR5IHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn19IGdyb3VwT2Zmc2V0XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gcGFnZUluZGV4XG4gKiBAcmV0dXJucyB7UGFnZUluZm98bnVsbH1cbiAqL1xuRG9jdW1lbnRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2VJbmZvID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICByZXR1cm4gdGhpcy5fcGFnZUxvb2t1cFtwYWdlSW5kZXhdIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGltZW5zaW9ucyBvZiBhIHBhZ2VcbiAqXG4gKiBAcGFyYW0gcGFnZUluZGV4XG4gKiBAcmV0dXJucyB7e2hlaWdodDogbnVtYmVyLCB3aWR0aDogbnVtYmVyfX1cbiAqL1xuRG9jdW1lbnRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2VEaW1lbnNpb25zID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICBpZiAoIXRoaXMuX3BhZ2VMb29rdXAgfHwgIXRoaXMuX3BhZ2VMb29rdXBbcGFnZUluZGV4XSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgcmVnaW9uID0gZ2V0UGFnZVJlZ2lvbkZyb21QYWdlSW5mbyh0aGlzLl9wYWdlTG9va3VwW3BhZ2VJbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiByZWdpb24uYm90dG9tIC0gcmVnaW9uLnRvcCxcbiAgICAgICAgd2lkdGg6IHJlZ2lvbi5yaWdodCAtIHJlZ2lvbi5sZWZ0XG4gICAgfTtcbn07XG5cbi8vIFRPRE8od2FiYWluKTogR2V0IHJpZCBvZiB0aGlzOyBpdCdzIGEgc3Vic2V0IG9mIHRoZSBwYWdlIHJlZ2lvbiwgc29cbi8vIGdpdmUgdGhhdCBpbnN0ZWFkXG4vKipcbiAqIEdldCB0aGUgdG9wLWxlZnQgY29vcmRpbmF0ZXMgb2YgYSBwYWdlLCBpbmNsdWRpbmcqKiogcGFkZGluZ1xuICpcbiAqIEBwYXJhbSBwYWdlSW5kZXhcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9IHwgbnVsbH1cbiAqL1xuRG9jdW1lbnRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2VPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBvcHRpb25zKVxue1xuICAgIHZhciByZWdpb24gPSB0aGlzLmdldFBhZ2VSZWdpb24ocGFnZUluZGV4LCBvcHRpb25zKTtcblxuICAgIGlmICghcmVnaW9uKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogcmVnaW9uLnRvcCxcbiAgICAgICAgbGVmdDogcmVnaW9uLmxlZnRcbiAgICB9O1xufTtcblxuRG9jdW1lbnRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2VSZWdpb24gPSBmdW5jdGlvbiAocGFnZUluZGV4LCBvcHRpb25zKVxue1xuICAgIHZhciBwYWdlSW5mbyA9IHRoaXMuX3BhZ2VMb29rdXBbcGFnZUluZGV4XTtcblxuICAgIGlmICghcGFnZUluZm8pXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJlZ2lvbiA9IGdldFBhZ2VSZWdpb25Gcm9tUGFnZUluZm8ocGFnZUluZm8pO1xuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5leGNsdWRlUGFkZGluZylcbiAgICB7XG4gICAgICAgIC8vIEZJWE1FP1xuICAgICAgICB2YXIgcGFkZGluZyA9IHBhZ2VJbmZvLmdyb3VwLnBhZGRpbmc7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogcmVnaW9uLnRvcCArIHBhZGRpbmcudG9wLFxuICAgICAgICAgICAgbGVmdDogcmVnaW9uLmxlZnQgKyBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgICBib3R0b206IHJlZ2lvbi5ib3R0b20sXG4gICAgICAgICAgICByaWdodDogcmVnaW9uLnJpZ2h0XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2lvbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBkaXN0YW5jZSBmcm9tIHRoZSB0b3AtcmlnaHQgb2YgdGhlIHBhZ2UgdG8gdGhlIGNlbnRlciBvZiB0aGVcbiAqIHNwZWNpZmllZCB2aWV3cG9ydCByZWdpb25cbiAqXG4gKiBAcGFyYW0gcGFnZUluZGV4XG4gKiBAcGFyYW0gdmlld3BvcnQge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyLCBib3R0b206IG51bWJlciwgcmlnaHQ6IG51bWJlcn19XG4gKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAqL1xuRG9jdW1lbnRMYXlvdXQucHJvdG90eXBlLmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgdmlld3BvcnQpXG57XG4gICAgdmFyIHNjcm9sbExlZnQgPSB2aWV3cG9ydC5sZWZ0O1xuICAgIHZhciBlbGVtZW50V2lkdGggPSB2aWV3cG9ydC5yaWdodCAtIHZpZXdwb3J0LmxlZnQ7XG5cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRQYWdlT2Zmc2V0KHBhZ2VJbmRleCk7XG5cbiAgICB2YXIgeCA9IHNjcm9sbExlZnQgLSBvZmZzZXQubGVmdCArIHBhcnNlSW50KGVsZW1lbnRXaWR0aCAvIDIsIDEwKTtcblxuICAgIHZhciBzY3JvbGxUb3AgPSB2aWV3cG9ydC50b3A7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQgPSB2aWV3cG9ydC5ib3R0b20gLSB2aWV3cG9ydC50b3A7XG5cbiAgICB2YXIgeSA9IHNjcm9sbFRvcCAtIG9mZnNldC50b3AgKyBwYXJzZUludChlbGVtZW50SGVpZ2h0IC8gMiwgMTApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH07XG59O1xuXG5mdW5jdGlvbiBnZXRQYWdlUmVnaW9uRnJvbVBhZ2VJbmZvKHBhZ2UpXG57XG4gICAgdmFyIHRvcCAgICA9IHBhZ2UuZ3JvdXBPZmZzZXQudG9wICArIHBhZ2UuZ3JvdXAucmVnaW9uLnRvcDtcbiAgICB2YXIgYm90dG9tID0gdG9wICsgcGFnZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICB2YXIgbGVmdCAgID0gcGFnZS5ncm91cE9mZnNldC5sZWZ0ICsgcGFnZS5ncm91cC5yZWdpb24ubGVmdDtcbiAgICB2YXIgcmlnaHQgID0gbGVmdCArIHBhZ2UuZGltZW5zaW9ucy53aWR0aDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFnZUxvb2t1cChwYWdlR3JvdXBzKVxue1xuICAgIHZhciBwYWdlTG9va3VwID0ge307XG5cbiAgICBwYWdlR3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKVxuICAgIHtcbiAgICAgICAgZ3JvdXAucGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZUxvb2t1cFtwYWdlLmluZGV4XSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFnZS5pbmRleCxcbiAgICAgICAgICAgICAgICBncm91cDogZ3JvdXAsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZS5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiBwYWdlLmdyb3VwT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwYWdlTG9va3VwO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wdXRlZExheW91dChjb25maWcsIHpvb21MZXZlbClcbntcbiAgICB2YXIgc2NhbGVkTGF5b3V0cyA9IHpvb21MZXZlbCA9PT0gbnVsbCA/IGNvbmZpZy5wYWdlTGF5b3V0cyA6IGdldFNjYWxlZFBhZ2VMYXlvdXRzKGNvbmZpZywgem9vbUxldmVsKTtcblxuICAgIHZhciBkb2N1bWVudFNlY29uZGFyeUV4dGVudCA9IGdldEV4dGVudEFsb25nU2Vjb25kYXJ5QXhpcyhjb25maWcsIHNjYWxlZExheW91dHMpO1xuXG4gICAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50IGFsb25nIHRoZSBwcmltYXJ5IGF4aXNcbiAgICB2YXIgcHJpbWFyeURvY1Bvc2l0aW9uID0gY29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZCA/XG4gICAgICAgIGNvbmZpZy5wYWRkaW5nLmRvY3VtZW50LnRvcCA6XG4gICAgICAgIGNvbmZpZy5wYWRkaW5nLmRvY3VtZW50LmxlZnQ7XG5cbiAgICB2YXIgcGFnZUdyb3VwcyA9IFtdO1xuXG4gICAgLy8gVE9ETzogVXNlIGJvdHRvbSwgcmlnaHQgYXMgd2VsbFxuICAgIHZhciBwYWdlUGFkZGluZyA9IHtcbiAgICAgICAgdG9wOiBjb25maWcucGFkZGluZy5wYWdlLnRvcCxcbiAgICAgICAgbGVmdDogY29uZmlnLnBhZGRpbmcucGFnZS5sZWZ0XG4gICAgfTtcblxuICAgIHNjYWxlZExheW91dHMuZm9yRWFjaChmdW5jdGlvbiAobGF5b3V0LCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciB0b3AsIGxlZnQ7XG5cbiAgICAgICAgaWYgKGNvbmZpZy52ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvcCA9IHByaW1hcnlEb2NQb3NpdGlvbjtcbiAgICAgICAgICAgIGxlZnQgPSAoZG9jdW1lbnRTZWNvbmRhcnlFeHRlbnQgLSBsYXlvdXQuZGltZW5zaW9ucy53aWR0aCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdG9wID0gKGRvY3VtZW50U2Vjb25kYXJ5RXh0ZW50IC0gbGF5b3V0LmRpbWVuc2lvbnMuaGVpZ2h0KSAvIDI7XG4gICAgICAgICAgICBsZWZ0ID0gcHJpbWFyeURvY1Bvc2l0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZ2lvbiA9IHtcbiAgICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBwYWdlUGFkZGluZy50b3AgKyBsYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IGxlZnQgKyBwYWdlUGFkZGluZy5sZWZ0ICsgbGF5b3V0LmRpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgfTtcblxuICAgICAgICBwYWdlR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZGltZW5zaW9uczogbGF5b3V0LmRpbWVuc2lvbnMsXG4gICAgICAgICAgICBwYWdlczogbGF5b3V0LnBhZ2VzLFxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb24sXG4gICAgICAgICAgICBwYWRkaW5nOiBwYWdlUGFkZGluZ1xuICAgICAgICB9KTtcblxuICAgICAgICBwcmltYXJ5RG9jUG9zaXRpb24gPSBjb25maWcudmVydGljYWxseU9yaWVudGVkID8gcmVnaW9uLmJvdHRvbSA6IHJlZ2lvbi5yaWdodDtcbiAgICB9KTtcblxuICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuXG4gICAgaWYgKGNvbmZpZy52ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAge1xuICAgICAgICBoZWlnaHQgPSBwcmltYXJ5RG9jUG9zaXRpb24gKyBwYWdlUGFkZGluZy50b3A7XG4gICAgICAgIHdpZHRoID0gZG9jdW1lbnRTZWNvbmRhcnlFeHRlbnQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGhlaWdodCA9IGRvY3VtZW50U2Vjb25kYXJ5RXh0ZW50O1xuICAgICAgICB3aWR0aCA9IHByaW1hcnlEb2NQb3NpdGlvbiArIHBhZ2VQYWRkaW5nLmxlZnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZUdyb3VwczogcGFnZUdyb3Vwc1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlZFBhZ2VMYXlvdXRzKGNvbmZpZywgem9vbUxldmVsKVxue1xuICAgIHZhciBzY2FsZVJhdGlvID0gTWF0aC5wb3coMiwgem9vbUxldmVsIC0gY29uZmlnLm1heFpvb21MZXZlbCk7XG5cbiAgICByZXR1cm4gY29uZmlnLnBhZ2VMYXlvdXRzLm1hcChmdW5jdGlvbiAoZ3JvdXApXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGltZW5zaW9uczogc2NhbGVEaW1lbnNpb25zKGdyb3VwLmRpbWVuc2lvbnMsIHNjYWxlUmF0aW8pLFxuICAgICAgICAgICAgcGFnZXM6IGdyb3VwLnBhZ2VzLm1hcChmdW5jdGlvbiAocGFnZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogcGFnZS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogTWF0aC5mbG9vcihwYWdlLmdyb3VwT2Zmc2V0LnRvcCAqIHNjYWxlUmF0aW8pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogTWF0aC5mbG9vcihwYWdlLmdyb3VwT2Zmc2V0LmxlZnQgKiBzY2FsZVJhdGlvKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBzY2FsZURpbWVuc2lvbnMocGFnZS5kaW1lbnNpb25zLCBzY2FsZVJhdGlvKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZURpbWVuc2lvbnMoZGltZW5zaW9ucywgc2NhbGVSYXRpbylcbntcbiAgICByZXR1cm4ge1xuICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoZGltZW5zaW9ucy5oZWlnaHQgKiBzY2FsZVJhdGlvKSxcbiAgICAgICAgd2lkdGg6IE1hdGguZmxvb3IoZGltZW5zaW9ucy53aWR0aCAqIHNjYWxlUmF0aW8pXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RXh0ZW50QWxvbmdTZWNvbmRhcnlBeGlzKGNvbmZpZywgc2NhbGVkTGF5b3V0cylcbntcbiAgICAvLyBHZXQgdGhlIGV4dGVudCBvZiB0aGUgZG9jdW1lbnQgYWxvbmcgdGhlIHNlY29uZGFyeSBheGlzXG4gICAgdmFyIHNlY29uZGFyeURpbSwgc2Vjb25kYXJ5UGFkZGluZztcbiAgICB2YXIgZG9jUGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nLmRvY3VtZW50O1xuXG4gICAgaWYgKGNvbmZpZy52ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAge1xuICAgICAgICBzZWNvbmRhcnlEaW0gPSAnd2lkdGgnO1xuICAgICAgICBzZWNvbmRhcnlQYWRkaW5nID0gZG9jUGFkZGluZy5sZWZ0ICsgZG9jUGFkZGluZy5yaWdodDtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgc2Vjb25kYXJ5RGltID0gJ2hlaWdodCc7XG4gICAgICAgIHNlY29uZGFyeVBhZGRpbmcgPSBkb2NQYWRkaW5nLnRvcCArIGRvY1BhZGRpbmcuYm90dG9tO1xuICAgIH1cblxuICAgIHJldHVybiBzZWNvbmRhcnlQYWRkaW5nICsgc2NhbGVkTGF5b3V0cy5yZWR1Y2UoZnVuY3Rpb24gKG1heERpbSwgbGF5b3V0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGxheW91dC5kaW1lbnNpb25zW3NlY29uZGFyeURpbV0sIG1heERpbSk7XG4gICAgfSwgMCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9kb2N1bWVudC1sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpJbWFnZUNhY2hlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VDYWNoZTtcblxuLyogRklYTUUod2FiYWluKTogVGhlIGNhY2hpbmcgc3RyYXRlZ3kgaGVyZSBpcyBjb21wbGV0ZWx5XG4gKiBhcmJpdHJhcnkgYW5kIHRoZSBpbXBsZW1lbnRhdGlvbiBpc24ndCBlc3BlY2lhbGx5IGVmZmljaWVudC5cbiAqL1xuXG52YXIgREVGQVVMVF9NQVhfS0VZUyA9IDEwMDtcblxuZnVuY3Rpb24gSW1hZ2VDYWNoZShvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgbWF4S2V5czogREVGQVVMVF9NQVhfS0VZUyB9O1xuICAgIHRoaXMubWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cyB8fCBERUZBVUxUX01BWF9LRVlTO1xuXG4gICAgdGhpcy5faGVsZCA9IHt9O1xuICAgIHRoaXMuX3VybHMgPSB7fTtcbiAgICB0aGlzLl9scnUgPSBbXTtcbn1cblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybClcbntcbiAgICB2YXIgcmVjb3JkID0gdGhpcy5fdXJsc1t1cmxdO1xuICAgIHJldHVybiByZWNvcmQgPyByZWNvcmQuaW1nIDogbnVsbDtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uICh1cmwpXG57XG4gICAgcmV0dXJuICEhdGhpcy5fdXJsc1t1cmxdO1xufTtcblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKHVybCwgaW1nKVxue1xuICAgIHZhciByZWNvcmQgPSB0aGlzLl91cmxzW3VybF07XG4gICAgaWYgKHJlY29yZClcbiAgICB7XG4gICAgICAgIC8vIEZJWE1FOiBEb2VzIHRoaXMgbWFrZSBzZW5zZSBmb3IgdGhpcyB1c2UgY2FzZT9cbiAgICAgICAgcmVjb3JkLmltZyA9IGltZztcbiAgICAgICAgdGhpcy5fcHJvbW90ZShyZWNvcmQpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICByZWNvcmQgPSB7XG4gICAgICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fdXJsc1t1cmxdID0gcmVjb3JkO1xuICAgICAgICB0aGlzLl90cnlFdmljdCgxKTtcbiAgICAgICAgdGhpcy5fbHJ1LnVuc2hpZnQocmVjb3JkKTtcbiAgICB9XG59O1xuXG5JbWFnZUNhY2hlLnByb3RvdHlwZS5fcHJvbW90ZSA9IGZ1bmN0aW9uIChyZWNvcmQpXG57XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fbHJ1LmluZGV4T2YocmVjb3JkKTtcbiAgICB0aGlzLl9scnUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLl9scnUudW5zaGlmdChyZWNvcmQpO1xufTtcblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUuX3RyeUV2aWN0ID0gZnVuY3Rpb24gKGV4dHJhQ2FwYWNpdHkpXG57XG4gICAgdmFyIGFsbG93ZWRFbnRyeUNvdW50ID0gdGhpcy5tYXhLZXlzIC0gZXh0cmFDYXBhY2l0eTtcblxuICAgIGlmICh0aGlzLl9scnUubGVuZ3RoIDw9IGFsbG93ZWRFbnRyeUNvdW50KVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgZXZpY3Rpb25JbmRleCA9IHRoaXMuX2xydS5sZW5ndGggLSAxO1xuXG4gICAgZm9yICg7OylcbiAgICB7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLl9scnVbZXZpY3Rpb25JbmRleF07XG5cbiAgICAgICAgaWYgKCF0aGlzLl9oZWxkW3RhcmdldC51cmxdKVxuICAgICAgICB7XG4gICAgICAgICAgICBkZWJ1ZygnRXZpY3RpbmcgaW1hZ2UgJXMnLCB0YXJnZXQudXJsKTtcbiAgICAgICAgICAgIHRoaXMuX2xydS5zcGxpY2UoZXZpY3Rpb25JbmRleCwgMSk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdXJsc1t0YXJnZXQudXJsXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2xydS5sZW5ndGggPD0gYWxsb3dlZEVudHJ5Q291bnQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZpY3Rpb25JbmRleCA9PT0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGRlYnVnLmVuYWJsZWQgJiYgZGVidWcoJ0NhY2hlIG92ZXJmdWxsIGJ5ICVzIChhbGwgZW50cmllcyBhcmUgYmVpbmcgaGVsZCknLFxuICAgICAgICAgICAgICAgIHRoaXMuX2xydS5sZW5ndGggLSBhbGxvd2VkRW50cnlDb3VudCk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZpY3Rpb25JbmRleC0tO1xuICAgIH1cbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLmFjcXVpcmUgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIHRoaXMuX2hlbGRbdXJsXSA9ICh0aGlzLl9oZWxkW3VybF0gfHwgMCkgKyAxO1xuICAgIHRoaXMuX3Byb21vdGUodGhpcy5fdXJsc1t1cmxdKTtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIHZhciBjb3VudCA9IHRoaXMuX2hlbGRbdXJsXTtcblxuICAgIGlmIChjb3VudCA+IDEpXG4gICAgICAgIHRoaXMuX2hlbGRbdXJsXS0tO1xuICAgIGVsc2VcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hlbGRbdXJsXTtcblxuICAgIHRoaXMuX3RyeUV2aWN0KDApO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2ltYWdlLWNhY2hlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOkltYWdlUmVxdWVzdEhhbmRsZXInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZVJlcXVlc3RIYW5kbGVyO1xuXG4vKipcbiAqIEhhbmRsZXIgZm9yIHRoZSByZXF1ZXN0IGZvciBhbiBpbWFnZSB0aWxlXG4gKlxuICogQHBhcmFtIHVybFxuICogQHBhcmFtIGNhbGxiYWNrXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSW1hZ2VSZXF1ZXN0SGFuZGxlcihvcHRpb25zKVxue1xuICAgIHRoaXMuX3VybCA9IG9wdGlvbnMudXJsO1xuICAgIHRoaXMuX2NhbGxiYWNrID0gb3B0aW9ucy5sb2FkO1xuICAgIHRoaXMuX2Vycm9yQ2FsbGJhY2sgPSBvcHRpb25zLmVycm9yO1xuICAgIHRoaXMudGltZW91dFRpbWUgPSBvcHRpb25zLnRpbWVvdXRUaW1lIHx8IDA7XG4gICAgdGhpcy5fYWJvcnRlZCA9IHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAvL1VzZSBhIHRpbWVvdXQgdG8gYWxsb3cgdGhlIHJlcXVlc3RzIHRvIGJlIGRlYm91bmNlZCAoYXMgdGhleSBhcmUgaW4gcmVuZGVyZXIpXG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICAvLyBJbml0aWF0ZSB0aGUgcmVxdWVzdFxuICAgICAgICB0aGlzLl9pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICB0aGlzLl9pbWFnZS5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgIHRoaXMuX2ltYWdlLm9ubG9hZCA9IHRoaXMuX2hhbmRsZUxvYWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faW1hZ2Uub25lcnJvciA9IHRoaXMuX2hhbmRsZUVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ltYWdlLnNyYyA9IG9wdGlvbnMudXJsO1xuXG4gICAgICAgIGRlYnVnKCdSZXF1ZXN0aW5nIGltYWdlICVzJywgb3B0aW9ucy51cmwpO1xuICAgIH0uYmluZCh0aGlzKSwgdGhpcy50aW1lb3V0VGltZSk7XG59XG5cbkltYWdlUmVxdWVzdEhhbmRsZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKClcbntcbiAgICBkZWJ1ZygnQWJvcnRpbmcgcmVxdWVzdCB0byAlcycsIHRoaXMuX3VybCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcblxuICAgIC8vIEZJWE1FXG4gICAgLy8gUGVvcGxlIG9uIHRoZSBJbnRlcm5ldCBzYXkgdGhhdCBkb2luZyB0aGlzIHt7c2hvdWxkL3Nob3VsZCBub3R9fSBhYm9ydCB0aGUgcmVxdWVzdC4gSSBiZWxpZXZlXG4gICAgLy8gaXQgY29ycmVzcG9uZHMgdG8gd2hhdCB0aGUgV0hBVFdHIEhUTUwgc3BlYyBzYXlzIHNob3VsZCBoYXBwZW4gd2hlbiB0aGUgVUFcbiAgICAvLyB1cGRhdGVzIHRoZSBpbWFnZSBkYXRhIGlmIHNlbGVjdGVkIHNvdXJjZSBpcyBudWxsLlxuICAgIC8vXG4gICAgLy8gU291cmNlczpcbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2VtYmVkZGVkLWNvbnRlbnQuaHRtbCN0aGUtaW1nLWVsZW1lbnRcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczOTA4ODgvZG9lcy1jaGFuZ2luZy10aGUtc3JjLWF0dHJpYnV0ZS1vZi1hbi1pbWFnZS1zdG9wLXRoZS1pbWFnZS1mcm9tLWRvd25sb2FkaW5nXG4gICAgaWYgKHRoaXMuX2ltYWdlKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW1hZ2Uub25sb2FkID0gdGhpcy5faW1hZ2Uub25lcnJvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5faW1hZ2Uuc3JjID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5fYWJvcnRlZCA9IHRydWU7XG59O1xuXG5JbWFnZVJlcXVlc3RIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlTG9hZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgaWYgKHRoaXMuX2Fib3J0ZWQpXG4gICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZVJlcXVlc3RIYW5kbGVyIGludm9rZWQgb24gY2FuY2VsbGVkIHJlcXVlc3QgZm9yICcgKyB0aGlzLl91cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbXBsZXRlKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VSZXF1ZXN0SGFuZGxlciBpbnZva2VkIG9uIGNvbXBsZXRlZCByZXF1ZXN0IGZvciAnICsgdGhpcy5fdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbXBsZXRlID0gdHJ1ZTtcblxuICAgIGRlYnVnKCdSZWNlaXZlZCBpbWFnZSAlcycsIHRoaXMuX3VybCk7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy5faW1hZ2UpO1xufTtcblxuSW1hZ2VSZXF1ZXN0SGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZUVycm9yID0gZnVuY3Rpb24gKClcbntcbiAgICBkZWJ1ZygnRmFpbGVkIHRvIGxvYWQgaW1hZ2UgJXMnLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2Vycm9yQ2FsbGJhY2sodGhpcy5faW1hZ2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2ltYWdlLXJlcXVlc3QtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogZ2xvYmFsIHBlcmZvcm1hbmNlICovXG5cbi8vIFRPRE86IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmYWxsYmFja1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhbmltYXRlOiBhbmltYXRlLFxuICAgIGVhc2luZzoge1xuICAgICAgICBsaW5lYXI6IGxpbmVhckVhc2luZ1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGFuaW1hdGUob3B0aW9ucylcbntcbiAgICB2YXIgZHVyYXRpb25NcyA9IG9wdGlvbnMuZHVyYXRpb247XG4gICAgdmFyIHBhcmFtZXRlcnMgPSBvcHRpb25zLnBhcmFtZXRlcnM7XG4gICAgdmFyIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICB2YXIgb25FbmQgPSBvcHRpb25zLm9uRW5kO1xuXG4gICAgLy8gU2V0dXBcbiAgICAvLyBUaW1lcyBhcmUgaW4gbWlsbGlzZWNvbmRzIGZyb20gYSBiYXNpY2FsbHkgYXJiaXRyYXJ5IHN0YXJ0XG4gICAgdmFyIHN0YXJ0ID0gbm93KCk7XG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgZHVyYXRpb25NcztcblxuICAgIHZhciB0d2VlbkZucyA9IHt9O1xuICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICB2YXIgcGFyYW1LZXlzID0gT2JqZWN0LmtleXMocGFyYW1ldGVycyk7XG5cbiAgICBwYXJhbUtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgdHdlZW5GbnNba2V5XSA9IGludGVycG9sYXRlKGNvbmZpZy5mcm9tLCBjb25maWcudG8sIGNvbmZpZy5lYXNpbmcgfHwgbGluZWFyRWFzaW5nKTtcbiAgICB9KTtcblxuICAgIC8vIFJ1biBpdCFcbiAgICB2YXIgcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SWQgIT09IG51bGwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdElkKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVBbmltYXRpb25Db21wbGV0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJydXB0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKVxuICAgIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSBub3coKTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSBNYXRoLm1pbigoY3VycmVudCAtIHN0YXJ0KSAvIGR1cmF0aW9uTXMsIDEpO1xuXG4gICAgICAgIHVwZGF0ZVZhbHVlcyhlbGFwc2VkKTtcbiAgICAgICAgb25VcGRhdGUodmFsdWVzKTtcblxuICAgICAgICBpZiAoY3VycmVudCA8IGVuZClcbiAgICAgICAgICAgIHJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBoYW5kbGVBbmltYXRpb25Db21wbGV0aW9uKHtcbiAgICAgICAgICAgICAgICBpbnRlcnJ1cHRlZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlcyhlbGFwc2VkKVxuICAgIHtcbiAgICAgICAgcGFyYW1LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0d2VlbkZuc1trZXldKGVsYXBzZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVBbmltYXRpb25Db21wbGV0aW9uKGluZm8pXG4gICAge1xuICAgICAgICByZXF1ZXN0SWQgPSBudWxsO1xuXG4gICAgICAgIGlmIChvbkVuZClcbiAgICAgICAgICAgIG9uRW5kKGluZm8pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgZWFzaW5nKVxue1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxhcHNlZClcbiAgICB7XG4gICAgICAgIHJldHVybiBzdGFydCArIChlbmQgLSBzdGFydCkgKiBlYXNpbmcoZWxhcHNlZCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbGluZWFyRWFzaW5nKGUpXG57XG4gICAgcmV0dXJuIGU7XG59XG5cbnZhciBub3c7XG5cbmlmICh0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIHBlcmZvcm1hbmNlLm5vdylcbntcbiAgICBub3cgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG59XG5lbHNlXG57XG4gICAgbm93ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpO1xuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9pbnRlcnBvbGF0ZS1hbmltYXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRCb29rTGF5b3V0R3JvdXBzID0gcmVxdWlyZSgnLi9ib29rLWxheW91dCcpO1xudmFyIGdldFNpbmdsZXNMYXlvdXRHcm91cHMgPSByZXF1aXJlKCcuL3NpbmdsZXMtbGF5b3V0Jyk7XG52YXIgZ2V0R3JpZExheW91dEdyb3VwcyA9IHJlcXVpcmUoJy4vZ3JpZC1sYXlvdXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRQYWdlTGF5b3V0cztcblxuLyoqIEdldCB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcGFnZXMgZm9yIHRoZSBjdXJyZW50IHZpZXcgKi9cbmZ1bmN0aW9uIGdldFBhZ2VMYXlvdXRzKHNldHRpbmdzKVxue1xuICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0R3JpZExheW91dEdyb3VwcyhwbHVjayhzZXR0aW5ncywgW1xuICAgICAgICAgICAgJ21hbmlmZXN0JyxcbiAgICAgICAgICAgICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAncGFnZXNQZXJSb3cnLFxuICAgICAgICAgICAgJ2ZpeGVkSGVpZ2h0R3JpZCcsXG4gICAgICAgICAgICAnZml4ZWRQYWRkaW5nJyxcbiAgICAgICAgICAgICdzaG93Tm9uUGFnZWRQYWdlcydcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB2YXIgY29uZmlnID0gcGx1Y2soc2V0dGluZ3MsIFsnbWFuaWZlc3QnLCAndmVydGljYWxseU9yaWVudGVkJywgJ3Nob3dOb25QYWdlZFBhZ2VzJ10pO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICByZXR1cm4gZ2V0Qm9va0xheW91dEdyb3Vwcyhjb25maWcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZ2V0U2luZ2xlc0xheW91dEdyb3Vwcyhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcGx1Y2sob2JqLCBrZXlzKVxue1xuICAgIHZhciBvdXQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIG91dFtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldFBhZ2VEaW1lbnNpb25zID0gcmVxdWlyZSgnLi9wYWdlLWRpbWVuc2lvbnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCb29rTGF5b3V0R3JvdXBzO1xuXG5mdW5jdGlvbiBnZXRCb29rTGF5b3V0R3JvdXBzKHZpZXdlckNvbmZpZylcbntcbiAgICB2YXIgZ3JvdXBpbmdzID0gZ2V0R3JvdXBpbmdzKHZpZXdlckNvbmZpZyk7XG5cbiAgICByZXR1cm4gZ3JvdXBpbmdzLm1hcChmdW5jdGlvbiAoZ3JvdXBpbmcpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0R3JvdXBMYXlvdXRzRnJvbVBhZ2VHcm91cGluZyh2aWV3ZXJDb25maWcsIGdyb3VwaW5nKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0R3JvdXBpbmdzKHZpZXdlckNvbmZpZylcbntcbiAgICB2YXIgbWFuaWZlc3QgPSB2aWV3ZXJDb25maWcubWFuaWZlc3Q7XG5cbiAgICB2YXIgcGFnZXNCeUdyb3VwID0gW107XG4gICAgdmFyIGxlZnRQYWdlID0gbnVsbDtcbiAgICB2YXIgbm9uUGFnZWRQYWdlcyA9IFtdOyAvLyBQYWdlcyB0byBkaXNwbGF5IGJlbG93IHRoZSBjdXJyZW50IGdyb3VwXG5cbiAgICB2YXIgX2FkZE5vblBhZ2VkUGFnZXMgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vblBhZ2VkUGFnZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VzQnlHcm91cC5wdXNoKFsgbm9uUGFnZWRQYWdlc1tpXSBdKTtcbiAgICAgICAgfVxuICAgICAgICBub25QYWdlZFBhZ2VzID0gW107XG4gICAgfTtcblxuICAgIG1hbmlmZXN0LnBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UsIGluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIHBhZ2VSZWNvcmQgPSB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBnZXRQYWdlRGltZW5zaW9ucyhpbmRleCwgbWFuaWZlc3QpLFxuICAgICAgICAgICAgcGFnZWQ6ICghbWFuaWZlc3QucGFnZWQgfHwgcGFnZS5wYWdlZClcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBPbmx5IGRpc3BsYXkgbm9uLXBhZ2VkIHBhZ2VzIGlmIHNwZWNpZmllZCBpbiB0aGUgc2V0dGluZ3NcbiAgICAgICAgaWYgKCF2aWV3ZXJDb25maWcuc2hvd05vblBhZ2VkUGFnZXMgJiYgIXBhZ2VSZWNvcmQucGFnZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKCFwYWdlUmVjb3JkLnBhZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICBub25QYWdlZFBhZ2VzLnB1c2gocGFnZVJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IDAgfHwgcGFnZS5mYWNpbmdQYWdlcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBhZ2UgaXMgcGxhY2VkIG9uIGl0cyBvd25cbiAgICAgICAgICAgIHBhZ2VzQnlHcm91cC5wdXNoKFtwYWdlUmVjb3JkXSk7XG4gICAgICAgICAgICBfYWRkTm9uUGFnZWRQYWdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlZnRQYWdlID09PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZWZ0UGFnZSA9IHBhZ2VSZWNvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlc0J5R3JvdXAucHVzaChbbGVmdFBhZ2UsIHBhZ2VSZWNvcmRdKTtcbiAgICAgICAgICAgIGxlZnRQYWdlID0gbnVsbDtcbiAgICAgICAgICAgIF9hZGROb25QYWdlZFBhZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEZsdXNoIGEgZmluYWwgbGVmdCBwYWdlXG4gICAgaWYgKGxlZnRQYWdlICE9PSBudWxsKVxuICAgIHtcbiAgICAgICAgcGFnZXNCeUdyb3VwLnB1c2goW2xlZnRQYWdlXSk7XG4gICAgICAgIF9hZGROb25QYWdlZFBhZ2VzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2VzQnlHcm91cDtcbn1cblxuZnVuY3Rpb24gZ2V0R3JvdXBMYXlvdXRzRnJvbVBhZ2VHcm91cGluZyh2aWV3ZXJDb25maWcsIGdyb3VwaW5nKVxue1xuICAgIHZhciB2ZXJ0aWNhbGx5T3JpZW50ZWQgPSB2aWV3ZXJDb25maWcudmVydGljYWxseU9yaWVudGVkO1xuXG4gICAgaWYgKGdyb3VwaW5nLmxlbmd0aCA9PT0gMilcbiAgICAgICAgcmV0dXJuIGdldEZhY2luZ1BhZ2VHcm91cChncm91cGluZ1swXSwgZ3JvdXBpbmdbMV0sIHZlcnRpY2FsbHlPcmllbnRlZCk7XG5cbiAgICB2YXIgcGFnZSA9IGdyb3VwaW5nWzBdO1xuICAgIHZhciBwYWdlRGltcyA9IHBhZ2UuZGltZW5zaW9ucztcblxuICAgIC8vIFRoZSBmaXJzdCBwYWdlIGlzIHBsYWNlZCBvbiBpdHMgb3duIHRvIHRoZSByaWdodCBpbiB2ZXJ0aWNhbCBvcmllbnRhdGlvbi5cbiAgICAvLyBOQiB0aGF0IHRoaXMgbmVlZHMgdG8gYmUgdGhlIHBhZ2Ugd2l0aCBpbmRleCAwOyBpZiB0aGUgZmlyc3QgcGFnZSBpcyBleGNsdWRlZFxuICAgIC8vIGZyb20gdGhlIGxheW91dCB0aGVuIHRoaXMgc3BlY2lhbCBjYXNlIHNob3VsZG4ndCBhcHBseS5cbiAgICAvLyBJZiB0aGUgcGFnZSBpcyB0YWdnZWQgYXMgJ25vbi1wYWdlZCcsIGNlbnRlciBpdCBob3Jpem9udGFsbHlcbiAgICB2YXIgbGVmdE9mZnNldDtcbiAgICBpZiAocGFnZS5wYWdlZClcbiAgICAgICAgbGVmdE9mZnNldCA9IChwYWdlLmluZGV4ID09PSAwICYmIHZlcnRpY2FsbHlPcmllbnRlZCkgPyBwYWdlRGltcy53aWR0aCA6IDA7XG4gICAgZWxzZVxuICAgICAgICBsZWZ0T2Zmc2V0ID0gKHZlcnRpY2FsbHlPcmllbnRlZCkgPyBwYWdlRGltcy53aWR0aCAvIDIgOiAwO1xuXG4gICAgdmFyIHNob3VsZEJlSG9yaXpvbnRhbGx5QWRqdXN0ZWQgPVxuICAgICAgICB2ZXJ0aWNhbGx5T3JpZW50ZWQgJiYgIXZpZXdlckNvbmZpZy5tYW5pZmVzdC5wYWdlc1twYWdlLmluZGV4XS5mYWNpbmdQYWdlcztcblxuICAgIC8vIFdlIG5lZWQgdG8gbGVmdC1hbGlnbiB0aGUgcGFnZSBpbiB2ZXJ0aWNhbCBvcmllbnRhdGlvbiwgc28gd2UgZG91YmxlXG4gICAgLy8gdGhlIGdyb3VwIHdpZHRoXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBwYWdlRGltcy5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogc2hvdWxkQmVIb3Jpem9udGFsbHlBZGp1c3RlZCA/IHBhZ2VEaW1zLndpZHRoICogMiA6IHBhZ2VEaW1zLndpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2VzOiBbe1xuICAgICAgICAgICAgaW5kZXg6IHBhZ2UuaW5kZXgsXG4gICAgICAgICAgICBncm91cE9mZnNldDoge1xuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0T2Zmc2V0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZURpbXNcbiAgICAgICAgfV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRGYWNpbmdQYWdlR3JvdXAobGVmdFBhZ2UsIHJpZ2h0UGFnZSwgdmVydGljYWxseU9yaWVudGVkKVxue1xuICAgIHZhciBsZWZ0RGltcyA9IGxlZnRQYWdlLmRpbWVuc2lvbnM7XG4gICAgdmFyIHJpZ2h0RGltcyA9IHJpZ2h0UGFnZS5kaW1lbnNpb25zO1xuXG4gICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGxlZnREaW1zLmhlaWdodCwgcmlnaHREaW1zLmhlaWdodCk7XG5cbiAgICB2YXIgd2lkdGgsIGZpcnN0TGVmdE9mZnNldCwgc2Vjb25kTGVmdE9mZnNldDtcblxuICAgIGlmICh2ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAge1xuICAgICAgICB2YXIgbWlkV2lkdGggPSBNYXRoLm1heChsZWZ0RGltcy53aWR0aCwgcmlnaHREaW1zLndpZHRoKTtcblxuICAgICAgICB3aWR0aCA9IG1pZFdpZHRoICogMjtcblxuICAgICAgICBmaXJzdExlZnRPZmZzZXQgPSBtaWRXaWR0aCAtIGxlZnREaW1zLndpZHRoO1xuICAgICAgICBzZWNvbmRMZWZ0T2Zmc2V0ID0gbWlkV2lkdGg7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHdpZHRoID0gbGVmdERpbXMud2lkdGggKyByaWdodERpbXMud2lkdGg7XG4gICAgICAgIGZpcnN0TGVmdE9mZnNldCA9IDA7XG4gICAgICAgIHNlY29uZExlZnRPZmZzZXQgPSBsZWZ0RGltcy53aWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9LFxuICAgICAgICBwYWdlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4OiBsZWZ0UGFnZS5pbmRleCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBsZWZ0RGltcyxcbiAgICAgICAgICAgICAgICBncm91cE9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGZpcnN0TGVmdE9mZnNldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHJpZ2h0UGFnZS5pbmRleCxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiByaWdodERpbXMsXG4gICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzZWNvbmRMZWZ0T2Zmc2V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ib29rLWxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgsIG1hbmlmZXN0KVxue1xuICAgIHZhciBkaW1zID0gbWFuaWZlc3QuZ2V0TWF4UGFnZURpbWVuc2lvbnMocGFnZUluZGV4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBNYXRoLmZsb29yKGRpbXMud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGguZmxvb3IoZGltcy5oZWlnaHQpXG4gICAgfTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvcGFnZS1kaW1lbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0UGFnZURpbWVuc2lvbnMgPSByZXF1aXJlKCcuL3BhZ2UtZGltZW5zaW9ucycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNpbmdsZXNMYXlvdXRHcm91cHModmlld2VyQ29uZmlnKVxue1xuICAgIHZhciBtYW5pZmVzdCA9IHZpZXdlckNvbmZpZy5tYW5pZmVzdDtcblxuICAgIC8vIFJlbmRlciBlYWNoIHBhZ2UgYWxvbmUgaW4gYSBncm91cFxuICAgIHZhciBwYWdlcyA9IFtdO1xuICAgIG1hbmlmZXN0LnBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UsIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCF2aWV3ZXJDb25maWcuc2hvd05vblBhZ2VkUGFnZXMgJiYgbWFuaWZlc3QucGFnZWQgJiYgIXBhZ2UucGFnZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIHBhZ2VEaW1zID0gZ2V0UGFnZURpbWVuc2lvbnMoaW5kZXgsIG1hbmlmZXN0KTtcblxuICAgICAgICBwYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhZ2VEaW1zLFxuICAgICAgICAgICAgcGFnZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHt0b3A6IDAsIGxlZnQ6IDB9LFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBwYWdlRGltc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFnZXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3NpbmdsZXMtbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IGdldEdyaWRMYXlvdXRHcm91cHM7XG5cbmZ1bmN0aW9uIGdldEdyaWRMYXlvdXRHcm91cHModmlld2VyQ29uZmlnKVxue1xuICAgIHZhciB2aWV3cG9ydFdpZHRoID0gdmlld2VyQ29uZmlnLnZpZXdwb3J0LndpZHRoO1xuICAgIHZhciBtYW5pZmVzdCA9IHZpZXdlckNvbmZpZy5tYW5pZmVzdDtcbiAgICB2YXIgcGFnZXNQZXJSb3cgPSB2aWV3ZXJDb25maWcucGFnZXNQZXJSb3c7XG4gICAgdmFyIGZpeGVkSGVpZ2h0R3JpZCA9IHZpZXdlckNvbmZpZy5maXhlZEhlaWdodEdyaWQ7XG4gICAgdmFyIGZpeGVkUGFkZGluZyA9IHZpZXdlckNvbmZpZy5maXhlZFBhZGRpbmc7XG4gICAgdmFyIHNob3dOb25QYWdlZFBhZ2VzID0gdmlld2VyQ29uZmlnLnNob3dOb25QYWdlZFBhZ2VzO1xuXG4gICAgdmFyIGhvcml6b250YWxQYWRkaW5nID0gZml4ZWRQYWRkaW5nICogKHBhZ2VzUGVyUm93ICsgMSk7XG4gICAgdmFyIHBhZ2VXaWR0aCA9ICh2aWV3cG9ydFdpZHRoIC0gaG9yaXpvbnRhbFBhZGRpbmcpIC8gcGFnZXNQZXJSb3c7XG4gICAgdmFyIGdyaWRQYWdlV2lkdGggPSBwYWdlV2lkdGg7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIHJvdyBoZWlnaHQgZGVwZW5kaW5nIG9uIHdoZXRoZXIgd2Ugd2FudCB0byBmaXggdGhlIHdpZHRoIG9yIHRoZSBoZWlnaHRcbiAgICB2YXIgcm93SGVpZ2h0ID0gKGZpeGVkSGVpZ2h0R3JpZCkgPyBmaXhlZFBhZGRpbmcgKyBtYW5pZmVzdC5taW5SYXRpbyAqIHBhZ2VXaWR0aCA6IGZpeGVkUGFkZGluZyArIG1hbmlmZXN0Lm1heFJhdGlvICogcGFnZVdpZHRoO1xuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIHZhciBjdXJyZW50UGFnZXMgPSBbXTtcblxuICAgIHZhciBnZXRHcmlkUGFnZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAocGFnZURhdGEpXG4gICAge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHdpZHRoLCBoZWlnaHQgYW5kIGhvcml6b250YWwgcGxhY2VtZW50IG9mIHRoaXMgcGFnZVxuICAgICAgICAvLyBHZXQgZGltZW5zaW9ucyBhdCBtYXggem9vbSBsZXZlbCwgYWx0aG91Z2ggYW55IGxldmVsIHNob3VsZCBiZSBmaW5lXG4gICAgICAgIHZhciBwYWdlRGltZW5EYXRhID0gcGFnZURhdGEuZFtwYWdlRGF0YS5kLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgaGVpZ2h0VG9XaWR0aFJhdGlvID0gcGFnZURpbWVuRGF0YS5oIC8gcGFnZURpbWVuRGF0YS53O1xuXG4gICAgICAgIHZhciBwYWdlV2lkdGgsIHBhZ2VIZWlnaHQ7XG5cbiAgICAgICAgaWYgKGZpeGVkSGVpZ2h0R3JpZClcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZVdpZHRoID0gKHJvd0hlaWdodCAtIGZpeGVkUGFkZGluZykgLyBoZWlnaHRUb1dpZHRoUmF0aW87XG4gICAgICAgICAgICBwYWdlSGVpZ2h0ID0gcm93SGVpZ2h0IC0gZml4ZWRQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZVdpZHRoID0gZ3JpZFBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBhZ2VIZWlnaHQgPSBwYWdlV2lkdGggKiBoZWlnaHRUb1dpZHRoUmF0aW87XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQocGFnZVdpZHRoKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChwYWdlSGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgcm93RGltZW5zaW9ucyA9IHtcbiAgICAgICAgaGVpZ2h0OiByb3dIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB2aWV3cG9ydFdpZHRoXG4gICAgfTtcblxuICAgIG1hbmlmZXN0LnBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UsIHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIGlmICghc2hvd05vblBhZ2VkUGFnZXMgJiYgbWFuaWZlc3QucGFnZWQgJiYgIXBhZ2UucGFnZWQpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBob3Jpem9udGFsIHBsYWNlbWVudCBvZiB0aGlzIHBhZ2VcbiAgICAgICAgdmFyIHBhZ2VEaW1lbnMgPSBnZXRHcmlkUGFnZURpbWVuc2lvbnMocGFnZSk7XG4gICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gTWF0aC5mbG9vcihjdXJyZW50UGFnZXMubGVuZ3RoICogKGZpeGVkUGFkZGluZyArIGdyaWRQYWdlV2lkdGgpICsgZml4ZWRQYWRkaW5nKTtcblxuICAgICAgICAvLyBDZW50ZXIgdGhlIHBhZ2UgaWYgdGhlIGhlaWdodCBpcyBmaXhlZCAob3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBob3Jpem9udGFsIHBhZGRpbmcpXG4gICAgICAgIGlmIChmaXhlZEhlaWdodEdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxlZnRPZmZzZXQgKz0gKGdyaWRQYWdlV2lkdGggLSBwYWdlRGltZW5zLndpZHRoKSAvIDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBQcmVjb21wdXRlIHBhZ2UgZGltZW5zaW9ucyBldmVyeXdoZXJlXG4gICAgICAgIGN1cnJlbnRQYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgICAgICBkaW1lbnNpb25zOiBwYWdlRGltZW5zLFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY3VycmVudFBhZ2VzLmxlbmd0aCA9PT0gcGFnZXNQZXJSb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiByb3dEaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIHBhZ2VzOiBjdXJyZW50UGFnZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjdXJyZW50UGFnZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGN1cnJlbnRQYWdlcy5sZW5ndGggPiAwKVxuICAgIHtcbiAgICAgICAgZ3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgZGltZW5zaW9uczogcm93RGltZW5zaW9ucyxcbiAgICAgICAgICAgIHBhZ2VzOiBjdXJyZW50UGFnZXNcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ncmlkLWxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXR0aW5nc1ZpZXc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNldHRpbmdzVmlldyhzb3VyY2VzKVxue1xuICAgIHZhciBvYmogPSB7fTtcblxuICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoc291cmNlKVxuICAgIHtcbiAgICAgICAgcmVnaXN0ZXJNaXhpbihvYmosIHNvdXJjZSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiByZWdpc3Rlck1peGluKG9iaiwgbWl4aW4pXG57XG4gICAgT2JqZWN0LmtleXMobWl4aW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhpbltrZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIGV2ZXJ5dGhpbmcgc3RyaWN0IG1vZGUgc28gdGhpcyBpc24ndCBuZWVkZWRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3Qgc2V0IHNldHRpbmdzLicgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3NldHRpbmdzLXZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBleHRlbmQgPSByZXF1aXJlKCdqcXVlcnknKS5leHRlbmQ7XG5cbm1vZHVsZS5leHBvcnRzID0gVmFsaWRhdGlvblJ1bm5lcjtcblxuZnVuY3Rpb24gVmFsaWRhdGlvblJ1bm5lcihvcHRpb25zKVxue1xuICAgIHRoaXMud2hpdGVsaXN0ZWRLZXlzID0gb3B0aW9ucy53aGl0ZWxpc3RlZEtleXMgfHwgW107XG4gICAgdGhpcy5hZGRpdGlvbmFsUHJvcGVydGllcyA9IG9wdGlvbnMuYWRkaXRpb25hbFByb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy52YWxpZGF0aW9ucyA9IG9wdGlvbnMudmFsaWRhdGlvbnM7XG59XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgc2V0dGluZ3MpXG57XG4gICAgLy8gR2V0IHRoZSB2YWxpZGF0aW9uIGluZGV4XG4gICAgdmFyIHZhbGlkYXRpb25JbmRleCA9IG51bGw7XG5cbiAgICB0aGlzLnZhbGlkYXRpb25zLnNvbWUoZnVuY3Rpb24gKHZhbGlkYXRpb24sIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbGlkYXRpb24ua2V5ICE9PSBrZXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFsaWRhdGlvbkluZGV4ID0gaW5kZXg7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKHZhbGlkYXRpb25JbmRleCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBSdW4gdGhlIHZhbGlkYXRpb25cbiAgICB2YXIgZHVtbXlDaGFuZ2VzID0ge307XG4gICAgZHVtbXlDaGFuZ2VzW2tleV0gPSB2YWx1ZTtcbiAgICB2YXIgcHJveGllciA9IGNyZWF0ZVNldHRpbmdzUHJveGllcihzZXR0aW5ncywgZHVtbXlDaGFuZ2VzLCB0aGlzKTtcblxuICAgIHJldHVybiAhdGhpcy5fcnVuVmFsaWRhdGlvbih2YWxpZGF0aW9uSW5kZXgsIHZhbHVlLCBwcm94aWVyKTtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHNldHRpbmdzKVxue1xuICAgIHRoaXMuX3ZhbGlkYXRlT3B0aW9ucyh7fSwgc2V0dGluZ3MpO1xufTtcblxuVmFsaWRhdGlvblJ1bm5lci5wcm90b3R5cGUuZ2V0VmFsaWRhdGVkT3B0aW9ucyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgb3B0aW9ucylcbntcbiAgICB2YXIgY2xvbmVkID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB0aGlzLl92YWxpZGF0ZU9wdGlvbnMoc2V0dGluZ3MsIGNsb25lZCk7XG4gICAgcmV0dXJuIGNsb25lZDtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLl92YWxpZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdGlvbnMpXG57XG4gICAgdmFyIHNldHRpbmdzUHJveGllciA9IGNyZWF0ZVNldHRpbmdzUHJveGllcihzZXR0aW5ncywgb3B0aW9ucywgdGhpcyk7XG4gICAgdGhpcy5fYXBwbHlWYWxpZGF0aW9ucyhvcHRpb25zLCBzZXR0aW5nc1Byb3hpZXIpO1xufTtcblxuVmFsaWRhdGlvblJ1bm5lci5wcm90b3R5cGUuX2FwcGx5VmFsaWRhdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucywgcHJveGllcilcbntcbiAgICB0aGlzLnZhbGlkYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRpb24sIGluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KHZhbGlkYXRpb24ua2V5KSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgaW5wdXQgPSBvcHRpb25zW3ZhbGlkYXRpb24ua2V5XTtcbiAgICAgICAgdmFyIGNvcnJlY3RlZCA9IHRoaXMuX3J1blZhbGlkYXRpb24oaW5kZXgsIGlucHV0LCBwcm94aWVyKTtcblxuICAgICAgICBpZiAoY29ycmVjdGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNvcnJlY3RlZC53YXJuaW5nU3VwcHJlc3NlZClcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyh2YWxpZGF0aW9uLmtleSwgaW5wdXQsIGNvcnJlY3RlZC52YWx1ZSk7XG5cbiAgICAgICAgICAgIG9wdGlvbnNbdmFsaWRhdGlvbi5rZXldID0gY29ycmVjdGVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG59O1xuXG5WYWxpZGF0aW9uUnVubmVyLnByb3RvdHlwZS5fcnVuVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChpbmRleCwgaW5wdXQsIHByb3hpZXIpXG57XG4gICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRpb25zW2luZGV4XTtcblxuICAgIHByb3hpZXIuaW5kZXggPSBpbmRleDtcblxuICAgIHZhciB3YXJuaW5nU3VwcHJlc3NlZCA9IGZhbHNlO1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgIHN1cHByZXNzV2FybmluZzogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgd2FybmluZ1N1cHByZXNzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBvdXRwdXRWYWx1ZSA9IHZhbGlkYXRpb24udmFsaWRhdGUoaW5wdXQsIHByb3hpZXIucHJveHksIGNvbmZpZyk7XG5cbiAgICBpZiAob3V0cHV0VmFsdWUgPT09IHVuZGVmaW5lZCB8fCBvdXRwdXRWYWx1ZSA9PT0gaW5wdXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG91dHB1dFZhbHVlLFxuICAgICAgICB3YXJuaW5nU3VwcHJlc3NlZDogd2FybmluZ1N1cHByZXNzZWRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBUaGUgc2V0dGluZ3MgcHJveHkgd3JhcHMgdGhlIHNldHRpbmdzIG9iamVjdCBhbmQgZW5zdXJlcyB0aGF0XG4gKiBvbmx5IHZhbHVlcyB3aGljaCBoYXZlIHByZXZpb3VzbHkgYmVlbiB2YWxpZGF0ZWQgYXJlIGFjY2Vzc2VkLFxuICogdGhyb3dpbmcgYSBUeXBlRXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEZJWE1FKHdhYmFpbik6IElzIGl0IHdvcnRoIGtlZXBpbmcgdGhpcz8gV2hlbiBJIHdyb3RlIGl0IEkgaGFkXG4gKiBtdWx0aXBsZSB2YWxpZGF0aW9uIHN0YWdlcyBhbmQgaXQgd2FzIGEgbG90IGhhcmRlciB0byBrZWVwIHRyYWNrXG4gKiBvZiBldmVyeXRoaW5nLCBzbyB0aGlzIHdhcyBtb3JlIHZhbHVhYmxlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZXR0aW5nc1Byb3hpZXIoc2V0dGluZ3MsIG9wdGlvbnMsIHJ1bm5lcilcbntcbiAgICB2YXIgcHJveGllciA9IHtcbiAgICAgICAgcHJveHk6IHt9LFxuICAgICAgICBpbmRleDogbnVsbFxuICAgIH07XG5cbiAgICB2YXIgbG9va3VwID0gbG9va3VwVmFsdWUuYmluZChudWxsLCBzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuXG4gICAgcnVubmVyLndoaXRlbGlzdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uICh3aGl0ZWxpc3RlZClcbiAgICB7XG4gICAgICAgIHByb3BlcnRpZXNbd2hpdGVsaXN0ZWRdID0ge1xuICAgICAgICAgICAgZ2V0OiBsb29rdXAuYmluZChudWxsLCB3aGl0ZWxpc3RlZClcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJ1bm5lci5hZGRpdGlvbmFsUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChhZGRpdGlvbmFsKVxuICAgIHtcbiAgICAgICAgcHJvcGVydGllc1thZGRpdGlvbmFsLmtleV0gPSB7XG4gICAgICAgICAgICBnZXQ6IGFkZGl0aW9uYWwuZ2V0XG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBydW5uZXIudmFsaWRhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsaWRhdGlvbiwgdmFsaWRhdGlvbkluZGV4KVxuICAgIHtcbiAgICAgICAgcHJvcGVydGllc1t2YWxpZGF0aW9uLmtleV0gPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25JbmRleCA8IHByb3hpZXIuaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb29rdXAodmFsaWRhdGlvbi5rZXkpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBydW5uZXIudmFsaWRhdGlvbnNbcHJveGllci5pbmRleF0ua2V5O1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhY2Nlc3Mgc2V0dGluZyAnICsgdmFsaWRhdGlvbi5rZXkgKyAnIHdoaWxlIHZhbGlkYXRpbmcgJyArIGN1cnJlbnRLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJveGllci5wcm94eSwgcHJvcGVydGllcyk7XG5cbiAgICByZXR1cm4gcHJveGllcjtcbn1cblxuZnVuY3Rpb24gZW1pdFdhcm5pbmcoa2V5LCBvcmlnaW5hbCwgY29ycmVjdGVkKVxue1xuICAgIGNvbnNvbGUud2FybignSW52YWxpZCB2YWx1ZSBmb3IgJyArIGtleSArICc6ICcgKyBvcmlnaW5hbCArICcuIFVzaW5nICcgKyBjb3JyZWN0ZWQgKyAnIGluc3RlYWQuJyk7XG59XG5cbmZ1bmN0aW9uIGxvb2t1cFZhbHVlKGJhc2UsIGV4dGVuc2lvbiwga2V5KVxue1xuICAgIGlmIChrZXkgaW4gZXh0ZW5zaW9uKVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uW2tleV07XG5cbiAgICByZXR1cm4gYmFzZVtrZXldO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdmFsaWRhdGlvbi1ydW5uZXIuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnQ7XG5cbmZ1bmN0aW9uIFZpZXdwb3J0KG91dGVyLCBvcHRpb25zKVxue1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5pbnRlcnNlY3Rpb25Ub2xlcmFuY2UgPSBvcHRpb25zLmludGVyc2VjdGlvblRvbGVyYW5jZSB8fCAwO1xuICAgIHRoaXMubWF4RXh0ZW50ID0gb3B0aW9ucy5tYXhFeHRlbnQgfHwgMjAwMDtcblxuICAgIHRoaXMub3V0ZXIgPSBvdXRlcjtcblxuICAgIHRoaXMuX3RvcCA9IHRoaXMuX2xlZnQgPSB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IHRoaXMuX2lubmVyRGltZW5zaW9ucyA9IG51bGw7XG5cbiAgICB0aGlzLmludmFsaWRhdGUoKTtcbn1cblxuVmlld3BvcnQucHJvdG90eXBlLmludGVyc2VjdHNSZWdpb24gPSBmdW5jdGlvbiAocmVnaW9uKVxue1xuICAgIHJldHVybiB0aGlzLmhhc0hvcml6b250YWxPdmVybGFwKHJlZ2lvbikgJiYgdGhpcy5oYXNWZXJ0aWNhbE92ZXJsYXAocmVnaW9uKTtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZS5oYXNWZXJ0aWNhbE92ZXJsYXAgPSBmdW5jdGlvbiAocmVnaW9uKVxue1xuICAgIHZhciB0b3AgPSB0aGlzLnRvcCAtIHRoaXMuaW50ZXJzZWN0aW9uVG9sZXJhbmNlO1xuICAgIHZhciBib3R0b20gPSB0aGlzLmJvdHRvbSArIHRoaXMuaW50ZXJzZWN0aW9uVG9sZXJhbmNlO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgZmFsbHNCZXR3ZWVuKHJlZ2lvbi50b3AsIHRvcCwgYm90dG9tKSB8fFxuICAgICAgICBmYWxsc0JldHdlZW4ocmVnaW9uLmJvdHRvbSwgdG9wLCBib3R0b20pIHx8XG4gICAgICAgIChyZWdpb24udG9wIDw9IHRvcCAmJiByZWdpb24uYm90dG9tID49IGJvdHRvbSlcbiAgICApO1xufTtcblxuVmlld3BvcnQucHJvdG90eXBlLmhhc0hvcml6b250YWxPdmVybGFwID0gZnVuY3Rpb24gKHJlZ2lvbilcbntcbiAgICB2YXIgbGVmdCA9IHRoaXMubGVmdCAtIHRoaXMuaW50ZXJzZWN0aW9uVG9sZXJhbmNlO1xuICAgIHZhciByaWdodCA9IHRoaXMucmlnaHQgKyB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIGZhbGxzQmV0d2VlbihyZWdpb24ubGVmdCwgbGVmdCwgcmlnaHQpIHx8XG4gICAgICAgIGZhbGxzQmV0d2VlbihyZWdpb24ucmlnaHQsIGxlZnQsIHJpZ2h0KSB8fFxuICAgICAgICAocmVnaW9uLmxlZnQgPD0gbGVmdCAmJiByZWdpb24ucmlnaHQgPj0gcmlnaHQpXG4gICAgKTtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBGSVhNRTogU2hvdWxkIHRoaXMgY2hlY2sgdGhlIGlubmVyIGRpbWVuc2lvbnMgYXMgd2VsbD9cbiAgICB0aGlzLl93aWR0aCA9IGNsYW1wTWF4KHRoaXMub3V0ZXIuY2xpZW50V2lkdGgsIHRoaXMubWF4RXh0ZW50KTtcbiAgICB0aGlzLl9oZWlnaHQgPSBjbGFtcE1heCh0aGlzLm91dGVyLmNsaWVudEhlaWdodCwgdGhpcy5tYXhFeHRlbnQpO1xuXG4gICAgdGhpcy5fdG9wID0gdGhpcy5vdXRlci5zY3JvbGxUb3A7XG4gICAgdGhpcy5fbGVmdCA9IHRoaXMub3V0ZXIuc2Nyb2xsTGVmdDtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZS5zZXRJbm5lckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAoZGltZW5zaW9ucylcbntcbiAgICB0aGlzLl9pbm5lckRpbWVuc2lvbnMgPSBkaW1lbnNpb25zO1xuXG4gICAgaWYgKGRpbWVuc2lvbnMpXG4gICAge1xuICAgICAgICB0aGlzLl90b3AgPSBjbGFtcCh0aGlzLl90b3AsIDAsIGRpbWVuc2lvbnMuaGVpZ2h0IC0gdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgdGhpcy5fbGVmdCA9IGNsYW1wKHRoaXMuX2xlZnQsIDAsIGRpbWVuc2lvbnMud2lkdGggLSB0aGlzLl93aWR0aCk7XG4gICAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVmlld3BvcnQucHJvdG90eXBlLCB7XG4gICAgdG9wOiBnZXRDb29yZGluYXRlRGVzY3JpcHRvcigndG9wJywgJ2hlaWdodCcpLFxuICAgIGxlZnQ6IGdldENvb3JkaW5hdGVEZXNjcmlwdG9yKCdsZWZ0JywgJ3dpZHRoJyksXG5cbiAgICB3aWR0aDogZ2V0RGltZW5zaW9uRGVzY3JpcHRvcignd2lkdGgnKSxcbiAgICBoZWlnaHQ6IGdldERpbWVuc2lvbkRlc2NyaXB0b3IoJ2hlaWdodCcpLFxuXG4gICAgYm90dG9tOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RvcCArIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVmdCArIHRoaXMuX3dpZHRoO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldENvb3JkaW5hdGVEZXNjcmlwdG9yKGNvb3JkLCBhc3NvY2lhdGVkRGltZW5zaW9uKVxue1xuICAgIHZhciBwcml2YXRlUHJvcCA9ICdfJyArIGNvb3JkO1xuICAgIHZhciBzb3VyY2UgPSAnc2Nyb2xsJyArIGNvb3JkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgY29vcmQuc2xpY2UoMSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVQcm9wXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBub3JtYWxpemVkO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faW5uZXJEaW1lbnNpb25zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBtYXhBbGxvd2VkID0gdGhpcy5faW5uZXJEaW1lbnNpb25zW2Fzc29jaWF0ZWREaW1lbnNpb25dIC0gdGhpc1thc3NvY2lhdGVkRGltZW5zaW9uXTtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY2xhbXAobmV3VmFsdWUsIDAsIG1heEFsbG93ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQgPSBjbGFtcE1pbihuZXdWYWx1ZSwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNbcHJpdmF0ZVByb3BdID0gdGhpcy5vdXRlcltzb3VyY2VdID0gbm9ybWFsaXplZDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbkRlc2NyaXB0b3IoZGltZW4pXG57XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1snXycgKyBkaW1lbl07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmYWxsc0JldHdlZW4ocG9pbnQsIHN0YXJ0LCBlbmQpXG57XG4gICAgcmV0dXJuIHBvaW50ID49IHN0YXJ0ICYmIHBvaW50IDw9IGVuZDtcbn1cblxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KVxue1xuICAgIHJldHVybiBjbGFtcE1pbihjbGFtcE1heCh2YWx1ZSwgbWF4KSwgbWluKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBNaW4odmFsdWUsIG1pbilcbntcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWUsIG1pbik7XG59XG5cbmZ1bmN0aW9uIGNsYW1wTWF4KHZhbHVlLCBtYXgpXG57XG4gICAgcmV0dXJuIE1hdGgubWluKHZhbHVlLCBtYXgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdmlld3BvcnQuanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5cbkNhbnZhcyBwbHVnaW4gZm9yIGRpdmEuanNcbkFkZHMgYW4gYWRqdXN0bWVudCBpY29uIG5leHQgdG8gZWFjaCBpbWFnZVxuXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4uL2RpdmEnKTtcblxucmVxdWlyZSgnLi4vdXRpbHMvanF1ZXJ5LWV4dGVuc2lvbnMnKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgY2FudmFzID0ge30sXG4gICAgICAgICAgICBtYXAgPSB7fSxcbiAgICAgICAgICAgIHNldHRpbmdzID0ge30sXG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHNsaWRlcnMsXG4gICAgICAgICAgICBzbGlkZXJNb2RlO1xuXG4gICAgICAgIC8vIFNldCB1cCBzb21lIGRlZmF1bHQgc2V0dGluZ3MgKGNhbiBiZSBvdmVycmlkZGVuIHRoZSBub3JtYWwgd2F5KVxuICAgICAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBicmlnaHRuZXNzTWF4OiAxNTAsXG4gICAgICAgICAgICBicmlnaHRuZXNzTWluOiAtMTAwLFxuICAgICAgICAgICAgYnJpZ2h0bmVzc1N0ZXA6IDEsXG4gICAgICAgICAgICBjb250cmFzdE1heDogMyxcbiAgICAgICAgICAgIGNvbnRyYXN0TWluOiAtMSxcbiAgICAgICAgICAgIGNvbnRyYXN0U3RlcDogMC4wNSxcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZVByZWZpeDogJ2NhbnZhcy0nLFxuICAgICAgICAgICAgbW9iaWxlV2Via2l0TWF4Wm9vbTogMixcbiAgICAgICAgICAgIHJnYk1heDogNTAsXG4gICAgICAgICAgICByZ2JNaW46IC01MCxcbiAgICAgICAgICAgIHRocm9iYmVyRmFkZVNwZWVkOiAyMDAsXG4gICAgICAgICAgICB0aHJvYmJlclRpbWVvdXQ6IDEwMCxcbiAgICAgICAgICAgIGJ1dHRvbnM6IFtcbiAgICAgICAgICAgICAgICAnY29udHJhc3QnLFxuICAgICAgICAgICAgICAgICdicmlnaHRuZXNzJyxcbiAgICAgICAgICAgICAgICAncm90YXRpb24nLFxuICAgICAgICAgICAgICAgICd6b29tJ1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbnZlcnQgYW4gYW5nbGUgZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnNcbiAgICAgICAgdmFyIHRvUmFkaWFucyA9IGZ1bmN0aW9uIChhbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIG5ldyBjZW50ZXIgb2YgdGhlIHBhZ2UgYWZ0ZXIgcm90YXRpbmcgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gICAgICAgIHZhciBnZXROZXdDZW50ZXIgPSBmdW5jdGlvbiAoY3VycmVudENlbnRlciwgYW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB4ID0gY3VycmVudENlbnRlci54IC0gY2FudmFzLmNlbnRlclg7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBuZWdhdGl2ZSBiZWNhdXNlIHRoZSByb3RhdGlvbiBpcyBjb3VudGVyY2xvY2t3aXNlXG4gICAgICAgICAgICB2YXIgeSA9IC0oY3VycmVudENlbnRlci55IC0gY2FudmFzLmNlbnRlclkpO1xuXG4gICAgICAgICAgICB2YXIgdGhldGEgPSB0b1JhZGlhbnMoc2xpZGVycy5yb3RhdGlvbi5wcmV2aW91cyAtIGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBuZXdYID0gTWF0aC5jb3ModGhldGEpICogeCAtIE1hdGguc2luKHRoZXRhKSAqIHkgKyBjYW52YXMuY2VudGVyWDtcbiAgICAgICAgICAgIHZhciBuZXdZID0gLShNYXRoLnNpbih0aGV0YSkgKiB4ICsgTWF0aC5jb3ModGhldGEpICogeSkgKyBjYW52YXMuY2VudGVyWTtcblxuICAgICAgICAgICAgcmV0dXJuIHsneCc6IG5ld1gsICd5JzogbmV3WX07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUm90YXRlcyB0aGUgaW1hZ2Ugb24gdGhlIGdpdmVuIGNhbnZhcyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAgICAgICAgdmFyIHJvdGF0ZUNhbnZhcyA9IGZ1bmN0aW9uIChhQ2FudmFzLCBhbmdsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gYUNhbnZhcy5zaXplIC8gMjtcbiAgICAgICAgICAgIHZhciBzdGFydFggPSAtKGFDYW52YXMud2lkdGggLyAyKTtcbiAgICAgICAgICAgIHZhciBzdGFydFkgPSAtKGFDYW52YXMuaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXMgc28gdGhhdCByZW1uYW50cyBvZiB0aGUgb2xkIGltYWdlIGRvbid0IHNob3dcbiAgICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGFDYW52YXMuc2l6ZSwgYUNhbnZhcy5zaXplKTtcblxuICAgICAgICAgICAgLy8gRG8gdGhlIHJvdGF0aW9uXG4gICAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICAgIGNvbnRleHQucm90YXRlKHRvUmFkaWFucyhhbmdsZSkpO1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIHN0YXJ0WCwgc3RhcnRZLCBhQ2FudmFzLndpZHRoLCBhQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbmV3IHBpeGVsIGRhdGEgc28gdGhhdCBpdCBjYW4gbGF0ZXIgYmUgYWRqdXN0ZWQgaW4gYWRqdXN0TGV2ZWxzXG4gICAgICAgICAgICBhQ2FudmFzLmRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBhQ2FudmFzLnNpemUsIGFDYW52YXMuc2l6ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBsYXJnZSBjYW52YXNcbiAgICAgICAgdmFyIHNob3VsZEFkanVzdExldmVscyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzbGlkZXI7XG5cbiAgICAgICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBzb21ldGhpbmcgaGFzIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVycylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVyc1tzbGlkZXJdLmN1cnJlbnQgIT09IHNsaWRlcnNbc2xpZGVyXS5wcmV2aW91cylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNldHMgdGhlIFwicHJldmlvdXNcIiB2YWx1ZSB0byB0aGUgXCJjdXJyZW50XCIgdmFsdWUgZm9yIGV2ZXJ5IHNsaWRlclxuICAgICAgICB2YXIgdXBkYXRlUHJldmlvdXNMZXZlbHMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2xpZGVyO1xuXG4gICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNsaWRlcnNbc2xpZGVyXS5wcmV2aW91cyA9IHNsaWRlcnNbc2xpZGVyXS5jdXJyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGh1bWJuYWlsIHByZXZpZXcgKGNhbGxlZCB3aGVuIGEgc2xpZGVyIGlzIG1vdmVkL3Jlc2V0KVxuICAgICAgICB2YXIgdXBkYXRlTWFwID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcm90YXRlQ2FudmFzKG1hcCwgc2xpZGVycy5yb3RhdGlvbi5jdXJyZW50KTtcbiAgICAgICAgICAgIGFkanVzdExldmVscyhtYXApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFyZ2UgY2FudmFzIChyb3RhdGlvbiwgem9vbWluZywgc2Nyb2xsaW5nLCBwaXhlbCBtYW5pcHVsYXRpb24pXG4gICAgICAgIHZhciB1cGRhdGVDYW52YXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgYW5nbGUgPSBzbGlkZXJzLnJvdGF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgb2xkQW5nbGUgPSBzbGlkZXJzLnJvdGF0aW9uLnByZXZpb3VzO1xuICAgICAgICAgICAgdmFyIHpvb21MZXZlbCA9IHNsaWRlcnMuem9vbS5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIG9sZFpvb21MZXZlbCA9IHNsaWRlcnMuem9vbS5wcmV2aW91cztcblxuICAgICAgICAgICAgLy8gU2Nyb2xsIHRoZSB1c2VyIHRvIHRoZSBkZXNpcmVkIGxvY2F0aW9uXG4gICAgICAgICAgICBpZiAoYW5nbGUgIT09IG9sZEFuZ2xlIHx8IHpvb21MZXZlbCAhPT0gb2xkWm9vbUxldmVsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIEZpcnN0IGZpZ3VyZSBvdXQgdGhlIGN1cnJlbnQgY2VudGVyIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICAgICAgICAgIHZhciBsZWZ0U2Nyb2xsID0gJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvcFNjcm9sbCA9ICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKCk7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRPZmZzZXQgPSBzZXR0aW5ncy52aWV3cG9ydC53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgdmFyIHRvcE9mZnNldCA9IHNldHRpbmdzLnZpZXdwb3J0LmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGRldGVybWluZSB0aGUgbmV3IGNlbnRlciAodGhlIHNhbWUgcGFydCBvZiB0aGUgaW1hZ2UpXG4gICAgICAgICAgICAgICAgdmFyIG5ld0NlbnRlciA9IGdldE5ld0NlbnRlcih7eDogbGVmdFNjcm9sbCArIGxlZnRPZmZzZXQsIHk6IHRvcFNjcm9sbCArIHRvcE9mZnNldH0sIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIEluY29ycG9yYXRlIHRoZSB6b29tIGNoYW5nZSByYXRpbyAod291bGQgYmUgMSBpZiBubyBjaGFuZ2UpXG4gICAgICAgICAgICAgICAgdmFyIHpvb21DaGFuZ2UgPSBNYXRoLnBvdygyLCB6b29tTGV2ZWwgLSBvbGRab29tTGV2ZWwpO1xuICAgICAgICAgICAgICAgIHZhciB0b0xlZnRTY3JvbGwgPSB6b29tQ2hhbmdlICogbmV3Q2VudGVyLnggLSBsZWZ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIHZhciB0b1RvcFNjcm9sbCA9IHpvb21DaGFuZ2UgKiBuZXdDZW50ZXIueSAtIHRvcE9mZnNldDtcblxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgbGFyZ2UgY2FudmFzXG4gICAgICAgICAgICAgICAgcm90YXRlQ2FudmFzKGNhbnZhcywgYW5nbGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIHRoZSBuZXcgY2VudGVyXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KHRvTGVmdFNjcm9sbCk7XG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AodG9Ub3BTY3JvbGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IGNhbGwgYWRqdXN0TGV2ZWxzIGFnYWluIGlmIHdlIHJlYWxseSBuZWVkIHRvIChleHBlbnNpdmUpXG4gICAgICAgICAgICBpZiAoc2hvdWxkQWRqdXN0TGV2ZWxzKCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWRqdXN0TGV2ZWxzKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUHJldmlvdXNMZXZlbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb3BpZXMgdGhlIGNhbnZhcycgcGl4ZWwgYXJyYXkgYW5kIHJldHVybnMgdGhlIGNvcHlcbiAgICAgICAgdmFyIGNvcHlJbWFnZURhdGEgPSBmdW5jdGlvbiAoYUNhbnZhcylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9sZEltYWdlRGF0YSA9IGFDYW52YXMuZGF0YTtcbiAgICAgICAgICAgIHZhciBuZXdJbWFnZURhdGEgPSBhQ2FudmFzLmNvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKG9sZEltYWdlRGF0YSk7XG4gICAgICAgICAgICB2YXIgcGl4ZWxBcnJheSA9IG5ld0ltYWdlRGF0YS5kYXRhO1xuICAgICAgICAgICAgdmFyIGksIGxlbmd0aDtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gcGl4ZWxBcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwaXhlbEFycmF5W2ldID0gb2xkSW1hZ2VEYXRhLmRhdGFbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdJbWFnZURhdGE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB3ZSBuZWVkIHRvIGFkanVzdCB0aGlzIGxldmVsIC0gdmVyeSBzaW1wbGVcbiAgICAgICAgdmFyIHNob3VsZEFkanVzdCA9IGZ1bmN0aW9uIChtb2RlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGhpc0NoYW5nZWQgPSBzbGlkZXJzW21vZGVdLmN1cnJlbnQgIT09IHNsaWRlcnNbbW9kZV0ucHJldmlvdXM7XG4gICAgICAgICAgICB2YXIgdGhpc05vdERlZmF1bHQgPSBzbGlkZXJzW21vZGVdLmN1cnJlbnQgIT09IHNsaWRlcnNbbW9kZV0uaW5pdGlhbDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNDaGFuZ2VkIHx8IHRoaXNOb3REZWZhdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhZGp1c3RMZXZlbHMgPSBmdW5jdGlvbiAoYUNhbnZhcylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ29weSB0aGUgcGl4ZWwgYXJyYXkgdG8gYXZvaWQgZGVzdHJ1Y3RpdmVseSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICB2YXIgaW1hZ2VEYXRhID0gY29weUltYWdlRGF0YShhQ2FudmFzKTtcbiAgICAgICAgICAgIHZhciBwaXhlbEFycmF5ID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGFuZCBjYWxjdWxhdGUgc29tZSBzY2FsZSBmYWN0b3JzIGFuZCBvZmZzZXRzXG4gICAgICAgICAgICB2YXIgYnJpZ2h0bmVzcyA9IHNsaWRlcnMuYnJpZ2h0bmVzcy5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIGNvbnRyYXN0ID0gc2xpZGVycy5jb250cmFzdC5jdXJyZW50O1xuXG4gICAgICAgICAgICB2YXIgYnJpZ2h0TXVsID0gMSArIE1hdGgubWluKHNldHRpbmdzLmJyaWdodG5lc3NNYXgsIE1hdGgubWF4KHNldHRpbmdzLmJyaWdodG5lc3NNaW4sIGJyaWdodG5lc3MpKSAvIHNldHRpbmdzLmJyaWdodG5lc3NNYXg7XG4gICAgICAgICAgICB2YXIgYnJpZ2h0VGltZXNDb250cmFzdCA9IGJyaWdodE11bCAqIGNvbnRyYXN0O1xuICAgICAgICAgICAgdmFyIGNvbnRyYXN0T2Zmc2V0ID0gMTI4IC0gKGNvbnRyYXN0ICogMTI4KTtcblxuICAgICAgICAgICAgdmFyIHJlZE9mZnNldCA9IHNsaWRlcnMucmVkLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgZ3JlZW5PZmZzZXQgPSBzbGlkZXJzLmdyZWVuLmN1cnJlbnQ7XG4gICAgICAgICAgICB2YXIgYmx1ZU9mZnNldCA9IHNsaWRlcnMuYmx1ZS5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBhZGp1c3QgY2VydGFpbiB0aGluZ3NcbiAgICAgICAgICAgIHZhciBhZGp1c3RSZWQgPSBzaG91bGRBZGp1c3QoJ3JlZCcpO1xuICAgICAgICAgICAgdmFyIGFkanVzdEdyZWVuID0gc2hvdWxkQWRqdXN0KCdncmVlbicpO1xuICAgICAgICAgICAgdmFyIGFkanVzdEJsdWUgPSBzaG91bGRBZGp1c3QoJ2JsdWUnKTtcblxuICAgICAgICAgICAgdmFyIGFkanVzdEJyaWdodG5lc3MgPSBzaG91bGRBZGp1c3QoJ2JyaWdodG5lc3MnKTtcbiAgICAgICAgICAgIHZhciBhZGp1c3RDb250cmFzdCA9IHNob3VsZEFkanVzdCgnY29udHJhc3QnKTtcbiAgICAgICAgICAgIHZhciBhZGp1c3RPdGhlcnMgPSBhZGp1c3RCcmlnaHRuZXNzIHx8IGFkanVzdENvbnRyYXN0O1xuXG4gICAgICAgICAgICB2YXIgeCwgeSwgd2lkdGgsIGhlaWdodCwgb2Zmc2V0LCByLCBnLCBiO1xuXG4gICAgICAgICAgICBmb3IgKHggPSAwLCB3aWR0aCA9IGltYWdlRGF0YS53aWR0aDsgeCA8IHdpZHRoOyB4KyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZm9yICh5ID0gMCwgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKHkgKiB3aWR0aCArIHgpICogNDtcblxuICAgICAgICAgICAgICAgICAgICByID0gcGl4ZWxBcnJheVtvZmZzZXRdO1xuICAgICAgICAgICAgICAgICAgICBnID0gcGl4ZWxBcnJheVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IHBpeGVsQXJyYXlbb2Zmc2V0ICsgMl07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBkbyBzb21ldGhpbmcgaWYgdGhlIHBpeGVsIGlzIG5vdCBibGFjayBvcmlnaW5hbGx5XG4gICAgICAgICAgICAgICAgICAgIGlmIChyICsgZyArIGIgPiAwKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFkanVzdCBpbmRpdmlkdWFsIGNvbG91ciBjaGFubmVscyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RSZWQgJiYgcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHJlZE9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdEdyZWVuICYmIGcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyArPSBncmVlbk9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdEJsdWUgJiYgYilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiICs9IGJsdWVPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIG5lZWQgdG8gYWRqdXN0IGJyaWdodG5lc3MgYW5kL29yIGNvbnRyYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0T3RoZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gciAqIGJyaWdodFRpbWVzQ29udHJhc3QgKyBjb250cmFzdE9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnID0gZyAqIGJyaWdodFRpbWVzQ29udHJhc3QgKyBjb250cmFzdE9mZnNldDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYiAqIGJyaWdodFRpbWVzQ29udHJhc3QgKyBjb250cmFzdE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxBcnJheVtvZmZzZXRdID0gcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsQXJyYXlbb2Zmc2V0ICsgMV0gPSBnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxBcnJheVtvZmZzZXQgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFDYW52YXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBhQ2FudmFzLmNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBib3ggaW4gdGhlIHByZXZpZXcgc2hvd2luZyB3aGVyZSB5b3UgY3VycmVudGx5IGFyZVxuICAgICAgICB2YXIgdXBkYXRlVmlld2JveCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgdG9wIGxlZnQgY29ybmVyIGNvb3JkaW5hdGVzIGJhc2VkIG9uIG91ciBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICB2YXIgY29ybmVyWCA9ICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdCgpICogbWFwLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgdmFyIGNvcm5lclkgPSAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCgpICogbWFwLnNjYWxlRmFjdG9yO1xuXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCA0IHRvIGNvbXBlbnNhdGUgZm9yIHRoZSBib3JkZXJzXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5taW4oTWF0aC5yb3VuZChzZXR0aW5ncy52aWV3cG9ydC5oZWlnaHQgKiBtYXAuc2NhbGVGYWN0b3IpLCBzZXR0aW5ncy5tYXBTaXplKSAtIDQ7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBNYXRoLm1pbihNYXRoLnJvdW5kKHNldHRpbmdzLnZpZXdwb3J0LndpZHRoICogbWFwLnNjYWxlRmFjdG9yKSwgc2V0dGluZ3MubWFwU2l6ZSkgLSA0O1xuXG4gICAgICAgICAgICAkKCcjZGl2YS1tYXAtdmlld2JveCcpLmhlaWdodChoZWlnaHQpLndpZHRoKHdpZHRoKS5jc3Moe3RvcDogY29ybmVyWSwgbGVmdDogY29ybmVyWH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERyYXcgdGhlIHRodW1ibmFpbCBwcmV2aWV3IGluIHRoZSB0b29sYmFyXG4gICAgICAgIHZhciBsb2FkTWFwID0gZnVuY3Rpb24gKGltYWdlKVxuICAgICAgICB7XG4gICAgICAgICAgICBtYXAuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLW1pbmltYXAnKTtcbiAgICAgICAgICAgIG1hcC5zaXplID0gc2V0dGluZ3MubWFwU2l6ZTtcbiAgICAgICAgICAgIG1hcC5jYW52YXMud2lkdGggPSBtYXAuc2l6ZTtcbiAgICAgICAgICAgIG1hcC5jYW52YXMuaGVpZ2h0ID0gbWFwLnNpemU7XG5cbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBibGFjayBiYWNrZ3JvdW5kXG4gICAgICAgICAgICBtYXAuY29udGV4dCA9IG1hcC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgIG1hcC5jb250ZXh0LmZpbGxSZWN0KDAsIDAsIG1hcC5zaXplLCBtYXAuc2l6ZSk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgY29vcmRpbmF0ZXMvZGltZW5zaW9ucyBvZiB0aGUgcHJldmlld1xuICAgICAgICAgICAgbWFwLnNjYWxlRmFjdG9yID0gc2V0dGluZ3MubWFwU2l6ZSAvIGNhbnZhcy5zaXplO1xuICAgICAgICAgICAgbWFwLmNvcm5lclggPSBjYW52YXMuY29ybmVyWCAqIG1hcC5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIG1hcC5jb3JuZXJZID0gY2FudmFzLmNvcm5lclkgKiBtYXAuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBtYXAud2lkdGggPSBpbWFnZS53aWR0aCAqIG1hcC5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIG1hcC5oZWlnaHQgPSBpbWFnZS5oZWlnaHQgKiBtYXAuc2NhbGVGYWN0b3I7XG5cbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGltYWdlIHdpdGhpbiB0aGUgbWFwIChubyBhZGp1c3RtZW50cykgYW5kIHNhdmUgdGhlIHBpeGVsIGFycmF5XG4gICAgICAgICAgICBtYXAuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIG1hcC5jb3JuZXJYLCBtYXAuY29ybmVyWSwgbWFwLndpZHRoLCBtYXAuaGVpZ2h0KTtcbiAgICAgICAgICAgIG1hcC5kYXRhID0gbWFwLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHNldHRpbmdzLm1hcFNpemUsIHNldHRpbmdzLm1hcFNpemUpO1xuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSB2aWV3Ym94LCBtYWtlIGl0IHJlZmxlY3Qgd2hlcmUgd2UgY3VycmVudGx5IGFyZVxuICAgICAgICAgICAgJCgnI2RpdmEtbWFwLXZpZXdib3gnKS5zaG93KCk7XG4gICAgICAgICAgICB1cGRhdGVWaWV3Ym94KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9hZCB0aGUgaW1hZ2Ugd2l0aGluIHRoZSBsYXJnZSBhbmQgc21hbGwgY2FudmFzZXNcbiAgICAgICAgdmFyIGxvYWRDYW52YXMgPSBmdW5jdGlvbiAoaW1hZ2VVUkwsIGNhbGxiYWNrKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuXG4gICAgICAgICAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiB0aGUgKHNxdWFyZSkgY2FudmFzIGJhc2VkIG9uIHRoZSBoeXBvdGVuZXVzZVxuICAgICAgICAgICAgICAgIGNhbnZhcy5zaXplID0gTWF0aC5zcXJ0KGltYWdlLndpZHRoICogaW1hZ2Uud2lkdGggKyBpbWFnZS5oZWlnaHQgKiBpbWFnZS5oZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzaXplIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgY2FudmFzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcycpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jYW52YXMud2lkdGggPSBjYW52YXMuc2l6ZTtcbiAgICAgICAgICAgICAgICBjYW52YXMuY2FudmFzLmhlaWdodCA9IGNhbnZhcy5zaXplO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jb3JuZXJYID0gKGNhbnZhcy5zaXplIC0gaW1hZ2Uud2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBjYW52YXMuY29ybmVyWSA9IChjYW52YXMuc2l6ZSAtIGltYWdlLmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNlbnRlclggPSBjYW52YXMuc2l6ZSAvIDI7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNlbnRlclkgPSBjYW52YXMuc2l6ZSAvIDI7XG5cbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSB0byB0aGUgbGFyZ2UgY2FudmFzLCBhbmQgc2F2ZSB0aGUgcGl4ZWwgYXJyYXlcbiAgICAgICAgICAgICAgICBjYW52YXMuY29udGV4dCA9IGNhbnZhcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMuY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIGNhbnZhcy5jb3JuZXJYLCBjYW52YXMuY29ybmVyWSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0cnlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5kYXRhID0gY2FudmFzLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy5zaXplLCBjYW52YXMuc2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNFcnJvciA9ICc8ZGl2IGlkPVwiZGl2YS1lcnJvclwiIGNsYXNzPVwiZGl2YS1lcnJvclwiPjxwPjxzdHJvbmc+RXJyb3I8L3N0cm9uZz48L3A+PHA+JyArIGVycm9yLm1lc3NhZ2UgKyAnPC9wPic7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzRXJyb3IgKz0gJzxwPllvdSBtYXkgbmVlZCB0byB1cGRhdGUgeW91ciBzZXJ2ZXIgY29uZmlndXJhdGlvbiBpbiBvcmRlciB0byB1c2UgdGhlIGltYWdlIG1hbmlwdWxhdGlvbiB0b29scy4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnRm9yIGhlbHAsIHNlZSB0aGUgPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9ERE1BTC9kaXZhLmpzL3dpa2kvVGhlLUFQSS1hbmQtUGx1Z2lucyNhLW5vdGUtYWJvdXQtJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FudmFzLWFuZC1jcm9zcy1zaXRlLWRhdGFcIiB0YXJnZXQ9XCJfYmxhbmtcIj5jYW52YXMgY3Jvc3Mtc2l0ZSBkYXRhIGRvY3VtZW50YXRpb248L2E+LjwvcD4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYW52YXNFcnJvciArPSAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJhY2tkcm9wJykuYXBwZW5kKGNhbnZhc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZVRocm9iYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gT25seSBsb2FkIHRoZSBtYXAgdGhlIGZpcnN0IHRpbWUgKHdoZW4gdGhlcmUgaXMgbm8gY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZE1hcChpbWFnZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXAgYW5kIHRoZSBjYW52YXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgdXBkYXRlTWFwKCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2FudmFzKGNhbnZhcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBIaWRlIHRoZSB0aHJvYmJlciBpZiBpdCBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaGlkZVRocm9iYmVyKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gZXhpc3RzLCBleGVjdXRlIGl0IChmb3Igem9vbWluZylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGltYWdlLnNyYyA9IGltYWdlVVJMO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGxvYWQgZXZlbnQgZmlyZXMgZm9yIGNhY2hlZCBpbWFnZXMgdG9vXG4gICAgICAgICAgICBpZiAoIGltYWdlLmNvbXBsZXRlIHx8IGltYWdlLmNvbXBsZXRlID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3l3QUFBQUFBUUFCQUFBQ0FVd0FPdz09XCI7XG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gaW1hZ2VVUkw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwZGF0ZVNsaWRlckxhYmVsID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRoaXNTbGlkZXIgPSBzbGlkZXJzW3NsaWRlck1vZGVdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpc1NsaWRlci5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gKHRoaXNTbGlkZXIudHJhbnNmb3JtKSA/IHRoaXNTbGlkZXIudHJhbnNmb3JtKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXZhbHVlJykuaHRtbChzdHJpbmdWYWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHVwZGF0ZVNsaWRlclZhbHVlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXNsaWRlcicpLnZhbChzbGlkZXJzW3NsaWRlck1vZGVdLmN1cnJlbnQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIFVSTCBmb3IgdGhlIGltYWdlIGF0IHRoZSBzcGVjaWZpZWQgem9vbSBsZXZlbFxuICAgICAgICB2YXIgZ2V0SW1hZ2VVUkwgPSBmdW5jdGlvbiAoem9vbUxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzZXR0aW5ncy56b29tV2lkdGhSYXRpbyAqIE1hdGgucG93KDIsIHpvb21MZXZlbCk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5kaXZhSW5zdGFuY2UuZ2V0UGFnZUltYWdlVVJMKHNldHRpbmdzLnNlbGVjdGVkUGFnZUluZGV4LCB7IHdpZHRoOiB3aWR0aCB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2hvd1Rocm9iYmVyID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IHRoZSB0aHJvYmJlciBpZiBpdCB3aWxsIHRha2UgYSBsb25nIHRpbWVcbiAgICAgICAgICAgIGlmIChzbGlkZXJzLnpvb20uY3VycmVudCA+IDAgfHwgc2V0dGluZ3MubW9iaWxlV2Via2l0KVxuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5hZGRDbGFzcygnY2FudmFzLXRocm9iYmVyJykuc2hvdygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhpZGVzIHRoZSBsb2FkaW5nIGluZGljYXRvciBpY29uXG4gICAgICAgIHZhciBoaWRlVGhyb2JiZXIgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3Rocm9iYmVyJykucmVtb3ZlQ2xhc3MoJ2NhbnZhcy10aHJvYmJlcicpLmhpZGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJZiBhbnkgbW9kaWZpY2F0aW9ucyBoYXZlIGJlZW4gYXBwbGllZCwgc2F2ZSB0aGVtIHRvIGxvY2FsU3RvcmFnZVxuICAgICAgICB2YXIgc2F2ZVNldHRpbmdzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNsaWRlclNldHRpbmdzID0ge307XG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5sb2NhbFN0b3JhZ2VQcmVmaXggKyBzZXR0aW5ncy5maWxlbmFtZTtcbiAgICAgICAgICAgIHZhciBzbGlkZXI7XG5cbiAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlcnNbc2xpZGVyXS5wcmV2aW91cyAhPT0gc2xpZGVyc1tzbGlkZXJdLmluaXRpYWwpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJTZXR0aW5nc1tzbGlkZXJdID0gc2xpZGVyc1tzbGlkZXJdLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG1vZGlmaWNhdGlvbnMgbmVlZCB0byBiZSBzYXZlZCwgdXBkYXRlIHRoZSBjYW52YXMgcGx1Z2luIGljb25cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbkljb24uYWRkQ2xhc3MoJ25ldycpO1xuICAgICAgICAgICAgICAgIHN0b3JlT2JqZWN0KHN0b3JhZ2VLZXksIHNsaWRlclNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW5JY29uLnJlbW92ZUNsYXNzKCduZXcnKTtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIYW5kbGVzIHpvb21pbmcgaW4gd2hlbiB0aGUgem9vbSBzbGlkZXIgaXMgY2hhbmdlZCBhbmQgdGhlIGNoYW5nZSBpcyBhcHBsaWVkXG4gICAgICAgIHZhciB1cGRhdGVab29tID0gZnVuY3Rpb24gKG5ld1pvb21MZXZlbCwgY2FsbGJhY2spXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnpvb21MZXZlbCA9IG5ld1pvb21MZXZlbDtcblxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgVVJMIGZvciB0aGUgaW1hZ2UgYXQgdGhpcyBuZXcgem9vbSBsZXZlbFxuICAgICAgICAgICAgdmFyIGltYWdlVVJMID0gZ2V0SW1hZ2VVUkwobmV3Wm9vbUxldmVsKTtcblxuICAgICAgICAgICAgbG9hZENhbnZhcyhpbWFnZVVSTCwgZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIG5ldyBzY2FsZSBmYWN0b3IgYW5kIHVwZGF0ZSB0aGUgdmlld2JveFxuICAgICAgICAgICAgICAgIG1hcC5zY2FsZUZhY3RvciA9IG1hcC5zaXplIC8gY2FudmFzLnNpemU7XG4gICAgICAgICAgICAgICAgdXBkYXRlVmlld2JveCgpO1xuXG4gICAgICAgICAgICAgICAgc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYmluZENhbnZhc0tleUV2ZW50cyA9IGZ1bmN0aW9uIChldmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHVwQXJyb3dLZXkgPSAzOCxcbiAgICAgICAgICAgICAgICBkb3duQXJyb3dLZXkgPSA0MCxcbiAgICAgICAgICAgICAgICBsZWZ0QXJyb3dLZXkgPSAzNyxcbiAgICAgICAgICAgICAgICByaWdodEFycm93S2V5ID0gMzk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjYXNlIHVwQXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwIGFycm93IC0gc2Nyb2xsIHVwXG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wIC0gc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYXNlIGRvd25BcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgLy8gRG93biBhcnJvdyAtIHNjcm9sbCBkb3duXG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wICsgc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYXNlIGxlZnRBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgLy8gTGVmdCBhcnJvdyAtIHNjcm9sbCBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQgLSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNhc2UgcmlnaHRBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmlnaHQgYXJyb3cgLSBzY3JvbGwgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdCArIHNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNlcmlhbGl6ZSBhbiBvYmplY3QgdG8gSlNPTiBhbmQgc2F2ZSBpdCBpbiBsb2NhbFN0b3JhZ2VcbiAgICAgICAgdmFyIHN0b3JlT2JqZWN0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBMb2FkIGFuZCBkZXNlcmlhbGl6ZSBhIGxvY2FsU3RvcmFnZSBvYmplY3RcbiAgICAgICAgdmFyIGxvYWRTdG9yZWRPYmplY3QgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICYmIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZXR2YWwgPVxuICAgICAgICB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjYW52YXMsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAvLyBBbmQsIGRpc2FibGUgdGhpcyBwbHVnaW5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzU3VwcG9ydGVkID0gISF3aW5kb3cuSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFjYW52YXNTdXBwb3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIGFsbCB0aGUgY29uZmlndXJhYmxlIHNldHRpbmdzIGRlZmluZWQgdW5kZXIgY2FudmFzUGx1Z2luXG4gICAgICAgICAgICAgICAgJC5leHRlbmQoc2V0dGluZ3MsIGRlZmF1bHRzLCBkaXZhU2V0dGluZ3MuY2FudmFzUGx1Z2luKTtcblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpdmFJbnN0YW5jZSA9IGRpdmFJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pbkNhbnZhcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmlpcFNlcnZlclVSTCA9IGRpdmFTZXR0aW5ncy5paXBTZXJ2ZXJVUkw7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaW1hZ2VEaXIgPSBkaXZhU2V0dGluZ3MuaW1hZ2VEaXI7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2VsZWN0b3IgPSBkaXZhU2V0dGluZ3Muc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubW9iaWxlV2Via2l0ID0gZGl2YVNldHRpbmdzLm1vYmlsZVdlYmtpdDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudCA9IGRpdmFTZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgc2V0dGluZ3MgZm9yIHRoZSBzbGlkZXJzL2ljb25zXG4gICAgICAgICAgICAgICAgc2xpZGVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbnRyYXN0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHNldHRpbmdzLmNvbnRyYXN0TWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHNldHRpbmdzLmNvbnRyYXN0TWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiBzZXR0aW5ncy5jb250cmFzdFN0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0NoYW5nZSB0aGUgY29udHJhc3QnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdicmlnaHRuZXNzJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHNldHRpbmdzLmJyaWdodG5lc3NNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4Jzogc2V0dGluZ3MuYnJpZ2h0bmVzc01heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogc2V0dGluZ3MuYnJpZ2h0bmVzc1N0ZXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQWRqdXN0IHRoZSBicmlnaHRuZXNzJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAncm90YXRpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiAzNTksXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAndHJhbnNmb3JtJzogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgJyZkZWc7JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnUm90YXRlIHRoZSBpbWFnZSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3pvb20nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0LCBtaW4gYW5kIG1heCB2YWx1ZXMgdXBkYXRlZCB3aXRoaW4gc2V0dXBIb29rXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0FkanVzdCB0aGUgem9vbSBsZXZlbCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3JlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBzZXR0aW5ncy5yZ2JNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4Jzogc2V0dGluZ3MucmdiTWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0FkanVzdCB0aGUgcmVkIGNoYW5uZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdncmVlbic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBzZXR0aW5ncy5yZ2JNaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4Jzogc2V0dGluZ3MucmdiTWF4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0FkanVzdCB0aGUgZ3JlZW4gY2hhbm5lbCdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2JsdWUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc2V0dGluZ3MucmdiTWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHNldHRpbmdzLnJnYk1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdBZGp1c3QgdGhlIGJsdWUgY2hhbm5lbCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBcImRlZmF1bHRcIiB2YWx1ZSBpbnRvIFwidmFsdWVcIiBhbmQgXCJwcmV2aW91c1wiIGZvciBlYWNoIHNsaWRlclxuICAgICAgICAgICAgICAgIHZhciByZXNldFNsaWRlcnMgPSBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRWYWx1ZSwgdGhpc1NsaWRlciwgc2xpZGVyO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzU2xpZGVyID0gc2xpZGVyc1tzbGlkZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdGhpc1NsaWRlci5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1NsaWRlci5jdXJyZW50ID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1NsaWRlci5wcmV2aW91cyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXNldFNsaWRlcnMoKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgRE9NIGVsZW1lbnRzIGlmIHRoZXkgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgIGlmICgkKCcjZGl2YS1jYW52YXMtYmFja2Ryb3AnKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdHJ1ZSB0byBrZWVwIHRoZSBwbHVnaW4gZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzQnV0dG9uc0xpc3QgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uSFRNTCwgYnV0dG9uLCBidXR0b25UaXRsZSwgaTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBzZXR0aW5ncy5idXR0b25zKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gc2V0dGluZ3MuYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uVGl0bGUgPSBzbGlkZXJzW2J1dHRvbl0udGl0bGU7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkhUTUwgPSAnPGRpdiBjbGFzcz1cIicgKyBidXR0b24gKyAnXCIgdGl0bGU9XCInICsgYnV0dG9uVGl0bGUgKyAnXCI+PC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQnV0dG9uc0xpc3QucHVzaChidXR0b25IVE1MKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0J1dHRvbnMgPSBjYW52YXNCdXR0b25zTGlzdC5qb2luKCcnKTtcblxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNUb29scyA9ICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtdG9vbHNcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy10b29sYmFyXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLWNsb3NlXCIgdGl0bGU9XCJSZXR1cm4gdG8gdGhlIGRvY3VtZW50IHZpZXdlclwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy1taW5pbWlzZVwiIHRpdGxlPVwiTWluaW1pc2UgdGhlIHRvb2xiYXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBpZD1cImRpdmEtY2FudmFzLWluZm9cIj5UZXN0PC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtdG9vbHdpbmRvd1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLW1hcC12aWV3Ym94XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGNhbnZhcyBpZD1cImRpdmEtY2FudmFzLW1pbmltYXBcIj48L2NhbnZhcz4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtYnV0dG9uc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0J1dHRvbnMgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy1wYW5lXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxwIGlkPVwiZGl2YS1jYW52YXMtdG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gaWQ9XCJkaXZhLWNhbnZhcy1tb2RlXCI+Y29udHJhc3Q8L3NwYW4+OiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGlkPVwiZGl2YS1jYW52YXMtdmFsdWVcIj4wPC9zcGFuPiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGlkPVwiZGl2YS1jYW52YXMtcmVzZXRcIiBjbGFzcz1cImxpbmtcIj4oUmVzZXQpPC9zcGFuPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVwicmFuZ2VcIiBpZD1cImRpdmEtY2FudmFzLXNsaWRlclwiPjwvaW5wdXQ+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGJyIC8+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFjdGlvbi1idXR0b25zXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgaWQ9XCJkaXZhLWNhbnZhcy1yZXNldC1hbGxcIj5SZXNldCBhbGw8L2E+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxhIGhyZWY9XCIjXCIgaWQ9XCJkaXZhLWNhbnZhcy1hcHBseVwiPkFwcGx5PC9hPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1dyYXBwZXIgPSAnPGRpdiBpZD1cImRpdmEtY2FudmFzLXdyYXBwZXJcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxjYW52YXMgaWQ9XCJkaXZhLWNhbnZhc1wiPjwvY2FudmFzPicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXNTdHJpbmcgPSAnPGRpdiBpZD1cImRpdmEtY2FudmFzLWJhY2tkcm9wXCI+JyArXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1Rvb2xzICtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzV3JhcHBlciArXG4gICAgICAgICAgICAgICAgJzwvZGl2Pic7XG5cbiAgICAgICAgICAgICAgICAkKCdib2R5JykuYXBwZW5kKGNhbnZhc1N0cmluZyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBzaXplIG9mIHRoZSBtYXAsIGFzIGRlZmluZWQgaW4gdGhlIENTU1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1hcFNpemUgPSAkKCcjZGl2YS1jYW52YXMtbWluaW1hcCcpLndpZHRoKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHNsaWRlciB3aGVuIHNvbWV0aGluZyBpcyBjbGlja2VkLCBhbmQgbWFrZSB0aGF0IHRoZSBjdXJyZW50IG1vZGVcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYnV0dG9ucyBkaXYnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJ1dHRvbnMgLmNsaWNrZWQnKS5yZW1vdmVDbGFzcygnY2xpY2tlZCcpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoJCh0aGlzKS5hdHRyKCdjbGFzcycpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTbGlkZXIgPSBmdW5jdGlvbiAobmV3TW9kZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlck1vZGUgPSBuZXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyRGF0YSA9IHNsaWRlcnNbc2xpZGVyTW9kZV07XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJ1dHRvbnMgLicgKyBzbGlkZXJNb2RlKS5hZGRDbGFzcygnY2xpY2tlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1tb2RlJykudGV4dChzbGlkZXJNb2RlKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBzbGlkZXJEYXRhLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZVN0cmluZyA9IChzbGlkZXJEYXRhLnRyYW5zZm9ybSkgPyBzbGlkZXJEYXRhLnRyYW5zZm9ybShuZXdWYWx1ZSkgOiBuZXdWYWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLXNsaWRlcicpO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXIubWluID0gc2xpZGVyRGF0YS5taW47XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci5tYXggPSBzbGlkZXJEYXRhLm1heDtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyLnN0ZXAgPSBzbGlkZXJEYXRhLnN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1zbGlkZXInKS52YWwobmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtdmFsdWUnKS5odG1sKG5ld1ZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyKCdjb250cmFzdCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBzbGlkZXJcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtc2xpZGVyJykub24oJ2lucHV0JywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbc2xpZGVyTW9kZV0uY3VycmVudCA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU1hcCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYWxsIHRoZSBzbGlkZXJzIHRvIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXJlc2V0LWFsbCcpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpZGVyO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlcnMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbc2xpZGVyXS5jdXJyZW50ID0gc2xpZGVyc1tzbGlkZXJdLmluaXRpYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBsYWJlbFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJWYWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJldmlld1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVNYXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjdXJyZW50IHNsaWRlciB0byB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1yZXNldCcpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHRoZSBzbGlkZXJcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyc1tzbGlkZXJNb2RlXS5jdXJyZW50ID0gc2xpZGVyc1tzbGlkZXJNb2RlXS5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJWYWx1ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJldmlld1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVNYXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFyZ2UgY2FudmFzIHdoZW4gdGhlIGFwcGx5IGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWFwcGx5JykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRBZGp1c3RMZXZlbHMoKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rocm9iYmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVycy56b29tLmN1cnJlbnQgIT09IHNsaWRlcnMuem9vbS5wcmV2aW91cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVpvb20oc2xpZGVycy56b29tLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZVRocm9iYmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBtb2RpZmljYXRpb25zIHRvIGxvY2FsU2V0dGluZ3MgKGFsc28gZG9uZSBpbiB1cGRhdGVab29tIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXR0aW5ncy50aHJvYmJlclRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZXhpdGluZyBjYW52YXMgbW9kZVxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1jbG9zZScpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKCdib2R5JykucmVtb3ZlQ2xhc3MoJ292ZXJmbG93LWhpZGRlbicpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXNlcyBhbmQgaGlkZSB0aGluZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBpbXByb3ZlZCAtIG5vdCBkb25lIHByb3Blcmx5P1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLnNpemUsIGNhbnZhcy5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIG1hcC5zaXplLCBtYXAuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKDApLnNjcm9sbExlZnQoMCk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1iYWNrZHJvcCcpLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtbWFwLXZpZXdib3gnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLWVuYWJsZSBzY3JvbGxpbmcgb2YgZGl2YSB3aGVuIGl0IGlzIGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5ZG93bicsIGJpbmRDYW52YXNLZXlFdmVudHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRTbGlkZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlclZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1idXR0b25zIC5jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2NsaWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyKCdjb250cmFzdCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2goXCJDYW52YXNWaWV3RGlkSGlkZVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2xiYXIgd2hlbiB0aGUgbWluaW1pc2UgaWNvbiBpcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLW1pbmltaXNlJykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy10b29sd2luZG93Jykuc2xpZGVUb2dnbGUoJ2Zhc3QnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkanVzdCB0aGUgc2l6ZSBvZiB0aGUgY2FudmFzIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy52aWV3cG9ydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gZGl2YVNldHRpbmdzLnNjcm9sbGJhcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoIC0gZGl2YVNldHRpbmdzLnNjcm9sbGJhcldpZHRoXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSB0aGUgc2V0dGluZ3MgYnV0IG9ubHkgcmVkcmF3IGlmIGluIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5DYW52YXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3Ym94KCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZpZXdib3ggd2hlbiB0aGUgbGFyZ2UgY2FudmFzIGlzIHNjcm9sbGVkXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGwoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkNhbnZhcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdib3goKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBjbGlja2luZy9kcmFnZ2luZyBvZiB0aGUgdmlld2JveCAoc2hvdWxkIHNjcm9sbCB0aGUgbGFyZ2UgY2FudmFzKVxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1taW5pbWFwLCAjZGl2YS1tYXAtdmlld2JveCcpLm1vdXNldXAoZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgY2FjaGluZyB0aGlzIGV2ZW50dWFsbHkgKGNhbid0IGJlIGRvbmUgaW4gaW5pdCB0aG91Z2gpXG4gICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAkKCcjZGl2YS1jYW52YXMtbWluaW1hcCcpLm9mZnNldCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZWRYID0gKGV2ZW50LnBhZ2VYIC0gb2Zmc2V0LmxlZnQpIC8gbWFwLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVkWSA9IChldmVudC5wYWdlWSAtIG9mZnNldC50b3ApIC8gbWFwLnNjYWxlRmFjdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKHNjYWxlZFkgLSBzZXR0aW5ncy52aWV3cG9ydC5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0KHNjYWxlZFggLSBzZXR0aW5ncy52aWV3cG9ydC53aWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gRW5hYmxlIGRyYWcgc2Nyb2xsXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzJykubW91c2Vkb3duKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmFkZENsYXNzKCdncmFiYmluZycpO1xuICAgICAgICAgICAgICAgIH0pLm1vdXNldXAoZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2dyYWJiaW5nJyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyB0b3VjaCBldmVudHNcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLmtpbmV0aWMoKTtcblxuICAgICAgICAgICAgICAgIC8vIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuZHJhZ3Njcm9sbGFibGUoe1xuICAgICAgICAgICAgICAgICAgICBhY2NlcHRQcm9wYWdhdGVkRXZlbnQ6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnT2JqZWN0RGlkTG9hZCcsIHRoaXMuc2V0dXBIb29rLCBkaXZhU2V0dGluZ3MuSUQpO1xuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgdGhpcy5kZXN0cm95LCBkaXZhU2V0dGluZ3MuSUQpO1xuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnUGFnZURpZExvYWQnLCB0aGlzLm9uUGFnZUxvYWQsIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdjYW52YXMnLFxuXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdWaWV3IHRoZSBpbWFnZSBvbiBhIGNhbnZhcyBhbmQgYWRqdXN0IHZhcmlvdXMgc2V0dGluZ3MnLFxuXG4gICAgICAgICAgICBzZXR1cEhvb2s6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy52aWV3cG9ydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBkaXZhU2V0dGluZ3Muc2Nyb2xsYmFyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBtaW4gYW5kIG1heCB6b29tIGxldmVsLCBhbmQgdXBkYXRlIHRoZSB6b29tIHNsaWRlclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1pblpvb21MZXZlbCA9IGRpdmFTZXR0aW5ncy5taW5ab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MubWF4Wm9vbUxldmVsID0gZGl2YVNldHRpbmdzLm1heFpvb21MZXZlbDtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG9uIHRoZSBpUGFkLCBsaW1pdCB0aGUgbWF4IHpvb20gbGV2ZWwgdG8gMlxuICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGNhbnZhcyBlbGVtZW50cyB0aGF0IGFyZSA+IDUgbWVnYXBpeGVscyAoaXNzdWUgIzExMilcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubW9iaWxlV2Via2l0KVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYXhab29tTGV2ZWwgPSBNYXRoLm1pbihzZXR0aW5ncy5tYXhab29tTGV2ZWwsIHNldHRpbmdzLm1vYmlsZVdlYmtpdE1heFpvb20pO1xuXG4gICAgICAgICAgICAgICAgc2xpZGVycy56b29tLm1pbiA9IHNldHRpbmdzLm1pblpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICBzbGlkZXJzLnpvb20ubWF4ID0gc2V0dGluZ3MubWF4Wm9vbUxldmVsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSwgc2VsZWN0ZWRQYWdlSW5kZXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gbG9hZENhbnZhcygpIGNhbGxzIGFsbCB0aGUgb3RoZXIgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byBsb2FkXG4gICAgICAgICAgICAgICAgdmFyIGZpbGVuYW1lID0gZGl2YUluc3RhbmNlLmdldEZpbGVuYW1lcygpW3NlbGVjdGVkUGFnZUluZGV4XTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgcmF0aW9uYWxlIGZvciAtMSBmcm9tIFdpa2kgKFRMRFIgYW4gb2xkIElJUCBidWcpXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGl2YUluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIC5nZXRQYWdlRGltZW5zaW9ucyhzZWxlY3RlZFBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLndpZHRoIC0gMTtcblxuICAgICAgICAgICAgICAgIHZhciB6b29tTGV2ZWwgPSBkaXZhU2V0dGluZ3Muem9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHZhciBzbGlkZXI7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy56b29tV2lkdGhSYXRpbyA9IHdpZHRoIC8gTWF0aC5wb3coMiwgem9vbUxldmVsKTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW5JY29uID0gJCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1hbmlmZXN0ID0gZGl2YVNldHRpbmdzLm1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnNlbGVjdGVkUGFnZUluZGV4ID0gc2VsZWN0ZWRQYWdlSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBMaW1pdCB0aGUgbWF4IHpvb20gbGV2ZWwgaWYgd2UncmUgb24gdGhlIGlQYWRcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubW9iaWxlV2Via2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IE1hdGgubWluKHNldHRpbmdzLm1heFpvb21MZXZlbCwgem9vbUxldmVsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICAgICAgICAgIHNsaWRlcnMuem9vbS5pbml0aWFsID0gem9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHNsaWRlcnMuem9vbS5jdXJyZW50ID0gem9vbUxldmVsO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc2V0dGluZ3Mgc3RvcmVkIGluIGxvY2FsU3RvcmFnZSwgaWYgdGhleSBleGlzdFxuICAgICAgICAgICAgICAgIHZhciBzbGlkZXJTZXR0aW5ncyA9IGxvYWRTdG9yZWRPYmplY3Qoc2V0dGluZ3MubG9jYWxTdG9yYWdlUHJlZml4ICsgc2V0dGluZ3MuZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZXJTZXR0aW5ncylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlclNldHRpbmdzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXJzW3NsaWRlcl0uY3VycmVudCA9IHNsaWRlclNldHRpbmdzW3NsaWRlcl07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IHNsaWRlcidzIHZhbHVlIGhhcyBjaGFuZ2VkLCB1cGRhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbGlkZXIgPT09IHNsaWRlck1vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVyID09PSAnem9vbScpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsID0gc2xpZGVyU2V0dGluZ3Nbc2xpZGVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNsaWRlcnMuem9vbS5wcmV2aW91cyA9IHpvb21MZXZlbDtcblxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsIGluIGJvZHksIGFuZCBzaG93IHRoZSBjYW52YXMgYmFja2Ryb3BcbiAgICAgICAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ292ZXJmbG93LWhpZGRlbicpO1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1iYWNrZHJvcCcpLnNob3coKTtcblxuICAgICAgICAgICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIG1haW4gZGl2YSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBjYW52YXMgc2Nyb2xsaW5nXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkua2V5ZG93bihiaW5kQ2FudmFzS2V5RXZlbnRzKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0aGlzIHRvIHRydWUgc28gZXZlbnRzIGNhbiBiZSBjYXB0dXJlZFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmluQ2FudmFzID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZVVSTCA9IGdldEltYWdlVVJMKHpvb21MZXZlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgdGhlIHRpdGxlIG9mIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFRoaXMgaXMgbGVnYWN5IGJlaGF2aW91ci4gU2hvdWxkIHRoaXMgYmUgYSBmaWxlbmFtZS9sYWJlbD9cbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtaW5mbycpLnRleHQoJ1BhZ2UgJyArIChzZWxlY3RlZFBhZ2VJbmRleCArIDEpKTtcblxuICAgICAgICAgICAgICAgIHNob3dUaHJvYmJlcigpO1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaCgnQ2FudmFzVmlld0RpZEFjdGl2YXRlJywgW3NlbGVjdGVkUGFnZUluZGV4XSk7XG5cbiAgICAgICAgICAgICAgICBsb2FkQ2FudmFzKGltYWdlVVJMKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uUGFnZUxvYWQ6IGZ1bmN0aW9uKHBhZ2VJbmRleCwgZmlsZW5hbWUsIHNlbGVjdG9yKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyBleGlzdHMgZm9yIHRoaXMgcGFnZSBpbiBsb2NhbFN0b3JhZ2UsIHRoZW4gY2hhbmdlIGljb24gY29sb3JcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZUtleSA9IHNldHRpbmdzLmxvY2FsU3RvcmFnZVByZWZpeCArIGZpbGVuYW1lO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJChzZWxlY3RvcikuZmluZCgnLmRpdmEtY2FudmFzLWljb24nKS5hZGRDbGFzcygnbmV3Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJhY2tkcm9wJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdGhpcyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGFsbCBvZiB0aGUgbmVjZXNzYXJ5IGhvb2tzIGFuZCBjYWxsYmFja3NcbiAgICAgICAgLy8gZW1iZWRkZWQuXG4gICAgICAgIHJldHVybiByZXR2YWw7XG5cbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BsdWdpbnMvY2FudmFzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuRG93bmxvYWQgcGx1Z2luIGZvciBkaXZhLmpzXG5BbGxvd3MgeW91IHRvIGRvd25sb2FkIGltYWdlcyBzZXJ2ZWQgYnkgSUlQSW1hZ2Ugb3IgSUlJRiBjb21wYXRpYmxlIGltYWdlIHNlcnZlcnNcbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGl2YUluc3RhbmNlID0gZGl2YUluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdEb3dubG9hZCBpbWFnZSBhdCB0aGUgZ2l2ZW4gem9vbSBsZXZlbCcsXG4gICAgICAgICAgICBoYW5kbGVDbGljazogZnVuY3Rpb24oZXZlbnQsIGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlLCBwYWdlSW5kZXgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSByYXRpb25hbGUgZm9yIC0xIGZyb20gV2lraSAoVExEUiBhbiBvbGQgSUlQIGJ1ZylcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSBkaXZhSW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAud2lkdGggLSAxO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gc2V0dGluZ3MuZGl2YUluc3RhbmNlLmdldFBhZ2VJbWFnZVVSTChwYWdlSW5kZXgsIHsgd2lkdGg6IHdpZHRoIH0pO1xuXG4gICAgICAgICAgICAgICAgd2luZG93Lm9wZW4oaW1hZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2Rvd25sb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuSGlnaGxpZ2h0IHBsdWdpbiBmb3IgZGl2YS5qc1xuQWxsb3dzIHlvdSB0byBoaWdobGlnaHQgcmVnaW9ucyBvZiBhIHBhZ2UgaW1hZ2VcbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBlbHQgPSByZXF1aXJlKCcuLi91dGlscy9lbHQnKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi4vZGl2YScpO1xuXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHRNYW5hZ2VyID0gbmV3IEhpZ2hsaWdodE1hbmFnZXIoZGl2YUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LmRhdGEoJ2hpZ2hsaWdodE1hbmFnZXInLCBoaWdobGlnaHRNYW5hZ2VyKTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50SGlnaGxpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgUmVzZXQgdGhlIGhpZ2hsaWdodHMgb2JqZWN0IGFuZCByZW1vdmVzIGFsbCBoaWdobGlnaHRzIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnJlc2V0SGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgUmVzZXRzIHRoZSBoaWdobGlnaHRzIGZvciBhIHNpbmdsZSBwYWdlLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnJlbW92ZUhpZ2hsaWdodHNPblBhZ2UgPSBmdW5jdGlvbihwYWdlSWR4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5yZW1vdmVIaWdobGlnaHRzT25QYWdlKHBhZ2VJZHgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBIaWdobGlnaHRzIHJlZ2lvbnMgb24gbXVsdGlwbGUgcGFnZXMuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBwYWdlSWR4cyBBbiBhcnJheSBvZiBwYWdlIGluZGV4IG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHJlZ2lvbnMgIEFuIGFycmF5IG9mIHJlZ2lvbnNcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGNvbG91ciAgIChvcHRpb25hbCkgQSBjb2xvdXIgZm9yIHRoZSBoaWdobGlnaHRpbmcsIHNwZWNpZmllZCBpbiBSR0JBIENTUyBmb3JtYXRcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2VzID0gZnVuY3Rpb24ocGFnZUlkeHMsIHJlZ2lvbnMsIGNvbG91ciwgZGl2Q2xhc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaiA9IHBhZ2VJZHhzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGotLSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZShwYWdlSWR4c1tqXSwgcmVnaW9uc1tqXSwgY29sb3VyLCBkaXZDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0cyByZWdpb25zIG9uIGEgcGFnZS5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHBhZ2VJZHggIEEgcGFnZSBpbmRleCBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHJlZ2lvbnMgIEFuIGFycmF5IG9mIHJlZ2lvbnMuIFVzZSB7J3dpZHRoJzppLCAnaGVpZ2h0JzppLCAndWx4JzppLCAndWx5JzogaSwgJ2RpdklEJzogc3RyfSBmb3IgZWFjaCByZWdpb24uXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBjb2xvdXIgICAob3B0aW9uYWwpIEEgY29sb3VyIGZvciB0aGUgaGlnaGxpZ2h0aW5nLCBzcGVjaWZpZWQgaW4gUkdCQSBDU1MgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBkaXZDbGFzcyAob3B0aW9uYWwpIEEgY2xhc3MgdG8gaWRlbnRpZnkgYSBncm91cCBvZiBoaWdobGlnaHRlZCByZWdpb25zIG9uIGEgc3BlY2lmaWMgcGFnZSBieVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZSA9IGZ1bmN0aW9uKHBhZ2VJZHgsIHJlZ2lvbnMsIGNvbG91ciwgZGl2Q2xhc3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb3VyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91ciA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4yKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2Q2xhc3MgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Q2xhc3MgPSBkaXZhU2V0dGluZ3MuSUQgKyAnaGlnaGxpZ2h0IGRpdmEtaGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzID0gZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCBkaXZhLWhpZ2hsaWdodCAnICsgZGl2Q2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLmFkZEhpZ2hsaWdodCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlSWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaW9uczogcmVnaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG91cjogY29sb3VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Q2xhc3M6IGRpdkNsYXNzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBKdW1wcyB0byBhIGhpZ2hsaWdodCBzb21ld2hlcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gZGl2SUQgVGhlIElEIG9mIHRoZSBkaXYgdG8ganVtcCB0by4gVGhpcyBJRCBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBkaXYgdXNpbmcgLmhpZ2hsaWdodE9uUGFnZShzKSBhcyB0aGUgaGlnaGxpZ2h0IG1heSBub3QgYmUgY3VycmVudGx5IGFwcGVuZGVkIHRvIHRoZSBET00uXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b0hpZ2hsaWdodCA9IGZ1bmN0aW9uKGRpdklEKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0QnlSZWdpb25JZChkaXZJRCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnb3RvRGl2KHJlc3VsdC5oaWdobGlnaHQucGFnZSwgcmVzdWx0LnJlZ2lvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRGl2YSBqdXN0IHRyaWVkIHRvIGZpbmQgYSBoaWdobGlnaHQgdGhhdCBkb2Vzbid0IGV4aXN0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAqIE1vdmVzIHRoZSBkaXZhIHBhbmUgdG8gKHBhZ2UpIGFuZCBtYWtlcyBhIGRhcmtlciBib3JkZXIgb24gKHRoaXNEaXYpXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgZ290b0RpdiA9IGZ1bmN0aW9uKHBhZ2UsIHRoaXNEaXYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvL2dldHMgY2VudGVyIG9mIHRoZSBkaXZcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlcllPZkRpdiA9IHBhcnNlRmxvYXQodGhpc0Rpdi51bHkpICsgcGFyc2VGbG9hdCh0aGlzRGl2LmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyWE9mRGl2ID0gcGFyc2VGbG9hdCh0aGlzRGl2LnVseCkgKyBwYXJzZUZsb2F0KHRoaXNEaXYud2lkdGgpIC8gMjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzaXJlZFkgPSBkaXZhSW5zdGFuY2UudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbChjZW50ZXJZT2ZEaXYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzaXJlZFggPSBkaXZhSW5zdGFuY2UudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbChjZW50ZXJYT2ZEaXYpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbmF2aWdhdGVzIHRvIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBwYXJzZUludChwYWdlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nb3RvUGFnZUJ5SW5kZXgocGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydE9iamVjdCA9IGRpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpLnZpZXdwb3J0T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRvcCA9IHZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcCgpICsgZGVzaXJlZFkgLSAodmlld3BvcnRPYmplY3QuaGVpZ2h0KCkgLyAyKSArIGRpdmFTZXR0aW5ncy52ZXJ0aWNhbFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGVmdCA9IHZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoKSArIGRlc2lyZWRYIC0gKHZpZXdwb3J0T2JqZWN0LndpZHRoKCkgLyAyKSArIGRpdmFTZXR0aW5ncy5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZXMgdGhlIHNjcm9sbCBsb2NhdGlvbiB0byBjZW50ZXIgb24gdGhlIGRpdiBhcyBtdWNoIGFzIGlzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcChjdXJyZW50VG9wKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRPYmplY3Quc2Nyb2xsTGVmdChjdXJyZW50TGVmdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhpZ2hsaWdodCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogdGhpc0RpdixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKFwiU2VsZWN0ZWRIaWdobGlnaHRDaGFuZ2VkXCIsIFt0aGlzRGl2LmlkLCBjdXJyZW50SGlnaGxpZ2h0LnBhZ2VdKTtcblxuICAgICAgICAgICAgICAgICAgICAvL3NlbGVjdHMgdGhlIGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50SGlnaGxpZ2h0KGRpdmFJbnN0YW5jZSwgY3VycmVudEhpZ2hsaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzRGl2LmlkO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0RGl2Q2VudGVyID0gZnVuY3Rpb24odGhpc0RpdilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKSByZXR1cm4gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwocGFyc2VGbG9hdCh0aGlzRGl2LnVseSkgKyBwYXJzZUZsb2F0KHRoaXNEaXYuaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBkaXZhSW5zdGFuY2UudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbChwYXJzZUZsb2F0KHRoaXNEaXYudWx4KSArIHBhcnNlRmxvYXQodGhpc0Rpdi53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSnVtcHMgdG8gdGhlIG5leHQgaGlnaGxpZ2h0IGFsb25nIHRoZSBwcmltYXJ5IGF4aXMgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGZpbmRBZGphY2VudEhpZ2hsaWdodCA9IGZ1bmN0aW9uKGZvcndhcmQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyT2ZUYXJnZXREaXY7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyT2ZDdXJyZW50RGl2O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFBhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdpb25BcnIsIGFyckluZGV4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZURpbXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJPZkRpdiwgdGFyZ2V0RGl2O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlzRGl2O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcEZ1bmN0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGN1cnJlbnRIaWdobGlnaHQgZG9lcyBub3QgYWxyZWFkeSBleGlzdHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcHJldGVuZCB3ZSdyZSBzdGFydGluZyBhdCB0aGUgbm9ydGh3ZXN0IGNvcm5lciBvZiBkaXZhLWlubmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudEhpZ2hsaWdodClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZDdXJyZW50RGl2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlID0gY3VycmVudEhpZ2hsaWdodC5wYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIGNlbnRlciBvZiB0aGUgY3VycmVudCBkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mQ3VycmVudERpdiA9IGdldERpdkNlbnRlcihjdXJyZW50SGlnaGxpZ2h0LnJlZ2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIHdlIGRvIGhhdmUgYSBjdXJyZW50IGhpZ2hsaWdodCwgdHJ5IHRvIGZpbmQgdGhlIG5leHQgb25lIGluIHRoZSBzYW1lIHBhZ2VcblxuICAgICAgICAgICAgICAgICAgICByZWdpb25BcnIgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodFJlZ2lvbnMoY3VycmVudFBhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBhcnJJbmRleCA9IHJlZ2lvbkFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VEaW1zID0gZGl2YUluc3RhbmNlLmdldFBhZ2VEaW1lbnNpb25zQXRab29tTGV2ZWwoY3VycmVudFBhZ2UsIGRpdmFJbnN0YW5jZS5nZXRab29tTGV2ZWwoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pbml0aWFsaXplIHRoZSBjZW50ZXIgb2YgdGhlIGRpdiB0byB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBpZihmb3J3YXJkKSBjZW50ZXJPZlRhcmdldERpdiA9IChkaXZhU2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKSA/IHBhZ2VEaW1zLmhlaWdodCA6IHBhZ2VEaW1zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGNlbnRlck9mVGFyZ2V0RGl2ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBpZihmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wRnVuY3Rpb24gPSBmdW5jdGlvbih0aGlzQywgY3VyQywgdGFyZ2V0QylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNDID4gY3VyQyAmJiB0aGlzQyA8IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBGdW5jdGlvbiA9IGZ1bmN0aW9uKHRoaXNDLCBjdXJDLCB0YXJnZXRDKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpc0MgPCBjdXJDICYmIHRoaXNDID4gdGFyZ2V0Qyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoYXJySW5kZXgtLSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0RpdiA9IHJlZ2lvbkFyclthcnJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZkRpdiA9IGdldERpdkNlbnRlcih0aGlzRGl2KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiB0aGlzIGRpdiBpcyBmYXJ0aGVyIGFsb25nIHRoZSBtYWluIGF4aXMgYnV0IGNsb3NlciB0aGFuIHRoZSBjdXJyZW50IGNsb3Nlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21wRnVuY3Rpb24oY2VudGVyT2ZEaXYsIGNlbnRlck9mQ3VycmVudERpdiwgY2VudGVyT2ZUYXJnZXREaXYpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIHRhcmdldERpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZlRhcmdldERpdiA9IGNlbnRlck9mRGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERpdiA9IHRoaXNEaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIGEgaGlnaGxpZ2h0IHdhcyBmb3VuZCBvbiB0aGUgY3VycmVudCBwYWdlIHRoYXQgd2FzIG5leHQ7IHRoaXMgY2FuIGdldCBvdmVyd3JpdHRlbiBidXQgd2UncmUgc3RpbGwgZ29vZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0Rm91bmQpIHJldHVybiBnb3RvRGl2KGN1cnJlbnRQYWdlLCB0YXJnZXREaXYpO1xuICAgICAgICAgICAgICAgICAgICAvL2lmIGl0IHdhc24ndCBmb3VuZCwgY29udGludWUgb24uLi5cblxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIG1pbmltdW0gZGl2IG9uIHRoZSBuZXh0IHBhZ2Ugd2l0aCBoaWdobGlnaHRzIGFuZCBsb29wIGFyb3VuZCBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgICAgICAgICAvL2ZpbmQgdGhlIG5leHQgcGFnZSBpbiB0aGUgcGFnZUFycjsgdGhpcyB3aWxsIGJlIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWdlQXJyID0gaGlnaGxpZ2h0TWFuYWdlci5nZXRIaWdobGlnaHRlZFBhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJJZHggPSBwYWdlQXJyLmluZGV4T2YoY3VycmVudFBhZ2UudG9TdHJpbmcoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldFBhZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCF0YXJnZXRQYWdlIHx8ICFkaXZhSW5zdGFuY2UuaXNQYWdlSW5kZXhWYWxpZCAodGFyZ2V0UGFnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZWZhdWx0IHRvIGZpcnN0IHBhZ2UsIG1vdmUgdG8gbmV4dCBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJJZHggPT0gcGFnZUFyci5sZW5ndGggLSAxKSB0YXJnZXRQYWdlID0gcGFnZUFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRhcmdldFBhZ2UgPSBwYWdlQXJyWysrY3VySWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCF0YXJnZXRQYWdlIHx8ICFkaXZhSW5zdGFuY2UuaXNQYWdlSW5kZXhWYWxpZCAodGFyZ2V0UGFnZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9kZWZhdWx0IHRvIGxhc3QgcGFnZSwgbW92ZSB0byBwcmV2aW91cyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJJZHggPT09IDApIHRhcmdldFBhZ2UgPSBwYWdlQXJyW3BhZ2VBcnIubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0YXJnZXRQYWdlID0gcGFnZUFyclstLWN1cklkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3Jlc2V0IHJlZ2lvbkFyciBhbmQgY2VudGVyT2ZUYXJnZXREaXYgZm9yIHRoZSBuZXcgcGFnZSB3ZSdyZSB0ZXN0aW5nXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbkFyciA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0UmVnaW9ucyh0YXJnZXRQYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJySW5kZXggPSByZWdpb25BcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYWdlRGltcyA9IGRpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsKHRhcmdldFBhZ2UsIGRpdmFJbnN0YW5jZS5nZXRNYXhab29tTGV2ZWwoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZCkgY2VudGVyT2ZUYXJnZXREaXYgPSAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgPyBwYWdlRGltcy5oZWlnaHQgOiBwYWdlRGltcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjZW50ZXJPZlRhcmdldERpdiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBtaW5pbXVtIHRoaXMgdGltZVxuICAgICAgICAgICAgICAgICAgICBpZihmb3J3YXJkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wRnVuY3Rpb24gPSBmdW5jdGlvbih0aGlzQywgdGFyZ2V0QylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNDIDwgdGFyZ2V0Qyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcEZ1bmN0aW9uID0gZnVuY3Rpb24odGhpc0MsIHRhcmdldEMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzQyA+IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGFyckluZGV4LS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEaXYgPSByZWdpb25BcnJbYXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZEaXYgPSBnZXREaXZDZW50ZXIodGhpc0Rpdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcEZ1bmN0aW9uKGNlbnRlck9mRGl2LCBjZW50ZXJPZlRhcmdldERpdikpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mVGFyZ2V0RGl2ID0gY2VudGVyT2ZEaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RGl2ID0gdGhpc0RpdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vd2UndmUgZm91bmQgaXQgdGhpcyB0aW1lLCBhcyB0aGVyZSdsbCBiZSBhIHJlZ2lvbiBpbiB0aGUgZnVsbCByZWdpb25BcnIgdG8gYmUgdGhlIG1pbmltdW1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdvdG9EaXYodGFyZ2V0UGFnZSwgdGFyZ2V0RGl2KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSnVtcHMgdG8gdGhlIG5leHQgaGlnaGxpZ2h0IGFsb25nIHRoZSBwcmltYXJ5IGF4aXMgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9OZXh0SGlnaGxpZ2h0ID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0Q291bnQoKSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZEFkamFjZW50SGlnaGxpZ2h0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIHRoZSBwcmV2aW91cyBoaWdobGlnaHQgYWxvbmcgdGhlIHByaW1hcnkgYXhpcyBvZiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b1ByZXZpb3VzSGlnaGxpZ2h0ID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0Q291bnQoKSA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmluZEFkamFjZW50SGlnaGxpZ2h0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlcldpbGxUZXJtaW5hdGUnLCB0aGlzLmRlc3Ryb3ksIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZGl2YVNldHRpbmdzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHRNYW5hZ2VyID0gZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5kYXRhKCdoaWdobGlnaHRNYW5hZ2VyJyk7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5jbGVhcigpO1xuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QucmVtb3ZlRGF0YSgnaGlnaGxpZ2h0TWFuYWdlcicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdoaWdobGlnaHQnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnSGlnaGxpZ2h0IHJlZ2lvbnMgb2YgcGFnZXMnLFxuXG4gICAgICAgICAgICAvLyBFeHBvc2VkIGV4cG9ydFxuICAgICAgICAgICAgSGlnaGxpZ2h0TWFuYWdlcjogSGlnaGxpZ2h0TWFuYWdlclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG4vKiogTWFuYWdlcyB0aGUgYWRkaXRpb24gYW5kIHJlbW92YWwgb2YgdGhlIHBhZ2Ugb3ZlcmxheXMgd2hpY2ggZGlzcGxheSB0aGUgaGlnaGxpZ2h0cyAqL1xuZnVuY3Rpb24gSGlnaGxpZ2h0TWFuYWdlcihkaXZhSW5zdGFuY2UsIGdldEN1cnJlbnRIaWdobGlnaHQpXG57XG4gICAgdGhpcy5fZGl2YUluc3RhbmNlID0gZGl2YUluc3RhbmNlO1xuICAgIHRoaXMuX292ZXJsYXlzID0ge307XG4gICAgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCA9IGdldEN1cnJlbnRIaWdobGlnaHQ7XG59XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLmdldEhpZ2hsaWdodENvdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX292ZXJsYXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBjb3VudCArPSB0aGlzLl9vdmVybGF5c1trZXldLmhpZ2hsaWdodC5yZWdpb25zLmxlbmd0aDtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiBjb3VudDtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLmdldEhpZ2hsaWdodFJlZ2lvbnMgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIGlmICghdGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XSlcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlzW3BhZ2VJbmRleF0uaGlnaGxpZ2h0LnJlZ2lvbnM7XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRlZFBhZ2VzID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBGSVhNRTogQ29uY2VwdHVhbGx5IGF3a3dhcmQgdGhhdCB0aGVzZSBhcmUgc3RyaW5nc1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vdmVybGF5cyk7XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRCeVJlZ2lvbklkID0gZnVuY3Rpb24gKGlkKVxue1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fb3ZlcmxheXMpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlzLmhhc093blByb3BlcnR5KGkpKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIHJlZ2lvbnMgPSB0aGlzLl9vdmVybGF5c1tpXS5oaWdobGlnaHQucmVnaW9ucztcbiAgICAgICAgZm9yICh2YXIgaiBpbiByZWdpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXJlZ2lvbnMuaGFzT3duUHJvcGVydHkoaikpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGlmIChyZWdpb25zW2pdLmRpdklEID09PSBpZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQ6IHRoaXMuX292ZXJsYXlzW2ldLmhpZ2hsaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uOiByZWdpb25zW2pdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUuYWRkSGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGhpZ2hsaWdodClcbntcbiAgICB2YXIgZXhpc3RpbmdPdmVybGF5ID0gdGhpcy5fb3ZlcmxheXNbaGlnaGxpZ2h0LnBhZ2VdO1xuXG4gICAgaWYgKGV4aXN0aW5nT3ZlcmxheSlcbiAgICAgICAgdGhpcy5fZGl2YUluc3RhbmNlLl9fcmVtb3ZlUGFnZU92ZXJsYXkoZXhpc3RpbmdPdmVybGF5KTtcblxuICAgIHZhciBvdmVybGF5ID0gbmV3IEhpZ2hsaWdodFBhZ2VPdmVybGF5KGhpZ2hsaWdodCwgdGhpcy5fZGl2YUluc3RhbmNlLCB0aGlzLl9nZXRDdXJyZW50SGlnaGxpZ2h0KTtcbiAgICB0aGlzLl9vdmVybGF5c1toaWdobGlnaHQucGFnZV0gPSBvdmVybGF5O1xuICAgIHRoaXMuX2RpdmFJbnN0YW5jZS5fX2FkZFBhZ2VPdmVybGF5KG92ZXJsYXkpO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlSGlnaGxpZ2h0c09uUGFnZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgaWYgKCF0aGlzLl9vdmVybGF5c1twYWdlSW5kZXhdKVxuICAgICAgICByZXR1cm47XG5cbiAgICB0aGlzLl9kaXZhSW5zdGFuY2UuX19yZW1vdmVQYWdlT3ZlcmxheSh0aGlzLl9vdmVybGF5c1twYWdlSW5kZXhdKTtcbiAgICBkZWxldGUgdGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XTtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKClcbntcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX292ZXJsYXlzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHRoaXMuX2RpdmFJbnN0YW5jZS5fX3JlbW92ZVBhZ2VPdmVybGF5KHRoaXMuX292ZXJsYXlzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl9vdmVybGF5cyA9IHt9O1xufTtcblxuLyoqXG4gV2hlbiBhIG5ldyBwYWdlIGlzIGxvYWRlZCwgdGhpcyBvdmVybGF5IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gcGFnZSBpbmRleCBmb3IgdGhlIHBhZ2UuIEl0IGxvb2tzIGF0IHRoZSAnaGlnaGxpZ2h0cycgZGF0YSBvYmplY3RcbiBzZXQgb24gdGhlIGRpdmEgcGFyZW50IGVsZW1lbnQsIGFuZCBkZXRlcm1pbmVzIHdoZXRoZXJcbiBoaWdobGlnaHRzIGV4aXN0IGZvciB0aGF0IHBhZ2UuXG5cbiBJZiBzbywgdGhlIG92ZXJsYXkgd2lsbCBjcmVhdGUgYW5kIHJlbmRlciBlbGVtZW50cyBmb3IgZXZlcnlcbiBoaWdobGlnaHRlZCBib3guXG5cbiBAcGFyYW0gaGlnaGxpZ2h0XG4gQHBhcmFtIGRpdmFJbnN0YW5jZVxuIEBwYXJhbSBnZXRDdXJyZW50SGlnaGxpZ2h0IChvcHRpb25hbClcbiAqL1xuZnVuY3Rpb24gSGlnaGxpZ2h0UGFnZU92ZXJsYXkoaGlnaGxpZ2h0LCBkaXZhSW5zdGFuY2UsIGdldEN1cnJlbnRIaWdobGlnaHQpXG57XG4gICAgdGhpcy5wYWdlID0gaGlnaGxpZ2h0LnBhZ2U7XG4gICAgdGhpcy5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG4gICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucyA9IFtdO1xuICAgIHRoaXMuX2RpdmFJbnN0YW5jZSA9IGRpdmFJbnN0YW5jZTtcbiAgICB0aGlzLl9nZXRDdXJyZW50SGlnaGxpZ2h0ID0gZ2V0Q3VycmVudEhpZ2hsaWdodDtcbn1cblxuSGlnaGxpZ2h0UGFnZU92ZXJsYXkucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgZGl2YVNldHRpbmdzID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFNldHRpbmdzKCk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHQ7XG4gICAgdmFyIHJlZ2lvbnMgPSBoaWdobGlnaHQucmVnaW9ucztcbiAgICB2YXIgY29sb3VyID0gaGlnaGxpZ2h0LmNvbG91cjtcbiAgICB2YXIgZGl2Q2xhc3MgPSBoaWdobGlnaHQuZGl2Q2xhc3M7XG5cbiAgICB2YXIgaiA9IHJlZ2lvbnMubGVuZ3RoO1xuICAgIHdoaWxlIChqLS0pXG4gICAge1xuICAgICAgICB2YXIgcmVnaW9uID0gcmVnaW9uc1tqXTtcblxuICAgICAgICAvLyBGSVhNRTogVXNlIENTUyBjbGFzcyBpbnN0ZWFkIG9mIGlubGluZSBzdHlsZVxuICAgICAgICB2YXIgYm94ID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogZGl2Q2xhc3MsXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG91cixcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM1NTVcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHpJbmRleDogMTAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZWdpb24uZGl2SUQgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1oaWdobGlnaHQtaWQnLCByZWdpb24uZGl2SUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlZCBieSBJSUlGSGlnaGxpZ2h0XG4gICAgICAgIGlmIChyZWdpb24ubmFtZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBib3guc2V0QXR0cmlidXRlKCdkYXRhLW5hbWUnLCByZWdpb24ubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9oaWdobGlnaHRSZWdpb25zLnB1c2goe1xuICAgICAgICAgICAgZWxlbWVudDogYm94LFxuICAgICAgICAgICAgcmVnaW9uOiByZWdpb25cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoKCk7XG5cbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB0aGlzLl9oaWdobGlnaHRSZWdpb25zLmZvckVhY2goZnVuY3Rpb24gKGhpZ2hsaWdodClcbiAgICB7XG4gICAgICAgIGZyYWcuYXBwZW5kQ2hpbGQoaGlnaGxpZ2h0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgZGl2YVNldHRpbmdzLmlubmVyRWxlbWVudC5hcHBlbmRDaGlsZChmcmFnKTtcblxuICAgIGlmICh0aGlzLl9nZXRDdXJyZW50SGlnaGxpZ2h0KVxuICAgICAgICB1cGRhdGVDdXJyZW50SGlnaGxpZ2h0KHRoaXMuX2RpdmFJbnN0YW5jZSwgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCgpKTtcblxuICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2goXCJIaWdobGlnaHRDb21wbGV0ZWRcIiwgW3RoaXMucGFnZSwgdGhpcy5fZGl2YUluc3RhbmNlLmdldEZpbGVuYW1lcygpW3RoaXMucGFnZV1dKTtcbn07XG5cbkhpZ2hsaWdodFBhZ2VPdmVybGF5LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgaW5uZXJFbGVtZW50ID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFNldHRpbmdzKCkuaW5uZXJFbGVtZW50O1xuXG4gICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChoaWdobGlnaHQpXG4gICAge1xuICAgICAgICBpbm5lckVsZW1lbnQucmVtb3ZlQ2hpbGQoaGlnaGxpZ2h0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucyA9IFtdO1xufTtcblxuLy8gRklYTUU6IFVwZGF0aW5nIGEgYm94IHBlciBoaWdobGlnaHQgcmVnaW9uIG1pZ2h0IGJlIHRvbyBleHBlbnNpdmVcbi8vIE1heWJlIHN0aWNrIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjb250YWluZXIgYW5kIHRoZW4gc2NhbGUgaXQgdXNpbmcgQ1NTIHRyYW5zZm9ybXM/XG5IaWdobGlnaHRQYWdlT3ZlcmxheS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIG1heFpvb20gPSB0aGlzLl9kaXZhSW5zdGFuY2UuZ2V0TWF4Wm9vbUxldmVsKCk7XG5cbiAgICB2YXIgbWF4Wm9vbVdpZHRoID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFBhZ2VEaW1lbnNpb25zQXRab29tTGV2ZWwodGhpcy5wYWdlLCBtYXhab29tKS53aWR0aDtcbiAgICB2YXIgY3VycmVudFdpZHRoID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFBhZ2VEaW1lbnNpb25zKHRoaXMucGFnZSkud2lkdGg7XG4gICAgdmFyIHpvb21EaWZmZXJlbmNlID0gTWF0aC5sb2cobWF4Wm9vbVdpZHRoIC8gY3VycmVudFdpZHRoKSAvIE1hdGgubG9nKDIpO1xuXG4gICAgdmFyIHBhZ2VPZmZzZXQgPSB0aGlzLl9kaXZhSW5zdGFuY2UuZ2V0UGFnZU9mZnNldCh0aGlzLnBhZ2UsIHtcbiAgICAgICAgZXhjbHVkZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGluY29ycG9yYXRlVmlld3BvcnQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaGlnaGxpZ2h0KVxuICAgIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGhpZ2hsaWdodC5yZWdpb247XG5cbiAgICAgICAgZWx0LnNldEF0dHJpYnV0ZXMoaGlnaGxpZ2h0LmVsZW1lbnQsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGluY29ycG9yYXRlWm9vbShyZWdpb24ud2lkdGgsIHpvb21EaWZmZXJlbmNlKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGluY29ycG9yYXRlWm9vbShyZWdpb24uaGVpZ2h0LCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgdG9wOiBwYWdlT2Zmc2V0LnRvcCArIGluY29ycG9yYXRlWm9vbShyZWdpb24udWx5LCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgbGVmdDogcGFnZU9mZnNldC5sZWZ0ICsgaW5jb3Jwb3JhdGVab29tKHJlZ2lvbi51bHgsIHpvb21EaWZmZXJlbmNlKSArIFwicHhcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGluY29ycG9yYXRlWm9vbShwb3NpdGlvbiwgem9vbURpZmZlcmVuY2UpXG57XG4gICAgcmV0dXJuIHBvc2l0aW9uIC8gTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDdXJyZW50SGlnaGxpZ2h0KGRpdmFJbnN0YW5jZSwgY3VycmVudEhpZ2hsaWdodClcbntcbiAgICB2YXIgY2xhc3NTdHJpbmcgPSBkaXZhSW5zdGFuY2UuZ2V0SW5zdGFuY2VJZCgpICsgXCJzZWxlY3RlZC1oaWdobGlnaHRcIjtcbiAgICB2YXIgY2xhc3NFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc1N0cmluZyk7XG4gICAgdmFyIGlkeDtcbiAgICB2YXIgYm94O1xuICAgIHZhciBib3hlcztcblxuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgY2xhc3NFbGVtLmxlbmd0aDsgaWR4KyspXG4gICAge1xuICAgICAgICBib3ggPSBjbGFzc0VsZW1baWR4XTtcbiAgICAgICAgaWYgKGJveC5pZCAhPT0gY3VycmVudEhpZ2hsaWdodC5pZClcbiAgICAgICAge1xuICAgICAgICAgICAgYm94LmNsYXNzTmFtZSA9IGJveC5jbGFzc05hbWUucmVwbGFjZSgnICcrY2xhc3NTdHJpbmcsICcnKTtcbiAgICAgICAgICAgIGJveC5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCAjNTU1XCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGl2YUluc3RhbmNlLmlzUGFnZUluVmlld3BvcnQoY3VycmVudEhpZ2hsaWdodC5wYWdlKSlcbiAgICB7XG4gICAgICAgIGJveGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIipbZGF0YS1oaWdobGlnaHQtaWQ9XCIgKyBjdXJyZW50SGlnaGxpZ2h0LmlkICsgXCJdXCIpO1xuICAgICAgICBmb3IoaWR4ID0gMDsgaWR4IDwgYm94ZXMubGVuZ3RoOyBpZHgrKylcbiAgICAgICAge1xuICAgICAgICAgICAgYm94ID0gYm94ZXNbaWR4XTtcbiAgICAgICAgICAgIGJveC5jbGFzc05hbWUgPSBib3guY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc1N0cmluZztcbiAgICAgICAgICAgIGJveC5zdHlsZS5ib3JkZXIgPSBcIjJweCBzb2xpZCAjMDAwXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2hpZ2hsaWdodC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbklJSUYgSGlnaGxpZ2h0IHBsdWdpbiBmb3IgZGl2YS5qc1xuQWxsb3dzIHlvdSB0byBoaWdobGlnaHQgcmVnaW9ucyBvZiBhIHBhZ2UgaW1hZ2UgYmFzZWQgb2ZmIG9mIGFubm90YXRpb25zIGluIGEgSUlJRiBNYW5pZmVzdFxuKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG52YXIgSGlnaGxpZ2h0TWFuYWdlciA9IHJlcXVpcmUoJy4vaGlnaGxpZ2h0JykuSGlnaGxpZ2h0TWFuYWdlcjtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodE1hbmFnZXIgPSBuZXcgSGlnaGxpZ2h0TWFuYWdlcihkaXZhSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QuZGF0YSgnaGlnaGxpZ2h0TWFuYWdlcicsIGhpZ2hsaWdodE1hbmFnZXIpO1xuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlnaGxpZ2h0ZWRQYWdlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgUmVzZXQgdGhlIGhpZ2hsaWdodHMgb2JqZWN0IGFuZCByZW1vdmVzIGFsbCBoaWdobGlnaHRzIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnJlc2V0SGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgUmVzZXRzIHRoZSBoaWdobGlnaHRzIGZvciBhIHNpbmdsZSBwYWdlLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnJlbW92ZUhpZ2hsaWdodHNPblBhZ2UgPSBmdW5jdGlvbihwYWdlSWR4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5yZW1vdmVIaWdobGlnaHRzT25QYWdlKHBhZ2VJZHgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlkZUhpZ2hsaWdodHMgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaWdobGlnaHRzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5pbm5lckVsZW1lbnQpLmFkZENsYXNzKCdhbm5vdGF0aW9ucy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnNob3dIaWdobGlnaHRzID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlnaGxpZ2h0c1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5pbm5lckVsZW1lbnQpLnJlbW92ZUNsYXNzKCdhbm5vdGF0aW9ucy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0cyByZWdpb25zIG9uIG11bHRpcGxlIHBhZ2VzLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcGFnZUlkeHMgQW4gYXJyYXkgb2YgcGFnZSBpbmRleCBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBjb2xvdXIgICAob3B0aW9uYWwpIEEgY29sb3VyIGZvciB0aGUgaGlnaGxpZ2h0aW5nLCBzcGVjaWZpZWQgaW4gUkdCQSBDU1MgZm9ybWF0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlcyA9IGZ1bmN0aW9uKHBhZ2VJZHhzLCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBwYWdlSWR4cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UocGFnZUlkeHNbal0sIHJlZ2lvbnNbal0sIGNvbG91ciwgZGl2Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEhpZ2hsaWdodHMgcmVnaW9ucyBvbiBhIHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBwYWdlSWR4ICBBIHBhZ2UgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zLiBVc2Ugeyd3aWR0aCc6aSwgJ2hlaWdodCc6aSwgJ3VseCc6aSwgJ3VseSc6IGksICdkaXZJRCc6IHN0cn0gZm9yIGVhY2ggcmVnaW9uLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gY29sb3VyICAgKG9wdGlvbmFsKSBBIGNvbG91ciBmb3IgdGhlIGhpZ2hsaWdodGluZywgc3BlY2lmaWVkIGluIFJHQkEgQ1NTIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gZGl2Q2xhc3MgKG9wdGlvbmFsKSBBIGNsYXNzIHRvIGlkZW50aWZ5IGEgZ3JvdXAgb2YgaGlnaGxpZ2h0ZWQgcmVnaW9ucyBvbiBhIHNwZWNpZmljIHBhZ2UgYnlcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UgPSBmdW5jdGlvbihwYWdlSWR4LCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG91ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXIgPSAncmdiYSgyNTUsIDAsIDAsIDAuMiknO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdkNsYXNzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzID0gZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCBkaXZhLWhpZ2hsaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZDbGFzcyA9IGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQgZGl2YS1oaWdobGlnaHQgJyArIGRpdkNsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5hZGRIaWdobGlnaHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnM6IHJlZ2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6IGNvbG91cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzOiBkaXZDbGFzc1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIGEgaGlnaGxpZ2h0IHNvbWV3aGVyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBkaXZJRCBUaGUgSUQgb2YgdGhlIGRpdiB0byBqdW1wIHRvLiBUaGlzIElEIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIGRpdiB1c2luZyAuaGlnaGxpZ2h0T25QYWdlKHMpIGFzIHRoZSBoaWdobGlnaHQgbWF5IG5vdCBiZSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9IaWdobGlnaHQgPSBmdW5jdGlvbihkaXZJRClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodEJ5UmVnaW9uSWQoZGl2SUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ290b0RpdihyZXN1bHQuaGlnaGxpZ2h0LnBhZ2UsIHJlc3VsdC5yZWdpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRpdmEganVzdCB0cmllZCB0byBmaW5kIGEgaGlnaGxpZ2h0IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTW92ZXMgdGhlIGRpdmEgcGFuZSB0byAocGFnZSlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgZ290b0RpdiA9IGZ1bmN0aW9uKHBhZ2UsIHRoaXNEaXYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvL2dldHMgY2VudGVyIG9mIHRoZSBkaXZcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlcllPZkRpdiA9IHBhcnNlRmxvYXQodGhpc0Rpdi51bHkpICsgcGFyc2VGbG9hdCh0aGlzRGl2LmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyWE9mRGl2ID0gcGFyc2VGbG9hdCh0aGlzRGl2LnVseCkgKyBwYXJzZUZsb2F0KHRoaXNEaXYud2lkdGgpIC8gMjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzaXJlZFkgPSBkaXZhSW5zdGFuY2UudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbChjZW50ZXJZT2ZEaXYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVzaXJlZFggPSBkaXZhSW5zdGFuY2UudHJhbnNsYXRlRnJvbU1heFpvb21MZXZlbChjZW50ZXJYT2ZEaXYpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vbmF2aWdhdGVzIHRvIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UgPSBwYXJzZUludChwYWdlLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nb3RvUGFnZUJ5SW5kZXgocGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydE9iamVjdCA9IGRpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpLnZpZXdwb3J0T2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFRvcCA9IHZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcCgpICsgZGVzaXJlZFkgLSAodmlld3BvcnRPYmplY3QuaGVpZ2h0KCkgLyAyKSArIGRpdmFTZXR0aW5ncy52ZXJ0aWNhbFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGVmdCA9IHZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoKSArIGRlc2lyZWRYIC0gKHZpZXdwb3J0T2JqZWN0LndpZHRoKCkgLyAyKSArIGRpdmFTZXR0aW5ncy5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICAgICAgICAgICAgICAvL2NoYW5nZXMgdGhlIHNjcm9sbCBsb2NhdGlvbiB0byBjZW50ZXIgb24gdGhlIGRpdiBhcyBtdWNoIGFzIGlzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcChjdXJyZW50VG9wKTtcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRPYmplY3Quc2Nyb2xsTGVmdChjdXJyZW50TGVmdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBzaG93QW5ub3RhdGlvbnMgPSBmdW5jdGlvbihjYW52YXNJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBzdGF0dXMsIGpxWEhSKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzQW5ub3RhdGlvbnMgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG51bUFubm90YXRpb25zID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY29udmVydCBhbm5vdGF0aW9ucyBpbiBhbm5vdGF0aW9ucyBvYmplY3QgdG8gZGl2YSBoaWdobGlnaHQgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ2lvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb29wIG92ZXIgYW5ub3RhdGlvbnMgaW4gYSBzaW5nbGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG51bUFubm90YXRpb25zOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRBbm5vdGF0aW9uID0gY2FudmFzQW5ub3RhdGlvbnNba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gY3VycmVudEFubm90YXRpb24ucmVzb3VyY2UuY2hhcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgeCx5LHcsaCAoc2xpY2Ugc3RyaW5nIGZyb20gJyN4eXdoPScgdG8gZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblN0cmluZyA9IGN1cnJlbnRBbm5vdGF0aW9uLm9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZFN0cmluZyA9IG9uU3RyaW5nLnNsaWNlKG9uU3RyaW5nLmluZGV4T2YoJyN4eXdoPScpICsgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gY29vcmRTdHJpbmcuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVseDogcGFyc2VJbnQoY29vcmRpbmF0ZXNbMF0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWx5OiBwYXJzZUludChjb29yZGluYXRlc1sxXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VJbnQoY29vcmRpbmF0ZXNbMl0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChjb29yZGluYXRlc1szXSwgMTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnMucHVzaChyZWdpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlKGNhbnZhc0luZGV4LCByZWdpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZmxhZyB0aGlzIHBhZ2UncyBhbm5vdGF0aW9ucyBhcyBoYXZpbmcgYmVlbiByZXRyaWV2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpZ2hsaWdodGVkUGFnZXMucHVzaChjYW52YXNJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBnZXRBbm5vdGF0aW9uc0xpc3QgPSBmdW5jdGlvbihwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvL2lmIHBhZ2UgaGFzIGFubm90YXRpb25MaXN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNlcyA9IHNldHRpbmdzLm1hbmlmZXN0LnNlcXVlbmNlc1swXS5jYW52YXNlcztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FudmFzZXNbcGFnZUluZGV4XS5oYXNPd25Qcm9wZXJ0eSgnb3RoZXJDb250ZW50JykpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckNvbnRlbnQgPSBjYW52YXNlc1twYWdlSW5kZXhdLm90aGVyQ29udGVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvdGhlckNvbnRlbnQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG90aGVyQ29udGVudFtqXVsnQHR5cGUnXSA9PT0gJ3NjOkFubm90YXRpb25MaXN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbnZhcyBoYXMgYW5ub3RhdGlvbnMuIGdldCB0aGUgYW5ub3RhdGlvbnM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IG90aGVyQ29udGVudFtqXVsnQGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBzaG93QW5ub3RhdGlvbnMocGFnZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldE1hbmlmZXN0ID0gZnVuY3Rpb24obWFuaWZlc3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ01hbmlmZXN0RGlkTG9hZCcsIHNldE1hbmlmZXN0LCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdQYWdlV2lsbExvYWQnLCBmdW5jdGlvbihwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmhpZ2hsaWdodHNWaXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL2lmIGhpZ2hsaWdodHMgZm9yIHRoaXMgcGFnZSBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkL2xvYWRlZCwgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MuaGlnaGxpZ2h0ZWRQYWdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmhpZ2hsaWdodGVkUGFnZXNbaV0gPT09IHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBnZXRBbm5vdGF0aW9uc0xpc3QocGFnZUluZGV4LCBzZXR0aW5ncy5tYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgfSwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVPdmVybGF5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy9vbiBtb3VzZW92ZXIsIHNob3cgdGhlIGFubm90YXRpb24gdGV4dFxuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5pbm5lck9iamVjdC5vbignbW91c2VlbnRlcicsICcuJyArIGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFubm90YXRpb25FbGVtZW50ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYW5ub3RhdGlvbkVsZW1lbnQuZGF0YXNldC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS50b3AgPSAoYW5ub3RhdGlvbkVsZW1lbnQub2Zmc2V0VG9wICsgYW5ub3RhdGlvbkVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gMSkgKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS5sZWZ0ID0gYW5ub3RhdGlvbkVsZW1lbnQuc3R5bGUubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUuYmFja2dyb3VuZCA9ICcjZmZmJztcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjNTU1JztcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5zdHlsZS56SW5kZXggPSAxMDE7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LmNsYXNzTmFtZSA9ICdhbm5vdGF0aW9uLW92ZXJsYXknO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS50ZXh0Q29udGVudCA9IG5hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGlvbkVsZW1lbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0ZXh0T3ZlcmxheSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZU92ZXJsYXlzLnB1c2godGV4dE92ZXJsYXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmlubmVyT2JqZWN0Lm9uKCdtb3VzZWxlYXZlJywgJy4nICsgZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCcsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYWN0aXZlT3ZlcmxheXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dE92ZXJsYXkgPSBhY3RpdmVPdmVybGF5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGV4dE92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvL2J1dHRvbiB0byB0b2dnbGUgYW5ub3RhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgJCgnIycgKyBkaXZhU2V0dGluZ3MuSUQgKyAncGFnZS1uYXYnKS5iZWZvcmUoJzxkaXYgaWQ9XCInICsgZGl2YVNldHRpbmdzLklEICsgJ2Fubm90YXRpb25zLWljb25cIiBjbGFzcz1cImRpdmEtYnV0dG9uIGRpdmEtYW5ub3RhdGlvbnMtaWNvblwiIHRpdGxlPVwiVHVybiBhbm5vdGF0aW9ucyBvbiBvciBvZmZcIj48L2Rpdj4nKTtcblxuICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdhbm5vdGF0aW9ucy1pY29uJykuYWRkQ2xhc3MoJ2Fubm90YXRpb25zLWljb24tYWN0aXZlJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgJCgnIycgKyBkaXZhU2V0dGluZ3MuSUQgKyAnYW5ub3RhdGlvbnMtaWNvbicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdG9nZ2xlIHZpc2liaWxpdHkgb2YgYW5ub3RhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oaWdobGlnaHRzVmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlkZUhpZ2hsaWdodHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdhbm5vdGF0aW9ucy1pY29uJykucmVtb3ZlQ2xhc3MoJ2Fubm90YXRpb25zLWljb24tYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnNob3dIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnYW5ub3RhdGlvbnMtaWNvbicpLmFkZENsYXNzKCdhbm5vdGF0aW9ucy1pY29uLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgLy9lbmFibGUgYW5ub3RhdGlvbnMgYnkgZGVmYXVsdFxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpZ2hsaWdodHNWaXNpYmxlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LnJlbW92ZURhdGEoJ2hpZ2hsaWdodHMnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnSUlJRkhpZ2hsaWdodCcsXG4gICAgICAgICAgICB0aXRsZVRleHQ6ICdIaWdobGlnaHQgcmVnaW9ucyBvZiBwYWdlcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BsdWdpbnMvaWlpZi1oaWdobGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIElJSUYgTWV0YWRhdGEgcGx1Z2luIGZvciBkaXZhLmpzXG4vLyBEaXNwbGF5cyBvYmplY3QgbWV0YWRhdGEgZnJvbSBhIElJSUYgbWFuaWZlc3RcblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIF9kaXNwbGF5TWV0YWRhdGEgPSBmdW5jdGlvbihtYW5pZmVzdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG93TWV0YWRhdGEgPSBmdW5jdGlvbihsYWJlbCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYWJlbFByb3BlciA9IGxhYmVsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbGFiZWwuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxGb3JtYXR0ZWQgPSBsYWJlbFByb3Blci5yZXBsYWNlKCdfJywgJyAnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKC9eaHR0cHM/OlxcL1xcLy8pKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzxhIGhyZWY9XCInICsgdmFsdWUgKyAnXCIgdGFyZ2V0PVwiX2JsYW5rXCI+JyArIHZhbHVlICsgJzwvYT4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJtZXRhZGF0YS1yb3dcIj48c3BhbiBjbGFzcz1cIm1ldGFkYXRhLWxhYmVsXCI+JyArIGxhYmVsRm9ybWF0dGVkICsgJzo8L3NwYW4+IDxzcGFuIGNsYXNzPVwibWV0YWRhdGEtdmFsdWVcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgKyAnPC9zcGFuPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldERhdGFGb3JMYW5ndWFnZSA9IGZ1bmN0aW9uKGRhdGEsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbaV1bJ0BsYW5ndWFnZSddID09PSBsYW5ndWFnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhW2ldWydAdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBubyBsYW5ndWFnZSBpcyBzcGVjaWZpZWQsIG9yIHdoZW4gYSBzaW5nbGUgb2JqZWN0IGlzIHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMF1bJ0B2YWx1ZSddIHx8IGRhdGFbJ0B2YWx1ZSddO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTaG93cyBtZXRhZGF0YSBmcm9tIGxhYmVsIG5hbWVzIChpZiB0aGUgbWV0YWRhdGEgZXhpc3RzKS5cbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWVzIHtBcnJheX0gLSBBbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBmaWVsZCBuYW1lcyB0byBkaXNwbGF5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNob3dNZXRhZGF0YUZyb21MYWJlbE5hbWVzID0gZnVuY3Rpb24obmFtZXMpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IG5hbWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0Lmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYW5pZmVzdFtmaWVsZF0uY29uc3RydWN0b3IgPT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL211bHRpcGxlIGxhbmd1YWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsaXplZERhdGEgPSBnZXREYXRhRm9yTGFuZ3VhZ2UobWFuaWZlc3RbZmllbGRdLCAnZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzICs9IHNob3dNZXRhZGF0YShmaWVsZCwgbG9jYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyArPSBzaG93TWV0YWRhdGEoZmllbGQsIG1hbmlmZXN0W2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGFFbGVtZW50ID0gJzxkaXYgaWQ9XCInICsgZGl2YVNldHRpbmdzLklEICsgJ21ldGFkYXRhXCIgY2xhc3M9XCJkaXZhLW1vZGFsXCI+JztcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbGVtZW50ICs9IHNob3dNZXRhZGF0YUZyb21MYWJlbE5hbWVzKFsnbGFiZWwnXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0Lmhhc093blByb3BlcnR5KCdtZXRhZGF0YScpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWV0YWRhdGFGaWVsZCA9IG1hbmlmZXN0Lm1ldGFkYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhRmllbGQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhRmllbGRbaV0udmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbm9uaWNhbERhdGEgPSBnZXREYXRhRm9yTGFuZ3VhZ2UobWV0YWRhdGFGaWVsZFtpXS52YWx1ZSwgJ2VuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRWxlbWVudCArPSBzaG93TWV0YWRhdGEobWV0YWRhdGFGaWVsZFtpXS5sYWJlbCwgY2Fub25pY2FsRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRWxlbWVudCArPSBzaG93TWV0YWRhdGEobWV0YWRhdGFGaWVsZFtpXS5sYWJlbCwgbWV0YWRhdGFGaWVsZFtpXS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFFbGVtZW50ICs9IHNob3dNZXRhZGF0YUZyb21MYWJlbE5hbWVzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2l0aGluJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWVfYWxzbycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbGljZW5zZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXR0cmlidXRpb24nXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRWxlbWVudCArPSAnPC9kaXY+JztcblxuICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LnByZXBlbmQobWV0YWRhdGFFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnbWV0YWRhdGEnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vc3Vic2NyaWJlIHRvIE1hbmlmZXN0RGlkTG9hZCBldmVudCwgZ2V0IHRoZSBtYW5pZmVzdFxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnTWFuaWZlc3REaWRMb2FkJywgX2Rpc3BsYXlNZXRhZGF0YSwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QucHJlcGVuZCgnPGRpdiBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlcjsgY2xlYXI6IGJvdGhcIj48YSBocmVmPVwiI1wiIGlkPVwiJyArIGRpdmFTZXR0aW5ncy5JRCArICdtZXRhZGF0YS1saW5rXCIgY2xhc3M9XCJkaXZhLW1ldGFkYXRhLWxpbmtcIj5EZXRhaWxzPC9hPjwvZGl2PicpO1xuICAgICAgICAgICAgICAgIC8vICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ3RpdGxlJykuYXBwZW5kKCc8ZGl2PjxhIGhyZWY9XCIjXCIgaWQ9XCInICsgZGl2YVNldHRpbmdzLklEICsgJ21ldGFkYXRhLWxpbmtcIiBjbGFzcz1cImRpdmEtbWV0YWRhdGEtbGlua1wiPkRldGFpbHM8L2E+PC9kaXY+Jyk7XG5cbiAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdtZXRhZGF0YS1saW5rJykub24oJ2NsaWNrJywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ21ldGFkYXRhJykuZmFkZVRvZ2dsZSgnZmFzdCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdJSUlGTWV0YWRhdGEnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnU2hvdyBtZXRhZGF0YSBmcm9tIGEgSUlJRiBtYW5pZmVzdCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BsdWdpbnMvaWlpZi1tZXRhZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==