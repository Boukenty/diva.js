(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["diva"] = factory(require("jquery"));
	else
		root["diva"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	module.exports = __webpack_require__(7);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	var diva = __webpack_require__(2);
	
	diva.registerPlugin(__webpack_require__(6));
	diva.registerPlugin(__webpack_require__(43));
	diva.registerPlugin(__webpack_require__(44));
	diva.registerPlugin(__webpack_require__(45));
	diva.registerPlugin(__webpack_require__(46));
	diva.registerPlugin(__webpack_require__(47));


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var Events = __webpack_require__(4);
	var PluginRegistry = __webpack_require__(5);
	
	var diva = module.exports = {
	    Events: new Events(),
	
	    registerPlugin: function (plugin)
	    {
	        PluginRegistry.register(plugin);
	    },
	
	    /**
	     * Create a new Diva instance at the given element
	     *
	     * @param element {Element}
	     * @param options {Object}
	     * @returns {Diva}
	     */
	    create: function (element, options)
	    {
	        if (diva.find(element))
	            throw new Error('Diva is already initialized on ' + reprElem(element));
	
	        var $elem = $(element);
	        $elem.diva(options);
	
	        return $elem.data('diva');
	    },
	
	    /**
	     * Return the Diva instance attached to the
	     * element, if any.
	     *
	     * @param element
	     * @returns {Diva|null}
	     */
	    find: function (element)
	    {
	        return $(element).data('diva') || null;
	    }
	};
	
	function reprElem(elem)
	{
	    var id = elem.id ? '#' + elem.id : elem.id;
	    var classes = elem.className ? '.' + elem.className.split(/\s+/g).join('.') : '';
	
	    return (id ? id : elem.tagName.toLowerCase()) + classes;
	}


/***/ }),
/* 3 */
/***/ (function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	module.exports = Events;
	
	/**
	 *      Events. Pub/Sub system for Loosely Coupled logic.
	 *      Based on Peter Higgins' port from Dojo to jQuery
	 *      https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js
	 *
	 *      Re-adapted to vanilla Javascript
	 *
	 *      @class Events
	 */
	function Events()
	{
	    this._cache = {};
	}
	
	/**
	 *      diva.Events.publish
	 *      e.g.: diva.Events.publish("PageDidLoad", [pageIndex, filename, pageSelector], this);
	 *
	 *      @class Events
	 *      @method publish
	 *      @param topic {String}
	 *      @param args  {Array}
	 *      @param scope {Object=} Optional - Subscribed functions will be executed with the supplied object as `this`.
	 *          It is necessary to supply this argument with the self variable when within a Diva instance.
	 *          The scope argument is matched with the instance ID of subscribers to determine whether they
	 *              should be executed. (See instanceID argument of subscribe.)
	 */
	Events.prototype.publish = function (topic, args, scope)
	{
	    if (this._cache[topic])
	    {
	        var thisTopic = this._cache[topic];
	
	        if (typeof thisTopic.global !== 'undefined')
	        {
	            var thisTopicGlobal = thisTopic.global;
	            var globalCount = thisTopicGlobal.length;
	
	            for (var i=0; i < globalCount; i++)
	            {
	                thisTopicGlobal[i].apply(scope || null, args || []);
	            }
	        }
	
	        if (scope && typeof scope.getInstanceId !== 'undefined')
	        {
	            // get publisher instance ID from scope arg, compare, and execute if match
	            var instanceID = scope.getInstanceId();
	
	            if (this._cache[topic][instanceID])
	            {
	                var thisTopicInstance = this._cache[topic][instanceID];
	                var scopedCount = thisTopicInstance.length;
	
	                for (var j=0; j < scopedCount; j++)
	                {
	                    thisTopicInstance[j].apply(scope, args || []);
	                }
	            }
	        }
	    }
	};
	
	/**
	 *      diva.Events.subscribe
	 *      e.g.: diva.Events.subscribe("PageDidLoad", highlight, settings.ID)
	 *
	 *      @class Events
	 *      @method subscribe
	 *      @param topic {String}
	 *      @param callback {Function}
	 *      @param instanceID {String=} Optional - String representing the ID of a Diva instance; if provided,
	 *                                            callback only fires for events published from that instance.
	 *      @return Event handler {Array}
	 */
	Events.prototype.subscribe = function (topic, callback, instanceID)
	{
	    if (!this._cache[topic])
	    {
	        this._cache[topic] = {};
	    }
	
	    if (typeof instanceID === 'string')
	    {
	        if (!this._cache[topic][instanceID])
	        {
	            this._cache[topic][instanceID] = [];
	        }
	
	        this._cache[topic][instanceID].push(callback);
	    }
	    else
	    {
	        if (!this._cache[topic].global)
	        {
	            this._cache[topic].global = [];
	        }
	
	        this._cache[topic].global.push(callback);
	    }
	
	    var handle = instanceID ? [topic, callback, instanceID] : [topic, callback];
	
	    return handle;
	};
	
	/**
	 *      diva.Events.unsubscribe
	 *      e.g.: var handle = Events.subscribe("PageDidLoad", highlight);
	 *              Events.unsubscribe(handle);
	 *
	 *      @class Events
	 *      @method unsubscribe
	 *      @param handle {Array}
	 *      @param completely {Boolean=} - Unsubscribe all events for a given topic.
	 *      @return success {Boolean}
	 */
	Events.prototype.unsubscribe = function (handle, completely)
	{
	    var t = handle[0];
	
	    if (this._cache[t])
	    {
	        var topicArray;
	        var instanceID = handle.length === 3 ? handle[2] : 'global';
	
	        topicArray = this._cache[t][instanceID];
	
	        if (!topicArray)
	        {
	            return false;
	        }
	
	        if (completely)
	        {
	            delete this._cache[t][instanceID];
	            return topicArray.length > 0;
	        }
	
	        var i = topicArray.length;
	        while (i--)
	        {
	            if (topicArray[i] === handle[1])
	            {
	                this._cache[t][instanceID].splice(i, 1);
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	/**
	 *      diva.Events.unsubscribeAll
	 *      e.g.: diva.Events.unsubscribeAll('global');
	 *
	 *      @class Events
	 *      @param instanceID {String=} Optional - instance ID to remove subscribers from or 'global' (if omitted,
	 *                                   subscribers in all scopes removed)
	 *      @method unsubscribeAll
	 */
	Events.prototype.unsubscribeAll = function (instanceID)
	{
	    if (instanceID)
	    {
	        var topics = Object.keys(this._cache);
	        var i = topics.length;
	        var topic;
	
	        while (i--)
	        {
	            topic = topics[i];
	
	            if (typeof this._cache[topic][instanceID] !== 'undefined')
	            {
	                delete this._cache[topic][instanceID];
	            }
	        }
	    }
	    else
	    {
	        this._cache = {};
	    }
	};


/***/ }),
/* 5 */
/***/ (function(module, exports) {

	/**
	 * @module
	 * @private
	 * The global plugin registry.
	 */
	
	var plugins = [];
	
	module.exports = {
	    register: function (plugin)
	    {
	        plugins.push(plugin);
	    },
	    getAll: function ()
	    {
	        return plugins;
	    }
	};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	Diva.JS autoscroll plugin
	Author: Andrew Horwitz
	
	Lets Diva scroll in the primary direction (as determined by
	settings.verticallyOriented) automatically at a given/changeable rate.
	
	Relevant settings:
	    -scrollSpeed: pixels per second (defaults to 10)
	    -disableManualScroll: disables manual scroll while automatic scroll is on (defaults to false)
	    -currentlyAutoScrolling: whether or not autoscroll is currently on
	    -autoScrollRefresh: ms between scrolling actions
	    -disableAutoscrollPrefs: disables the autoscroll preferences panel
	
	Relevant methods:
	    -startScrolling, stopScrolling, toggleScrolling
	    -changeRefresh, changeScrollSpeed (setters for respective options)
	    -disableManualScroll, enableManualScroll
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var pixelsPerScroll;
	                var disableManualScroll;
	                var autoScrollRefresh;
	                var defaultAutoRefresh;
	                var scrollSpeed;
	
	                function log10(x)
	                {
	                    return Math.log(x) / Math.log(10);
	                }
	
	                divaInstance.startScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to start autoscrolling, but it is already scrolling.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn off");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = true;
	                    restartScrollingInterval();
	                };
	
	                var restartScrollingInterval = function()
	                {
	                    clearInterval(divaSettings.autoScrollInterval);
	                    if (divaSettings.verticallyOriented)
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollTop(divaSettings.viewportObject.scrollTop() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                    else
	                    {
	                        divaSettings.autoScrollInterval = setInterval(function(){
	                            divaSettings.viewportObject.scrollLeft(divaSettings.viewportObject.scrollLeft() + pixelsPerScroll);
	                        }, autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.stopScrolling = function()
	                {
	                    if (!divaSettings.currentlyAutoScrolling)
	                    {
	                        console.warn("You are trying to stop autoscrolling, but it is not currently active.");
	                        return;
	                    }
	
	                    $("#" + divaSettings.ID + "autoscroll-toggle").text("Turn on");
	                    if (disableManualScroll)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	
	                    divaSettings.currentlyAutoScrolling = false;
	                    clearInterval(divaSettings.autoScrollInterval);
	                };
	
	                divaInstance.toggleScrolling = function()
	                {
	                    if (divaSettings.currentlyAutoScrolling)
	                        divaInstance.stopScrolling();
	                    else
	                        divaInstance.startScrolling();
	                };
	
	                divaInstance.changeRefresh = function(newRefresh)
	                {
	                    autoScrollRefresh = newRefresh;
	                    updatePixelsPerScroll();
	                };
	
	                divaInstance.changeScrollSpeed = function(newSpeed)
	                {
	                    scrollSpeed = newSpeed;
	                    updatePixelsPerScroll();
	
	                    $("#" + divaSettings.ID + "autoscroll-pps").val(log10(scrollSpeed));
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        restartScrollingInterval();
	                    }
	                };
	
	                var updatePixelsPerScroll = function()
	                {
	                    autoScrollRefresh = defaultAutoRefresh;
	                    pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	
	                    //should be minimum of one otherwise it won't change the actual value
	                    //user can change autoscrollrefresh or scrollspeed; this may overwrite autoScrollRefresh
	                    if (pixelsPerScroll < 1)
	                    {
	                        autoScrollRefresh = autoScrollRefresh * (1 / pixelsPerScroll);
	                        pixelsPerScroll = scrollSpeed / (1000 / autoScrollRefresh);
	                    }
	                };
	
	                divaInstance.disableManualScroll = function()
	                {
	                    disableManualScroll = true;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.disableScrollable();
	                    }
	                };
	
	                divaInstance.enableManualScroll = function()
	                {
	                    disableManualScroll = false;
	                    if (divaSettings.currentlyAutoScrolling)
	                    {
	                        divaInstance.enableScrollable();
	                    }
	                };
	
	                divaSettings.currentlyAutoScrolling = false;
	                divaSettings.autoScrollInterval = "";
	
	                disableManualScroll = divaSettings.disableManualScroll || false;
	                autoScrollRefresh = divaSettings.autoScrollRefresh || 50;
	                defaultAutoRefresh = autoScrollRefresh;
	
	                divaInstance.changeScrollSpeed((divaSettings.scrollSpeed || 10));
	
	                $(window).on('keyup', function(e)
	                {
	                    if (e.shiftKey && e.keyCode === 32)
	                    {
	                        divaInstance.toggleScrolling();
	                    }
	                });
	
	                if (!divaSettings.disableAutoscrollPrefs)
	                {
	                    var setPosition = function(isFullscreen)
	                    {
	                        if (divaSettings.inFullscreen)
	                        {
	                            var fullscreenTools = $(divaSettings.selector + 'tools');
	                            var toolsMargin = fullscreenTools.css('right');
	                            settings.jqObj.css({
	                                'right': toolsMargin,
	                                'margin-right': 0,
	                                'top': fullscreenTools.offset().top + fullscreenTools.outerHeight() + 15
	                            });
	                        }
	                        else
	                        {
	                            settings.jqObj.css({
	                                'right': $(window).width() - (divaSettings.viewportObject.offset().left + divaSettings.viewportObject.outerWidth()) + divaSettings.scrollbarWidth,
	                                'margin-right': '.6em'
	                            });
	                            settings.jqObj.offset({'top': divaSettings.viewportObject.offset().top + 1});
	                        }
	                    };
	
	                    diva.Events.subscribe('ModeDidSwitch', setPosition, divaSettings.ID);
	
	                    diva.Events.subscribe('ViewerDidLoad', function(s)
	                    {
	                        var autoscrollPrefsString =
	                        "<div id='" + divaSettings.ID + "autoscroll-prefs' class='diva-autoscroll-prefs diva-popup'>" +
	                            "<b>Autoscrolling options:</b><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Speed:</span>" +
	                            "<input type='range' id='" + divaSettings.ID + "autoscroll-pps' class='diva-autoscroll-pps diva-autoscroll-prefs-input' value='" + log10(scrollSpeed) + "' min='0' max='3' step='0.1'><br>" +
	                            "<span class='diva-autoscroll-prefs-text'>Allow manual scroll:</span>" +
	                            "<input type='checkbox' id='" + divaSettings.ID + "autoscroll-manual' class='diva-autoscroll-manual diva-autoscroll-prefs-input' checked='checked'><br>" +
	                            "<button id='" + divaSettings.ID + "autoscroll-toggle' class='diva-autoscroll-prefs-toggle diva-autoscroll-prefs-input'> Turn on </button>" +
	                        "</div>";
	                        $("#" + divaSettings.ID + "page-nav").before("<div id='" + divaSettings.ID + "autoscroll-icon' class='diva-button diva-autoscroll-icon' title='Expand autoscroll options'></div>");
	                        $("body").prepend(autoscrollPrefsString);
	
	                        $("#" + divaSettings.ID + "autoscroll-pps").on('change', function(e)
	                        {
	                            divaInstance.changeScrollSpeed(Math.pow(10, e.target.value));
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-manual").on('change', function(e)
	                        {
	                            if (e.target.checked)
	                                divaInstance.enableManualScroll();
	                            else
	                                divaInstance.disableManualScroll();
	                        });
	
	                        $("#" + divaSettings.ID + "autoscroll-toggle").on('click', divaInstance.toggleScrolling);
	
	                        $("#" + divaSettings.ID + "autoscroll-icon").on('click', function(e)
	                        {
	                            settings.jqObj = $("#" + divaSettings.ID + "autoscroll-prefs");
	
	                            if (settings.jqObj.css('display') === 'none')
	                            {
	                                settings.jqObj.css({'display': 'block'});
	
	                                setPosition(divaSettings.inFullscreen);
	
	                            }
	                            else
	                            {
	                                settings.jqObj.css('display', 'none');
	                            }
	                        });
	                    }, divaSettings.ID);
	                }
	            },
	            pluginName: 'autoscroll',
	            titleText: 'Automatically scrolls page along primary axis'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	Copyright (C) 2011-2016 by Wendy Liu, Evan Magoni, Andrew Hankinson, Andrew Horwitz, Laurent Pugin
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	*/
	__webpack_require__(8);
	
	var jQuery = __webpack_require__(3);
	
	var elt = __webpack_require__(9);
	var HashParams = __webpack_require__(10);
	
	var ActiveDivaController = __webpack_require__(11);
	var diva = __webpack_require__(2);
	var ImageManifest = __webpack_require__(12);
	var createToolbar = __webpack_require__(14);
	var ViewerCore = __webpack_require__(15);
	
	// Start the active Diva tracker
	var activeDiva = new ActiveDivaController(); // jshint ignore: line
	
	module.exports = diva;
	
	// this pattern was taken from http://www.virgentech.com/blog/2009/10/building-object-oriented-jquery-plugin.html
	(function ($)
	{
	    var Diva = function (element, options)
	    {
	        // Global instance variables (set way down in `init`)
	        var settings, viewerState, divaState;
	        var self = this;
	
	        // These are elements that can be overridden upon instantiation
	        // See https://github.com/DDMAL/diva.js/wiki/Settings for more details
	        options = $.extend({
	            adaptivePadding: 0.05,      // The ratio of padding to the page dimension
	            arrowScrollAmount: 40,      // The amount (in pixels) to scroll by when using arrow keys
	            blockMobileMove: false,     // Prevent moving or scrolling the page on mobile devices
	            objectData: '',             // A IIIF Manifest or a JSON file generated by process.py that provides the object dimension data, or a URL pointing to such data - *REQUIRED*
	            enableAutoTitle: true,      // Shows the title within a div of id diva-title
	            enableFilename: true,       // Uses filenames and not page numbers for links (i=bm_001.tif, not p=1)
	            enableFullscreen: true,     // Enable or disable fullscreen icon (mode still available)
	            enableGotoPage: true,       // A "go to page" jump box
	            enableGotoSuggestions: true, // Controls whether suggestions are shown under the input field when the user is typing in the 'go to page' form
	            enableGridIcon: true,       // A grid view of all the pages
	            enableGridControls: 'buttons',  // Specify control of pages per grid row in Grid view. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            enableImageTitles: true,    // Adds "Page {n}" title to page images if true
	            enableKeyScroll: true,      // Captures scrolling using the arrow and page up/down keys regardless of page focus. When off, defers to default browser scrolling behavior.
	            enableLinkIcon: true,       // Controls the visibility of the link icon
	            enableNonPagedVisibilityIcon: true, // Controls the visibility of the icon to toggle the visibility of non-paged pages. (Automatically hidden if no 'non-paged' pages).
	            enableSpaceScroll: false,   // Scrolling down by pressing the space key
	            enableToolbar: true,        // Enables the toolbar. Note that disabling this means you have to handle all controls yourself.
	            enableZoomControls: 'buttons', // Specify controls for zooming in and out. Possible values: 'buttons' (+/-), 'slider'. Any other value disables the controls.
	            fillParentHeight: true,     // Use a flexbox layout to allow Diva to fill its parent's height
	            fixedPadding: 10,           // Fallback if adaptive padding is set to 0
	            fixedHeightGrid: true,      // So each page in grid view has the same height (only widths differ)
	            goDirectlyTo: 0,            // Default initial page to show (0-indexed)
	            hashParamSuffix: null,      // Used when there are multiple document viewers on a page
	            iipServerURL: '',           // The URL to the IIPImage installation, including the `?FIF=` - *REQUIRED*, unless using IIIF
	            inFullscreen: false,        // Set to true to load fullscreen mode initially
	            inBookLayout: false,       // Set to true to view the document with facing pages in document mode
	            inGrid: false,              // Set to true to load grid view initially
	            imageDir: '',               // Image directory, either absolute path or relative to IIP's FILESYSTEM_PREFIX - *REQUIRED*, unless using IIIF
	            maxPagesPerRow: 8,          // Maximum number of pages per row in grid view
	            maxZoomLevel: -1,           // Optional; defaults to the max zoom returned in the JSON response
	            minPagesPerRow: 2,          // Minimum pages per row in grid view. Recommended default.
	            minZoomLevel: 0,            // Defaults to 0 (the minimum zoom)
	            onGotoSubmit: null,         // When set to a function that takes a string and returns a page index, this will override the default behaviour of the 'go to page' form submission
	            pageAliases: {},            // An object mapping specific page indices to aliases (has priority over 'pageAliasFunction'
	            pageAliasFunction: function(){return false;},  // A function mapping page indices to an alias. If false is returned, default page number is displayed
	            pageLoadTimeout: 200,       // Number of milliseconds to wait before loading pages
	            pagesPerRow: 5,             // The default number of pages per row in grid view
	            showNonPagedPages: false,   // Whether pages tagged as 'non-paged' (in IIIF manifests only) should be visible after initial load
	            throbberTimeout: 100,       // Number of milliseconds to wait before showing throbber
	            tileHeight: 256,            // The height of each tile, in pixels; usually 256
	            tileWidth: 256,             // The width of each tile, in pixels; usually 256
	            toolbarParentObject: null,  // The toolbar parent object.
	            verticallyOriented: true,   // Determines vertical vs. horizontal orientation
	            viewportMargin: 200,        // Pretend tiles +/- 200px away from viewport are in
	            zoomLevel: 2                // The initial zoom level (used to store the current zoom level)
	        }, options);
	
	        // Returns the page index associated with the given filename; must called after setting settings.manifest
	        var getPageIndex = function (filename)
	        {
	            return getPageIndexForManifest(settings.manifest, filename);
	        };
	
	        var NotAnIIIFManifestException = function (message)
	        {
	            return message;
	        };
	
	        var getPageIndexForManifest = function (manifest, filename)
	        {
	            var i,
	                np = manifest.pages.length;
	
	            for (i = 0; i < np; i++)
	            {
	                if (!manifest.pages[i])
	                {
	                    return -1;
	                }
	
	                if (manifest.pages[i].f === filename)
	                {
	                    return i;
	                }
	            }
	
	            return -1;
	        };
	
	        // Check if a page index is valid
	        var isPageValid = function (pageIndex)
	        {
	            return settings.manifest.isPageValid(pageIndex, settings.showNonPagedPages);
	        };
	
	        var reloadViewer = function (newOptions)
	        {
	            return divaState.viewerCore.reload(newOptions);
	        };
	
	        // Called when the change view icon is clicked
	        var changeView = function (destinationView)
	        {
	            switch (destinationView)
	            {
	                case 'document':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: false
	                    });
	
	                case 'book':
	                    return reloadViewer({
	                        inGrid: false,
	                        inBookLayout: true
	                    });
	
	                case 'grid':
	                    return reloadViewer({
	                        inGrid: true
	                    });
	
	                default:
	                    return false;
	            }
	        };
	
	        //toggles between orientations
	        var toggleOrientation = function ()
	        {
	            var verticallyOriented = !settings.verticallyOriented;
	
	            //if in grid, switch out of grid
	            reloadViewer({
	                inGrid: false,
	                verticallyOriented: verticallyOriented,
	                goDirectlyTo: settings.currentPageIndex,
	                verticalOffset: divaState.viewerCore.getYOffset(),
	                horizontalOffset: divaState.viewerCore.getXOffset()
	            });
	
	            return verticallyOriented;
	        };
	
	        // Called when the fullscreen icon is clicked
	        var toggleFullscreen = function ()
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        };
	
	        var getState = function ()
	        {
	            var view;
	
	            if (settings.inGrid)
	            {
	                view = 'g';
	            }
	            else if (settings.inBookLayout)
	            {
	                view = 'b';
	            }
	            else
	            {
	                view = 'd';
	            }
	
	            var layout = divaState.viewerCore.getCurrentLayout();
	            var pageOffset = layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            var state = {
	                'f': settings.inFullscreen,
	                'v': view,
	                'z': settings.zoomLevel,
	                'n': settings.pagesPerRow,
	                'i': settings.enableFilename ? settings.manifest.pages[settings.currentPageIndex].f : false,
	                'p': settings.enableFilename ? false : settings.currentPageIndex + 1,
	                'y': pageOffset ? pageOffset.y : false,
	                'x': pageOffset ? pageOffset.x : false
	            };
	
	            return state;
	        };
	
	        var getLoadOptionsForState = function (state, manifest)
	        {
	            manifest = manifest || settings.manifest;
	
	            var options = ('v' in state) ? getViewState(state.v) : {};
	
	            if ('f' in state)
	                options.inFullscreen = state.f;
	
	            if ('z' in state)
	                options.zoomLevel = state.z;
	
	            if ('n' in state)
	                options.pagesPerRow = state.n;
	
	            // Only change specify the page if state.i or state.p is valid
	            var pageIndex = getPageIndexForManifest(manifest, state.i);
	
	            if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	            {
	                pageIndex = state.p - 1;
	
	                // Possibly NaN
	                if (!(pageIndex >= 0 && pageIndex < manifest.pages.length))
	                    pageIndex = null;
	            }
	
	            if (pageIndex !== null)
	            {
	                var horizontalOffset = parseInt(state.x, 10);
	                var verticalOffset = parseInt(state.y, 10);
	
	                options.goDirectlyTo = pageIndex;
	                options.horizontalOffset = horizontalOffset;
	                options.verticalOffset = verticalOffset;
	            }
	
	            return options;
	        };
	
	        var getURLHash = function ()
	        {
	            var hashParams = getState();
	            var hashStringBuilder = [];
	            var param;
	
	            for (param in hashParams)
	            {
	                if (hashParams[param] !== false)
	                    hashStringBuilder.push(param + settings.hashParamSuffix + '=' + encodeURIComponent(hashParams[param]));
	            }
	
	            return hashStringBuilder.join('&');
	        };
	
	        // Returns the URL to the current state of the document viewer (so it should be an exact replica)
	        var getCurrentURL = function ()
	        {
	            return location.protocol + '//' + location.host + location.pathname + location.search + '#' + getURLHash();
	        };
	
	        var getViewState = function(view)
	        {
	            switch (view)
	            {
	                case 'd':
	                    return {
	                        inGrid: false,
	                        inBookLayout: false
	                    };
	
	                case 'b':
	                    return {
	                        inGrid: false,
	                        inBookLayout: true
	                    };
	
	                case 'g':
	                    return {
	                        inGrid: true,
	                        inBookLayout: false
	                    };
	
	                default:
	                    return null;
	            }
	        };
	
	        var showError = function(message)
	        {
	            divaState.viewerCore.showError(message);
	        };
	
	        var ajaxError = function(jqxhr, status, error)
	        {
	            // Show a basic error message within the document viewer pane
	
	            var errorMessage = ['Invalid objectData setting. Error code: ' + jqxhr.status + ' ' + error];
	
	            // Detect and handle CORS errors
	            var dataHasAbsolutePath = settings.objectData.lastIndexOf('http', 0) === 0;
	
	            if (dataHasAbsolutePath && error === '')
	            {
	                var jsonHost = settings.objectData.replace(/https?:\/\//i, "").split(/[/?#]/)[0];
	
	                if (location.hostname !== jsonHost)
	                {
	                    errorMessage.push(
	                        elt('p', 'Attempted to access cross-origin data without CORS.'),
	                        elt('p',
	                            'You may need to update your server configuration to support CORS. For help, see the ',
	                            elt('a', {
	                                href: 'https://github.com/DDMAL/diva.js/wiki/Installation#a-note-about-cross-site-requests',
	                                target: '_blank'
	                            }, 'cross-site request documentation.')
	                        )
	                    );
	                }
	            }
	
	            showError(errorMessage);
	        };
	
	        var loadObjectData = function (responseData, hashState)
	        {
	            var manifest;
	
	            // TODO improve IIIF detection method
	            if (!responseData.hasOwnProperty('@context') && (responseData['@context'].indexOf('iiif') === -1 || responseData['@context'].indexOf('shared-canvas') === -1))
	            {
	                throw new NotAnIIIFManifestException('This does not appear to be a IIIF Manifest.');
	            }
	
	            // trigger ManifestDidLoad event
	            // FIXME: Why is this triggered before the manifest is parsed? See https://github.com/DDMAL/diva.js/issues/357
	            diva.Events.publish('ManifestDidLoad', [responseData], self);
	
	            manifest = ImageManifest.fromIIIF(responseData);
	            var loadOptions = hashState ? getLoadOptionsForState(hashState, manifest) : {};
	
	            divaState.viewerCore.setManifest(manifest, loadOptions);
	        };
	
	        /** Parse the hash parameters into the format used by getState and setState */
	        var getHashParamState = function ()
	        {
	            var state = {};
	
	            ['f', 'v', 'z', 'n', 'i', 'p', 'y', 'x'].forEach(function (param)
	            {
	                var value = HashParams.get(param + settings.hashParamSuffix);
	
	                // `false` is returned if the value is missing
	                if (value !== false)
	                    state[param] = value;
	            });
	
	            // Do some awkward special-casing, since this format is kind of weird.
	
	            // For inFullscreen (f), true and false strings should be interpreted
	            // as booleans.
	            if (state.f === 'true')
	                state.f = true;
	            else if (state.f === 'false')
	                state.f = false;
	
	            // Convert numerical values to integers, if provided
	            ['z', 'n', 'p', 'x', 'y'].forEach(function (param)
	            {
	                if (param in state)
	                    state[param] = parseInt(state[param], 10);
	            });
	
	            return state;
	        };
	
	        var checkLoaded = function()
	        {
	            if (!viewerState.loaded)
	            {
	                console.warn("The viewer is not completely initialized. This is likely because it is still downloading data. To fix this, only call this function if the isReady() method returns true.");
	                return false;
	            }
	            return true;
	        };
	
	        var init = function ()
	        {
	            // In order to fill the height, use a wrapper div displayed using a flexbox layout
	            var wrapperElement = elt('div', {
	                class: "diva-wrapper" + (options.fillParentHeight ? " diva-wrapper-flexbox" : "")
	            });
	            element.appendChild(wrapperElement);
	            options.toolbarParentObject = options.toolbarParentObject || $(wrapperElement);
	
	            var viewerCore = new ViewerCore(wrapperElement, options, self);
	
	            viewerState = viewerCore.getInternalState();
	            settings = viewerCore.getSettings();
	
	            // Add the ID to the wrapper element now that the ID has been generated by the viewer core
	            wrapperElement.id = settings.ID + 'wrapper';
	
	            divaState = {
	                viewerCore: viewerCore,
	                toolbar: settings.enableToolbar ? createToolbar(self) : null
	            };
	
	            var hashState = getHashParamState();
	
	            if (typeof settings.objectData === 'object')
	            {
	                // Defer execution until initialization has completed
	                setTimeout(function ()
	                {
	                    loadObjectData(settings.objectData, hashState);
	                }, 0);
	            }
	            else
	            {
	                var pendingManifestRequest = $.ajax({
	                    url: settings.objectData,
	                    cache: true,
	                    dataType: 'json',
	                    error: ajaxError,
	                    success: function (responseData)
	                    {
	                        loadObjectData(responseData, hashState);
	                    }
	                });
	
	                // Store the pending request so that it can be cancelled in the event that Diva needs to be destroyed
	                viewerCore.setPendingManifestRequest(pendingManifestRequest);
	            }
	        };
	
	        /* PUBLIC FUNCTIONS
	        ===============================================
	        */
	
	        // Returns the title of the document, based on the directory name
	        this.getItemTitle = function ()
	        {
	            return settings.manifest.itemTitle;
	        };
	
	        // Go to a particular page by its page number (with indexing starting at 1)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page number passed is valid; false if it is not.
	        this.gotoPageByNumber = function (pageNumber, xAnchor, yAnchor)
	        {
	            console.warn("This method is deprecated. Consider using gotoPageByIndex(pageIndex, xAnchor, yAnchor) instead.");
	            var pageIndex = parseInt(pageNumber, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Go to a particular page (with indexing starting at 0)
	            //xAnchor may either be "left", "right", or default "center"; the (xAnchor) side of the page will be anchored to the (xAnchor) side of the diva-outer element
	            //yAnchor may either be "top", "bottom", or default "center"; same process as xAnchor.
	        // returns True if the page index is valid; false if it is not.
	        this.gotoPageByIndex = function (pageIndex, xAnchor, yAnchor)
	        {
	            pageIndex = parseInt(pageIndex, 10);
	
	            if (isPageValid(pageIndex))
	            {
	                var xOffset = divaState.viewerCore.getXOffset(pageIndex, xAnchor);
	                var yOffset = divaState.viewerCore.getYOffset(pageIndex, yAnchor);
	
	                viewerState.renderer.goto(pageIndex, yOffset, xOffset);
	                return true;
	            }
	
	            return false;
	        };
	
	        this.getNumberOfPages = function ()
	        {
	            if (!checkLoaded())
	                return false;
	
	            return settings.numPages;
	        };
	
	        // Get page dimensions in the current view and zoom level
	        this.getPageDimensions = function (pageIndex)
	        {
	            if (!checkLoaded())
	                return null;
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of a given page index at a given zoom level
	        this.getPageDimensionsAtZoomLevel = function (pageIdx, zoomLevel)
	        {
	            if (!checkLoaded())
	                return false;
	
	            if (zoomLevel > settings.maxZoomLevel)
	                zoomLevel = settings.maxZoomLevel;
	
	            var pg = settings.manifest.pages[parseInt(pageIdx, 10)];
	            var pgAtZoom = pg.d[parseInt(zoomLevel, 10)];
	            return {'width': pgAtZoom.w, 'height': pgAtZoom.h};
	        };
	
	        // Returns the dimensions of a given page at the current zoom level
	        // The current page index will be used if no pageIndex is specified
	        // Also works in Grid view
	        this.getPageDimensionsAtCurrentZoomLevel = function(pageIndex)
	        {
	            pageIndex = isPageValid(pageIndex) ? pageIndex : settings.currentPageIndex;
	
	            if (!isPageValid(pageIndex))
	                throw new Error('Invalid Page Index');
	
	            return divaState.viewerCore.getCurrentLayout().getPageDimensions(pageIndex);
	        };
	
	        // Returns the dimensions of the current page at the current zoom level
	        // Also works in Grid view
	        this.getCurrentPageDimensionsAtCurrentZoomLevel = function ()
	        {
	            return this.getPageDimensionsAtCurrentZoomLevel(settings.currentPageIndex);
	        };
	
	        this.isReady = function ()
	        {
	            return viewerState.loaded;
	        };
	
	        this.getCurrentPageIndex = function ()
	        {
	            return settings.currentPageIndex;
	        };
	
	        this.getCurrentPageFilename = function ()
	        {
	            return settings.manifest.pages[settings.currentPageIndex].f;
	        };
	
	        this.getCurrentCanvas = function (settings)
	        {
	            return settings.manifest.pages[settings.currentPageIndex].canvas;
	        };
	
	        this.getCurrentPageNumber = function ()
	        {
	            console.warn("This method is deprecated. Consider using getCurrentPageIndex() instead.");
	            return settings.currentPageIndex + 1;
	        };
	
	        // Returns an array of all filenames in the document
	        this.getFilenames = function ()
	        {
	            var filenames = [];
	
	            for (var i = 0; i < settings.numPages; i++)
	            {
	                filenames[i] = settings.manifest.pages[i].f;
	            }
	
	            return filenames;
	        };
	
	        // Returns the current zoom level
	        this.getZoomLevel = function ()
	        {
	            return settings.zoomLevel;
	        };
	
	        // gets the maximum zoom level for the entire document
	        this.getMaxZoomLevel = function ()
	        {
	            return settings.maxZoomLevel;
	        };
	
	        // gets the max zoom level for a given page
	        this.getMaxZoomLevelForPage = function (pageIdx)
	        {
	            if (!checkLoaded)
	                return false;
	
	            return settings.manifest.pages[pageIdx].m;
	        };
	
	        this.getMinZoomLevel = function ()
	        {
	            return settings.minZoomLevel;
	        };
	
	        // Use the provided zoom level (will check for validity first)
	        // Returns false if the zoom level is invalid, true otherwise
	        this.setZoomLevel = function (zoomLevel)
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({
	                    inGrid: false
	                });
	            }
	
	            return divaState.viewerCore.zoom(zoomLevel);
	        };
	
	        this.getGridPagesPerRow = function ()
	        {
	            // TODO(wabain): Add test case
	            return this.pagesPerRow;
	        };
	
	        this.setGridPagesPerRow = function (newValue)
	        {
	            // TODO(wabain): Add test case
	            if (!divaState.viewerCore.isValidOption('pagesPerRow', newValue))
	                return false;
	
	            return reloadViewer({
	                inGrid: true,
	                pagesPerRow: newValue
	            });
	        };
	
	        // Zoom in. Will return false if it's at the maximum zoom
	        this.zoomIn = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel + 1);
	        };
	
	        // Zoom out. Will return false if it's at the minimum zoom
	        this.zoomOut = function ()
	        {
	            return this.setZoomLevel(settings.zoomLevel - 1);
	        };
	
	        // Check if something (e.g. a highlight box on a particular page) is visible
	        this.isRegionInViewport = function (pageIndex, leftOffset, topOffset, width, height)
	        {
	            var layout = divaState.viewerCore.getCurrentLayout();
	
	            if (!layout)
	                return false;
	
	            var offset = layout.getPageOffset(pageIndex);
	
	            var top = offset.top + topOffset;
	            var left = offset.left + leftOffset;
	
	            return viewerState.viewport.intersectsRegion({
	                top: top,
	                bottom: top + height,
	                left: left,
	                right: left + width
	            });
	        };
	
	        //Public wrapper for isPageVisible
	        //Determines if a page is currently in the viewport
	        this.isPageInViewport = function (pageIndex)
	        {
	            return viewerState.renderer.isPageVisible(pageIndex);
	        };
	
	        //Public wrapper for isPageLoaded
	        //Determines if a page is currently in the DOM
	        this.isPageLoaded = function (pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using isPageInViewport(pageIndex) instead.");
	            return this.isPageInViewport(pageIndex);
	        };
	
	        // Toggle fullscreen mode
	        this.toggleFullscreenMode = function ()
	        {
	            toggleFullscreen();
	        };
	
	        // Show/Hide non-paged pages
	        this.toggleNonPagedPagesVisibility = function ()
	        {
	            reloadViewer({ showNonPagedPages: !settings.showNonPagedPages });
	        };
	
	        // Show non-paged pages
	        this.showNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: true });
	        };
	
	        // Hide non-paged pages
	        this.hideNonPagedPages = function ()
	        {
	            reloadViewer({ showNonPagedPages: false });
	        };
	
	        // Close toolbar popups
	        this.closePopups = function ()
	        {
	            divaState.toolbar.closePopups();
	        };
	
	        // Enter fullscreen mode if currently not in fullscreen mode
	        // Returns false if in fullscreen mode initially, true otherwise
	        // This function will work even if enableFullscreen is set to false
	        this.enterFullscreenMode = function ()
	        {
	            if (!settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave fullscreen mode if currently in fullscreen mode
	        // Returns true if in fullscreen mode intitially, false otherwise
	        this.leaveFullscreenMode = function ()
	        {
	            if (settings.inFullscreen)
	            {
	                toggleFullscreen();
	                return true;
	            }
	
	            return false;
	        };
	
	        this.isInFullscreen = function ()
	        {
	            return settings.inFullscreen;
	        };
	
	        // Change views. Takes 'document', 'book', or 'grid' to specify which view to switch into
	        this.changeView = function(destinationView)
	        {
	            return changeView(destinationView);
	        };
	
	        // Enter grid view if currently not in grid view
	        // Returns false if in grid view initially, true otherwise
	        this.enterGridView = function ()
	        {
	            if (!settings.inGrid)
	            {
	                changeView('grid');
	                return true;
	            }
	
	            return false;
	        };
	
	        // Leave grid view if currently in grid view
	        // Returns true if in grid view initially, false otherwise
	        this.leaveGridView = function ()
	        {
	            if (settings.inGrid)
	            {
	                reloadViewer({ inGrid: false });
	                return true;
	            }
	
	            return false;
	        };
	
	        // Jump to a page based on its filename
	        // Returns true if successful and false if the filename is invalid
	        this.gotoPageByName = function (filename, xAnchor, yAnchor)
	        {
	            var pageIndex = getPageIndex(filename);
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        this.gotoPageByLabel = function (label, xAnchor, yAnchor)
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0, len = pages.length; i < len; i++)
	            {
	                if (pages[i].l.toLowerCase().indexOf(label.toLowerCase()) > -1)
	                    return this.gotoPageByIndex(i, xAnchor, yAnchor);
	            }
	
	            // If no label was found, try to parse a page number
	            var pageIndex = parseInt(label, 10) - 1;
	            return this.gotoPageByIndex(pageIndex, xAnchor, yAnchor);
	        };
	
	        // Get the page index (0-based) corresponding to a given filename
	        // If the page index doesn't exist, this will return -1
	        this.getPageIndex = function (filename)
	        {
	            return getPageIndex(filename);
	        };
	
	        // Get the current URL (exposes the private method)
	        this.getCurrentURL = function ()
	        {
	            return getCurrentURL();
	        };
	
	        // Check if a page index is within the range of the document
	        this.isPageIndexValid = function (pageIndex)
	        {
	            return isPageValid(pageIndex);
	        };
	
	        // Get the hash part only of the current URL (without the leading #)
	        this.getURLHash = function ()
	        {
	            return getURLHash();
	        };
	
	        // Get an object representing the state of this diva instance (for setState)
	        this.getState = function ()
	        {
	            return getState();
	        };
	
	        // Align this diva instance with a state object (as returned by getState)
	        this.setState = function (state)
	        {
	            reloadViewer(getLoadOptionsForState(state));
	        };
	
	        // Get the instance selector for this instance, since it's auto-generated.
	        this.getInstanceSelector = function ()
	        {
	            return settings.selector;
	        };
	
	        // Get the instance ID -- essentially the selector without the leading '#'.
	        this.getInstanceId = function ()
	        {
	            return settings.ID;
	        };
	
	        this.getSettings = function ()
	        {
	            return settings;
	        };
	
	        /*
	            Translates a measurement from the zoom level on the largest size
	            to one on the current zoom level.
	
	            For example, a point 1000 on an image that is on zoom level 2 of 5
	            translates to a position of 111.111... (1000 / (5 - 2)^2).
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 1000 pixels wide on the original to one that is 111.111 pixels wide
	            on the current zoom level).
	        */
	        this.translateFromMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	            return position / Math.pow(2, zoomDifference);
	        };
	
	        /*
	            Translates a measurement from the current zoom level to the position on the
	            largest zoom level.
	
	            Works for a single pixel co-ordinate or a dimension (e.g., translates a box
	            that is 111.111 pixels wide on the current image to one that is 1000 pixels wide
	            on the current zoom level).
	        */
	        this.translateToMaxZoomLevel = function (position)
	        {
	            var zoomDifference = settings.maxZoomLevel - settings.zoomLevel;
	
	            // if there is no difference, it's a box on the max zoom level and
	            // we can just return the position.
	            if (zoomDifference === 0)
	                return position;
	
	            return position * Math.pow(2, zoomDifference);
	        };
	
	        // Re-enables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.enableScrollable = function()
	        {
	            divaState.viewerCore.enableScrollable();
	        };
	
	        // Disables document dragging, scrolling (by keyboard if set), and zooming by double-clicking
	        this.disableScrollable = function ()
	        {
	            divaState.viewerCore.disableScrollable();
	        };
	
	        //Changes between horizontal layout and vertical layout. Returns true if document is now vertically oriented, false otherwise.
	        this.toggleOrientation = function ()
	        {
	            return toggleOrientation();
	        };
	
	        //Returns distance between the northwest corners of diva-inner and page index
	        this.getPageOffset = function(pageIndex, options)
	        {
	            var region = divaState.viewerCore.getPageRegion(pageIndex, options);
	
	            return {
	                top: region.top,
	                left: region.left
	            };
	        };
	
	        //shortcut to getPageOffset for current page
	        this.getCurrentPageOffset = function()
	        {
	            return this.getPageOffset(settings.currentPageIndex);
	        };
	
	        //Returns the page dimensions of given page at the current zoom level
	        this.getPageDimensionsAtCurrentGridLevel = function(pageIndex)
	        {
	            console.warn("This method is deprecated. Consider using getPageDimensionsAtCurrentZoomLevel(pageIndex) instead.");
	            return this.getPageDimensionsAtCurrentZoomLevel(pageIndex);
	        };
	
	        /*
	            Given a pageX and pageY value (as could be retreived from a jQuery event object),
	                returns either the page visible at that (x,y) position or -1 if no page is.
	        */
	        this.getPageIndexForPageXYValues = function(pageX, pageY)
	        {
	            //get the four edges of the outer element
	            var outerOffset = viewerState.outerElement.getBoundingClientRect();
	            var outerTop = outerOffset.top;
	            var outerLeft = outerOffset.left;
	            var outerBottom = outerOffset.bottom;
	            var outerRight = outerOffset.right;
	
	            //if the clicked position was outside the diva-outer object, it was not on a visible portion of a page
	            if (pageX < outerLeft || pageX > outerRight)
	                return -1;
	
	            if (pageY < outerTop || pageY > outerBottom)
	                return -1;
	
	            //navigate through all diva page objects
	            var pages = document.getElementsByClassName('diva-page');
	            var curPageIdx = pages.length;
	            while (curPageIdx--)
	            {
	                //get the offset for each page
	                var curPage = pages[curPageIdx];
	                var curOffset = curPage.getBoundingClientRect();
	
	                //if this point is outside the horizontal boundaries of the page, continue
	                if (pageX < curOffset.left || pageX > curOffset.right)
	                    continue;
	
	                //same with vertical boundaries
	                if (pageY < curOffset.top || pageY > curOffset.bottom)
	                    continue;
	
	                //if we made it through the above two, we found the page we're looking for
	                return curPage.getAttribute('data-index');
	            }
	
	            //if we made it through that entire while loop, we didn't click on a page
	            return -1;
	        };
	
	        /*
	        *   Given a set of clientX, clientY co-ordinates, returns an object
	        *
	        **/
	        this.getPageCoordinatesHit = function(clientX, clientY)
	        {
	            if (viewerState.renderer)
	            {
	                return viewerState.renderer.getPageHit(clientX, clientY);
	            }
	
	            return null;
	        };
	
	        /**
	         * Returns a URL for the image of the page at the given index. The
	         * optional size parameter supports setting the image width or height
	         * (default is full-sized).
	         */
	        this.getPageImageURL = function (pageIndex, size)
	        {
	            return settings.manifest.getPageImageURL(pageIndex, size);
	        };
	
	        //Pretty self-explanatory.
	        this.isVerticallyOriented = function()
	        {
	            return settings.verticallyOriented;
	        };
	
	        this.changeObject = function(objectData)
	        {
	            viewerState.loaded = false;
	            divaState.viewerCore.clear();
	
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            viewerState.options.objectData = objectData;
	
	            if (typeof objectData === 'object')
	            {
	                setTimeout(function ()
	                {
	                    loadObjectData(objectData);
	                });
	
	                return;
	            }
	
	            viewerState.throbberTimeoutID = setTimeout(function ()
	            {
	                $(settings.selector + 'throbber').show();
	            }, settings.throbberTimeout);
	
	            $.ajax({
	                url: settings.objectData,
	                cache: true,
	                dataType: 'json',
	                error: ajaxError,
	                success: function (responseData)
	                {
	                    loadObjectData(responseData);
	                }
	            });
	        };
	
	        this.activate = function ()
	        {
	            viewerState.isActiveDiva = true;
	        };
	
	        this.deactivate = function ()
	        {
	            viewerState.isActiveDiva = false;
	        };
	
	        // Destroys this instance, tells plugins to do the same (for testing)
	        this.destroy = function ()
	        {
	            divaState.viewerCore.destroy();
	        };
	
	        // "Secretly" expose the page overlay API for the highlight plugin
	        this.__addPageOverlay = function (overlay)
	        {
	            divaState.viewerCore.addPageOverlay(overlay);
	        };
	
	        this.__removePageOverlay = function (overlay)
	        {
	            divaState.viewerCore.removePageOverlay(overlay);
	        };
	
	        /**** Page Alias Functions ****/
	        /*
	         Main function. Will return the first of these three that
	         resolves to boolean true:
	         -Explicit alias as defined in pageAliases
	         -Result of pageAliasFunction
	         -originalPageIndex + 1 (to simulate the original mapping)
	
	         Else the function will return false.
	         */
	        this.getAliasForPageIndex = function(originalPageIndex)
	        {
	            var pageIndex = parseInt(originalPageIndex, 10);
	            return settings.pageAliases[pageIndex] || settings.pageAliasFunction(pageIndex) || pageIndex + 1;
	        };
	
	        /*
	         Returns the first page index found for a given aliased number or false if not found.
	         This may cause issues if a specific alias is found for multiple page indices; use getPageIndicesForAlias and reimplement functions as necessary if this is the case.
	         */
	        this.getPageIndexForAlias = function(aliasedNumber)
	        {
	            for(var idx = 0; idx < settings.numPages; idx++)
	            {
	                if(this.getAliasForPageIndex(idx) === aliasedNumber)
	                {
	                    return idx;
	                }
	            }
	            return false;
	        };
	
	        //Returns array of page indices for a given aliased number. Returns an empty array if none are found.
	        this.getPageIndicesForAlias = function(aliasedNumber)
	        {
	            var indexArr = [];
	            for(var idx = 0; idx < settings.numPages; idx++)
	            {
	                if(this.getAliasForPageIndex(idx) === aliasedNumber)
	                {
	                    indexArr.push(idx);
	                }
	            }
	            return indexArr;
	        };
	
	
	        //Maps the current page index to getAliasForPageIndex
	        this.getCurrentAliasedPageIndex = function()
	        {
	            return this.getAliasForPageIndex(settings.currentPageIndex);
	        };
	
	        //Wrapper for gotoPageByIndex, keeping the aliased numbers in mind
	        this.gotoPageByAliasedNumber = function(aliasedNumber, xAnchor, yAnchor)
	        {
	            return this.gotoPageByIndex(this.getPageIndexForAlias(aliasedNumber), xAnchor, yAnchor);
	        };
	
	        // Call the init function when this object is created.
	        init();
	    };
	
	    $.fn.diva = function (options)
	    {
	        return this.each(function ()
	        {
	            var divaParent = $(this);
	
	            // Return early if this element already has a plugin instance
	            if (divaParent.data('diva'))
	                return;
	
	            // Throw an error if the element is not in the DOM, since it causes some problems
	            if (!document.body.contains(this))
	                throw new Error('Diva could not be initialized because this element is not attached to the DOM');
	
	            // Otherwise, instantiate the document viewer
	            var diva = new Diva(this, options);
	            divaParent.data('diva', diva);
	        });
	    };
	})(jQuery);


/***/ }),
/* 8 */
/***/ (function(module, exports) {

	(function () {
	  if (Array.prototype.fill) return;
	
	  var fill = function (value) {
	    // Steps 1-2.
	    if (this == null) {
	      throw new TypeError("this is null or not defined");
	    }
	
	    var O = Object(this);
	
	    // Steps 3-5.
	    var len = O.length >>> 0;
	
	    // Steps 6-7.
	    var start = arguments[1];
	    var relativeStart = start >> 0;
	
	    // Step 8.
	    var k = relativeStart < 0 ?
	      Math.max(len + relativeStart, 0) :
	      Math.min(relativeStart, len);
	
	    // Steps 9-10.
	    var end = arguments[2];
	    var relativeEnd = end === undefined ?
	      len : end >> 0;
	
	    // Step 11.
	    var last = relativeEnd < 0 ?
	      Math.max(len + relativeEnd, 0) :
	      Math.min(relativeEnd, len);
	
	    // Step 12.
	    while (k < last) {
	      O[k] = value;
	      k++;
	    }
	
	    // Step 13.
	    return O;
	  };
	
	  if (Object.defineProperty) {
	    try {
	      Object.defineProperty(Array.prototype, 'fill', {
	        value: fill,
	        configurable: true,
	        enumerable: false,
	        writable: true
	      });
	    } catch(e) {}
	  }
	
	  if (!Array.prototype.fill) {
	    Array.prototype.fill = fill;
	  }
	})(this);


/***/ }),
/* 9 */
/***/ (function(module, exports) {

	module.exports = elt;
	module.exports.setAttributes = setDOMAttributes;
	
	/**
	 * Convenience function to create a DOM element, set attributes on it, and
	 * append children. All arguments which are not of primitive type, are not
	 * arrays, and are not DOM nodes are treated as attribute hashes and are
	 * handled as described for setDOMAttributes. Children can either be a DOM
	 * node or a primitive value, which is converted to a text node. Arrays are
	 * handled recursively. Null and undefined values are ignored.
	 *
	 * Inspired by the ProseMirror helper of the same name.
	 */
	function elt(tag)
	{
	    var el = document.createElement(tag);
	    var args = Array.prototype.slice.call(arguments, 1);
	
	    while (args.length)
	    {
	        var arg = args.shift();
	        handleEltConstructorArg(el, arg);
	    }
	
	    return el;
	}
	
	function handleEltConstructorArg(el, arg)
	{
	    if (arg == null)
	        return;
	
	    if (typeof arg !== 'object' && typeof arg !== 'function')
	    {
	        // Coerce to string
	        el.appendChild(document.createTextNode(arg));
	    }
	    else if (arg instanceof window.Node)
	    {
	        el.appendChild(arg);
	    }
	    else if (arg instanceof Array)
	    {
	        var childCount = arg.length;
	        for (var i = 0; i < childCount; i++)
	            handleEltConstructorArg(el, arg[i]);
	    }
	    else
	    {
	        setDOMAttributes(el, arg);
	    }
	}
	
	/**
	 * Set attributes of a DOM element. The `style` property is special-cased to
	 * accept either a string or an object whose own attributes are assigned to
	 * el.style.
	 */
	function setDOMAttributes(el, attributes)
	{
	    for (var prop in attributes)
	    {
	        if (!attributes.hasOwnProperty(prop))
	            continue;
	
	        if (prop === 'style')
	        {
	            setStyle(el, attributes.style);
	        }
	        else
	        {
	            el.setAttribute(prop, attributes[prop]);
	        }
	    }
	}
	
	function setStyle(el, style)
	{
	    if (!style)
	        return;
	
	    if (typeof style !== 'object')
	    {
	        el.style.cssText = style;
	        return;
	    }
	
	    for (var cssProp in style)
	    {
	        if (!style.hasOwnProperty(cssProp))
	            continue;
	
	        el.style[cssProp] = style[cssProp];
	    }
	}


/***/ }),
/* 10 */
/***/ (function(module, exports) {

	module.exports.get = getHashParam;
	module.exports.update = updateHashParam;
	
	// For getting the #key values from the URL. For specifying a page and zoom level
	// Look into caching, because we only need to get this during the initial load
	// Although for the tests I guess we would need to override caching somehow
	function getHashParam(key) {
	    var hash = window.location.hash;
	    if (hash !== '') {
	        // Check if there is something that looks like either &key= or #key=
	        var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	
	        // If startIndex is still -1, it means it can't find either
	        if (startIndex >= 0) {
	            // Add the length of the key plus the & and =
	            startIndex += key.length + 2;
	
	            // Either to the next ampersand or to the end of the string
	            var endIndex = hash.indexOf('&', startIndex);
	            if (endIndex > startIndex) {
	                return decodeURIComponent(hash.substring(startIndex, endIndex));
	            } else if (endIndex < 0) {
	                // This means this hash param is the last one
	                return decodeURIComponent(hash.substring(startIndex));
	            }
	            // If the key doesn't have a value I think
	            return '';
	        } else {
	            // If it can't find the key
	            return false;
	        }
	    } else {
	        // If there are no hash params just return false
	        return false;
	    }
	}
	
	function updateHashParam(key, value) {
	    // First make sure that we have to do any work at all
	    var originalValue = getHashParam(key);
	    var hash = window.location.hash;
	    if (originalValue !== value) {
	        // Is the key already in the URL?
	        if (typeof originalValue == 'string') {
	            // Already in the URL. Just get rid of the original value
	            var startIndex = (hash.indexOf('&' + key + '=') > 0) ? hash.indexOf('&' + key + '=') : hash.indexOf('#' + key + '=');
	            var endIndex = startIndex + key.length + 2 + originalValue.length;
	            // # if it's the first, & otherwise
	            var startThing = (startIndex === 0) ? '#' : '&';
	            window.location.replace(hash.substring(0, startIndex) + startThing + key + '=' + value + hash.substring(endIndex));
	        } else {
	            // It's not present - add it
	            if (hash.length === 0) {
	                window.location.replace('#' + key + '=' + value);
	            } else {
	                // Append it
	                window.location.replace(hash + '&' + key + '=' + value);
	            }
	        }
	    }
	}


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	var jQuery = __webpack_require__(3);
	
	//Used to keep track of whether Diva was last clicked or which Diva was last clicked when there are multiple
	var ActiveDivaController = (function ($)
	{
	    return function ()
	    {
	        var active;
	
	        //global click listener
	        $(document).on('click', function(e)
	        {
	            updateActive($(e.target));
	        });
	
	        //parameter should already be a jQuery selector
	        var updateActive = function (target)
	        {
	            var nearestOuter;
	
	            //these will find 0 or 1 objects, never more
	            var findOuter = target.find('.diva-outer');
	            var closestOuter = target.closest('.diva-outer');
	            var outers = document.getElementsByClassName('diva-outer');
	            var outerLen = outers.length;
	            var idx;
	
	            //clicked on something that was not either a parent or sibling of a diva-outer
	            if (findOuter.length > 0)
	            {
	                nearestOuter = findOuter;
	            }
	            //clicked on something that was a child of a diva-outer
	            else if (closestOuter.length > 0)
	            {
	                nearestOuter = closestOuter;
	            }
	            //clicked on something that was not in any Diva tree
	            else
	            {
	                //deactivate everything and return
	                for (idx = 0; idx < outerLen; idx++)
	                {
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	                }
	                return;
	            }
	
	            //if we found one, activate it...
	            nearestOuter.parent().parent().data('diva').activate();
	            active = nearestOuter.parent();
	
	            //...and deactivate all the others
	            outers = document.getElementsByClassName('diva-outer');
	            for(idx = 0; idx < outerLen; idx++)
	            {
	                //getAttribute to attr - comparing DOM element to jQuery element
	                if (outers[idx].getAttribute('id') != nearestOuter.attr('id'))
	                    $(outers[idx].parentElement.parentElement).data('diva').deactivate();
	            }
	        };
	
	        //public accessor in case. Will return a jQuery selector.
	        this.getActive = function()
	        {
	            return active;
	        };
	    };
	})(jQuery);
	
	module.exports = ActiveDivaController;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* jshint unused: true */
	
	var parseIIIFManifest = __webpack_require__(13);
	
	module.exports = ImageManifest;
	
	function ImageManifest(data, urlAdapter)
	{
	    // Save all the data we need
	    this.pages = data.pgs;
	    this.maxZoom = data.max_zoom;
	    this.maxRatio = data.dims.max_ratio;
	    this.minRatio = data.dims.min_ratio;
	    this.itemTitle = data.item_title;
	
	    // Only given for IIIF manifests
	    this.paged = !!data.paged;
	
	    // These are arrays, the index corresponding to the zoom level
	    this._maxWidths = data.dims.max_w;
	    this._maxHeights = data.dims.max_h;
	    this._averageWidths = data.dims.a_wid;
	    this._averageHeights = data.dims.a_hei;
	    this._totalHeights = data.dims.t_hei;
	    this._totalWidths = data.dims.t_wid;
	
	    this._urlAdapter = urlAdapter;
	}
	
	ImageManifest.fromIIIF = function (iiifManifest)
	{
	    var data = parseIIIFManifest(iiifManifest);
	    return new ImageManifest(data, new IIIFSourceAdapter());
	};
	
	ImageManifest.fromLegacyManifest = function (data, config)
	{
	    // For IIP manifests, use the page number (indexed starting from 1) as a label for each page
	    for (var i = 0, len = data.pgs.length; i < len; i++)
	        data.pgs[i].l = (i + 1).toString();
	
	    return new ImageManifest(data, new LegacyManifestSourceAdapter(config));
	};
	
	ImageManifest.prototype.isPageValid = function (pageIndex, showNonPagedPages)
	{
	    if (!showNonPagedPages && this.paged && !this.pages[pageIndex].paged)
	        return false;
	
	    return pageIndex >= 0 && pageIndex < this.pages.length;
	};
	
	ImageManifest.prototype.getMaxPageDimensions = function (pageIndex)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    return {
	        height: maxDims.h,
	        width: maxDims.w
	    };
	};
	
	ImageManifest.prototype.getPageDimensionsAtZoomLevel = function (pageIndex, zoomLevel)
	{
	    var maxDims = this.pages[pageIndex].d[this.maxZoom];
	
	    var scaleRatio = getScaleRatio(this.maxZoom, zoomLevel);
	
	    return {
	        height: maxDims.h * scaleRatio,
	        width: maxDims.w * scaleRatio
	    };
	};
	
	/**
	 * Returns a URL for the image of the given page. The optional size
	 * parameter supports setting the image width or height (default is
	 * full-sized).
	 */
	ImageManifest.prototype.getPageImageURL = function (pageIndex, size)
	{
	    return this._urlAdapter.getPageImageURL(this, pageIndex, size);
	};
	
	/**
	 * Return an array of tile objects for the specified page and integer zoom level
	 */
	ImageManifest.prototype.getPageImageTiles = function (pageIndex, zoomLevel, tileDimensions)
	{
	    var page = this.pages[pageIndex];
	
	    if (!isFinite(zoomLevel) || zoomLevel % 1 !== 0)
	        throw new TypeError('Zoom level must be an integer: ' + zoomLevel);
	
	    var rows = Math.ceil(page.d[zoomLevel].h / tileDimensions.height);
	    var cols = Math.ceil(page.d[zoomLevel].w / tileDimensions.width);
	
	    var tiles = [];
	
	    var row, col, url;
	
	    for (row = 0; row < rows; row++)
	    {
	        for (col = 0; col < cols; col++)
	        {
	            url = this._urlAdapter.getTileImageURL(this, pageIndex, {
	                row: row,
	                col: col,
	                rowCount: rows,
	                colCount: cols,
	                zoomLevel: zoomLevel,
	                tileDimensions: tileDimensions
	            });
	
	            // FIXME: Dimensions should account for partial tiles (e.g. the
	            // last row and column in a tiled image)
	            tiles.push({
	                row: row,
	                col: col,
	                zoomLevel: zoomLevel,
	                dimensions: {
	                    height: tileDimensions.height,
	                    width: tileDimensions.width
	                },
	                offset: {
	                    top: row * tileDimensions.height,
	                    left: col * tileDimensions.width
	                },
	                url: url
	            });
	        }
	    }
	
	    return {
	        zoomLevel: zoomLevel,
	        rows: rows,
	        cols: cols,
	        tiles: tiles
	    };
	};
	
	ImageManifest.prototype.getMaxWidth = zoomedPropertyGetter('_maxWidths');
	ImageManifest.prototype.getMaxHeight = zoomedPropertyGetter('_maxHeights');
	ImageManifest.prototype.getAverageWidth = zoomedPropertyGetter('_averageWidths');
	ImageManifest.prototype.getAverageHeight = zoomedPropertyGetter('_averageHeights');
	ImageManifest.prototype.getTotalWidth = zoomedPropertyGetter('_totalWidths');
	ImageManifest.prototype.getTotalHeight = zoomedPropertyGetter('_totalHeights');
	
	function zoomedPropertyGetter(privateName)
	{
	    return function (zoomLevel)
	    {
	        return this[privateName][zoomLevel];
	    };
	}
	
	function getScaleRatio(sourceZoomLevel, targetZoomLevel)
	{
	    return 1 / Math.pow(2, sourceZoomLevel - targetZoomLevel);
	}
	
	function IIIFSourceAdapter()
	{
	    // No-op
	}
	
	IIIFSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    var dimens;
	
	    if (!size || (size.width == null && size.height == null))
	        dimens = 'full';
	    else
	        dimens = (size.width == null ? '' : size.width) + ',' + (size.height == null ? '' : size.height);
	
	    var page = manifest.pages[pageIndex];
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + 'full/' + dimens + '/0/' + quality + '.jpg');
	};
	
	IIIFSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	
	    var height, width;
	
	    if (params.row === params.rowCount - 1)
	        height = page.d[params.zoomLevel].h - (params.rowCount - 1) * params.tileDimensions.height;
	    else
	        height = params.tileDimensions.height;
	
	    if (params.col === params.colCount - 1)
	        width = page.d[params.zoomLevel].w - (params.colCount - 1) * params.tileDimensions.width;
	    else
	        width = params.tileDimensions.width;
	
	    var zoomDifference = Math.pow(2, manifest.maxZoom - params.zoomLevel);
	
	    var x = params.col * params.tileDimensions.width * zoomDifference;
	    var y = params.row * params.tileDimensions.height * zoomDifference;
	
	    if (page.hasOwnProperty('xoffset'))
	    {
	        x += page.xoffset;
	        y += page.yoffset;
	    }
	
	    var region = [x, y, width * zoomDifference, height * zoomDifference].join(',');
	
	    var quality = (page.api > 1.1) ? 'default' : 'native';
	
	    return encodeURI(page.url + region + '/' + width + ',' + height + '/0/' + quality + '.jpg');
	};
	
	function LegacyManifestSourceAdapter(config)
	{
	    this._config = config;
	}
	
	LegacyManifestSourceAdapter.prototype.getPageImageURL = function (manifest, pageIndex, size)
	{
	    // Without width or height specified, IIPImage defaults to full-size
	    var dimens = '';
	
	    if (size)
	    {
	        if (size.width != null)
	            dimens += '&WID=' + size.width;
	
	        if (size.height != null)
	            dimens += '&HEI=' + size.height;
	    }
	
	    var filename = manifest.pages[pageIndex].f;
	
	    return this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + filename + dimens + '&CVT=JPEG';
	};
	
	LegacyManifestSourceAdapter.prototype.getTileImageURL = function (manifest, pageIndex, params)
	{
	    var page = manifest.pages[pageIndex];
	    var requestedZoomLevel = params.zoomLevel + page.m - manifest.maxZoom;
	    var index = (params.row * params.colCount) + params.col;
	    var jtl = requestedZoomLevel + ',' + index;
	
	    return encodeURI(this._config.iipServerURL + "?FIF=" + this._config.imageDir + '/' + page.f + '&JTL=' + jtl + '&CVT=JPEG');
	};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

	/* jshint unused: true */
	
	module.exports = parseIIIFManifest;
	
	var getMaxZoomLevel = function (width, height)
	{
	    var largestDimension = Math.max(width, height);
	    return Math.ceil(Math.log((largestDimension + 1) / (256 + 1)) / Math.log(2));
	};
	
	var incorporateZoom = function (imageDimension, zoomDifference)
	{
	    return imageDimension / (Math.pow(2, zoomDifference));
	};
	
	var getOtherImageData = function(otherImages, lowestMaxZoom, canvasWidth, canvasHeight)
	{
	    return otherImages.map(
	        function (itm)
	        {
	            var w = itm.width || canvasWidth;
	            var h = itm.height || canvasHeight;
	
	            var dims = new Array(lowestMaxZoom + 1);
	            for (var j = 0; j < lowestMaxZoom + 1; j++)
	            {
	                dims[j] = {
	                    h: Math.floor(incorporateZoom(h, lowestMaxZoom - j)),
	                    w: Math.floor(incorporateZoom(w, lowestMaxZoom - j))
	                };
	            }
	            return {
	                label: itm.label || "",
	                dims: dims
	            };
	        }
	    );
	};
	
	/**
	 * Parses a IIIF Presentation API Manifest and converts it into a Diva.js-format object
	 * (See https://github.com/DDMAL/diva.js/wiki/Development-notes#data-received-through-ajax-request)
	 * (This is a client-side re-implementation of generate_json.py)
	 *
	 * @param {Object} manifest - an object that represents a valid IIIF manifest
	 * @returns {Object} divaServiceBlock - the data needed by Diva to show a view of a single document
	 */
	function parseIIIFManifest(manifest)
	{
	    var sequence = manifest.sequences[0];
	    var canvases = sequence.canvases;
	    var numCanvases = canvases.length;
	
	    var pages = new Array(canvases.length);
	
	    var thisCanvas, thisResource, thisImage, otherImages, context, url, info, imageAPIVersion,
	        width, height, maxZoom, canvas, label, imageLabel, zoomDimensions, widthAtCurrentZoomLevel,
	        heightAtCurrentZoomLevel;
	
	    var lowestMaxZoom = 100;
	    var maxRatio = 0;
	    var minRatio = 100;
	
	    // quickly determine the lowest possible max zoom level (i.e., the upper bound for images) across all canvases.
	    // while we're here, compute the global ratios as well.
	    for (var z = 0; z < numCanvases; z++)
	    {
	        var c = canvases[z];
	        var w = c.width;
	        var h = c.height;
	        var mz = getMaxZoomLevel(w, h);
	        var ratio = h / w;
	        maxRatio = Math.max(ratio, maxRatio);
	        minRatio = Math.min(ratio, minRatio);
	
	        lowestMaxZoom = Math.min(lowestMaxZoom, mz);
	    }
	
	    // Uint8Arrays are pre-initialized with zeroes. These ones need to be
	    // pre-initialized since we will do arithmetic and value checking on them
	    var totalWidths = new Array(lowestMaxZoom + 1).fill(0);
	    var totalHeights = new Array(lowestMaxZoom + 1).fill(0);
	    var maxWidths = new Array(lowestMaxZoom + 1).fill(0);
	    var maxHeights = new Array(lowestMaxZoom + 1).fill(0);
	
	    for (var i = 0; i < numCanvases; i++)
	    {
	        thisCanvas = canvases[i];
	        canvas = thisCanvas['@id'];
	        label = thisCanvas.label;
	        thisResource = thisCanvas.images[0].resource;
	
	        /*
	         * If a canvas has multiple images it will be encoded
	         * with a resource type of "oa:Choice". The primary image will be available
	         * on the 'default' key, with other images available under 'item.'
	         * */
	        if (thisResource['@type'] === "oa:Choice")
	        {
	            thisImage = thisResource.default;
	        }
	        else
	        {
	            thisImage = thisResource;
	        }
	
	        // Prioritize the canvas height / width first, since images may not have h/w
	        width = thisCanvas.width || thisImage.width;
	        height = thisCanvas.height || thisImage.height;
	        if (width <= 0 || height <= 0)
	        {
	            console.warn('Invalid width or height for canvas ' + label + '. Skipping');
	            continue;
	        }
	
	        maxZoom = getMaxZoomLevel(width, height);
	
	        if (thisResource.item)
	        {
	            otherImages = getOtherImageData(thisResource.item, lowestMaxZoom, width, height);
	        }
	
	        imageLabel = thisImage.label || null;
	
	        info = parseImageInfo(thisImage);
	        url = info.url.slice(-1) !== '/' ? info.url + '/' : info.url;  // append trailing slash to url if it's not there.
	
	        context = thisImage.service['@context'];
	
	        if (context === 'http://iiif.io/api/image/2/context.json')
	        {
	            imageAPIVersion = 2;
	        }
	        else if (context === 'http://library.stanford.edu/iiif/image-api/1.1/context.json')
	        {
	            imageAPIVersion = 1.1;
	        }
	        else
	        {
	            imageAPIVersion = 1.0;
	        }
	
	        zoomDimensions = new Array(lowestMaxZoom + 1);
	
	        for (var k = 0; k < lowestMaxZoom + 1; k++)
	        {
	            widthAtCurrentZoomLevel = Math.floor(incorporateZoom(width, lowestMaxZoom - k));
	            heightAtCurrentZoomLevel = Math.floor(incorporateZoom(height, lowestMaxZoom - k));
	            zoomDimensions[k] = {
	                h: heightAtCurrentZoomLevel,
	                w: widthAtCurrentZoomLevel
	            };
	
	            totalWidths[k] += widthAtCurrentZoomLevel;
	            totalHeights[k] += heightAtCurrentZoomLevel;
	            maxWidths[k] = Math.max(widthAtCurrentZoomLevel, maxWidths[k]);
	            maxHeights[k] = Math.max(heightAtCurrentZoomLevel, maxHeights[k]);
	        }
	
	        pages[i] = {
	            d: zoomDimensions,
	            m: maxZoom,
	            l: label,         // canvas label ('page 1, page 2', etc.)
	            il: imageLabel,   // default image label ('primary image', 'UV light', etc.)
	            f: info.url,
	            url: url,
	            api: imageAPIVersion,
	            paged: thisCanvas.viewingHint !== 'non-paged',
	            facingPages: thisCanvas.viewingHint === 'facing-pages',
	            canvas: canvas,
	            otherImages: otherImages,
	            xoffset: info.x || null,
	            yoffset: info.y || null
	        };
	    }
	
	    var averageWidths = new Array(lowestMaxZoom + 1);
	    var averageHeights = new Array(lowestMaxZoom + 1);
	
	    for (var a = 0; a < lowestMaxZoom + 1; a++)
	    {
	        averageWidths[a] = totalWidths[a] / numCanvases;
	        averageHeights[a] = totalHeights[a] / numCanvases;
	    }
	
	    var dims = {
	        a_wid: averageWidths,
	        a_hei: averageHeights,
	        max_w: maxWidths,
	        max_h: maxHeights,
	        max_ratio: maxRatio,
	        min_ratio: minRatio,
	        t_hei: totalHeights,
	        t_wid: totalWidths
	    };
	
	    return {
	        item_title: manifest.label,
	        dims: dims,
	        max_zoom: lowestMaxZoom,
	        pgs: pages,
	        paged: manifest.viewingHint === 'paged' || sequence.viewingHint === 'paged'
	    };
	}
	
	/**
	 * Takes in a resource block from a canvas and outputs the following information associated with that resource:
	 * - Image URL
	 * - Image region to be displayed
	 *
	 * @param {Object} resource - an object representing the resource block of a canvas section in a IIIF manifest
	 * @returns {Object} imageInfo - an object containing image URL and region
	 */
	function parseImageInfo(resource)
	{
	    var url = resource['@id'];
	    var fragmentRegex = /#xywh=([0-9]+,[0-9]+,[0-9]+,[0-9]+)/;
	    var xywh = '';
	    var stripURL = true;
	
	    if (/\/([0-9]+,[0-9]+,[0-9]+,[0-9]+)\//.test(url))
	    {
	        // if resource in image API format, extract region x,y,w,h from URL (after 4th slash from last)
	        // matches coordinates in URLs of the form http://www.example.org/iiif/book1-page1/40,50,1200,1800/full/0/default.jpg
	        var urlArray = url.split('/');
	        xywh = urlArray[urlArray.length - 4];
	    }
	    else if (fragmentRegex.test(url))
	    {
	        // matches coordinates of the style http://www.example.org/iiif/book1/canvas/p1#xywh=50,50,320,240
	        var result = fragmentRegex.exec(url);
	        xywh = result[1];
	    }
	    else if (resource.service && resource.service['@id'])
	    {
	        // assume canvas size based on image size
	        url = resource.service['@id'];
	        // this URL excludes region parameters so we don't need to remove them
	        stripURL = false;
	    }
	
	    if (stripURL)
	    {
	        // extract URL up to identifier (we eliminate the last 5 parameters: /region/size/rotation/quality.format)
	        url = url.split('/').slice(0, -4).join('/');
	    }
	
	    var imageInfo = {
	        url: url
	    };
	
	    if (xywh.length)
	    {
	        // parse into separate components
	        var dimensions = xywh.split(',');
	        imageInfo.x = parseInt(dimensions[0], 10);
	        imageInfo.y = parseInt(dimensions[1], 10);
	        imageInfo.w = parseInt(dimensions[2], 10);
	        imageInfo.h = parseInt(dimensions[3], 10);
	    }
	
	    return imageInfo;
	}


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	var diva = __webpack_require__(2);
	var elt = __webpack_require__(9);
	
	module.exports = createToolbar;
	
	function createToolbar(viewer)
	{
	    var settings = viewer.getSettings();
	
	    // FIXME(wabain): Temporarily copied from within Diva
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    /** Convenience function to subscribe to a Diva event */
	    var subscribe = function (event, callback)
	    {
	        diva.Events.subscribe(event, callback, settings.ID);
	    };
	
	    // Creates a toolbar button
	    var createButtonElement = function(name, label, callback)
	    {
	        var button = elt('button', {
	            type: 'button',
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-button',
	            title: label
	        });
	
	        if (callback)
	            button.addEventListener('click', callback, false);
	
	        return button;
	    };
	
	    // Higher-level function for creators of zoom and grid controls
	    var getResolutionControlCreator = function (config)
	    {
	        return function ()
	        {
	            var controls;
	
	            switch (settings[config.controllerSetting])
	            {
	                case 'slider':
	                    controls = config.createSlider();
	                    break;
	
	                case 'buttons':
	                    controls = config.createButtons();
	                    break;
	
	                default:
	                    // Don't display anything
	                    return null;
	            }
	
	            var wrapper = elt('span',
	                controls,
	                config.createLabel()
	            );
	
	            var updateWrapper = function ()
	            {
	                if (settings.inGrid === config.showInGrid)
	                    wrapper.style.display = 'inline';
	                else
	                    wrapper.style.display = 'none';
	            };
	
	            subscribe('ViewDidSwitch', updateWrapper);
	            subscribe('ObjectDidLoad', updateWrapper);
	
	            // Set initial value
	            updateWrapper();
	
	            return wrapper;
	        };
	    };
	
	    // Zoom controls
	    var createZoomControls = getResolutionControlCreator({
	        controllerSetting: 'enableZoomControls',
	        showInGrid: false,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('zoom-slider', {
	                step: 0.1,
	                value: settings.zoomLevel,
	                min: settings.minZoomLevel,
	                max: settings.maxZoomLevel
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var floatValue = parseFloat(this.value);
	                viewer.setZoomLevel(floatValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var floatValue = parseFloat(this.value);
	                if (floatValue !== settings.zoomLevel)
	                    viewer.setZoomLevel(floatValue);
	            });
	
	            var updateSlider = function ()
	            {
	                if (settings.zoomLevel !== $elem.val())
	                    $elem.val(settings.zoomLevel);
	            };
	
	            subscribe('ZoomLevelDidChange', updateSlider);
	            subscribe('ViewerDidLoad', function ()
	            {
	                elt.setAttributes(elem, {
	                    min: settings.minZoomLevel,
	                    max: settings.maxZoomLevel
	                });
	
	                updateSlider();
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('zoom-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel - 1);
	                }),
	                createButtonElement('zoom-in-button', 'Zoom In', function ()
	                {
	                    viewer.setZoomLevel(settings.zoomLevel + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-zoom-label', 'zoom-label', 'Zoom level: ', 'zoom-level', settings.zoomLevel);
	            var textSpan = $(elem).find(settings.selector + 'zoom-level')[0];
	
	            var updateText = function ()
	            {
	                textSpan.textContent = settings.zoomLevel.toFixed(2);
	            };
	
	            subscribe('ZoomLevelDidChange', updateText);
	            subscribe('ViewerDidLoad', updateText);
	
	            return elem;
	        }
	    });
	
	    // Grid controls
	    var createGridControls = getResolutionControlCreator({
	        controllerSetting: 'enableGridControls',
	        showInGrid: true,
	
	        createSlider: function ()
	        {
	            var elem = createSlider('grid-slider', {
	                value: settings.pagesPerRow,
	                min: settings.minPagesPerRow,
	                max: settings.maxPagesPerRow
	            });
	            var $elem = $(elem);
	
	            $elem.on('input', function()
	            {
	                var intValue = parseInt(elem.value, 10);
	                viewer.setGridPagesPerRow(intValue);
	            });
	
	            $elem.on('change', function ()
	            {
	                var intValue = parseInt(elem.value, 10);
	                if (intValue !== settings.pagesPerRow)
	                    viewer.setGridPagesPerRow(intValue);
	            });
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                // Update the position of the handle within the slider
	                if (settings.pagesPerRow !== $elem.val())
	                    $elem.val(settings.pagesPerRow);
	            });
	
	            return elem;
	        },
	
	        createButtons: function ()
	        {
	            return elt('span',
	                createButtonElement('grid-out-button', 'Zoom Out', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow - 1);
	                }),
	                createButtonElement('grid-in-button', 'Zoom In', function ()
	                {
	                    viewer.setGridPagesPerRow(settings.pagesPerRow + 1);
	                })
	            );
	        },
	
	        createLabel: function ()
	        {
	            var elem = createLabel('diva-grid-label', 'grid-label', 'Pages per row: ', 'pages-per-row', settings.pagesPerRow);
	            var textSpan = $(elem).find(settings.selector + 'pages-per-row')[0];
	
	            subscribe('GridRowNumberDidChange', function ()
	            {
	                textSpan.textContent = settings.pagesPerRow;
	            });
	
	            return elem;
	        }
	    });
	
	    var createViewMenu = function()
	    {
	        var viewOptionsList = elt('div', elemAttrs('view-options'));
	
	        var changeViewButton = createButtonElement('view-icon', 'Change view', function ()
	        {
	            $(viewOptionsList).toggle();
	        });
	
	        $(document).mouseup(function (event)
	        {
	            var container = $(viewOptionsList);
	
	            if (!container.is(event.target) && container.has(event.target).length === 0 && event.target.id !== settings.ID + 'view-icon')
	            {
	                container.hide();
	            }
	        });
	
	        var selectView = function (view)
	        {
	            viewer.changeView(view);
	
	            //hide view menu
	            $(viewOptionsList).hide();
	        };
	
	        var updateViewMenu = function()
	        {
	            var viewIconClasses = ' diva-view-icon diva-button';
	
	            // display the icon of the mode we're currently in (?)
	            if (settings.inGrid)
	            {
	                changeViewButton.className = 'diva-grid-icon' + viewIconClasses;
	            }
	            else if (settings.inBookLayout)
	            {
	                changeViewButton.className = 'diva-book-icon' + viewIconClasses;
	            }
	            else
	            {
	                changeViewButton.className = 'diva-document-icon' + viewIconClasses;
	            }
	
	            var viewOptions = document.createDocumentFragment();
	
	            // then display document, book, and grid buttons in that order, excluding the current view
	            if (settings.inGrid || settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('document-icon', 'Document View', selectView.bind(null, 'document')));
	
	            if (settings.inGrid || !settings.inBookLayout)
	                viewOptions.appendChild(createButtonElement('book-icon', 'Book View', selectView.bind(null, 'book')));
	
	            if (!settings.inGrid)
	                viewOptions.appendChild(createButtonElement('grid-icon', 'Grid View', selectView.bind(null, 'grid')));
	
	            // remove old menu
	            while (viewOptionsList.firstChild)
	            {
	                viewOptionsList.removeChild(viewOptionsList.firstChild);
	            }
	
	            // insert new menu
	            viewOptionsList.appendChild(viewOptions);
	        };
	
	        subscribe('ViewDidSwitch', updateViewMenu);
	        subscribe('ObjectDidLoad', updateViewMenu);
	
	        return elt('div', elemAttrs('view-menu'),
	            changeViewButton,
	            viewOptionsList
	        );
	    };
	
	    var createSlider = function(name, options)
	    {
	        return elt('input', options, {
	            id: settings.ID + name,
	            class: 'diva-' + name + ' diva-slider',
	            type: 'range'
	        });
	    };
	
	    var createLabel = function(name, id, label, innerName, innerValue)
	    {
	        return elt('div', {
	                id: settings.ID + id,
	                class: name + ' diva-label'
	            },
	            [
	                label,
	                elt('span', {
	                    id: settings.ID + innerName
	                }, innerValue)
	            ]);
	    };
	
	    var createPageNavigationControls = function ()
	    {
	        // Go to page form
	        var gotoForm = settings.enableGotoPage ? createGotoPageForm() : null;
	
	        return elt('span', elemAttrs('page-nav'),
	            createPageLabel(), // 'Page x of y' label
	            gotoForm
	        );
	    };
	
	    var createGotoPageForm = function ()
	    {
	        var gotoPageInput = elt('input', {
	            id: settings.ID + 'goto-page-input',
	            class: 'diva-input diva-goto-page-input',
	            autocomplete: 'off',
	            type: 'text'
	        });
	
	        var gotoPageSubmit = elt('input', {
	            id: settings.ID + 'goto-page-submit',
	            class: 'diva-button diva-button-text',
	            type: 'submit',
	            value: 'Go'
	        });
	
	        var inputSuggestions = elt('div', {
	                id: settings.ID + 'input-suggestions',
	                class: 'diva-input-suggestions'
	            }
	        );
	
	        var gotoForm = elt('form', {
	                id: settings.ID + 'goto-page',
	                class: 'diva-goto-form'
	            },
	            gotoPageInput,
	            gotoPageSubmit,
	            inputSuggestions
	        );
	
	        $(gotoForm).on('submit', function ()
	        {
	            var desiredPageLabel = gotoPageInput.value;
	
	            if (settings.onGotoSubmit && typeof settings.onGotoSubmit === "function")
	            {
	                var pageIndex = settings.onGotoSubmit(desiredPageLabel);
	                if (!viewer.gotoPageByIndex(pageIndex))
	                    alert("No page could be found with that label or page number");
	
	            }
	            else // Default if no function is specified in the settings
	            {
	                if (!viewer.gotoPageByLabel(desiredPageLabel))
	                    alert("No page could be found with that label or page number");
	            }
	
	            // Hide the suggestions
	            inputSuggestions.style.display = 'none';
	
	            // Prevent the default action of reloading the page
	            return false;
	        });
	
	        $(gotoPageInput).on('input focus', function ()
	        {
	            inputSuggestions.innerHTML = ''; // Remove all previous suggestions
	
	            var value = gotoPageInput.value;
	            var numSuggestions = 0;
	            if (settings.enableGotoSuggestions && value)
	            {
	                var pages = settings.manifest.pages;
	                for (var i = 0, len = pages.length; i < len && numSuggestions < 10; i++)
	                {
	                    if (pages[i].l.toLowerCase().indexOf(value.toLowerCase()) > -1)
	                    {
	                        var newInputSuggestion = elt('div', {
	                                class: 'diva-input-suggestion'
	                            },
	                            pages[i].l
	                        );
	
	                        inputSuggestions.appendChild(newInputSuggestion);
	
	                        numSuggestions++;
	                    }
	                }
	
	                // Show label suggestions
	                if (numSuggestions > 0)
	                    inputSuggestions.style.display = 'block';
	            }
	            else
	                inputSuggestions.style.display = 'none';
	        });
	
	        $(gotoPageInput).on('keydown', function (e)
	        {
	            var el;
	            if (e.keyCode === 13) // 'Enter' key
	            {
	                var active = $('.active', inputSuggestions);
	                if (active.length)
	                    gotoPageInput.value = active.text();
	
	            }
	            if (e.keyCode === 38) // Up arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var prevEl = el.prev();
	                if (prevEl.length)
	                {
	                    el.removeClass('active');
	                    prevEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:last', inputSuggestions).addClass('active');
	                }
	            }
	            else if (e.keyCode === 40) // Down arrow key
	            {
	                el = $('.active', inputSuggestions);
	                var nextEl = el.next();
	                if (nextEl.length)
	                {
	                    el.removeClass('active');
	                    nextEl.addClass('active');
	                }
	                else
	                {
	                    el.removeClass('active');
	                    $('.diva-input-suggestion:first', inputSuggestions).addClass('active');
	                }
	            }
	        });
	
	        $(inputSuggestions).on('mousedown', '.diva-input-suggestion', function()
	        {
	            gotoPageInput.value = this.textContent;
	            inputSuggestions.style.display = 'none';
	            $(gotoPageInput).trigger('submit');
	        });
	
	        $(gotoPageInput).on('blur', function ()
	        {
	            // Hide label suggestions
	            inputSuggestions.style.display = 'none';
	        });
	
	        return gotoForm;
	    };
	
	    var createPageLabel = function()
	    {
	        // Current page
	        var currentPage = elt('span', {
	            id: settings.ID + 'current-page'
	        });
	
	        var updateCurrentPage = function ()
	        {
	            currentPage.textContent = viewer.getCurrentAliasedPageIndex();
	        };
	
	        subscribe('VisiblePageDidChange', updateCurrentPage);
	        subscribe('ViewerDidLoad', updateCurrentPage);
	
	        // Number of pages
	        var numPages = elt('span', {
	            id: settings.ID + 'num-pages'
	        });
	
	        var updateNumPages = function ()
	        {
	            numPages.textContent = settings.numPages;
	        };
	
	        subscribe('NumberOfPagesDidChange', updateNumPages);
	        subscribe('ObjectDidLoad', updateNumPages);
	
	        return elt('span', {
	                class: 'diva-page-label diva-label'
	            },
	            'Page ', currentPage, ' of ', numPages
	        );
	    };
	
	    var createToolbarButtonGroup = function ()
	    {
	        var buttons = [createViewMenu()];
	
	        if (settings.enableLinkIcon)
	            buttons.push(createLinkIcon());
	
	        if (settings.enableNonPagedVisibilityIcon)
	            buttons.push(createToggleNonPagedButton());
	
	        if (settings.enableFullscreen)
	            buttons.push(createFullscreenButton());
	
	        return elt('span', elemAttrs('toolbar-button-group'), buttons);
	    };
	
	    var createLinkIcon = function ()
	    {
	        var elem = createButtonElement('link-icon', 'Link to this page');
	        var linkIcon = $(elem);
	
	        linkIcon.on('click', function ()
	        {
	            $('body').prepend(
	                elt('div', {
	                    id: settings.ID + 'link-popup',
	                    class: 'diva-popup diva-link-popup'
	                }, [
	                    elt('input', {
	                        id: settings.ID + 'link-popup-input',
	                        class: 'diva-input',
	                        type: 'text',
	                        value: viewer.getCurrentURL()
	                    })
	                ])
	            );
	
	            if (settings.inFullscreen)
	            {
	                $(settings.selector + 'link-popup').addClass('in-fullscreen');
	            }
	            else
	            {
	                // Calculate the left and top offsets
	                var leftOffset = linkIcon.offset().left - 222 + linkIcon.outerWidth();
	                var topOffset = linkIcon.offset().top + linkIcon.outerHeight() - 1;
	
	                $(settings.selector + 'link-popup').css({
	                    'top': topOffset + 'px',
	                    'left': leftOffset + 'px'
	                });
	            }
	
	            // Catch onmouseup events outside of this div
	            $('body').mouseup(function (event)
	            {
	                var targetID = event.target.id;
	
	                if (targetID !== settings.ID + 'link-popup' && targetID !== settings.ID + 'link-popup-input')
	                    $(settings.selector + 'link-popup').remove();
	            });
	
	            // Also delete it upon scroll and page up/down key events
	            // FIXME(wabain): This is aggressive
	            settings.viewportObject.scroll(function ()
	            {
	                $(settings.selector + 'link-popup').remove();
	            });
	            $(settings.selector + 'link-popup input').click(function ()
	            {
	                $(this).focus().select();
	            });
	
	            return false;
	        });
	
	        return elem;
	    };
	
	    var createFullscreenButton = function ()
	    {
	        return createButtonElement('fullscreen-icon', 'Toggle fullscreen mode', function ()
	        {
	            viewer.toggleFullscreenMode();
	        });
	    };
	
	    var createToggleNonPagedButton = function ()
	    {
	        var getClassName = function()
	        {
	            return 'toggle-nonpaged-icon' + (viewer.getSettings().showNonPagedPages ? '-active' : '');
	        };
	
	        var toggleNonPagedButton = createButtonElement(getClassName(), 'Toggle visibility of non-paged pages', function()
	        {
	            viewer.toggleNonPagedPagesVisibility();
	            var newClassName = 'diva-' + getClassName();
	            this.className = this.className.replace(/diva-toggle-nonpaged-icon(-active)?/, newClassName);
	        });
	
	        var updateNonPagedButtonVisibility = function ()
	        {
	            var pages = settings.manifest.pages;
	            for (var i = 0; i < pages.length; i++)
	            {
	                if (settings.manifest.paged && !pages[i].paged)
	                {
	                    // Show the button, there is at least one non-paged page
	                    toggleNonPagedButton.style.display = 'inline-block';
	                    return;
	                }
	            }
	
	            // No non-paged pages were found, hide the button
	            toggleNonPagedButton.style.display = 'none';
	        };
	        subscribe('ObjectDidLoad', updateNonPagedButtonVisibility);
	
	        return toggleNonPagedButton;
	    };
	
	    // Handles all status updating etc (both fullscreen and not)
	    var init = function ()
	    {
	        var leftTools = [createZoomControls(), createGridControls()];
	        var rightTools = [createPageNavigationControls(), createToolbarButtonGroup()];
	
	        var tools = elt('div', elemAttrs('tools'),
	            elt('div', elemAttrs('tools-left'), leftTools),
	            elt('div', elemAttrs('tools-right'), rightTools)
	        );
	
	        settings.toolbarParentObject.prepend(tools);
	
	        // Handle entry to and exit from fullscreen mode
	        var switchMode = function ()
	        {
	            var toolsRightElement = document.getElementById(settings.ID + 'tools-right');
	            var pageNavElement = document.getElementById(settings.ID + 'page-nav');
	
	            if (!settings.inFullscreen)
	            {
	                // Leaving fullscreen
	                $(tools).removeClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to beginning of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.insertBefore(pageNavElement, toolsRightElement.firstChild);
	            }
	            else
	            {
	                // Entering fullscreen
	                $(tools).addClass('diva-fullscreen-tools');
	
	                //move ID-page-nav to end of tools right
	                toolsRightElement.removeChild(pageNavElement);
	                toolsRightElement.appendChild(pageNavElement);
	            }
	        };
	
	        subscribe('ModeDidSwitch', switchMode);
	        subscribe('ViewerDidLoad', switchMode);
	
	        var toolbar = {
	            element: tools,
	            closePopups: function ()
	            {
	                $('.diva-popup').css('display', 'none');
	            }
	        };
	
	        return toolbar;
	    };
	
	    return init();
	}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var $ = __webpack_require__(3);
	
	__webpack_require__(16);
	
	var elt = __webpack_require__(9);
	var getScrollbarWidth = __webpack_require__(17);
	
	var gestureEvents = __webpack_require__(18);
	var diva = __webpack_require__(2);
	var DocumentHandler = __webpack_require__(19);
	var GridHandler = __webpack_require__(23);
	var PageOverlayManager = __webpack_require__(24);
	var PluginRegistry = __webpack_require__(5);
	var Renderer = __webpack_require__(25);
	var getPageLayouts = __webpack_require__(35);
	var createSettingsView = __webpack_require__(40);
	var ValidationRunner = __webpack_require__(41);
	var Viewport = __webpack_require__(42);
	
	var debug = __webpack_require__(26)('diva:ViewerCore');
	
	module.exports = ViewerCore;
	
	// Define validations
	var optionsValidations = [
	    {
	        key: 'goDirectlyTo',
	        validate: function (value, settings)
	        {
	            if (value < 0 || value >= settings.manifest.pages.length)
	                return 0;
	        }
	    },
	    {
	        key: 'minPagesPerRow',
	        validate: function (value)
	        {
	            return Math.max(2, value);
	        }
	    },
	    {
	        key: 'maxPagesPerRow',
	        validate: function (value, settings)
	        {
	            return Math.max(value, settings.minPagesPerRow);
	        }
	    },
	    {
	        key: 'pagesPerRow',
	        validate: function (value, settings)
	        {
	            // Default to the maximum
	            if (value < settings.minPagesPerRow || value > settings.maxPagesPerRow)
	                return settings.maxPagesPerRow;
	        }
	    },
	    {
	        key: 'maxZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changing this value isn't really an error, it just depends on the
	            // source manifest
	            config.suppressWarning();
	
	            if (value < 0 || value > settings.manifest.maxZoom)
	                return settings.manifest.maxZoom;
	        }
	    },
	    {
	        key: 'minZoomLevel',
	        validate: function (value, settings, config)
	        {
	            // Changes based on the manifest value shouldn't trigger a
	            // warning
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < 0 || value > settings.maxZoomLevel)
	                return 0;
	        }
	    },
	    {
	        key: 'zoomLevel',
	        validate: function (value, settings, config)
	        {
	            if (value > settings.manifest.maxZoom)
	            {
	                config.suppressWarning();
	                return 0;
	            }
	
	            if (value < settings.minZoomLevel || value > settings.maxZoomLevel)
	                return settings.minZoomLevel;
	        }
	    }
	];
	
	function ViewerCore(element, options, publicInstance)
	{
	    var self = this;
	    var parentObject = $(element);
	
	    // Things that cannot be changed because of the way they are used by the script
	    // Many of these are declared with arbitrary values that are changed later on
	    var viewerState = {
	        currentPageIndex: 0,        // The current page in the viewport (center-most page)
	        horizontalOffset: 0,        // Distance from the center of the diva element to the top of the current page
	        horizontalPadding: 0,       // Either the fixed padding or adaptive padding
	        ID: null,                   // The prefix of the IDs of the elements (usually 1-diva-)
	        initialKeyScroll: false,    // Holds the initial state of enableKeyScroll
	        initialSpaceScroll: false,  // Holds the initial state of enableSpaceScroll
	        innerElement: null,         // The native .diva-outer DOM object
	        innerObject: {},            // $(settings.ID + 'inner'), for selecting the .diva-inner element
	        isActiveDiva: true,         // In the case that multiple diva panes exist on the same page, this should have events funneled to it.
	        isScrollable: true,         // Used in enable/disableScrollable public methods
	        isZooming: false,           // Flag to keep track of whether zooming is still in progress, for handleZoom
	        loaded: false,              // A flag for when everything is loaded and ready to go.
	        manifest: null,
	        mobileWebkit: false,        // Checks if the user is on a touch device (iPad/iPod/iPhone/Android)
	        numPages: 0,                // Number of pages in the array
	        oldZoomLevel: -1,           // Holds the previous zoom level after zooming in or out
	        options: options,
	        outerElement: null,         // The native .diva-outer DOM object
	        outerObject: {},            // $(settings.ID + 'outer'), for selecting the .diva-outer element
	        pageOverlays: new PageOverlayManager(),
	        pageTools: [],              // The plugins which are enabled as page tools
	        parentObject: parentObject, // JQuery object referencing the parent element
	        pendingManifestRequest: null, // Reference to the xhr request retrieving the manifest. Used to cancel the request on destroy()
	        plugins: [],                // Filled with the enabled plugins from the registry
	        renderer: null,
	        resizeTimer: -1,            // Holds the ID of the timeout used when resizing the window (for clearing)
	        scrollbarWidth: 0,          // Set to the actual scrollbar width in init()
	        selector: '',               // Uses the generated ID prefix to easily select elements
	        throbberTimeoutID: -1,      // Holds the ID of the throbber loading timeout
	        toolbar: null,              // Holds an object with some toolbar-related functions
	        verticalOffset: 0,          // Distance from the center of the diva element to the left side of the current page
	        verticalPadding: 0,         // Either the fixed padding or adaptive padding
	        viewHandler: null,
	        viewport: null,             // Object caching the viewport dimensions
	        viewportElement: null,
	        viewportObject: null
	    };
	
	    var settings = createSettingsView([options, viewerState]);
	
	    // Aliases for compatibilty
	    Object.defineProperties(settings, {
	        // Height of the document viewer pane
	        panelHeight: {
	            get: function ()
	            {
	                return viewerState.viewport.height;
	            }
	        },
	        // Width of the document viewer pane
	        panelWidth: {
	            get: function ()
	            {
	                return viewerState.viewport.width;
	            }
	        }
	    });
	
	    var optionsValidator = new ValidationRunner({
	        additionalProperties: [
	            {
	                key: 'manifest',
	                get: function ()
	                {
	                    return viewerState.manifest;
	                }
	            }
	        ],
	
	        validations: optionsValidations
	    });
	
	    var isValidOption = function (key, value)
	    {
	        return optionsValidator.isValid(key, value, viewerState.options);
	    };
	
	    var elemAttrs = function (ident, base)
	    {
	        var attrs = {
	            id: settings.ID + ident,
	            class: 'diva-' + ident
	        };
	
	        if (base)
	            return $.extend(attrs, base);
	        else
	            return attrs;
	    };
	
	    var getPageData = function (pageIndex, attribute)
	    {
	        return settings.manifest.pages[pageIndex].d[settings.zoomLevel][attribute];
	    };
	
	    // Reset some settings and empty the viewport
	    var clearViewer = function ()
	    {
	        viewerState.viewport.top = 0;
	
	        // Clear all the timeouts to prevent undesired pages from loading
	        clearTimeout(viewerState.resizeTimer);
	    };
	
	    /**
	     * Update settings to match the specified options. Load the viewer,
	     * fire appropriate events for changed options.
	     */
	    var reloadViewer = function (newOptions)
	    {
	        var queuedEvents = [];
	
	        newOptions = optionsValidator.getValidatedOptions(settings, newOptions);
	
	        // Set the zoom level if valid and fire a ZoomLevelDidChange event
	        if (hasChangedOption(newOptions, 'zoomLevel'))
	        {
	            viewerState.oldZoomLevel = settings.zoomLevel;
	            viewerState.options.zoomLevel = newOptions.zoomLevel;
	            queuedEvents.push(["ZoomLevelDidChange", newOptions.zoomLevel]);
	        }
	
	        // Set the pages per row if valid and fire an event
	        if (hasChangedOption(newOptions, 'pagesPerRow'))
	        {
	            viewerState.options.pagesPerRow = newOptions.pagesPerRow;
	            queuedEvents.push(["GridRowNumberDidChange", newOptions.pagesPerRow]);
	        }
	
	        // Update verticallyOriented (no event fired)
	        if (hasChangedOption(newOptions, 'verticallyOriented'))
	            viewerState.options.verticallyOriented = newOptions.verticallyOriented;
	
	        // Show/Hide non-paged pages
	        if (hasChangedOption(newOptions, 'showNonPagedPages'))
	        {
	            viewerState.options.showNonPagedPages = newOptions.showNonPagedPages;
	        }
	
	        // Update page position (no event fired here)
	        if ('goDirectlyTo' in newOptions)
	        {
	            viewerState.options.goDirectlyTo = newOptions.goDirectlyTo;
	
	            if ('verticalOffset' in newOptions)
	                viewerState.verticalOffset = newOptions.verticalOffset;
	
	            if ('horizontalOffset' in newOptions)
	                viewerState.horizontalOffset = newOptions.horizontalOffset;
	        }
	        else
	        {
	            // Otherwise the default is to remain on the current page
	            viewerState.options.goDirectlyTo = settings.currentPageIndex;
	        }
	
	        if (hasChangedOption(newOptions, 'inGrid') || hasChangedOption(newOptions, 'inBookLayout'))
	        {
	            if ('inGrid' in newOptions)
	                viewerState.options.inGrid = newOptions.inGrid;
	
	            if ('inBookLayout' in newOptions)
	                viewerState.options.inBookLayout = newOptions.inBookLayout;
	
	            queuedEvents.push(["ViewDidSwitch", settings.inGrid]);
	        }
	
	        // Note: prepareModeChange() depends on inGrid and the vertical/horizontalOffset (for now)
	        if (hasChangedOption(newOptions, 'inFullscreen'))
	        {
	            viewerState.options.inFullscreen = newOptions.inFullscreen;
	            prepareModeChange(newOptions);
	            queuedEvents.push(["ModeDidSwitch", settings.inFullscreen]);
	        }
	
	        clearViewer();
	        updateViewHandlerAndRendering();
	
	        if (viewerState.renderer)
	        {
	            // TODO: The usage of padding variables is still really
	            // messy and inconsistent
	            var rendererConfig = {
	                pageLayouts: getPageLayouts(settings),
	                padding: getPadding(),
	                maxZoomLevel: settings.inGrid ? null : viewerState.manifest.maxZoom,
	                verticallyOriented: settings.verticallyOriented || settings.inGrid,
	            };
	
	            var viewportPosition = {
	                zoomLevel: settings.inGrid ? null : settings.zoomLevel,
	                anchorPage: settings.goDirectlyTo,
	                verticalOffset: viewerState.verticalOffset,
	                horizontalOffset: viewerState.horizontalOffset
	            };
	
	            var sourceProvider = getCurrentSourceProvider();
	
	            if (debug.enabled)
	            {
	                var serialized = Object.keys(rendererConfig)
	                    .filter(function (key)
	                    {
	                        // Too long
	                        return key !== 'pageLayouts' && key !== 'padding';
	                    })
	                    .map(function (key)
	                    {
	                        var value = rendererConfig[key];
	                        return key + ': ' + JSON.stringify(value);
	                    })
	                    .join(', ');
	
	                debug('reload with %s', serialized);
	            }
	
	            viewerState.renderer.load(rendererConfig, viewportPosition, sourceProvider);
	        }
	
	        queuedEvents.forEach(function (params)
	        {
	            publish.apply(null, params);
	        });
	
	        return true;
	    };
	
	    var hasChangedOption = function (options, key)
	    {
	        return key in options && options[key] !== settings[key];
	    };
	
	    // Handles switching in and out of fullscreen mode
	    var prepareModeChange = function (options)
	    {
	        // Toggle the classes
	        var changeClass = options.inFullscreen ? 'addClass' : 'removeClass';
	        viewerState.outerObject[changeClass]('diva-fullscreen');
	        $('body')[changeClass]('diva-hide-scrollbar');
	        settings.parentObject[changeClass]('diva-full-width');
	
	        // Adjust Diva's internal panel size, keeping the old values
	        var storedHeight = settings.panelHeight;
	        var storedWidth = settings.panelWidth;
	        viewerState.viewport.invalidate();
	
	        // If this isn't the original load, the offsets matter, and the position isn't being changed...
	        if (!viewerState.loaded && !settings.inGrid && !('verticalOffset' in options))
	        {
	            //get the updated panel size
	            var newHeight = settings.panelHeight;
	            var newWidth = settings.panelWidth;
	
	            //and re-center the new panel on the same point
	            viewerState.verticalOffset += ((storedHeight - newHeight) / 2);
	            viewerState.horizontalOffset += ((storedWidth - newWidth) / 2);
	        }
	
	        //turn on/off escape key listener
	        if (options.inFullscreen)
	            $(document).on('keyup', escapeListener);
	        else
	            $(document).off('keyup', escapeListener);
	    };
	
	    // Update the view handler and the view rendering for the current view
	    var updateViewHandlerAndRendering = function ()
	    {
	        var Handler = settings.inGrid ? GridHandler : DocumentHandler;
	
	        if (viewerState.viewHandler && !(viewerState.viewHandler instanceof Handler))
	        {
	            viewerState.viewHandler.destroy();
	            viewerState.viewHandler = null;
	        }
	
	        if (!viewerState.viewHandler)
	            viewerState.viewHandler = new Handler(self);
	
	        if (!viewerState.renderer)
	            initializeRenderer();
	    };
	
	    // TODO: This could probably be done upon ViewerCore initialization
	    var initializeRenderer = function ()
	    {
	        var compatErrors = Renderer.getCompatibilityErrors();
	
	        if (compatErrors)
	        {
	            showError(compatErrors);
	        }
	        else
	        {
	            var options = {
	                viewport: viewerState.viewport,
	                outerElement: viewerState.outerElement,
	                innerElement: viewerState.innerElement
	            };
	
	            var hooks = {
	                onViewWillLoad: function ()
	                {
	                    viewerState.viewHandler.onViewWillLoad();
	                },
	                onViewDidLoad: function ()
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidLoad();
	                },
	                onViewDidUpdate: function (pages, targetPage)
	                {
	                    updatePageOverlays();
	                    viewerState.viewHandler.onViewDidUpdate(pages, targetPage);
	                },
	                onViewDidTransition: function ()
	                {
	                    updatePageOverlays();
	                },
	                onPageWillLoad: function (pageIndex)
	                {
	                    publish('PageWillLoad', pageIndex);
	                }
	            };
	
	            viewerState.renderer = new Renderer(options, hooks);
	        }
	    };
	
	    var getCurrentSourceProvider = function ()
	    {
	        if (settings.inGrid)
	        {
	            var gridSourceProvider = {
	                getAllZoomLevelsForPage: function (page)
	                {
	                    return [gridSourceProvider.getBestZoomLevelForPage(page)];
	                },
	                getBestZoomLevelForPage: function (page)
	                {
	                    var url = settings.manifest.getPageImageURL(page.index, {
	                        width: page.dimensions.width
	                    });
	
	                    return {
	                        zoomLevel: 1, // FIXME
	                        rows: 1,
	                        cols: 1,
	                        tiles: [{
	                            url: url,
	                            zoomLevel: 1, // FIXME
	                            row: 0,
	                            col: 0,
	                            dimensions: page.dimensions,
	                            offset: {
	                                top: 0,
	                                left: 0
	                            }
	                        }]
	                    };
	                }
	            };
	
	            return gridSourceProvider;
	        }
	
	        var tileDimens = {
	            width: settings.tileWidth,
	            height: settings.tileHeight
	        };
	
	        return {
	            getBestZoomLevelForPage: function (page)
	            {
	                return settings.manifest.getPageImageTiles(page.index, Math.ceil(settings.zoomLevel), tileDimens);
	            },
	            getAllZoomLevelsForPage: function (page)
	            {
	                var levels = [];
	
	                var levelCount = viewerState.manifest.maxZoom;
	                for (var level=0; level <= levelCount; level++)
	                {
	                    levels.push(settings.manifest.getPageImageTiles(page.index, level, tileDimens));
	                }
	
	                levels.reverse();
	
	                return levels;
	            }
	        };
	    };
	
	    var getPadding = function ()
	    {
	        var topPadding, leftPadding;
	        var docVPadding, docHPadding;
	
	        if (settings.inGrid)
	        {
	            docVPadding = settings.fixedPadding;
	            topPadding = leftPadding = docHPadding = 0;
	        }
	        else
	        {
	            topPadding = settings.verticallyOriented ? viewerState.verticalPadding : 0;
	            leftPadding = settings.verticallyOriented ? 0 : viewerState.horizontalPadding;
	
	            docVPadding = settings.verticallyOriented ? 0 : viewerState.verticalPadding;
	            docHPadding = settings.verticallyOriented ? viewerState.horizontalPadding : 0;
	        }
	
	        return {
	            document: {
	                top: docVPadding,
	                bottom: docVPadding,
	                left: docHPadding,
	                right: docHPadding
	            },
	            page: {
	                top: topPadding,
	                bottom: 0,
	                left: leftPadding,
	                right: 0
	            }
	        };
	    };
	
	    var updatePageOverlays = function ()
	    {
	        viewerState.pageOverlays.updateOverlays(viewerState.renderer.getRenderedPages());
	    };
	
	    //Shortcut for closing fullscreen with the escape key
	    var escapeListener = function (e)
	    {
	        if (e.keyCode == 27)
	        {
	            reloadViewer({
	                inFullscreen: !settings.inFullscreen
	            });
	        }
	    };
	
	    // Called to handle any zoom level
	    var handleZoom = function (newZoomLevel, focalPoint)
	    {
	        // If the zoom level provided is invalid, return false
	        if (!isValidOption('zoomLevel', newZoomLevel))
	            return false;
	
	        // If no focal point was given, zoom on the center of the viewport
	        if (focalPoint == null)
	        {
	            var viewport = viewerState.viewport;
	            var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	            focalPoint = {
	                anchorPage: settings.currentPageIndex,
	                offset: {
	                    left: (viewport.width / 2) - (currentRegion.left - viewport.left),
	                    top: (viewport.height / 2) - (currentRegion.top - viewport.top)
	                }
	            };
	        }
	
	        var pageRegion = viewerState.renderer.layout.getPageRegion(focalPoint.anchorPage);
	
	        // calculate distance from cursor coordinates to center of viewport
	        var focalXToCenter = (pageRegion.left + focalPoint.offset.left) -
	            (settings.viewport.left + (settings.viewport.width / 2));
	        var focalYToCenter = (pageRegion.top + focalPoint.offset.top) -
	            (settings.viewport.top + (settings.viewport.height / 2));
	
	        function getPositionForZoomLevel(zoomLevel)
	        {
	            var zoomRatio = Math.pow(2, zoomLevel - initialZoomLevel);
	
	            //TODO(jeromepl): Calculate position from page top left to viewport top left
	            // calculate horizontal/verticalOffset: distance from viewport center to page upper left corner
	            var horizontalOffset = (focalPoint.offset.left * zoomRatio) - focalXToCenter;
	            var verticalOffset = (focalPoint.offset.top * zoomRatio) - focalYToCenter;
	
	            return {
	                zoomLevel: zoomLevel,
	                anchorPage: focalPoint.anchorPage,
	                verticalOffset: verticalOffset,
	                horizontalOffset: horizontalOffset
	            };
	        }
	
	        var initialZoomLevel = viewerState.oldZoomLevel = settings.zoomLevel;
	        viewerState.options.zoomLevel = newZoomLevel;
	
	        var endPosition = getPositionForZoomLevel(newZoomLevel);
	        viewerState.options.goDirectlyTo = endPosition.anchorPage;
	        viewerState.verticalOffset = endPosition.verticalOffset;
	        viewerState.horizontalOffset = endPosition.horizontalOffset;
	
	        viewerState.renderer.transitionViewportPosition({
	            duration: 300,
	            parameters: {
	                zoomLevel: {
	                    from: initialZoomLevel,
	                    to: newZoomLevel
	                }
	            },
	            getPosition: function (parameters)
	            {
	                return getPositionForZoomLevel(parameters.zoomLevel);
	            },
	            onEnd: function (info)
	            {
	                viewerState.viewportObject.scroll(scrollFunction);
	
	                if (info.interrupted)
	                    viewerState.oldZoomLevel = newZoomLevel;
	            }
	        });
	
	        // Update the slider
	        publish("ZoomLevelDidChange", newZoomLevel);
	
	        // While zooming, don't update scroll offsets based on the scaled version of diva-inner
	        viewerState.viewportObject.off('scroll');
	
	        return true;
	    };
	
	    /*
	     Gets the Y-offset for a specific point on a specific page
	     Acceptable values for "anchor":
	     "top" (default) - will anchor top of the page to the top of the diva-outer element
	     "bottom" - top, s/top/bottom
	     "center" - will center the page on the diva element
	     Returned value will be the distance from the center of the diva-outer element to the top of the current page for the specified anchor
	     */
	    var getYOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "center" || anchor === "centre") //how you can tell an American coded this
	        {
	            return parseInt(getPageData(pageIndex, "h") / 2, 10);
	        }
	        else if (anchor === "bottom")
	        {
	            return parseInt(getPageData(pageIndex, "h") - settings.panelHeight / 2, 10);
	        }
	        else
	        {
	            return parseInt(settings.panelHeight / 2, 10);
	        }
	    };
	
	    //Same as getYOffset with "left" and "right" as acceptable values instead of "top" and "bottom"
	    var getXOffset = function (pageIndex, anchor)
	    {
	        pageIndex = (typeof(pageIndex) === "undefined" ? settings.currentPageIndex : pageIndex);
	
	        if (anchor === "left")
	        {
	            return parseInt(settings.panelWidth / 2, 10);
	        }
	        else if (anchor === "right")
	        {
	            return parseInt(getPageData(pageIndex, "w") - settings.panelWidth / 2, 10);
	        }
	        else
	        {
	            return parseInt(getPageData(pageIndex, "w") / 2, 10);
	        }
	    };
	
	    // updates panelHeight/panelWidth on resize
	    var updatePanelSize = function ()
	    {
	        viewerState.viewport.invalidate();
	
	        // FIXME(wabain): This should really only be called after initial load
	        if (viewerState.renderer)
	        {
	            updateOffsets();
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        return true;
	    };
	
	    var updateOffsets = function ()
	    {
	        var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	        if (pageOffset)
	        {
	            viewerState.horizontalOffset = pageOffset.x;
	            viewerState.verticalOffset = pageOffset.y;
	        }
	    };
	
	    // Bind mouse events (drag to scroll, double-click)
	    var bindMouseEvents = function()
	    {
	        // Set drag scroll on first descendant of class dragger on both selected elements
	        viewerState.viewportObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	        viewerState.innerObject.dragscrollable({dragSelector: '.diva-dragger', acceptPropagatedEvent: true});
	
	        gestureEvents.onDoubleClick(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double click at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    var onResize = function()
	    {
	        updatePanelSize();
	        // Cancel any previously-set resize timeouts
	        clearTimeout(viewerState.resizeTimer);
	
	        viewerState.resizeTimer = setTimeout(function ()
	        {
	            var pageOffset = viewerState.renderer.layout.getPageToViewportCenterOffset(settings.currentPageIndex, viewerState.viewport);
	
	            if (pageOffset)
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex,
	                    verticalOffset: pageOffset.y,
	                    horizontalOffset: pageOffset.x
	                });
	            }
	            else
	            {
	                reloadViewer({
	                    goDirectlyTo: settings.currentPageIndex
	                });
	            }
	        }, 200);
	    };
	
	    // Bind touch and orientation change events
	    var bindTouchEvents = function()
	    {
	        // Block the user from moving the window only if it's not integrated
	        if (settings.blockMobileMove)
	        {
	            $('body').bind('touchmove', function (event)
	            {
	                var e = event.originalEvent;
	                e.preventDefault();
	
	                return false;
	            });
	        }
	
	        // Touch events for swiping in the viewport to scroll pages
	        viewerState.viewportObject.kinetic({
	            triggerHardware: true
	        });
	
	        gestureEvents.onPinch(viewerState.viewportObject, function (event, coords, start, end)
	        {
	            debug('Pinch %s at %s, %s', end - start, coords.left, coords.top);
	            viewerState.viewHandler.onPinch(event, coords, start, end);
	        });
	
	        gestureEvents.onDoubleTap(viewerState.viewportObject, function (event, coords)
	        {
	            debug('Double tap at %s, %s', coords.left, coords.top);
	            viewerState.viewHandler.onDoubleClick(event, coords);
	        });
	    };
	
	    // Handle the scroll
	    var scrollFunction = function ()
	    {
	        var previousTopScroll = viewerState.viewport.top;
	        var previousLeftScroll = viewerState.viewport.left;
	
	        var direction;
	
	        viewerState.viewport.invalidate();
	
	        var newScrollTop = viewerState.viewport.top;
	        var newScrollLeft = viewerState.viewport.left;
	
	        if (settings.verticallyOriented || settings.inGrid)
	            direction = newScrollTop - previousTopScroll;
	        else
	            direction = newScrollLeft - previousLeftScroll;
	
	        //give adjust the direction we care about
	        viewerState.renderer.adjust(direction);
	
	        var primaryScroll = (settings.verticallyOriented || settings.inGrid) ? newScrollTop : newScrollLeft;
	
	        publish("ViewerDidScroll", primaryScroll);
	
	        if (direction > 0)
	        {
	            publish("ViewerDidScrollDown", primaryScroll);
	        }
	        else if (direction < 0)
	        {
	            publish("ViewerDidScrollUp", primaryScroll);
	        }
	
	        updateOffsets();
	    };
	
	    // Binds most of the event handlers (some more in createToolbar)
	    var handleEvents = function ()
	    {
	        // Change the cursor for dragging
	        viewerState.innerObject.mousedown(function ()
	        {
	            viewerState.innerObject.addClass('diva-grabbing');
	        });
	
	        viewerState.innerObject.mouseup(function ()
	        {
	            viewerState.innerObject.removeClass('diva-grabbing');
	        });
	
	        bindMouseEvents();
	
	        viewerState.viewportObject.scroll(scrollFunction);
	
	        var upArrowKey = 38,
	            downArrowKey = 40,
	            leftArrowKey = 37,
	            rightArrowKey = 39,
	            spaceKey = 32,
	            pageUpKey = 33,
	            pageDownKey = 34,
	            homeKey = 36,
	            endKey = 35;
	
	        // Catch the key presses in document
	        $(document).on('keydown.diva', function (event)
	        {
	            if (!viewerState.isActiveDiva)
	                return true;
	
	            // Space or page down - go to the next page
	            if ((settings.enableSpaceScroll && !event.shiftKey && event.keyCode === spaceKey) || (settings.enableKeyScroll && event.keyCode === pageDownKey))
	            {
	                viewerState.viewport.top += settings.panelHeight;
	                return false;
	            }
	            else if (!settings.enableSpaceScroll && event.keyCode === spaceKey)
	            {
	                event.preventDefault();
	            }
	
	            if (settings.enableKeyScroll)
	            {
	                // Don't steal keyboard shortcuts (metaKey = command [OS X], super [Win/Linux])
	                if (event.shiftKey || event.ctrlKey || event.metaKey)
	                    return true;
	
	                switch (event.keyCode)
	                {
	                    case pageUpKey:
	                        // Page up - go to the previous page
	                        viewerState.viewport.top -= settings.panelHeight;
	                        return false;
	
	                    case upArrowKey:
	                        // Up arrow - scroll up
	                        viewerState.viewport.top -= settings.arrowScrollAmount;
	                        return false;
	
	                    case downArrowKey:
	                        // Down arrow - scroll down
	                        viewerState.viewport.top += settings.arrowScrollAmount;
	                        return false;
	
	                    case leftArrowKey:
	                        // Left arrow - scroll left
	                        viewerState.viewport.left -= settings.arrowScrollAmount;
	                        return false;
	
	                    case rightArrowKey:
	                        // Right arrow - scroll right
	                        viewerState.viewport.left += settings.arrowScrollAmount;
	                        return false;
	
	                    case homeKey:
	                        // Home key - go to the beginning of the document
	                        viewerState.viewport.top = 0;
	                        return false;
	
	                    case endKey:
	                        // End key - go to the end of the document
	                        // Count on the viewport coordinate value being normalized
	                        if (settings.verticallyOriented)
	                            viewerState.viewport.top = Infinity;
	                        else
	                            viewerState.viewport.left = Infinity;
	
	                        return false;
	
	                    default:
	                        return true;
	                }
	            }
	            return true;
	        });
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            $(document).off('keydown.diva');
	        }, settings.ID);
	
	        bindTouchEvents();
	
	        // Handle window resizing events
	        window.addEventListener('resize', onResize, false);
	
	        diva.Events.subscribe('ViewerDidTerminate', function()
	        {
	            window.removeEventListener('resize', onResize, false);
	        }, settings.ID);
	
	        // Handle orientation change separately
	        if ('onorientationchange' in window)
	        {
	            window.addEventListener('orientationchange', onResize, false);
	
	            diva.Events.subscribe('ViewerDidTerminate', function()
	            {
	                window.removeEventListener('orientationchange', onResize, false);
	            }, settings.ID);
	        }
	
	        diva.Events.subscribe('PanelSizeDidChange', updatePanelSize, settings.ID);
	
	        // Clear page and resize timeouts when the viewer is destroyed
	        diva.Events.subscribe('ViewerDidTerminate', function ()
	        {
	            if (viewerState.renderer)
	                viewerState.renderer.destroy();
	
	            clearTimeout(viewerState.resizeTimer);
	        }, settings.ID);
	    };
	
	    var initPlugins = function ()
	    {
	        // Add all the plugins that have not been explicitly disabled to
	        // settings.plugins
	        PluginRegistry.getAll().forEach(function (plugin)
	        {
	            var pluginProperName = plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1);
	
	            if (settings['enable' + pluginProperName])
	            {
	                // Call the init function and check return value
	                var enablePlugin = plugin.init(settings, publicInstance);
	
	                // If int returns false, consider the plugin disabled
	                if (!enablePlugin)
	                    return;
	
	                // Create the pageTools bar if handleClick is set to a function
	                if (typeof plugin.handleClick === 'function')
	                {
	                    viewerState.pageTools.push(plugin);
	                }
	
	                // Add it to settings.plugins so it can be used later
	                settings.plugins.push(plugin);
	            }
	        });
	    };
	
	    var showThrobber = function ()
	    {
	        hideThrobber();
	
	        viewerState.throbberTimeoutID = setTimeout(function ()
	        {
	            $(settings.selector + 'throbber').show();
	        }, settings.throbberTimeout);
	    };
	
	    var hideThrobber = function ()
	    {
	        // Clear the timeout, if it hasn't executed yet
	        clearTimeout(viewerState.throbberTimeoutID);
	
	        // Hide the throbber if it has already executed
	        $(settings.selector + 'throbber').hide();
	    };
	
	    var showError = function(message)
	    {
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    var setManifest = function (manifest, loadOptions)
	    {
	        viewerState.manifest = manifest;
	
	        hideThrobber();
	
	        // Convenience value
	        viewerState.numPages = settings.manifest.pages.length;
	
	        optionsValidator.validate(viewerState.options);
	
	        publish('NumberOfPagesDidChange', settings.numPages);
	
	        if (settings.enableAutoTitle)
	        {
	            if ($(settings.selector + 'title').length)
	                $(settings.selector + 'title').html(settings.manifest.itemTitle);
	            else
	                settings.parentObject.prepend(elt('div', elemAttrs('title'), [settings.manifest.itemTitle]));
	        }
	
	        // Calculate the horizontal and vertical inter-page padding based on the dimensions of the average zoom level
	        if (settings.adaptivePadding > 0)
	        {
	            var z = Math.floor((settings.minZoomLevel + settings.maxZoomLevel) / 2);
	            viewerState.horizontalPadding = parseInt(settings.manifest.getAverageWidth(z) * settings.adaptivePadding, 10);
	            viewerState.verticalPadding = parseInt(settings.manifest.getAverageHeight(z) * settings.adaptivePadding, 10);
	        }
	        else
	        {
	            // It's less than or equal to 0; use fixedPadding instead
	            viewerState.horizontalPadding = settings.fixedPadding;
	            viewerState.verticalPadding = settings.fixedPadding;
	        }
	
	        // Make sure the vertical padding is at least 40, if plugin icons are enabled
	        if (viewerState.pageTools.length)
	        {
	            viewerState.verticalPadding = Math.max(40, viewerState.verticalPadding);
	        }
	
	        // If we detect a viewingHint of 'paged' in the manifest or sequence, enable book view by default
	        if (settings.manifest.paged)
	        {
	            viewerState.options.inBookLayout = true;
	        }
	
	        // Plugin setup hooks should be bound to the ObjectDidLoad event
	        publish('ObjectDidLoad', settings);
	
	        // Adjust the document panel dimensions
	        updatePanelSize();
	
	        var needsXCoord, needsYCoord;
	
	        var anchoredVertically = false;
	        var anchoredHorizontally = false;
	
	        // NB: `==` here will check both null and undefined
	        if (loadOptions.goDirectlyTo == null)
	        {
	            loadOptions.goDirectlyTo = settings.goDirectlyTo;
	            needsXCoord = needsYCoord = true;
	        }
	        else
	        {
	            needsXCoord = loadOptions.horizontalOffset == null || isNaN(loadOptions.horizontalOffset);
	            needsYCoord = loadOptions.verticalOffset == null || isNaN(loadOptions.verticalOffset);
	        }
	
	        // Set default values for the horizontal and vertical offsets
	        if (needsXCoord)
	        {
	            // FIXME: What if inBookLayout/verticallyOriented is changed by loadOptions?
	            if (loadOptions.goDirectlyTo === 0 && settings.inBookLayout && settings.verticallyOriented)
	            {
	                // if in book layout, center the first opening by default
	                loadOptions.horizontalOffset = viewerState.horizontalPadding;
	            }
	            else
	            {
	                anchoredHorizontally = true;
	                loadOptions.horizontalOffset = getXOffset(loadOptions.goDirectlyTo, "center");
	            }
	        }
	
	        if (needsYCoord)
	        {
	            anchoredVertically = true;
	            loadOptions.verticalOffset = getYOffset(loadOptions.goDirectlyTo, "top");
	        }
	
	        reloadViewer(loadOptions);
	
	        //prep dimensions one last time now that pages have loaded
	        updatePanelSize();
	
	        // FIXME: This is a hack to ensure that the outerElement scrollbars are taken into account
	        if (settings.verticallyOriented)
	            viewerState.innerElement.style.minWidth = settings.panelWidth + 'px';
	        else
	            viewerState.innerElement.style.minHeight = settings.panelHeight + 'px';
	
	        // FIXME: If the page was supposed to be positioned relative to the viewport we need to
	        // recalculate it to take into account the scrollbars
	        if (anchoredVertically || anchoredHorizontally)
	        {
	            if (anchoredVertically)
	                viewerState.verticalOffset = getYOffset(settings.currentPageIndex, "top");
	
	            if (anchoredHorizontally)
	                viewerState.horizontalOffset = getXOffset(settings.currentPageIndex, "center");
	
	            viewerState.renderer.goto(settings.currentPageIndex, viewerState.verticalOffset, viewerState.horizontalOffset);
	        }
	
	        // signal that everything should be set up and ready to go.
	        viewerState.loaded = true;
	
	        publish("ViewerDidLoad", settings);
	    };
	
	    var publish = function (event)
	    {
	        var args = Array.prototype.slice.call(arguments, 1);
	        diva.Events.publish(event, args, publicInstance);
	    };
	
	    var init = function ()
	    {
	        // First figure out the width of the scrollbar in this browser
	        // TODO(wabain): Cache this somewhere else
	        // Only some of the plugins rely on this now
	        viewerState.scrollbarWidth = getScrollbarWidth();
	
	        // If window.orientation is defined, then it's probably mobileWebkit
	        viewerState.mobileWebkit = window.orientation !== undefined;
	
	        // Generate an ID that can be used as a prefix for all the other IDs
	        var idNumber = generateId();
	        viewerState.ID = 'diva-' + idNumber + '-';
	        viewerState.selector = '#' + settings.ID;
	
	        if (options.hashParamSuffix === null)
	        {
	            // Omit the suffix from the first instance
	            if (idNumber === 1)
	                options.hashParamSuffix = '';
	            else
	                options.hashParamSuffix = idNumber + '';
	        }
	
	        // Create the inner and outer panels
	        var innerElem = elt('div', elemAttrs('inner', { class: 'diva-inner diva-dragger' }));
	        var viewportElem = elt('div', elemAttrs('viewport'), innerElem);
	        var outerElem = elt('div', elemAttrs('outer'),
	            viewportElem,
	            elt('div', elemAttrs('throbber')));
	
	        viewerState.innerElement = innerElem;
	        viewerState.viewportElement = viewportElem;
	        viewerState.outerElement = outerElem;
	
	        viewerState.innerObject = $(innerElem);
	        viewerState.viewportObject = $(viewportElem);
	        viewerState.outerObject = $(outerElem);
	
	        settings.parentObject.append(outerElem);
	
	        viewerState.viewport = new Viewport(viewerState.viewportElement, {
	            intersectionTolerance: settings.viewportMargin
	        });
	
	        // Do all the plugin initialisation
	        initPlugins();
	
	        handleEvents();
	
	        // Show the throbber while waiting for the manifest to load
	        showThrobber();
	    };
	
	    this.getSettings = function ()
	    {
	        return settings;
	    };
	
	    // Temporary accessor for the state of the viewer core
	    // TODO: Replace this with a more restricted view of whatever needs
	    // be exposed through settings for backwards compat
	    this.getInternalState = function ()
	    {
	        return viewerState;
	    };
	
	    this.getPublicInstance = function ()
	    {
	        return publicInstance;
	    };
	
	    this.getPageTools = function ()
	    {
	        return viewerState.pageTools;
	    };
	
	    this.getCurrentLayout = function ()
	    {
	        return viewerState.renderer ? viewerState.renderer.layout : null;
	    };
	
	    /** Get a copy of the current viewport dimensions */
	    this.getViewport = function ()
	    {
	        var viewport = viewerState.viewport;
	
	        return {
	            top: viewport.top,
	            left: viewport.left,
	            bottom: viewport.bottom,
	            right: viewport.right,
	
	            width: viewport.width,
	            height: viewport.height
	        };
	    };
	
	    this.addPageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.addOverlay(overlay);
	    };
	
	    this.removePageOverlay = function (overlay)
	    {
	        viewerState.pageOverlays.removeOverlay(overlay);
	    };
	
	    this.getPageRegion = function (pageIndex, options)
	    {
	        var layout = viewerState.renderer.layout;
	        var region = layout.getPageRegion(pageIndex, options);
	
	        if (options && options.incorporateViewport)
	        {
	            var secondaryDim = settings.verticallyOriented ? 'width' : 'height';
	
	            if (viewerState.viewport[secondaryDim] > layout.dimensions[secondaryDim])
	            {
	                var docOffset = (viewerState.viewport[secondaryDim] - layout.dimensions[secondaryDim]) / 2;
	
	                if (settings.verticallyOriented)
	                {
	                    return {
	                        top: region.top,
	                        bottom: region.bottom,
	
	                        left: region.left + docOffset,
	                        right: region.right + docOffset
	                    };
	                }
	                else
	                {
	                    return {
	                        top: region.top + docOffset,
	                        bottom: region.bottom + docOffset,
	
	                        left: region.left,
	                        right: region.right
	                    };
	                }
	            }
	        }
	
	        return region;
	    };
	
	    this.getPagePositionAtViewportOffset = function (coords)
	    {
	        var docCoords = {
	            left: coords.left + viewerState.viewport.left,
	            top: coords.top + viewerState.viewport.top
	        };
	
	        var renderedPages = viewerState.renderer.getRenderedPages();
	        var pageCount = renderedPages.length;
	
	        // Find the page on which the coords occur
	        for (var i=0; i < pageCount; i++)
	        {
	            var pageIndex = renderedPages[i];
	            var region = viewerState.renderer.layout.getPageRegion(pageIndex);
	
	            if (region.left <= docCoords.left && region.right >= docCoords.left &&
	                region.top <= docCoords.top && region.bottom >= docCoords.top)
	            {
	                return {
	                    anchorPage: pageIndex,
	                    offset: {
	                        left: docCoords.left - region.left,
	                        top: docCoords.top - region.top
	                    }
	                };
	            }
	        }
	
	        // Fall back to current page
	        // FIXME: Would be better to use the closest page or something
	        var currentRegion = viewerState.renderer.layout.getPageRegion(settings.currentPageIndex);
	
	        return {
	            anchorPage: settings.currentPageIndex,
	            offset: {
	                left: docCoords.left - currentRegion.left,
	                top: docCoords.top - currentRegion.top
	            }
	        };
	    };
	
	    this.setManifest = function (manifest, loadOptions)
	    {
	        setManifest(manifest, loadOptions || {});
	    };
	
	    /**
	     * Set the current page to the given index, firing VisiblePageDidChange
	     *
	     * @param pageIndex
	     */
	    this.setCurrentPage = function (pageIndex)
	    {
	        if (viewerState.currentPageIndex !== pageIndex)
	        {
	            viewerState.currentPageIndex = pageIndex;
	            publish("VisiblePageDidChange", pageIndex, this.getPageName(pageIndex));
	        }
	    };
	
	    this.getPageName = function (pageIndex)
	    {
	        return viewerState.manifest.pages[pageIndex].f;
	    };
	
	    this.reload = function (newOptions)
	    {
	        reloadViewer(newOptions);
	    };
	
	    this.zoom = function (zoomLevel, focalPoint)
	    {
	        return handleZoom(zoomLevel, focalPoint);
	    };
	
	    this.enableScrollable = function ()
	    {
	        if (!viewerState.isScrollable)
	        {
	            bindMouseEvents();
	            viewerState.options.enableKeyScroll = viewerState.initialKeyScroll;
	            viewerState.options.enableSpaceScroll = viewerState.initialSpaceScroll;
	            viewerState.viewportElement.style.overflow = 'auto';
	            viewerState.isScrollable = true;
	        }
	    };
	
	    this.disableScrollable = function ()
	    {
	        if (viewerState.isScrollable)
	        {
	            // block dragging/double-click zooming
	            if (viewerState.innerObject.hasClass('diva-dragger'))
	                viewerState.innerObject.unbind('mousedown');
	            viewerState.outerObject.unbind('dblclick');
	            viewerState.outerObject.unbind('contextmenu');
	
	            // disable all other scrolling actions
	            viewerState.viewportElement.style.overflow = 'hidden';
	
	            // block scrolling keys behavior, respecting initial scroll settings
	            viewerState.initialKeyScroll = settings.enableKeyScroll;
	            viewerState.initialSpaceScroll = settings.enableSpaceScroll;
	            viewerState.options.enableKeyScroll = false;
	            viewerState.options.enableSpaceScroll = false;
	
	            viewerState.isScrollable = false;
	        }
	    };
	
	    this.isValidOption = function (key, value)
	    {
	        return isValidOption(key, value);
	    };
	
	    this.showError = function (message)
	    {
	        // FIXME: Not totally sure it makes sense to always do that here
	        hideThrobber();
	
	        var errorElement = elt('div', elemAttrs('error'), [
	            elt('button', elemAttrs('error-close', {'aria-label': 'Close dialog'})),
	            elt('p',
	                elt('strong', 'Error')
	            ),
	            elt('div', message)
	        ]);
	
	        viewerState.outerObject.append(errorElement);
	
	        //bind dialog close button
	        $(settings.selector + 'error-close').on('click', function()
	        {
	            errorElement.parentNode.removeChild(errorElement);
	        });
	    };
	
	    this.getXOffset = function (pageIndex, xAnchor)
	    {
	        return getXOffset(pageIndex, xAnchor);
	    };
	
	    this.getYOffset = function (pageIndex, yAnchor)
	    {
	        return getYOffset(pageIndex, yAnchor);
	    };
	
	    this.publish = publish;
	
	    this.clear = function ()
	    {
	        clearViewer();
	    };
	
	    this.setPendingManifestRequest = function (pendingManifestRequest)
	    {
	        viewerState.pendingManifestRequest = pendingManifestRequest;
	    };
	
	    // Destroys this instance, tells plugins to do the same (for testing)
	    this.destroy = function ()
	    {
	        // Useful event to access elements in diva before they get destroyed. Used by the highlight plugin.
	        publish('ViewerWillTerminate', settings);
	
	        // Cancel any pending request retrieving a manifest
	        if (settings.pendingManifestRequest)
	            settings.pendingManifestRequest.abort();
	
	        // Removes the hide-scrollbar class from the body
	        $('body').removeClass('diva-hide-scrollbar');
	
	        // Empty the parent container and remove any diva-related data
	        settings.parentObject.parent().empty().removeData('diva');
	
	        // Remove any additional styling on the parent element
	        settings.parentObject.parent().removeAttr('style').removeAttr('class');
	
	        publish('ViewerDidTerminate', settings);
	
	        // Clear the Events cache
	        diva.Events.unsubscribeAll(settings.ID);
	    };
	
	    // Call the init function when this object is created.
	    init();
	}
	
	generateId.counter = 1;
	
	function generateId() {
	    return generateId.counter++;
	}


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* jshint unused: false */
	
	var jQuery = __webpack_require__(3);
	
	/* istanbul ignore next This is a vendored dependency */
	/*
	 * jQuery dragscrollable Plugin
	 * version: 1.0 (25-Jun-2009)
	 * Copyright (c) 2009 Miquel Herrera
	 * http://plugins.jquery.com/project/Dragscrollable
	 *
	 * Dual licensed under the MIT and GPL licenses:
	 *   http://www.opensource.org/licenses/mit-license.php
	 *   http://www.gnu.org/licenses/gpl.html
	 *
	 */
	(function ($) { // secure $ jQuery alias
	
	    /**
	     * Adds the ability to manage elements scroll by dragging
	     * one or more of its descendant elements. Options parameter
	     * allow to specifically select which inner elements will
	     * respond to the drag events.
	     *
	     * options properties:
	     * ------------------------------------------------------------------------
	     *  dragSelector         | jquery selector to apply to each wrapped element
	     *                       | to find which will be the dragging elements.
	     *                       | Defaults to '>:first' which is the first child of
	     *                       | scrollable element
	     * ------------------------------------------------------------------------
	     *  acceptPropagatedEvent| Will the dragging element accept propagated
	     *                       | events? default is yes, a propagated mouse event
	     *                       | on a inner element will be accepted and processed.
	     *                       | If set to false, only events originated on the
	     *                       | draggable elements will be processed.
	     * ------------------------------------------------------------------------
	     *  preventDefault       | Prevents the event to propagate further effectivey
	     *                       | dissabling other default actions. Defaults to true
	     * ------------------------------------------------------------------------
	     *
	     *  usage examples:
	     *
	     *  To add the scroll by drag to the element id=viewport when dragging its
	     *  first child accepting any propagated events
	     *  $('#viewport').dragscrollable();
	     *
	     *  To add the scroll by drag ability to any element div of class viewport
	     *  when dragging its first descendant of class dragMe responding only to
	     *  evcents originated on the '.dragMe' elements.
	     *  $('div.viewport').dragscrollable({dragSelector:'.dragMe:first',
	 *                                    acceptPropagatedEvent: false});
	     *
	     *  Notice that some 'viewports' could be nested within others but events
	     *  would not interfere as acceptPropagatedEvent is set to false.
	     *
	     */
	    $.fn.dragscrollable = function( options ){
	
	        var settings = $.extend(
	            {
	                dragSelector:'>:first',
	                acceptPropagatedEvent: true,
	                preventDefault: true
	            },options || {});
	
	
	        var dragscroll= {
	            mouseDownHandler : function(event) {
	                // mousedown, left click, check propagation
	                if (event.which!=1 ||
	                    (!event.data.acceptPropagatedEvent && event.target != this)){
	                    return false;
	                }
	
	                // Initial coordinates will be the last when dragging
	                event.data.lastCoord = {left: event.clientX, top: event.clientY};
	
	                $.event.add( document, "mouseup",
	                    dragscroll.mouseUpHandler, event.data );
	                $.event.add( document, "mousemove",
	                    dragscroll.mouseMoveHandler, event.data );
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            },
	            mouseMoveHandler : function(event) { // User is dragging
	                // How much did the mouse move?
	                var delta = {left: (event.clientX - event.data.lastCoord.left),
	                    top: (event.clientY - event.data.lastCoord.top)};
	
	                // Set the scroll position relative to what ever the scroll is now
	                event.data.scrollable.scrollLeft(
	                    event.data.scrollable.scrollLeft() - delta.left);
	                event.data.scrollable.scrollTop(
	                    event.data.scrollable.scrollTop() - delta.top);
	
	                // Save where the cursor is
	                event.data.lastCoord={left: event.clientX, top: event.clientY};
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	
	            },
	            mouseUpHandler : function(event) { // Stop scrolling
	                $.event.remove( document, "mousemove", dragscroll.mouseMoveHandler);
	                $.event.remove( document, "mouseup", dragscroll.mouseUpHandler);
	                if (event.data.preventDefault) {
	                    event.preventDefault();
	                    return false;
	                }
	            }
	        };
	
	        // set up the initial events
	        this.each(function() {
	            // closure object data for each scrollable element
	            var data = {scrollable : $(this),
	                acceptPropagatedEvent : settings.acceptPropagatedEvent,
	                preventDefault : settings.preventDefault };
	            // Set mouse initiating event on the desired descendant
	            $(this).find(settings.dragSelector).
	            bind('mousedown', data, dragscroll.mouseDownHandler);
	        });
	    }; //end plugin dragscrollable
	
	})( jQuery ); // confine scope
	
	/* istanbul ignore next This is a vendored dependency */
	/**
	 jQuery.kinetic v2.2.1
	 Dave Taylor http://davetayls.me
	
	 @license The MIT License (MIT)
	 @preserve Copyright (c) 2012 Dave Taylor http://davetayls.me
	 */
	(function ($){
	    'use strict';
	
	    var ACTIVE_CLASS = 'kinetic-active';
	
	    /**
	     * Provides requestAnimationFrame in a cross browser way.
	     * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
	     */
	    if (!window.requestAnimationFrame){
	
	        window.requestAnimationFrame = ( function (){
	
	            return window.webkitRequestAnimationFrame ||
	                window.mozRequestAnimationFrame ||
	                window.oRequestAnimationFrame ||
	                window.msRequestAnimationFrame ||
	                function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element){
	                    window.setTimeout(callback, 1000 / 60);
	                };
	
	        }());
	
	    }
	
	    // add touch checker to jQuery.support
	    $.support = $.support || {};
	    $.extend($.support, {
	        touch: 'ontouchend' in document
	    });
	
	
	    // KINETIC CLASS DEFINITION
	    // ======================
	
	    var Kinetic = function (element, settings) {
	        this.settings = settings;
	        this.el       = element;
	        this.$el      = $(element);
	
	        this._initElements();
	
	        return this;
	    };
	
	    Kinetic.DATA_KEY = 'kinetic';
	    Kinetic.DEFAULTS = {
	        cursor: 'move',
	        decelerate: true,
	        triggerHardware: false,
	        threshold: 0,
	        y: true,
	        x: true,
	        slowdown: 0.9,
	        maxvelocity: 40,
	        throttleFPS: 60,
	        invert: false,
	        movingClass: {
	            up: 'kinetic-moving-up',
	            down: 'kinetic-moving-down',
	            left: 'kinetic-moving-left',
	            right: 'kinetic-moving-right'
	        },
	        deceleratingClass: {
	            up: 'kinetic-decelerating-up',
	            down: 'kinetic-decelerating-down',
	            left: 'kinetic-decelerating-left',
	            right: 'kinetic-decelerating-right'
	        }
	    };
	
	
	    // Public functions
	
	    Kinetic.prototype.start = function (options){
	        this.settings = $.extend(this.settings, options);
	        this.velocity = options.velocity || this.velocity;
	        this.velocityY = options.velocityY || this.velocityY;
	        this.settings.decelerate = false;
	        this._move();
	    };
	
	    Kinetic.prototype.end = function (){
	        this.settings.decelerate = true;
	    };
	
	    Kinetic.prototype.stop = function (){
	        this.velocity = 0;
	        this.velocityY = 0;
	        this.settings.decelerate = true;
	        if ($.isFunction(this.settings.stopped)){
	            this.settings.stopped.call(this);
	        }
	    };
	
	    Kinetic.prototype.detach = function (){
	        this._detachListeners();
	        this.$el
	            .removeClass(ACTIVE_CLASS)
	            .css('cursor', '');
	    };
	
	    Kinetic.prototype.attach = function (){
	        if (this.$el.hasClass(ACTIVE_CLASS)) {
	            return;
	        }
	        this._attachListeners(this.$el);
	        this.$el
	            .addClass(ACTIVE_CLASS)
	            .css('cursor', this.settings.cursor);
	    };
	
	
	    // Internal functions
	
	    Kinetic.prototype._initElements = function (){
	        this.$el.addClass(ACTIVE_CLASS);
	
	        $.extend(this, {
	            xpos: null,
	            prevXPos: false,
	            ypos: null,
	            prevYPos: false,
	            mouseDown: false,
	            throttleTimeout: 1000 / this.settings.throttleFPS,
	            lastMove: null,
	            elementFocused: null
	        });
	
	        this.velocity = 0;
	        this.velocityY = 0;
	
	        // make sure we reset everything when mouse up
	        $(document)
	            .mouseup($.proxy(this._resetMouse, this))
	            .click($.proxy(this._resetMouse, this));
	
	        this._initEvents();
	
	        this.$el.css('cursor', this.settings.cursor);
	
	        if (this.settings.triggerHardware){
	            this.$el.css({
	                '-webkit-transform': 'translate3d(0,0,0)',
	                '-webkit-perspective': '1000',
	                '-webkit-backface-visibility': 'hidden'
	            });
	        }
	    };
	
	    Kinetic.prototype._initEvents = function(){
	        var self = this;
	        this.settings.events = {
	            touchStart: function (e){
	                var touch;
	                if (self._useTarget(e.target, e)){
	                    touch = e.originalEvent.touches[0];
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(touch.clientX, touch.clientY);
	                    e.stopPropagation();
	                }
	            },
	            touchMove: function (e){
	                var touch;
	                if (self.mouseDown){
	                    touch = e.originalEvent.touches[0];
	                    self._inputmove(touch.clientX, touch.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputDown: function (e){
	                if (self._useTarget(e.target, e)){
	                    self.threshold = self._threshold(e.target, e);
	                    self._start(e.clientX, e.clientY);
	                    self.elementFocused = e.target;
	                    if (e.target.nodeName === 'IMG'){
	                        e.preventDefault();
	                    }
	                    e.stopPropagation();
	                }
	            },
	            inputEnd: function (e){
	                if (self._useTarget(e.target, e)){
	                    self._end();
	                    self.elementFocused = null;
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            inputMove: function (e){
	                if (self.mouseDown){
	                    self._inputmove(e.clientX, e.clientY);
	                    if (e.preventDefault){
	                        e.preventDefault();
	                    }
	                }
	            },
	            scroll: function (e){
	                if ($.isFunction(self.settings.moved)){
	                    self.settings.moved.call(self, self.settings);
	                }
	                if (e.preventDefault){
	                    e.preventDefault();
	                }
	            },
	            inputClick: function (e){
	                if (Math.abs(self.velocity) > 0){
	                    e.preventDefault();
	                    return false;
	                }
	            },
	            // prevent drag and drop images in ie
	            dragStart: function (e){
	                if (self._useTarget(e.target, e) && self.elementFocused){
	                    return false;
	                }
	            },
	            // prevent selection when dragging
	            selectStart: function (e){
	                if ($.isFunction(self.settings.selectStart)){
	                    return self.settings.selectStart.apply(self, arguments);
	                } else if (self._useTarget(e.target, e)) {
	                    return false;
	                }
	            }
	        };
	
	        this._attachListeners(this.$el, this.settings);
	
	    };
	
	    Kinetic.prototype._inputmove = function (clientX, clientY){
	        var $this = this.$el;
	        var el = this.el;
	
	        if (!this.lastMove || new Date() > new Date(this.lastMove.getTime() + this.throttleTimeout)){
	            this.lastMove = new Date();
	
	            if (this.mouseDown && (this.xpos || this.ypos)){
	                var movedX = (clientX - this.xpos);
	                var movedY = (clientY - this.ypos);
	                if (this.settings.invert) {
	                    movedX *= -1;
	                    movedY *= -1;
	                }
	                if(this.threshold > 0){
	                    var moved = Math.sqrt(movedX * movedX + movedY * movedY);
	                    if(this.threshold > moved){
	                        return;
	                    } else {
	                        this.threshold = 0;
	                    }
	                }
	                if (this.elementFocused){
	                    $(this.elementFocused).blur();
	                    this.elementFocused = null;
	                    $this.focus();
	                }
	
	                this.settings.decelerate = false;
	                this.velocity = this.velocityY = 0;
	
	                var scrollLeft = this.scrollLeft();
	                var scrollTop = this.scrollTop();
	
	                this.scrollLeft(this.settings.x ? scrollLeft - movedX : scrollLeft);
	                this.scrollTop(this.settings.y ? scrollTop - movedY : scrollTop);
	
	                this.prevXPos = this.xpos;
	                this.prevYPos = this.ypos;
	                this.xpos = clientX;
	                this.ypos = clientY;
	
	                this._calculateVelocities();
	                this._setMoveClasses(this.settings.movingClass);
	
	                if ($.isFunction(this.settings.moved)){
	                    this.settings.moved.call(this, this.settings);
	                }
	            }
	        }
	    };
	
	    Kinetic.prototype._calculateVelocities = function (){
	        this.velocity = this._capVelocity(this.prevXPos - this.xpos, this.settings.maxvelocity);
	        this.velocityY = this._capVelocity(this.prevYPos - this.ypos, this.settings.maxvelocity);
	        if (this.settings.invert) {
	            this.velocity *= -1;
	            this.velocityY *= -1;
	        }
	    };
	
	    Kinetic.prototype._end = function (){
	        if (this.xpos && this.prevXPos && this.settings.decelerate === false){
	            this.settings.decelerate = true;
	            this._calculateVelocities();
	            this.xpos = this.prevXPos = this.mouseDown = false;
	            this._move();
	        }
	    };
	
	    Kinetic.prototype._useTarget = function (target, event){
	        if ($.isFunction(this.settings.filterTarget)){
	            return this.settings.filterTarget.call(this, target, event) !== false;
	        }
	        return true;
	    };
	
	    Kinetic.prototype._threshold = function (target, event){
	        if ($.isFunction(this.settings.threshold)){
	            return this.settings.threshold.call(this, target, event);
	        }
	        return this.settings.threshold;
	    };
	
	    Kinetic.prototype._start = function (clientX, clientY){
	        this.mouseDown = true;
	        this.velocity = this.prevXPos = 0;
	        this.velocityY = this.prevYPos = 0;
	        this.xpos = clientX;
	        this.ypos = clientY;
	    };
	
	    Kinetic.prototype._resetMouse = function (){
	        this.xpos = false;
	        this.ypos = false;
	        this.mouseDown = false;
	    };
	
	    Kinetic.prototype._decelerateVelocity = function (velocity, slowdown){
	        return Math.floor(Math.abs(velocity)) === 0 ? 0 // is velocity less than 1?
	            : velocity * slowdown; // reduce slowdown
	    };
	
	    Kinetic.prototype._capVelocity = function (velocity, max){
	        var newVelocity = velocity;
	        if (velocity > 0){
	            if (velocity > max){
	                newVelocity = max;
	            }
	        } else {
	            if (velocity < (0 - max)){
	                newVelocity = (0 - max);
	            }
	        }
	        return newVelocity;
	    };
	
	    Kinetic.prototype._setMoveClasses = function (classes){
	        // FIXME: consider if we want to apply PL #44, this should not remove
	        // classes we have not defined on the element!
	        var settings = this.settings;
	        var $this = this.$el;
	
	        $this.removeClass(settings.movingClass.up)
	            .removeClass(settings.movingClass.down)
	            .removeClass(settings.movingClass.left)
	            .removeClass(settings.movingClass.right)
	            .removeClass(settings.deceleratingClass.up)
	            .removeClass(settings.deceleratingClass.down)
	            .removeClass(settings.deceleratingClass.left)
	            .removeClass(settings.deceleratingClass.right);
	
	        if (this.velocity > 0){
	            $this.addClass(classes.right);
	        }
	        if (this.velocity < 0){
	            $this.addClass(classes.left);
	        }
	        if (this.velocityY > 0){
	            $this.addClass(classes.down);
	        }
	        if (this.velocityY < 0){
	            $this.addClass(classes.up);
	        }
	
	    };
	
	
	    // do the actual kinetic movement
	    Kinetic.prototype._move = function (){
	        var $scroller = this._getScroller();
	        var scroller = $scroller[0];
	        var self = this;
	        var settings = self.settings;
	
	        // set scrollLeft
	        if (settings.x && scroller.scrollWidth > 0){
	            this.scrollLeft(this.scrollLeft() + this.velocity);
	            if (Math.abs(this.velocity) > 0){
	                this.velocity = settings.decelerate ?
	                    self._decelerateVelocity(this.velocity, settings.slowdown) : this.velocity;
	            }
	        } else {
	            this.velocity = 0;
	        }
	
	        // set scrollTop
	        if (settings.y && scroller.scrollHeight > 0){
	            this.scrollTop(this.scrollTop() + this.velocityY);
	            if (Math.abs(this.velocityY) > 0){
	                this.velocityY = settings.decelerate ?
	                    self._decelerateVelocity(this.velocityY, settings.slowdown) : this.velocityY;
	            }
	        } else {
	            this.velocityY = 0;
	        }
	
	        self._setMoveClasses(settings.deceleratingClass);
	
	        if ($.isFunction(settings.moved)){
	            settings.moved.call(this, settings);
	        }
	
	        if (Math.abs(this.velocity) > 0 || Math.abs(this.velocityY) > 0){
	            if (!this.moving) {
	                this.moving = true;
	                // tick for next movement
	                window.requestAnimationFrame(function (){
	                    self.moving = false;
	                    self._move();
	                });
	            }
	        } else {
	            self.stop();
	        }
	    };
	
	    // get current scroller to apply positioning to
	    Kinetic.prototype._getScroller = function(){
	        var $scroller = this.$el;
	        if (this.$el.is('body') || this.$el.is('html')){
	            $scroller = $(window);
	        }
	        return $scroller;
	    };
	
	    // set the scroll position
	    Kinetic.prototype.scrollLeft = function(left){
	        var $scroller = this._getScroller();
	        if (typeof left === 'number'){
	            $scroller.scrollLeft(left);
	            this.settings.scrollLeft = left;
	        } else {
	            return $scroller.scrollLeft();
	        }
	    };
	    Kinetic.prototype.scrollTop = function(top){
	        var $scroller = this._getScroller();
	        if (typeof top === 'number'){
	            $scroller.scrollTop(top);
	            this.settings.scrollTop = top;
	        } else {
	            return $scroller.scrollTop();
	        }
	    };
	
	    Kinetic.prototype._attachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch){
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .mousedown(settings.events.inputDown)
	            .mouseup(settings.events.inputEnd)
	            .mousemove(settings.events.inputMove);
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    Kinetic.prototype._detachListeners = function (){
	        var $this = this.$el;
	        var settings = this.settings;
	        if ($.support.touch){
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('mousedown', settings.events.inputDown)
	            .unbind('mouseup', settings.events.inputEnd)
	            .unbind('mousemove', settings.events.inputMove);
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	
	
	    // EXPOSE KINETIC CONSTRUCTOR
	    // ==========================
	    $.Kinetic = Kinetic;
	
	    // KINETIC PLUGIN DEFINITION
	    // =======================
	
	    $.fn.kinetic = function (option, callOptions) {
	        return this.each(function () {
	            var $this    = $(this);
	            var instance = $this.data(Kinetic.DATA_KEY);
	            var options  = $.extend({}, Kinetic.DEFAULTS, $this.data(), typeof option === 'object' && option);
	
	            if (!instance) {
	                $this.data(Kinetic.DATA_KEY, (instance = new Kinetic(this, options)));
	            }
	
	            if (typeof option === 'string') {
	                instance[option](callOptions);
	            }
	
	        });
	    };
	
	}(jQuery));
	
	/* istanbul ignore next
	    We should maybe be testing this, but realistically that would mean maintaining a real fork */
	
	// jQuery.kinetic core modifications for diva.js (compatible with jQuery.kinetic 2.2.1)
	// use jQuery.kinetic for touch handlers only since we are using dragscrollable for mouse handlers
	//    - (kinetic provides inertial scrolling [ease into stopped state on release] for touch events and dragscrollable
	//      allows non-inertial scrolling which we like for mice)
	
	(function($)
	{
	    $.Kinetic.prototype._attachListeners = function()
	    {
	        // attach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .bind('touchstart', settings.events.touchStart)
	                .bind('touchend', settings.events.inputEnd)
	                .bind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .click(settings.events.inputClick)
	            .scroll(settings.events.scroll)
	            .bind('selectstart', settings.events.selectStart)
	            .bind('dragstart', settings.events.dragStart);
	    };
	
	    $.Kinetic.prototype._detachListeners = function()
	    {
	        // detach only touch listeners
	        var $this = this.$el;
	        var settings = this.settings;
	
	        if ($.support.touch)
	        {
	            $this
	                .unbind('touchstart', settings.events.touchStart)
	                .unbind('touchend', settings.events.inputEnd)
	                .unbind('touchmove', settings.events.touchMove);
	        }
	
	        $this
	            .unbind('click', settings.events.inputClick)
	            .unbind('scroll', settings.events.scroll)
	            .unbind('selectstart', settings.events.selectStart)
	            .unbind('dragstart', settings.events.dragStart);
	    };
	})(jQuery);


/***/ }),
/* 17 */
/***/ (function(module, exports) {

	// From http://www.alexandre-gomes.com/?p=115, modified slightly
	module.exports = function getScrollbarWidth() {
	    var inner = document.createElement('p');
	    inner.style.width = '100%';
	    inner.style.height = '200px';
	
	    var outer = document.createElement('div');
	    outer.style.position = 'absolute';
	    outer.style.top = '0px';
	    outer.style.left = '0px';
	    outer.style.visibility = 'hidden';
	    outer.style.width = '200px';
	    outer.style.height = '150px';
	    outer.style.overflow = 'hidden';
	    outer.appendChild(inner);
	
	    document.body.appendChild(outer);
	
	    var w1 = inner.offsetWidth;
	    outer.style.overflow = 'scroll';
	    var w2 = inner.offsetWidth;
	    if (w1 == w2) {
	        w2 = outer.clientWidth; // for IE i think
	    }
	
	    document.body.removeChild(outer);
	    return w1 - w2;
	};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	module.exports = {
	    onDoubleClick: onDoubleClick,
	    onPinch: onPinch,
	    onDoubleTap: onDoubleTap
	};
	
	var DOUBLE_CLICK_TIMEOUT = 500;
	
	var DOUBLE_TAP_DISTANCE_THRESHOLD = 50;
	var DOUBLE_TAP_TIMEOUT = 250;
	
	function onDoubleClick(elem, callback)
	{
	    elem.on('dblclick', function (event)
	    {
	        if (!event.ctrlKey)
	        {
	            callback(event, getRelativeOffset(event.currentTarget, event));
	        }
	    });
	
	    // Handle the control key for macs (in conjunction with double-clicking)
	    // FIXME: Does a click get handled with ctrl pressed on non-Macs?
	    var tracker = createDoubleEventTracker(DOUBLE_CLICK_TIMEOUT);
	
	    elem.on('contextmenu', function (event)
	    {
	        event.preventDefault();
	
	        if (event.ctrlKey)
	        {
	            if (tracker.isTriggered())
	            {
	                tracker.reset();
	                callback(event, getRelativeOffset(event.currentTarget, event));
	            }
	            else
	            {
	                tracker.trigger();
	            }
	        }
	    });
	}
	
	function onPinch(elem, callback)
	{
	    var startDistance = 0;
	
	    elem.on('touchstart', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            startDistance = distance(
	                event.originalEvent.touches[0].clientX,
	                event.originalEvent.touches[0].clientY,
	                event.originalEvent.touches[1].clientX,
	                event.originalEvent.touches[1].clientY
	            );
	        }
	    });
	
	    elem.on('touchmove', function(event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (event.originalEvent.touches.length === 2)
	        {
	            var touches = event.originalEvent.touches;
	
	            var moveDistance = distance(
	                touches[0].clientX,
	                touches[0].clientY,
	                touches[1].clientX,
	                touches[1].clientY
	            );
	
	            var zoomDelta = moveDistance - startDistance;
	
	            if (Math.abs(zoomDelta) > 0)
	            {
	                var touchCenter = {
	                    pageX: (touches[0].clientX + touches[1].clientX) / 2,
	                    pageY: (touches[0].clientY + touches[1].clientY) / 2
	                };
	
	                callback(event, getRelativeOffset(event.currentTarget, touchCenter), startDistance, moveDistance);
	            }
	        }
	    });
	}
	
	function onDoubleTap(elem, callback)
	{
	    var tracker = createDoubleEventTracker(DOUBLE_TAP_TIMEOUT);
	    var firstTap = null;
	
	    elem.on('touchend', function (event)
	    {
	        // Prevent mouse event from firing
	        event.preventDefault();
	
	        if (tracker.isTriggered())
	        {
	            tracker.reset();
	
	            // Doubletap has occurred
	            var secondTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            // If first tap is close to second tap (prevents interference with scale event)
	            var tapDistance = distance(firstTap.pageX, firstTap.pageY, secondTap.pageX, secondTap.pageY);
	
	            // TODO: Could give something higher-level than secondTap to callback
	            if (tapDistance < DOUBLE_TAP_DISTANCE_THRESHOLD)
	                callback(event, getRelativeOffset(event.currentTarget, secondTap));
	
	            firstTap = null;
	        }
	        else
	        {
	            firstTap = {
	                pageX: event.originalEvent.changedTouches[0].clientX,
	                pageY: event.originalEvent.changedTouches[0].clientY
	            };
	
	            tracker.trigger();
	        }
	    });
	}
	
	// Pythagorean theorem to get the distance between two points (used for
	// calculating finger distance for double-tap and pinch-zoom)
	function distance(x1, y1, x2, y2)
	{
	    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
	}
	
	// Utility to keep track of whether an event has been triggered twice
	// during a a given duration
	function createDoubleEventTracker(timeoutDuration)
	{
	    var triggered = false;
	    var timeoutId = null;
	
	    return {
	        trigger: function ()
	        {
	            triggered = true;
	            resetTimeout();
	            timeoutId = setTimeout(function ()
	            {
	                triggered = false;
	                timeoutId = null;
	            }, timeoutDuration);
	        },
	        isTriggered: function ()
	        {
	            return triggered;
	        },
	        reset: function ()
	        {
	            triggered = false;
	            resetTimeout();
	        }
	    };
	
	    function resetTimeout()
	    {
	        if (timeoutId !== null)
	        {
	            clearTimeout(timeoutId);
	            timeoutId = null;
	        }
	    }
	}
	
	function getRelativeOffset(elem, pageCoords)
	{
	    var bounds = elem.getBoundingClientRect();
	
	    return {
	        left: pageCoords.pageX - bounds.left,
	        top: pageCoords.pageY - bounds.top
	    };
	}


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(20);
	var PageToolsOverlay = __webpack_require__(22);
	
	module.exports = DocumentHandler;
	
	function DocumentHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	    this._viewerState = viewerCore.getInternalState();
	    this._overlays = [];
	
	    if (viewerCore.getPageTools().length)
	    {
	        var numPages = viewerCore.getSettings().numPages;
	
	        for (var i=0; i < numPages; i++)
	        {
	            var overlay = new PageToolsOverlay(i, viewerCore);
	            this._overlays.push(overlay);
	            viewerCore.addPageOverlay(overlay);
	        }
	    }
	}
	
	// USER EVENTS
	DocumentHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var settings = this._viewerCore.getSettings();
	    var newZoomLevel = event.ctrlKey ? settings.zoomLevel - 1 : settings.zoomLevel + 1;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    this._viewerCore.zoom(newZoomLevel, position);
	};
	
	DocumentHandler.prototype.onPinch = function (event, coords, startDistance, endDistance)
	{
	    // FIXME: Do this check in a way which is less spaghetti code-y
	    var viewerState = this._viewerCore.getInternalState();
	    var settings = this._viewerCore.getSettings();
	
	    var newZoomLevel = Math.log(Math.pow(2, settings.zoomLevel) * endDistance / (startDistance * Math.log(2))) / Math.log(2);
	    newZoomLevel = Math.max(settings.minZoomLevel, newZoomLevel);
	    newZoomLevel = Math.min(settings.maxZoomLevel, newZoomLevel);
	
	    if (newZoomLevel === settings.zoomLevel)
	        return;
	
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var centerOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewerState.viewport);
	    var scaleRatio = 1 / Math.pow(2, settings.zoomLevel - newZoomLevel);
	
	    this._viewerCore.reload({
	        zoomLevel: newZoomLevel,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: (centerOffset.x - position.offset.left) + position.offset.left * scaleRatio,
	        verticalOffset: (centerOffset.y - position.offset.top) + position.offset.top * scaleRatio
	    });
	};
	
	// VIEW EVENTS
	DocumentHandler.prototype.onViewWillLoad = function ()
	{
	    this._viewerCore.publish('DocumentWillLoad', this._viewerCore.getSettings());
	};
	
	DocumentHandler.prototype.onViewDidLoad = function ()
	{
	    // TODO: Should only be necessary to handle changes on view update, not
	    // initial load
	    this._handleZoomLevelChange();
	
	    var currentPageIndex = this._viewerCore.getSettings().currentPageIndex;
	    var fileName = this._viewerCore.getPageName(currentPageIndex);
	    this._viewerCore.publish("DocumentDidLoad", currentPageIndex, fileName);
	};
	
	DocumentHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    var currentPage = (targetPage !== null) ?
	        targetPage :
	        getCentermostPage(renderedPages, this._viewerCore.getCurrentLayout(), this._viewerCore.getViewport());
	
	    // Don't change the current page if there is no page in the viewport
	    // FIXME: Would be better to fall back to the page closest to the viewport
	    if (currentPage !== null)
	        this._viewerCore.setCurrentPage(currentPage);
	
	    if (targetPage !== null)
	        this._viewerCore.publish("ViewerDidJump", targetPage);
	
	    this._handleZoomLevelChange();
	};
	
	DocumentHandler.prototype._handleZoomLevelChange = function ()
	{
	    var viewerState = this._viewerState;
	    var zoomLevel = viewerState.options.zoomLevel;
	
	    // If this is not the initial load, trigger the zoom events
	    if (viewerState.oldZoomLevel !== zoomLevel && viewerState.oldZoomLevel >= 0)
	    {
	        if (viewerState.oldZoomLevel < zoomLevel)
	        {
	            this._viewerCore.publish("ViewerDidZoomIn", zoomLevel);
	        }
	        else
	        {
	            this._viewerCore.publish("ViewerDidZoomOut", zoomLevel);
	        }
	
	        this._viewerCore.publish("ViewerDidZoom", zoomLevel);
	    }
	
	    viewerState.oldZoomLevel = zoomLevel;
	};
	
	DocumentHandler.prototype.destroy = function ()
	{
	    this._overlays.forEach(function (overlay)
	    {
	        this._viewerCore.removePageOverlay(overlay);
	    }, this);
	};
	
	function getCentermostPage(renderedPages, layout, viewport)
	{
	    var centerY = viewport.top + (viewport.height / 2);
	    var centerX = viewport.left + (viewport.width / 2);
	
	    // Find the minimum distance from the viewport center to a page.
	    // Compute minus the squared distance from viewport center to the page's border.
	    // http://gamedev.stackexchange.com/questions/44483/how-do-i-calculate-distance-between-a-point-and-an-axis-aligned-rectangle
	    var centerPage = maxBy(renderedPages, function (pageIndex)
	    {
	        var dims = layout.getPageDimensions(pageIndex);
	        var imageOffset = layout.getPageOffset(pageIndex, {excludePadding: false});
	
	        var midX = imageOffset.left + (dims.width / 2);
	        var midY = imageOffset.top + (dims.height / 2);
	
	        var dx = Math.max(Math.abs(centerX - midX) - (dims.width / 2), 0);
	        var dy = Math.max(Math.abs(centerY - midY) - (dims.height / 2), 0);
	
	        return -(dx * dx + dy * dy);
	    });
	
	    return centerPage != null ? centerPage : null;
	}


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0,
	    MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/,
	    reLeadingDot = /^\./,
	    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;
	
	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];
	
	  var length = result.length,
	      skipIndexes = !!length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;
	
	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);
	
	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var index = 0,
	      length = path.length;
	
	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}
	
	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}
	
	/**
	 * The base implementation of `_.gt` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than `other`,
	 *  else `false`.
	 */
	function baseGt(value, other) {
	  return value > other;
	}
	
	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}
	
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}
	
	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}
	
	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
	  };
	}
	
	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}
	
	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value) {
	  return isArray(value) ? value : stringToPath(value);
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
	
	  stack.set(array, other);
	  stack.set(other, array);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	
	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;
	
	  while (length--) {
	    var key = result[length],
	        value = object[key];
	
	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = isKey(path, object) ? [path] : castPath(path);
	
	  var result,
	      index = -1,
	      length = path.length;
	
	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result) {
	    return result;
	  }
	  var length = object ? object.length : 0;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}
	
	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoize(function(string) {
	  string = toString(string);
	
	  var result = [];
	  if (reLeadingDot.test(string)) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, string) {
	    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});
	
	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;
	
	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result);
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}
	
	// Assign cache to `_.memoize`.
	memoize.Cache = MapCache;
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}
	
	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}
	
	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}
	
	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}
	
	/**
	 * This method is like `_.max` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.maxBy(objects, function(o) { return o.n; });
	 * // => { 'n': 2 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.maxBy(objects, 'n');
	 * // => { 'n': 2 }
	 */
	function maxBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee, 2), baseGt)
	    : undefined;
	}
	
	module.exports = maxBy;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)(module)))

/***/ }),
/* 21 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	var elt = __webpack_require__(9);
	
	module.exports = PageToolsOverlay;
	
	function PageToolsOverlay(pageIndex, viewerCore)
	{
	    this.page = pageIndex;
	
	    this._viewerCore = viewerCore;
	
	    this._innerElement = viewerCore.getSettings().innerElement;
	    this._pageToolsElem = null;
	}
	
	PageToolsOverlay.prototype.mount = function ()
	{
	    if (this._pageToolsElem === null)
	    {
	        var buttons = this._initializePageToolButtons();
	
	        this._pageToolsElem = elt('div', {class: 'diva-page-tools-wrapper'},
	            elt('div', {class: 'diva-page-tools'}, buttons)
	        );
	    }
	
	    this.refresh();
	    this._innerElement.appendChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype._initializePageToolButtons = function ()
	{
	    // Callback parameters
	    var settings = this._viewerCore.getSettings();
	    var publicInstance = this._viewerCore.getPublicInstance();
	    var pageIndex = this.page;
	
	    return this._viewerCore.getPageTools().map(function (plugin)
	    {
	        // If the title text is undefined, use the name of the plugin
	        var titleText = plugin.titleText || plugin.pluginName[0].toUpperCase() + plugin.pluginName.substring(1) + " plugin";
	
	        var button = elt('div', {
	            class: 'diva-' + plugin.pluginName + '-icon',
	            title: titleText
	        });
	
	        button.addEventListener('click', function (event)
	        {
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        button.addEventListener('touchend', function (event)
	        {
	            // Prevent firing of emulated mouse events
	            event.preventDefault();
	
	            plugin.handleClick.call(this, event, settings, publicInstance, pageIndex);
	        }, false);
	
	        return button;
	    }, this);
	};
	
	PageToolsOverlay.prototype.unmount = function ()
	{
	    this._innerElement.removeChild(this._pageToolsElem);
	};
	
	PageToolsOverlay.prototype.refresh = function ()
	{
	    var pos = this._viewerCore.getPageRegion(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._pageToolsElem.style.top = pos.top + 'px';
	    this._pageToolsElem.style.left = pos.left + 'px';
	};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var maxBy = __webpack_require__(20);
	
	module.exports = GridHandler;
	
	function GridHandler(viewerCore)
	{
	    this._viewerCore = viewerCore;
	}
	
	// USER EVENTS
	GridHandler.prototype.onDoubleClick = function (event, coords)
	{
	    var position = this._viewerCore.getPagePositionAtViewportOffset(coords);
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var viewport = this._viewerCore.getViewport();
	    var pageToViewportCenterOffset = layout.getPageToViewportCenterOffset(position.anchorPage, viewport);
	
	    this._viewerCore.reload({
	        inGrid: false,
	        goDirectlyTo: position.anchorPage,
	        horizontalOffset: pageToViewportCenterOffset.x + position.offset.left,
	        verticalOffset: pageToViewportCenterOffset.y + position.offset.top
	    });
	};
	
	GridHandler.prototype.onPinch = function ()
	{
	    this._viewerCore.reload({ inGrid: false });
	};
	
	// VIEW EVENTS
	GridHandler.prototype.onViewWillLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidLoad = function ()
	{
	    // FIXME(wabain): Should something happen here?
	    /* No-op */
	};
	
	GridHandler.prototype.onViewDidUpdate = function (renderedPages, targetPage)
	{
	    // return early if there are no rendered pages in view.
	    if (renderedPages.length === 0) return;
	
	    if (targetPage !== null)
	    {
	        this._viewerCore.setCurrentPage(targetPage);
	        return;
	    }
	
	    // Select the current page from the first row if it is fully visible, or from
	    // the second row if it is fully visible, or from the centermost row otherwise.
	    // If the current page is in that group then don't change it. Otherwise, set
	    // the current page to the group's first page.
	
	    var layout = this._viewerCore.getCurrentLayout();
	    var groups = [];
	
	    renderedPages.forEach(function (pageIndex)
	    {
	        var group = layout.getPageInfo(pageIndex).group;
	        if (groups.length === 0 || group !== groups[groups.length - 1])
	            groups.push(group);
	    });
	
	    var viewport = this._viewerCore.getViewport();
	    var chosenGroup;
	
	    if (groups.length === 1 || groups[0].region.top >= viewport.top)
	        chosenGroup = groups[0];
	    else if (groups[1].region.bottom <= viewport.bottom)
	        chosenGroup = groups[1];
	    else
	        chosenGroup = getCentermostGroup(groups, viewport);
	
	    var currentPage = this._viewerCore.getSettings().currentPageIndex;
	
	    var hasCurrentPage = chosenGroup.pages.some(function (page)
	    {
	        return page.index === currentPage;
	    });
	
	    if (!hasCurrentPage)
	        this._viewerCore.setCurrentPage(chosenGroup.pages[0].index);
	};
	
	GridHandler.prototype.destroy = function ()
	{
	    // No-op
	};
	
	function getCentermostGroup(groups, viewport)
	{
	    var viewportMiddle = viewport.top + viewport.height / 2;
	
	    return maxBy(groups, function (group)
	    {
	        var groupMiddle = group.region.top + group.dimensions.height / 2;
	        return -Math.abs(viewportMiddle - groupMiddle);
	    });
	}


/***/ }),
/* 24 */
/***/ (function(module, exports) {

	module.exports = PageOverlayManager;
	
	/**
	 * Manages a collection of page overlays, which implement a low-level
	 * API for synchronizing HTML pages to the canvas. Each overlay needs
	 * to implement the following protocol:
	 *
	 *   mount(): Called when a page is first rendered
	 *   refresh(): Called when a page is moved
	 *   unmount(): Called when a previously rendered page has stopped being rendered
	 *
	 * @class
	 */
	
	function PageOverlayManager()
	{
	    this._pages = {};
	    this._renderedPages = [];
	    this._renderedPageMap = {};
	}
	
	PageOverlayManager.prototype.addOverlay = function (overlay)
	{
	    var overlaysByPage = this._pages[overlay.page] || (this._pages[overlay.page] = []);
	
	    overlaysByPage.push(overlay);
	
	    if (this._renderedPageMap[overlay.page])
	        overlay.mount();
	};
	
	PageOverlayManager.prototype.removeOverlay = function (overlay)
	{
	    var page = overlay.page;
	    var overlaysByPage = this._pages[page];
	
	    if (!overlaysByPage)
	        return;
	
	    var overlayIndex = overlaysByPage.indexOf(overlay);
	
	    if (overlayIndex === -1)
	        return;
	
	    if (this._renderedPageMap[page])
	        overlaysByPage[overlayIndex].unmount();
	
	    overlaysByPage.splice(overlayIndex, 1);
	
	    if (overlaysByPage.length === 0)
	        delete this._pages[page];
	};
	
	PageOverlayManager.prototype.updateOverlays = function (renderedPages)
	{
	    var previouslyRendered = this._renderedPages;
	    var newRenderedMap = {};
	
	    renderedPages.forEach(function (pageIndex)
	    {
	        newRenderedMap[pageIndex] = true;
	
	        if (!this._renderedPageMap[pageIndex])
	        {
	            this._renderedPageMap[pageIndex] = true;
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.mount();
	            });
	        }
	    }, this);
	
	    previouslyRendered.forEach(function (pageIndex)
	    {
	        if (newRenderedMap[pageIndex])
	        {
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.refresh();
	            });
	        }
	        else
	        {
	            delete this._renderedPageMap[pageIndex];
	
	            this._invokeOnOverlays(pageIndex, function (overlay)
	            {
	                overlay.unmount();
	            });
	        }
	    }, this);
	
	    this._renderedPages = renderedPages;
	};
	
	PageOverlayManager.prototype._invokeOnOverlays = function (pageIndex, func)
	{
	    var overlays = this._pages[pageIndex];
	    if (overlays)
	        overlays.forEach(func, this);
	};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(26)('diva:Renderer');
	var debugPaints = __webpack_require__(26)('diva:Renderer:paints');
	
	var elt = __webpack_require__(9);
	
	var CompositeImage = __webpack_require__(30);
	var DocumentLayout = __webpack_require__(31);
	var ImageCache = __webpack_require__(32);
	var ImageRequestHandler = __webpack_require__(33);
	var InterpolateAnimation = __webpack_require__(34);
	
	var REQUEST_DEBOUNCE_INTERVAL = 250;
	
	
	module.exports = Renderer;
	
	function Renderer(options, hooks)
	{
	    this._viewport = options.viewport;
	    this._outerElement = options.outerElement;
	    this._documentElement = options.innerElement;
	
	    this._hooks = hooks || {};
	
	    this._canvas = elt('canvas', { class: 'diva-viewer-canvas', tabindex: '1' });
	    this._ctx = this._canvas.getContext('2d');
	
	    this.layout = null;
	
	    this._sourceResolver = null;
	    this._renderedPages = null;
	    this._config = null;
	    this._zoomLevel = null;
	    this._compositeImages = null;
	    this._renderedTiles = null;
	    this._animation = null;
	
	    // FIXME(wabain): What level should this be maintained at?
	    // Diva global?
	    this._cache = new ImageCache();
	    this._pendingRequests = {};
	}
	
	Renderer.getCompatibilityErrors = function ()
	{
	    if (typeof HTMLCanvasElement !== 'undefined')
	        return null;
	
	    return [
	        'Your browser lacks support for the ', elt('pre', 'canvas'),
	        ' element. Please upgrade your browser.'
	    ];
	};
	
	Renderer.prototype.getPageHit = function (clientX, clientY)
	{
	    var bounds = this._outerElement.getBoundingClientRect();
	    if (clientX < bounds.left || clientY < bounds.top ||
	        clientX > bounds.left + bounds.width || clientY > bounds.top + bounds.height)
	    {
	        return null;
	    }
	
	    clientX -= bounds.left;
	    clientY -= bounds.top;
	
	    var numRenderedPages = this._renderedPages.length;
	
	    for (var i = 0; i < numRenderedPages; i++)
	    {
	        var pageIndex = this._renderedPages[i];
	        var pageInfo = this.layout.getPageInfo(pageIndex);
	        var pageOffset = this._getImageOffset(pageIndex);
	
	        var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	        var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	        var viewportOffsetX = pageOffset.left - this._viewport.left + viewportPaddingX;
	        var viewportOffsetY = pageOffset.top - this._viewport.top + viewportPaddingY;
	
	        var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	        var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	        var canvasX = Math.max(0, viewportOffsetX);
	        var canvasY = Math.max(0, viewportOffsetY);
	
	        var destWidth = pageInfo.dimensions.width - destXOffset;
	        var destHeight = pageInfo.dimensions.height - destYOffset;
	
	        if (clientX >= canvasX && clientX <= canvasX + destWidth && clientY >= canvasY && clientY <= canvasY + destHeight)
	        {
	            var xhp = ((clientX + destXOffset) - canvasX);
	            var yhp = ((clientY + destYOffset) - canvasY);
	            // to get the percentage x and y you need to adjust the by the scroll offset and the canvas position
	            return {
	                pg: pageIndex,
	                pctx: xhp / pageInfo.dimensions.width,
	                pcty: yhp / pageInfo.dimensions.height,
	                x:  xhp,
	                y: yhp
	            };
	        }
	    }
	
	    return null;
	};
	
	Renderer.prototype.load = function (config, viewportPosition, sourceResolver)
	{
	    this._clearAnimation();
	
	    if (this._hooks.onViewWillLoad)
	        this._hooks.onViewWillLoad();
	
	    this._sourceResolver = sourceResolver;
	    this._config = config;
	    this._compositeImages = {};
	    this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	
	    // FIXME(wabain): Remove this when there's more confidence the check shouldn't be needed
	    if (!this.layout.getPageInfo(viewportPosition.anchorPage))
	        throw new Error('invalid page: ' + viewportPosition.anchorPage);
	
	    if (this._canvas.width !== this._viewport.width || this._canvas.height !== this._viewport.height)
	    {
	        debug('Canvas dimension change: (%s, %s) -> (%s, %s)', this._canvas.width, this._canvas.height,
	            this._viewport.width, this._viewport.height);
	
	        this._canvas.width = this._viewport.width;
	        this._canvas.height = this._viewport.height;
	    } else {
	        debug('Reload, no size change');
	    }
	
	    // FIXME: What hooks should be called here?
	    this.goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	
	    if (this._canvas.parentNode !== this._outerElement)
	        this._outerElement.insertBefore(this._canvas, this._outerElement.firstChild);
	
	    if (this._hooks.onViewDidLoad)
	        this._hooks.onViewDidLoad();
	};
	
	Renderer.prototype._setViewportPosition = function (viewportPosition)
	{
	    if (viewportPosition.zoomLevel !== this._zoomLevel)
	    {
	        if (this._zoomLevel === null)
	            throw new TypeError('The current view is not zoomable');
	        else if (viewportPosition.zoomLevel === null)
	            throw new TypeError('The current view requires a zoom level');
	
	        this._setLayoutToZoomLevel(viewportPosition.zoomLevel);
	    }
	
	    this._goto(viewportPosition.anchorPage, viewportPosition.verticalOffset, viewportPosition.horizontalOffset);
	};
	
	Renderer.prototype._setLayoutToZoomLevel = function (zoomLevel)
	{
	    this.layout = new DocumentLayout(this._config, zoomLevel);
	    this._zoomLevel = zoomLevel;
	
	    elt.setAttributes(this._documentElement, {
	        style: {
	            height: this.layout.dimensions.height + 'px',
	            width: this.layout.dimensions.width + 'px'
	        }
	    });
	
	    this._viewport.setInnerDimensions(this.layout.dimensions);
	};
	
	Renderer.prototype.adjust = function (direction)
	{
	    this._clearAnimation();
	
	    this._render(direction);
	
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), null);
	    }
	};
	
	
	
	// FIXME(wabain): Remove the direction argument if it doesn't end up being needed.
	Renderer.prototype._render = function (direction) // jshint ignore:line
	{
	    var newRenderedPages = [];
	    this.layout.pageGroups.forEach(function (group)
	    {
	        if (!this._viewport.intersectsRegion(group.region))
	            return;
	
	        var visiblePages = group.pages
	            .filter(function (page)
	            {
	                return this.isPageVisible(page.index);
	            }, this)
	            .map(function (page)
	            {
	                return page.index;
	            });
	
	        newRenderedPages.push.apply(newRenderedPages, visiblePages);
	    }, this);
	
	    this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
	    this._paintOutline(newRenderedPages);
	
	    newRenderedPages.forEach(function (pageIndex)
	    {
	        if (!this._compositeImages[pageIndex])
	        {
	            var page = this.layout.getPageInfo(pageIndex);
	            var zoomLevels = this._sourceResolver.getAllZoomLevelsForPage(page);
	            var composite = new CompositeImage(zoomLevels);
	            composite.updateFromCache(this._cache);
	            this._compositeImages[pageIndex] = composite;
	        }
	    }, this);
	
	    this._initiateTileRequests(newRenderedPages);
	
	    var changes = findChanges(this._renderedPages || [], newRenderedPages);
	
	    changes.removed.forEach(function (pageIndex)
	    {
	        delete this._compositeImages[pageIndex];
	    }, this);
	
	    this._renderedPages = newRenderedPages;
	    this._paint();
	
	    if (this._hooks.onPageWillLoad)
	    {
	        changes.added.forEach(function (pageIndex)
	        {
	            this._hooks.onPageWillLoad(pageIndex);
	        }, this);
	    }
	};
	
	Renderer.prototype._paint = function ()
	{
	    debug('Repainting');
	
	    var renderedTiles = [];
	
	    this._renderedPages.forEach(function (pageIndex)
	    {
	        this._compositeImages[pageIndex].getTiles(this._zoomLevel).forEach(function (source)
	        {
	            var scaled = getScaledTileRecord(source, this._zoomLevel);
	
	            if (this._isTileVisible(pageIndex, scaled))
	            {
	                renderedTiles.push(source.url);
	                this._drawTile(pageIndex, scaled, this._cache.get(source.url));
	            }
	        }, this);
	    }, this);
	
	    var cache = this._cache;
	
	    var changes = findChanges(this._renderedTiles || [], renderedTiles);
	
	    changes.added.forEach(function (url)
	    {
	        cache.acquire(url);
	    });
	
	    changes.removed.forEach(function (url)
	    {
	        cache.release(url);
	    });
	
	    if (changes.removed)
	    {
	        // FIXME: Should only need to update the composite images
	        // for which tiles were removed
	        this._renderedPages.forEach(function (pageIndex)
	        {
	            this._compositeImages[pageIndex].updateFromCache(this._cache);
	        }, this);
	    }
	
	    this._renderedTiles = renderedTiles;
	};
	
	// Paint a page outline while the tiles are loading.
	Renderer.prototype._paintOutline = function (pages)
	{
	    pages.forEach(function (pageIndex)
	    {
	        var pageInfo = this.layout.getPageInfo(pageIndex);
	        var pageOffset = this._getImageOffset(pageIndex);
	
	        // Ensure the document is drawn to the center of the viewport
	        var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	        var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	        var viewportOffsetX = pageOffset.left - this._viewport.left + viewportPaddingX;
	        var viewportOffsetY = pageOffset.top - this._viewport.top + viewportPaddingY;
	
	        var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	        var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	        var canvasX = Math.max(0, viewportOffsetX);
	        var canvasY = Math.max(0, viewportOffsetY);
	
	        var destWidth = pageInfo.dimensions.width - destXOffset;
	        var destHeight = pageInfo.dimensions.height - destYOffset;
	
	        this._ctx.strokeStyle = '#AAA';
	        // In order to get a 1px wide line using strokes, we need to start at a 'half pixel'
	        this._ctx.strokeRect(canvasX + 0.5, canvasY + 0.5, destWidth, destHeight);
	    }, this);
	};
	
	// This method should be sent all visible pages at once because it will initiate
	// all image requests and cancel any remaining image requests. In the case that
	// a request is ongoing and the tile is still visible in the viewport, the old request
	// is kept active instead of restarting it. The image requests are given a timeout
	// before loading in order to debounce them and have a small reaction time
	// to cancel them and avoid useless requests.
	Renderer.prototype._initiateTileRequests = function(pages)
	{
	    // Only requests in this object are kept alive, since all others are not visible in the viewport
	    var newPendingRequests = {};
	
	    // Used later as a closure to initiate the image requests with the right source and pageIndex
	    var initiateRequest = function (source, pageIndex)
	    {
	        var composite = this._compositeImages[pageIndex];
	
	        newPendingRequests[source.url] = new ImageRequestHandler({
	            url: source.url,
	            timeoutTime: REQUEST_DEBOUNCE_INTERVAL,
	            load: function (img)
	            {
	                delete this._pendingRequests[source.url];
	                this._cache.put(source.url, img);
	
	                // Awkward way to check for updates
	                if (composite === this._compositeImages[pageIndex])
	                {
	                    composite.updateWithLoadedUrls([source.url]);
	
	                    if (this._isTileForSourceVisible(pageIndex, source))
	                        this._paint();
	                    else
	                        debugPaints('Page %s, tile %s no longer visible on image load', pageIndex, source.url);
	                }
	            }.bind(this),
	            error: function ()
	            {
	                // TODO: Could make a limited number of retries, etc.
	                delete this._pendingRequests[source.url];
	            }.bind(this)
	        });
	    }.bind(this);
	
	    for (var i = 0; i < pages.length; i++)
	    {
	        var pageIndex = pages[i];
	        var tiles = this._sourceResolver.getBestZoomLevelForPage(this.layout.getPageInfo(pageIndex)).tiles;
	
	        for (var j = 0; j < tiles.length; j++)
	        {
	            var source = tiles[j];
	            if (this._cache.has(source.url) || !this._isTileForSourceVisible(pageIndex, source))
	                continue;
	
	            // Don't create a new request if the tile is already being loaded
	            if (this._pendingRequests[source.url])
	            {
	                newPendingRequests[source.url] = this._pendingRequests[source.url];
	                delete this._pendingRequests[source.url];
	                continue;
	            }
	
	            // Use a closure since the load and error methods are going to be called later and
	            // we need to keep the right reference to the source and the page index
	            initiateRequest(source, pageIndex);
	        }
	    }
	
	    for (var url in this._pendingRequests)
	        this._pendingRequests[url].abort();
	    this._pendingRequests = newPendingRequests;
	};
	
	Renderer.prototype._drawTile = function (pageIndex, scaledTile, img)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // Ensure the document is drawn to the center of the viewport
	    var viewportPaddingX = Math.max(0, (this._viewport.width - this.layout.dimensions.width) / 2);
	    var viewportPaddingY = Math.max(0, (this._viewport.height - this.layout.dimensions.height) / 2);
	
	    var viewportOffsetX = tileOffset.left - this._viewport.left + viewportPaddingX;
	    var viewportOffsetY = tileOffset.top - this._viewport.top + viewportPaddingY;
	
	    var destXOffset = viewportOffsetX < 0 ? -viewportOffsetX : 0;
	    var destYOffset = viewportOffsetY < 0 ? -viewportOffsetY : 0;
	
	    var sourceXOffset = destXOffset / scaledTile.scaleRatio;
	    var sourceYOffset = destYOffset / scaledTile.scaleRatio;
	
	    var canvasX = Math.max(0, viewportOffsetX);
	    var canvasY = Math.max(0, viewportOffsetY);
	
	    // Ensure that the specified dimensions are no greater than the actual
	    // size of the image. Safari won't display the tile if they are.
	    var destWidth = Math.min(scaledTile.dimensions.width, img.width * scaledTile.scaleRatio) - destXOffset;
	    var destHeight = Math.min(scaledTile.dimensions.height, img.height * scaledTile.scaleRatio) - destYOffset;
	
	    destWidth = Math.max(1, destWidth);
	    destHeight = Math.max(1, destHeight);
	
	    var sourceWidth = Math.abs(destWidth / scaledTile.scaleRatio);
	    var sourceHeight = Math.abs(destHeight / scaledTile.scaleRatio);
	
	    if (debugPaints.enabled)
	    {
	        debugPaints('Drawing page %s, tile %sx (%s, %s) from %s, %s to viewport at %s, %s, scale %s%%',
	            pageIndex,
	            scaledTile.sourceZoomLevel, scaledTile.row, scaledTile.col,
	            sourceXOffset, sourceYOffset,
	            canvasX, canvasY,
	            Math.round(scaledTile.scaleRatio * 100));
	    }
	
	    this._ctx.drawImage(
	        img,
	        sourceXOffset, sourceYOffset,
	        sourceWidth, sourceHeight,
	        canvasX, canvasY,
	        destWidth, destHeight);
	};
	
	Renderer.prototype._isTileForSourceVisible = function (pageIndex, tileSource)
	{
	    return this._isTileVisible(pageIndex, getScaledTileRecord(tileSource, this._zoomLevel));
	};
	
	Renderer.prototype._isTileVisible = function (pageIndex, scaledTile)
	{
	    var tileOffset = this._getTileToDocumentOffset(pageIndex, scaledTile);
	
	    // FIXME(wabain): This check is insufficient during a zoom transition
	    return this._viewport.intersectsRegion({
	        top: tileOffset.top,
	        bottom: tileOffset.top + scaledTile.dimensions.height,
	        left: tileOffset.left,
	        right: tileOffset.left + scaledTile.dimensions.width
	    });
	};
	
	Renderer.prototype._getTileToDocumentOffset = function (pageIndex, scaledTile)
	{
	    var imageOffset = this._getImageOffset(pageIndex);
	
	    return {
	        top: imageOffset.top + scaledTile.offset.top,
	        left: imageOffset.left + scaledTile.offset.left
	    };
	};
	
	Renderer.prototype._getImageOffset = function (pageIndex)
	{
	    return this.layout.getPageOffset(pageIndex, {excludePadding: true});
	};
	
	// TODO: Update signature
	Renderer.prototype.goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    this._clearAnimation();
	    this._goto(pageIndex, verticalOffset, horizontalOffset);
	    if (this._hooks.onViewDidUpdate)
	    {
	        this._hooks.onViewDidUpdate(this._renderedPages.slice(), pageIndex);
	    }
	};
	
	Renderer.prototype._goto = function (pageIndex, verticalOffset, horizontalOffset)
	{
	    // FIXME(wabain): Move this logic to the viewer
	    var pageOffset = this.layout.getPageOffset(pageIndex);
	
	    var desiredVerticalCenter = pageOffset.top + verticalOffset;
	    var top = desiredVerticalCenter - parseInt(this._viewport.height / 2, 10);
	
	    var desiredHorizontalCenter = pageOffset.left + horizontalOffset;
	    var left = desiredHorizontalCenter - parseInt(this._viewport.width / 2, 10);
	
	    this._viewport.top = top;
	    this._viewport.left = left;
	
	    this._render(0);
	};
	
	Renderer.prototype.transitionViewportPosition = function (options)
	{
	    this._clearAnimation();
	
	    var getPosition = options.getPosition;
	    var self = this;
	
	    var onViewDidTransition = this._hooks.onViewDidTransition;
	
	    this._animation = InterpolateAnimation.animate({
	        duration: options.duration,
	        parameters: options.parameters,
	        onUpdate: function (values)
	        {
	            // TODO: Do image preloading, work with that
	            self._setViewportPosition(getPosition(values));
	
	            if (onViewDidTransition)
	                onViewDidTransition();
	        },
	        onEnd: function (info)
	        {
	            if (options.onEnd)
	                options.onEnd(info);
	
	            if (self._hooks.onViewDidUpdate && !info.interrupted)
	            {
	                self._hooks.onViewDidUpdate(self._renderedPages.slice(), null);
	            }
	        }
	    });
	};
	
	Renderer.prototype._clearAnimation = function ()
	{
	    if (this._animation)
	    {
	        this._animation.cancel();
	        this._animation = null;
	    }
	};
	
	Renderer.prototype.preload = function ()
	{
	    // TODO
	};
	
	Renderer.prototype.isPageVisible = function (pageIndex)
	{
	    if (!this.layout)
	        return false;
	
	    var page = this.layout.getPageInfo(pageIndex);
	
	    if (!page)
	        return false;
	
	    return this._viewport.intersectsRegion(this.layout.getPageRegion(pageIndex));
	};
	
	Renderer.prototype.getRenderedPages = function ()
	{
	    return this._renderedPages.slice();
	};
	
	Renderer.prototype.destroy = function ()
	{
	    this._clearAnimation();
	
	    // FIXME(wabain): I don't know if we should actually do this
	    Object.keys(this._pendingRequests).forEach(function (req)
	    {
	        var handler = this._pendingRequests[req];
	        delete this._pendingRequests[req];
	
	        handler.abort();
	    }, this);
	
	    this._canvas.parentNode.removeChild(this._canvas);
	};
	
	function getScaledTileRecord(source, scaleFactor)
	{
	    var scaleRatio;
	
	    if (scaleFactor === null)
	        scaleRatio = 1;
	    else
	        scaleRatio = Math.pow(2, scaleFactor - source.zoomLevel);
	
	    return {
	        sourceZoomLevel: source.zoomLevel,
	        scaleRatio: scaleRatio,
	        row: source.row,
	        col: source.col,
	        dimensions: {
	            width: source.dimensions.width * scaleRatio,
	            height: source.dimensions.height * scaleRatio
	        },
	        offset: {
	            left: source.offset.left * scaleRatio,
	            top: source.offset.top * scaleRatio
	        },
	        url: source.url
	    };
	}
	
	function findChanges(oldArray, newArray)
	{
	    if (oldArray === newArray)
	    {
	        return {
	            added: [],
	            removed: []
	        };
	    }
	
	    var removed = oldArray.filter(function (oldEntry)
	    {
	        return newArray.indexOf(oldEntry) === -1;
	    });
	
	    var added = newArray.filter(function (newEntry)
	    {
	        return oldArray.indexOf(newEntry) === -1;
	    });
	
	    return {
	        added: added,
	        removed: removed
	    };
	}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(28);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // NB: In an Electron preload script, document will be defined but not fully
	  // initialized. Since we know we're in Chrome, we'll just detect this case
	  // explicitly
	  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
	    return true;
	  }
	
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
	    // double check webkit in userAgent just in case we are in a worker
	    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return;
	
	  var c = 'color: ' + this.color;
	  args.splice(1, 0, c, 'color: inherit')
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-zA-Z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (!r && typeof process !== 'undefined' && 'env' in process) {
	    r = process.env.DEBUG;
	  }
	
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27)))

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(29);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 * @param {String} namespace
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor(namespace) {
	  var hash = 0, i;
	
	  for (i in namespace) {
	    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
	    hash |= 0; // Convert to 32bit integer
	  }
	
	  return exports.colors[Math.abs(hash) % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function createDebug(namespace) {
	
	  function debug() {
	    // disabled?
	    if (!debug.enabled) return;
	
	    var self = debug;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // turn the `arguments` into a proper Array
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %O
	      args.unshift('%O');
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting (colors, etc.)
	    exports.formatArgs.call(self, args);
	
	    var logFn = debug.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	
	  debug.namespace = namespace;
	  debug.enabled = exports.enabled(namespace);
	  debug.useColors = exports.useColors();
	  debug.color = selectColor(namespace);
	
	  // env-specific initialization logic for debug instances
	  if ('function' === typeof exports.init) {
	    exports.init(debug);
	  }
	
	  return debug;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  exports.names = [];
	  exports.skips = [];
	
	  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ }),
/* 29 */
/***/ (function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return;
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name;
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ }),
/* 30 */
/***/ (function(module, exports) {

	module.exports = CompositeImage;
	
	/**
	 * @class CompositeImage
	 * @private
	 *
	 * Utility class to composite tiles into a complete image
	 * and track the rendered state of an image as new tiles
	 * load.
	 */
	
	/**
	 * @param levels {Array.<Array.<Tile>>}
	 * @constructor
	 */
	function CompositeImage(levels)
	{
	    this._levels = levels;  // Assume levels sorted high-res first
	    var urlsToTiles = this._urlsToTiles = {};
	
	    levels.forEach(function (level)
	    {
	        level.tiles.forEach(function (tile)
	        {
	            urlsToTiles[tile.url] = {
	                zoomLevel: level.zoomLevel,
	                row: tile.row,
	                col: tile.col
	            };
	        });
	    });
	
	    this.clear();
	}
	
	CompositeImage.prototype.clear = function ()
	{
	    var loadedByLevel = this._loadedByLevel = {};
	
	    this._levels.forEach(function (level)
	    {
	        loadedByLevel[level.zoomLevel] = new TileCoverageMap(level.rows, level.cols);
	    });
	};
	
	CompositeImage.prototype.getTiles = function (baseZoomLevel)
	{
	    var toRenderByLevel = [];
	    var highestZoomLevel = this._levels[0].zoomLevel;
	    var covered = new TileCoverageMap(this._levels[0].rows, this._levels[0].cols);
	
	    var bestLevelIndex;
	
	    // Default to the lowest zoom level
	    if (baseZoomLevel === null)
	    {
	        bestLevelIndex = 0;
	    }
	    else
	    {
	        var ceilLevel = Math.ceil(baseZoomLevel);
	        bestLevelIndex = findIndex(this._levels, function (level)
	        {
	            return level.zoomLevel <= ceilLevel;
	        });
	    }
	
	
	    // The best level, followed by higher-res levels in ascending order of resolution,
	    // followed by lower-res levels in descending order of resolution
	    var levelsByPreference = this._levels.slice(0, bestLevelIndex + 1).reverse()
	        .concat(this._levels.slice(bestLevelIndex + 1));
	
	    levelsByPreference.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        var additionalTiles = level.tiles.filter(function (tile)
	        {
	            return loaded.isLoaded(tile.row, tile.col);
	        });
	
	        // Filter out entirely covered tiles
	
	        // FIXME: Is it better to draw all of a partially covered tile,
	        // with some of it ultimately covered, or to pick out the region
	        // which needs to be drawn?
	        // See https://github.com/DDMAL/diva.js/issues/358
	
	        var scaleRatio = Math.pow(2, highestZoomLevel - level.zoomLevel);
	
	        additionalTiles = additionalTiles.filter(function (tile)
	        {
	            var isNeeded = false;
	
	            var highResRow = tile.row * scaleRatio;
	            var highResCol = tile.col * scaleRatio;
	
	            for (var i=0; i < scaleRatio; i++)
	            {
	                for (var j=0; j < scaleRatio; j++)
	                {
	                    if (!covered.isLoaded(highResRow + i, highResCol + j))
	                    {
	                        isNeeded = true;
	                        covered.set(highResRow + i, highResCol + j, true);
	                    }
	                }
	            }
	
	            return isNeeded;
	        });
	
	        toRenderByLevel.push(additionalTiles);
	    }, this);
	
	    // Less-preferred tiles should come first
	    toRenderByLevel.reverse();
	
	    var tiles = [];
	
	    toRenderByLevel.forEach(function (byLevel)
	    {
	        tiles.push.apply(tiles, byLevel);
	    });
	
	    return tiles;
	};
	
	/**
	 * Update the composite image to take into account all the URLs
	 * loaded in an image cache.
	 *
	 * @param cache {ImageCache}
	 */
	CompositeImage.prototype.updateFromCache = function (cache)
	{
	    this.clear();
	
	    this._levels.forEach(function (level)
	    {
	        var loaded = this._loadedByLevel[level.zoomLevel];
	
	        level.tiles.forEach(function (tile)
	        {
	            if (cache.has(tile.url))
	                loaded.set(tile.row, tile.col, true);
	        });
	    }, this);
	};
	
	CompositeImage.prototype.updateWithLoadedUrls = function (urls)
	{
	    urls.forEach(function (url)
	    {
	        var entry = this._urlsToTiles[url];
	        this._loadedByLevel[entry.zoomLevel].set(entry.row, entry.col, true);
	    }, this);
	};
	
	function TileCoverageMap(rows, cols)
	{
	    this._rows = rows;
	    this._cols = cols;
	
	    this._map = fill(rows).map(function ()
	    {
	        return fill(cols, false);
	    });
	}
	
	TileCoverageMap.prototype.isLoaded = function (row, col)
	{
	    // Return true for out of bounds tiles because they
	    // don't need to load. (Unfortunately this will also
	    // mask logical errors.)
	    if (row >= this._rows || col >= this._cols)
	        return true;
	
	    return this._map[row][col];
	};
	
	TileCoverageMap.prototype.set = function (row, col, value)
	{
	    this._map[row][col] = value;
	};
	
	function fill(count, value)
	{
	    var arr = new Array(count);
	
	    for (var i=0; i < count; i++)
	        arr[i] = value;
	
	    return arr;
	}
	
	function findIndex(array, predicate)
	{
	    var length = array.length;
	    for (var i = 0; i < length; i++)
	    {
	        if (predicate(array[i], i))
	            return i;
	    }
	
	    return -1;
	}


/***/ }),
/* 31 */
/***/ (function(module, exports) {

	module.exports = DocumentLayout;
	
	/**
	 * Translate page layouts, as generated by page-layouts, into an
	 * object which computes layout information for the document as
	 * a whole.
	 */
	function DocumentLayout(config, zoomLevel)
	{
	    var computedLayout = getComputedLayout(config, zoomLevel);
	
	    this.dimensions = computedLayout.dimensions;
	    this.pageGroups = computedLayout.pageGroups;
	    this._pageLookup = getPageLookup(computedLayout.pageGroups);
	}
	
	/**
	 * @typedef {Object} PageInfo
	 * @property {number} index
	 * @property {{index, dimensions, pages, region, padding}} group
	 * @property {{height: number, width: number}} dimensions
	 * @property {{top: number, left: number}} groupOffset
	 */
	
	/**
	 * @param pageIndex
	 * @returns {PageInfo|null}
	 */
	DocumentLayout.prototype.getPageInfo = function (pageIndex)
	{
	    return this._pageLookup[pageIndex] || null;
	};
	
	/**
	 * Get the dimensions of a page
	 *
	 * @param pageIndex
	 * @returns {{height: number, width: number}}
	 */
	DocumentLayout.prototype.getPageDimensions = function (pageIndex)
	{
	    if (!this._pageLookup || !this._pageLookup[pageIndex])
	        return null;
	
	    var region = getPageRegionFromPageInfo(this._pageLookup[pageIndex]);
	
	    return {
	        height: region.bottom - region.top,
	        width: region.right - region.left
	    };
	};
	
	// TODO(wabain): Get rid of this; it's a subset of the page region, so
	// give that instead
	/**
	 * Get the top-left coordinates of a page, including*** padding
	 *
	 * @param pageIndex
	 * @param options
	 * @returns {{top: number, left: number} | null}
	 */
	DocumentLayout.prototype.getPageOffset = function (pageIndex, options)
	{
	    var region = this.getPageRegion(pageIndex, options);
	
	    if (!region)
	        return null;
	
	    return {
	        top: region.top,
	        left: region.left
	    };
	};
	
	DocumentLayout.prototype.getPageRegion = function (pageIndex, options)
	{
	    var pageInfo = this._pageLookup[pageIndex];
	
	    if (!pageInfo)
	        return null;
	
	    var region = getPageRegionFromPageInfo(pageInfo);
	
	    if (options && options.excludePadding)
	    {
	        // FIXME?
	        var padding = pageInfo.group.padding;
	
	        return {
	            top: region.top + padding.top,
	            left: region.left + padding.left,
	            bottom: region.bottom,
	            right: region.right
	        };
	    }
	
	    return region;
	};
	
	/**
	 * Get the distance from the top-right of the page to the center of the
	 * specified viewport region
	 *
	 * @param pageIndex
	 * @param viewport {{top: number, left: number, bottom: number, right: number}}
	 * @returns {{x: number, y: number}}
	 */
	DocumentLayout.prototype.getPageToViewportCenterOffset = function (pageIndex, viewport)
	{
	    var scrollLeft = viewport.left;
	    var elementWidth = viewport.right - viewport.left;
	
	    var offset = this.getPageOffset(pageIndex);
	
	    var x = scrollLeft - offset.left + parseInt(elementWidth / 2, 10);
	
	    var scrollTop = viewport.top;
	    var elementHeight = viewport.bottom - viewport.top;
	
	    var y = scrollTop - offset.top + parseInt(elementHeight / 2, 10);
	
	    return {
	        x: x,
	        y: y
	    };
	};
	
	function getPageRegionFromPageInfo(page)
	{
	    var top    = page.groupOffset.top  + page.group.region.top;
	    var bottom = top + page.dimensions.height;
	    var left   = page.groupOffset.left + page.group.region.left;
	    var right  = left + page.dimensions.width;
	
	    return {
	        top: top,
	        bottom: bottom,
	        left: left,
	        right: right
	    };
	}
	
	function getPageLookup(pageGroups)
	{
	    var pageLookup = {};
	
	    pageGroups.forEach(function (group)
	    {
	        group.pages.forEach(function (page)
	        {
	            pageLookup[page.index] = {
	                index: page.index,
	                group: group,
	                dimensions: page.dimensions,
	                groupOffset: page.groupOffset
	            };
	        });
	    });
	
	    return pageLookup;
	}
	
	function getComputedLayout(config, zoomLevel)
	{
	    var scaledLayouts = zoomLevel === null ? config.pageLayouts : getScaledPageLayouts(config, zoomLevel);
	
	    var documentSecondaryExtent = getExtentAlongSecondaryAxis(config, scaledLayouts);
	
	    // The current position in the document along the primary axis
	    var primaryDocPosition = config.verticallyOriented ?
	        config.padding.document.top :
	        config.padding.document.left;
	
	    var pageGroups = [];
	
	    // TODO: Use bottom, right as well
	    var pagePadding = {
	        top: config.padding.page.top,
	        left: config.padding.page.left
	    };
	
	    scaledLayouts.forEach(function (layout, index)
	    {
	        var top, left;
	
	        if (config.verticallyOriented)
	        {
	            top = primaryDocPosition;
	            left = (documentSecondaryExtent - layout.dimensions.width) / 2;
	        }
	        else
	        {
	            top = (documentSecondaryExtent - layout.dimensions.height) / 2;
	            left = primaryDocPosition;
	        }
	
	        var region = {
	            top: top,
	            bottom: top + pagePadding.top + layout.dimensions.height,
	            left: left,
	            right: left + pagePadding.left + layout.dimensions.width
	        };
	
	        pageGroups.push({
	            index: index,
	            dimensions: layout.dimensions,
	            pages: layout.pages,
	            region: region,
	            padding: pagePadding
	        });
	
	        primaryDocPosition = config.verticallyOriented ? region.bottom : region.right;
	    });
	
	    var height, width;
	
	    if (config.verticallyOriented)
	    {
	        height = primaryDocPosition + pagePadding.top;
	        width = documentSecondaryExtent;
	    }
	    else
	    {
	        height = documentSecondaryExtent;
	        width = primaryDocPosition + pagePadding.left;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pageGroups: pageGroups
	    };
	}
	
	function getScaledPageLayouts(config, zoomLevel)
	{
	    var scaleRatio = Math.pow(2, zoomLevel - config.maxZoomLevel);
	
	    return config.pageLayouts.map(function (group)
	    {
	        return {
	            dimensions: scaleDimensions(group.dimensions, scaleRatio),
	            pages: group.pages.map(function (page)
	            {
	                return {
	                    index: page.index,
	                    groupOffset: {
	                        top: Math.floor(page.groupOffset.top * scaleRatio),
	                        left: Math.floor(page.groupOffset.left * scaleRatio)
	                    },
	                    dimensions: scaleDimensions(page.dimensions, scaleRatio)
	                };
	            })
	        };
	    });
	}
	
	function scaleDimensions(dimensions, scaleRatio)
	{
	    return {
	        height: Math.floor(dimensions.height * scaleRatio),
	        width: Math.floor(dimensions.width * scaleRatio)
	    };
	}
	
	function getExtentAlongSecondaryAxis(config, scaledLayouts)
	{
	    // Get the extent of the document along the secondary axis
	    var secondaryDim, secondaryPadding;
	    var docPadding = config.padding.document;
	
	    if (config.verticallyOriented)
	    {
	        secondaryDim = 'width';
	        secondaryPadding = docPadding.left + docPadding.right;
	    }
	    else
	    {
	        secondaryDim = 'height';
	        secondaryPadding = docPadding.top + docPadding.bottom;
	    }
	
	    return secondaryPadding + scaledLayouts.reduce(function (maxDim, layout)
	    {
	        return Math.max(layout.dimensions[secondaryDim], maxDim);
	    }, 0);
	}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var debug = __webpack_require__(26)('diva:ImageCache');
	
	module.exports = ImageCache;
	
	/* FIXME(wabain): The caching strategy here is completely
	 * arbitrary and the implementation isn't especially efficient.
	 */
	
	var DEFAULT_MAX_KEYS = 100;
	
	function ImageCache(options)
	{
	    options = options || { maxKeys: DEFAULT_MAX_KEYS };
	    this.maxKeys = options.maxKeys || DEFAULT_MAX_KEYS;
	
	    this._held = {};
	    this._urls = {};
	    this._lru = [];
	}
	
	ImageCache.prototype.get = function (url)
	{
	    var record = this._urls[url];
	    return record ? record.img : null;
	};
	
	ImageCache.prototype.has = function (url)
	{
	    return !!this._urls[url];
	};
	
	ImageCache.prototype.put = function (url, img)
	{
	    var record = this._urls[url];
	    if (record)
	    {
	        // FIXME: Does this make sense for this use case?
	        record.img = img;
	        this._promote(record);
	    }
	    else
	    {
	        record = {
	            img: img,
	            url: url
	        };
	
	        this._urls[url] = record;
	        this._tryEvict(1);
	        this._lru.unshift(record);
	    }
	};
	
	ImageCache.prototype._promote = function (record)
	{
	    var index = this._lru.indexOf(record);
	    this._lru.splice(index, 1);
	    this._lru.unshift(record);
	};
	
	ImageCache.prototype._tryEvict = function (extraCapacity)
	{
	    var allowedEntryCount = this.maxKeys - extraCapacity;
	
	    if (this._lru.length <= allowedEntryCount)
	        return;
	
	    var evictionIndex = this._lru.length - 1;
	
	    for (;;)
	    {
	        var target = this._lru[evictionIndex];
	
	        if (!this._held[target.url])
	        {
	            debug('Evicting image %s', target.url);
	            this._lru.splice(evictionIndex, 1);
	            delete this._urls[target.url];
	
	            if (this._lru.length <= allowedEntryCount)
	                break;
	        }
	
	        if (evictionIndex === 0)
	        {
	            /* istanbul ignore next */
	            debug.enabled && debug('Cache overfull by %s (all entries are being held)',
	                this._lru.length - allowedEntryCount);
	
	            break;
	        }
	
	        evictionIndex--;
	    }
	};
	
	ImageCache.prototype.acquire = function (url)
	{
	    this._held[url] = (this._held[url] || 0) + 1;
	    this._promote(this._urls[url]);
	};
	
	ImageCache.prototype.release = function (url)
	{
	    var count = this._held[url];
	
	    if (count > 1)
	        this._held[url]--;
	    else
	        delete this._held[url];
	
	    this._tryEvict(0);
	};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	var debug = __webpack_require__(26)('diva:ImageRequestHandler');
	
	module.exports = ImageRequestHandler;
	
	/**
	 * Handler for the request for an image tile
	 *
	 * @param url
	 * @param callback
	 * @constructor
	 */
	function ImageRequestHandler(options)
	{
	    this._url = options.url;
	    this._callback = options.load;
	    this._errorCallback = options.error;
	    this.timeoutTime = options.timeoutTime || 0;
	    this._aborted = this._complete = false;
	
	    //Use a timeout to allow the requests to be debounced (as they are in renderer)
	    this.timeout = setTimeout(function()
	    {
	        // Initiate the request
	        this._image = new Image();
	        this._image.crossOrigin = "anonymous";
	        this._image.onload = this._handleLoad.bind(this);
	        this._image.onerror = this._handleError.bind(this);
	        this._image.src = options.url;
	
	        debug('Requesting image %s', options.url);
	    }.bind(this), this.timeoutTime);
	}
	
	ImageRequestHandler.prototype.abort = function ()
	{
	    debug('Aborting request to %s', this._url);
	
	    clearTimeout(this.timeout);
	
	    // FIXME
	    // People on the Internet say that doing this {{should/should not}} abort the request. I believe
	    // it corresponds to what the WHATWG HTML spec says should happen when the UA
	    // updates the image data if selected source is null.
	    //
	    // Sources:
	    //
	    // https://html.spec.whatwg.org/multipage/embedded-content.html#the-img-element
	    // http://stackoverflow.com/questions/7390888/does-changing-the-src-attribute-of-an-image-stop-the-image-from-downloading
	    if (this._image)
	    {
	        this._image.onload = this._image.onerror = null;
	
	        this._image.src = '';
	    }
	
	    this._aborted = true;
	};
	
	ImageRequestHandler.prototype._handleLoad = function ()
	{
	    if (this._aborted)
	    {
	        console.error('ImageRequestHandler invoked on cancelled request for ' + this._url);
	        return;
	    }
	
	    if (this._complete)
	    {
	        console.error('ImageRequestHandler invoked on completed request for ' + this._url);
	        return;
	    }
	
	    this._complete = true;
	
	    debug('Received image %s', this._url);
	    this._callback(this._image);
	};
	
	ImageRequestHandler.prototype._handleError = function ()
	{
	    debug('Failed to load image %s', this._url);
	    this._errorCallback(this._image);
	};


/***/ }),
/* 34 */
/***/ (function(module, exports) {

	/* global performance */
	
	// TODO: requestAnimationFrame fallback
	
	module.exports = {
	    animate: animate,
	    easing: {
	        linear: linearEasing
	    }
	};
	
	function animate(options)
	{
	    var durationMs = options.duration;
	    var parameters = options.parameters;
	    var onUpdate = options.onUpdate;
	    var onEnd = options.onEnd;
	
	    // Setup
	    // Times are in milliseconds from a basically arbitrary start
	    var start = now();
	    var end = start + durationMs;
	
	    var tweenFns = {};
	    var values = {};
	    var paramKeys = Object.keys(parameters);
	
	    paramKeys.forEach(function (key)
	    {
	        var config = parameters[key];
	        tweenFns[key] = interpolate(config.from, config.to, config.easing || linearEasing);
	    });
	
	    // Run it!
	    var requestId = requestAnimationFrame(update);
	
	    return {
	        cancel: function ()
	        {
	            if (requestId !== null)
	            {
	                cancelAnimationFrame(requestId);
	                handleAnimationCompletion({
	                    interrupted: true
	                });
	            }
	        }
	    };
	
	    function update()
	    {
	        var current = now();
	        var elapsed = Math.min((current - start) / durationMs, 1);
	
	        updateValues(elapsed);
	        onUpdate(values);
	
	        if (current < end)
	            requestId = requestAnimationFrame(update);
	        else
	            handleAnimationCompletion({
	                interrupted: false
	            });
	    }
	
	    function updateValues(elapsed)
	    {
	        paramKeys.forEach(function (key)
	        {
	            values[key] = tweenFns[key](elapsed);
	        });
	    }
	
	    function handleAnimationCompletion(info)
	    {
	        requestId = null;
	
	        if (onEnd)
	            onEnd(info);
	    }
	}
	
	function interpolate(start, end, easing)
	{
	    return function (elapsed)
	    {
	        return start + (end - start) * easing(elapsed);
	    };
	}
	
	function linearEasing(e)
	{
	    return e;
	}
	
	var now;
	
	if (typeof performance !== 'undefined' && performance.now)
	{
	    now = function ()
	    {
	        return performance.now();
	    };
	}
	else
	{
	    now = function ()
	    {
	        return Date.now();
	    };
	}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	var getBookLayoutGroups = __webpack_require__(36);
	var getSinglesLayoutGroups = __webpack_require__(38);
	var getGridLayoutGroups = __webpack_require__(39);
	
	module.exports = getPageLayouts;
	
	/** Get the relative positioning of pages for the current view */
	function getPageLayouts(settings)
	{
	    if (settings.inGrid)
	    {
	        return getGridLayoutGroups(pluck(settings, [
	            'manifest',
	            'viewport',
	            'pagesPerRow',
	            'fixedHeightGrid',
	            'fixedPadding',
	            'showNonPagedPages'
	        ]));
	    }
	    else
	    {
	        var config = pluck(settings, ['manifest', 'verticallyOriented', 'showNonPagedPages']);
	
	        if (settings.inBookLayout)
	            return getBookLayoutGroups(config);
	        else
	            return getSinglesLayoutGroups(config);
	    }
	}
	
	function pluck(obj, keys)
	{
	    var out = {};
	    keys.forEach(function (key)
	    {
	        out[key] = obj[key];
	    });
	    return out;
	}


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(37);
	
	module.exports = getBookLayoutGroups;
	
	function getBookLayoutGroups(viewerConfig)
	{
	    var groupings = getGroupings(viewerConfig);
	
	    return groupings.map(function (grouping)
	    {
	        return getGroupLayoutsFromPageGrouping(viewerConfig, grouping);
	    });
	}
	
	function getGroupings(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    var pagesByGroup = [];
	    var leftPage = null;
	    var nonPagedPages = []; // Pages to display below the current group
	
	    var _addNonPagedPages = function()
	    {
	        for (var i = 0; i < nonPagedPages.length; i++)
	        {
	            pagesByGroup.push([ nonPagedPages[i] ]);
	        }
	        nonPagedPages = [];
	    };
	
	    manifest.pages.forEach(function (page, index)
	    {
	        var pageRecord = {
	            index: index,
	            dimensions: getPageDimensions(index, manifest),
	            paged: (!manifest.paged || page.paged)
	        };
	
	        // Only display non-paged pages if specified in the settings
	        if (!viewerConfig.showNonPagedPages && !pageRecord.paged)
	            return;
	
	        if (!pageRecord.paged)
	        {
	            nonPagedPages.push(pageRecord);
	        }
	        else if (index === 0 || page.facingPages)
	        {
	            // The first page is placed on its own
	            pagesByGroup.push([pageRecord]);
	            _addNonPagedPages();
	        }
	        else if (leftPage === null)
	        {
	            leftPage = pageRecord;
	        }
	        else
	        {
	            pagesByGroup.push([leftPage, pageRecord]);
	            leftPage = null;
	            _addNonPagedPages();
	        }
	    });
	
	    // Flush a final left page
	    if (leftPage !== null)
	    {
	        pagesByGroup.push([leftPage]);
	        _addNonPagedPages();
	    }
	
	    return pagesByGroup;
	}
	
	function getGroupLayoutsFromPageGrouping(viewerConfig, grouping)
	{
	    var verticallyOriented = viewerConfig.verticallyOriented;
	
	    if (grouping.length === 2)
	        return getFacingPageGroup(grouping[0], grouping[1], verticallyOriented);
	
	    var page = grouping[0];
	    var pageDims = page.dimensions;
	
	    // The first page is placed on its own to the right in vertical orientation.
	    // NB that this needs to be the page with index 0; if the first page is excluded
	    // from the layout then this special case shouldn't apply.
	    // If the page is tagged as 'non-paged', center it horizontally
	    var leftOffset;
	    if (page.paged)
	        leftOffset = (page.index === 0 && verticallyOriented) ? pageDims.width : 0;
	    else
	        leftOffset = (verticallyOriented) ? pageDims.width / 2 : 0;
	
	    var shouldBeHorizontallyAdjusted =
	        verticallyOriented && !viewerConfig.manifest.pages[page.index].facingPages;
	
	    // We need to left-align the page in vertical orientation, so we double
	    // the group width
	    return {
	        dimensions: {
	            height: pageDims.height,
	            width: shouldBeHorizontallyAdjusted ? pageDims.width * 2 : pageDims.width
	        },
	        pages: [{
	            index: page.index,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            },
	            dimensions: pageDims
	        }]
	    };
	}
	
	function getFacingPageGroup(leftPage, rightPage, verticallyOriented)
	{
	    var leftDims = leftPage.dimensions;
	    var rightDims = rightPage.dimensions;
	
	    var height = Math.max(leftDims.height, rightDims.height);
	
	    var width, firstLeftOffset, secondLeftOffset;
	
	    if (verticallyOriented)
	    {
	        var midWidth = Math.max(leftDims.width, rightDims.width);
	
	        width = midWidth * 2;
	
	        firstLeftOffset = midWidth - leftDims.width;
	        secondLeftOffset = midWidth;
	    }
	    else
	    {
	        width = leftDims.width + rightDims.width;
	        firstLeftOffset = 0;
	        secondLeftOffset = leftDims.width;
	    }
	
	    return {
	        dimensions: {
	            height: height,
	            width: width
	        },
	        pages: [
	            {
	                index: leftPage.index,
	                dimensions: leftDims,
	                groupOffset: {
	                    top: 0,
	                    left: firstLeftOffset
	                }
	            },
	            {
	                index: rightPage.index,
	                dimensions: rightDims,
	                groupOffset: {
	                    top: 0,
	                    left: secondLeftOffset
	                }
	            }
	        ]
	    };
	}


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	module.exports = function getPageDimensions(pageIndex, manifest)
	{
	    var dims = manifest.getMaxPageDimensions(pageIndex);
	
	    return {
	        width: Math.floor(dims.width),
	        height: Math.floor(dims.height)
	    };
	};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	var getPageDimensions = __webpack_require__(37);
	
	module.exports = function getSinglesLayoutGroups(viewerConfig)
	{
	    var manifest = viewerConfig.manifest;
	
	    // Render each page alone in a group
	    var pages = [];
	    manifest.pages.forEach(function (page, index)
	    {
	        if (!viewerConfig.showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        var pageDims = getPageDimensions(index, manifest);
	
	        pages.push({
	            dimensions: pageDims,
	            pages: [
	                {
	                    index: index,
	                    groupOffset: {top: 0, left: 0},
	                    dimensions: pageDims
	                }
	            ]
	        });
	    });
	
	    return pages;
	};


/***/ }),
/* 39 */
/***/ (function(module, exports) {

	module.exports = getGridLayoutGroups;
	
	function getGridLayoutGroups(viewerConfig)
	{
	    var viewportWidth = viewerConfig.viewport.width;
	    var manifest = viewerConfig.manifest;
	    var pagesPerRow = viewerConfig.pagesPerRow;
	    var fixedHeightGrid = viewerConfig.fixedHeightGrid;
	    var fixedPadding = viewerConfig.fixedPadding;
	    var showNonPagedPages = viewerConfig.showNonPagedPages;
	
	    var horizontalPadding = fixedPadding * (pagesPerRow + 1);
	    var pageWidth = (viewportWidth - horizontalPadding) / pagesPerRow;
	    var gridPageWidth = pageWidth;
	
	    // Calculate the row height depending on whether we want to fix the width or the height
	    var rowHeight = (fixedHeightGrid) ? fixedPadding + manifest.minRatio * pageWidth : fixedPadding + manifest.maxRatio * pageWidth;
	
	    var groups = [];
	    var currentPages = [];
	
	    var getGridPageDimensions = function (pageData)
	    {
	        // Calculate the width, height and horizontal placement of this page
	        // Get dimensions at max zoom level, although any level should be fine
	        var pageDimenData = pageData.d[pageData.d.length - 1];
	        var heightToWidthRatio = pageDimenData.h / pageDimenData.w;
	
	        var pageWidth, pageHeight;
	
	        if (fixedHeightGrid)
	        {
	            pageWidth = (rowHeight - fixedPadding) / heightToWidthRatio;
	            pageHeight = rowHeight - fixedPadding;
	        }
	        else
	        {
	            pageWidth = gridPageWidth;
	            pageHeight = pageWidth * heightToWidthRatio;
	        }
	
	        return {
	            width: Math.round(pageWidth),
	            height: Math.round(pageHeight)
	        };
	    };
	
	    var rowDimensions = {
	        height: rowHeight,
	        width: viewportWidth
	    };
	
	    manifest.pages.forEach(function (page, pageIndex)
	    {
	        if (!showNonPagedPages && manifest.paged && !page.paged)
	            return;
	
	        // Calculate the width, height and horizontal placement of this page
	        var pageDimens = getGridPageDimensions(page);
	        var leftOffset = Math.floor(currentPages.length * (fixedPadding + gridPageWidth) + fixedPadding);
	
	        // Center the page if the height is fixed (otherwise, there is no horizontal padding)
	        if (fixedHeightGrid)
	        {
	            leftOffset += (gridPageWidth - pageDimens.width) / 2;
	        }
	
	        // TODO: Precompute page dimensions everywhere
	        currentPages.push({
	            index: pageIndex,
	            dimensions: pageDimens,
	            groupOffset: {
	                top: 0,
	                left: leftOffset
	            }
	        });
	
	        if (currentPages.length === pagesPerRow)
	        {
	            groups.push({
	                dimensions: rowDimensions,
	                pages: currentPages
	            });
	
	            currentPages = [];
	        }
	    });
	
	    if (currentPages.length > 0)
	    {
	        groups.push({
	            dimensions: rowDimensions,
	            pages: currentPages
	        });
	    }
	
	    return groups;
	}


/***/ }),
/* 40 */
/***/ (function(module, exports) {

	module.exports = createSettingsView;
	
	function createSettingsView(sources)
	{
	    var obj = {};
	
	    sources.forEach(function (source)
	    {
	        registerMixin(obj, source);
	    });
	
	    return obj;
	}
	
	function registerMixin(obj, mixin)
	{
	    Object.keys(mixin).forEach(function (key)
	    {
	        Object.defineProperty(obj, key, {
	            get: function ()
	            {
	                return mixin[key];
	            },
	            set: function ()
	            {
	                // TODO: Make everything strict mode so this isn't needed
	                throw new TypeError('Cannot set settings.' + key);
	            }
	        });
	    });
	}


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	var extend = __webpack_require__(3).extend;
	
	module.exports = ValidationRunner;
	
	function ValidationRunner(options)
	{
	    this.whitelistedKeys = options.whitelistedKeys || [];
	    this.additionalProperties = options.additionalProperties || [];
	    this.validations = options.validations;
	}
	
	ValidationRunner.prototype.isValid = function (key, value, settings)
	{
	    // Get the validation index
	    var validationIndex = null;
	
	    this.validations.some(function (validation, index)
	    {
	        if (validation.key !== key)
	            return false;
	
	        validationIndex = index;
	        return true;
	    });
	
	    if (validationIndex === null)
	        return true;
	
	    // Run the validation
	    var dummyChanges = {};
	    dummyChanges[key] = value;
	    var proxier = createSettingsProxier(settings, dummyChanges, this);
	
	    return !this._runValidation(validationIndex, value, proxier);
	};
	
	ValidationRunner.prototype.validate = function (settings)
	{
	    this._validateOptions({}, settings);
	};
	
	ValidationRunner.prototype.getValidatedOptions = function (settings, options)
	{
	    var cloned = extend({}, options);
	    this._validateOptions(settings, cloned);
	    return cloned;
	};
	
	ValidationRunner.prototype._validateOptions = function (settings, options)
	{
	    var settingsProxier = createSettingsProxier(settings, options, this);
	    this._applyValidations(options, settingsProxier);
	};
	
	ValidationRunner.prototype._applyValidations = function (options, proxier)
	{
	    this.validations.forEach(function (validation, index)
	    {
	        if (!options.hasOwnProperty(validation.key))
	            return;
	
	        var input = options[validation.key];
	        var corrected = this._runValidation(index, input, proxier);
	
	        if (corrected)
	        {
	            if (!corrected.warningSuppressed)
	                emitWarning(validation.key, input, corrected.value);
	
	            options[validation.key] = corrected.value;
	        }
	    }, this);
	};
	
	ValidationRunner.prototype._runValidation = function (index, input, proxier)
	{
	    var validation = this.validations[index];
	
	    proxier.index = index;
	
	    var warningSuppressed = false;
	    var config = {
	        suppressWarning: function ()
	        {
	            warningSuppressed = true;
	        }
	    };
	
	    var outputValue = validation.validate(input, proxier.proxy, config);
	
	    if (outputValue === undefined || outputValue === input)
	        return null;
	
	    return {
	        value: outputValue,
	        warningSuppressed: warningSuppressed
	    };
	};
	
	/**
	 * The settings proxy wraps the settings object and ensures that
	 * only values which have previously been validated are accessed,
	 * throwing a TypeError otherwise.
	 *
	 * FIXME(wabain): Is it worth keeping this? When I wrote it I had
	 * multiple validation stages and it was a lot harder to keep track
	 * of everything, so this was more valuable.
	 */
	function createSettingsProxier(settings, options, runner)
	{
	    var proxier = {
	        proxy: {},
	        index: null
	    };
	
	    var lookup = lookupValue.bind(null, settings, options);
	
	    var properties = {};
	
	    runner.whitelistedKeys.forEach(function (whitelisted)
	    {
	        properties[whitelisted] = {
	            get: lookup.bind(null, whitelisted)
	        };
	    });
	
	    runner.additionalProperties.forEach(function (additional)
	    {
	        properties[additional.key] = {
	            get: additional.get
	        };
	    });
	
	    runner.validations.forEach(function (validation, validationIndex)
	    {
	        properties[validation.key] = {
	            get: function ()
	            {
	                if (validationIndex < proxier.index)
	                    return lookup(validation.key);
	
	                var currentKey = runner.validations[proxier.index].key;
	                throw new TypeError('Cannot access setting ' + validation.key + ' while validating ' + currentKey);
	            }
	        };
	    });
	
	    Object.defineProperties(proxier.proxy, properties);
	
	    return proxier;
	}
	
	function emitWarning(key, original, corrected)
	{
	    console.warn('Invalid value for ' + key + ': ' + original + '. Using ' + corrected + ' instead.');
	}
	
	function lookupValue(base, extension, key)
	{
	    if (key in extension)
	        return extension[key];
	
	    return base[key];
	}


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	module.exports = Viewport;
	
	function Viewport(outer, options)
	{
	    options = options || {};
	
	    this.intersectionTolerance = options.intersectionTolerance || 0;
	    this.maxExtent = options.maxExtent || 2000;
	
	    this.outer = outer;
	
	    this._top = this._left = this._width = this._height = this._innerDimensions = null;
	
	    this.invalidate();
	}
	
	Viewport.prototype.intersectsRegion = function (region)
	{
	    return this.hasHorizontalOverlap(region) && this.hasVerticalOverlap(region);
	};
	
	Viewport.prototype.hasVerticalOverlap = function (region)
	{
	    var top = this.top - this.intersectionTolerance;
	    var bottom = this.bottom + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.top, top, bottom) ||
	        fallsBetween(region.bottom, top, bottom) ||
	        (region.top <= top && region.bottom >= bottom)
	    );
	};
	
	Viewport.prototype.hasHorizontalOverlap = function (region)
	{
	    var left = this.left - this.intersectionTolerance;
	    var right = this.right + this.intersectionTolerance;
	
	    return (
	        fallsBetween(region.left, left, right) ||
	        fallsBetween(region.right, left, right) ||
	        (region.left <= left && region.right >= right)
	    );
	};
	
	Viewport.prototype.invalidate = function ()
	{
	    // FIXME: Should this check the inner dimensions as well?
	    this._width = clampMax(this.outer.clientWidth, this.maxExtent);
	    this._height = clampMax(this.outer.clientHeight, this.maxExtent);
	
	    this._top = this.outer.scrollTop;
	    this._left = this.outer.scrollLeft;
	};
	
	Viewport.prototype.setInnerDimensions = function (dimensions)
	{
	    this._innerDimensions = dimensions;
	
	    if (dimensions)
	    {
	        this._top = clamp(this._top, 0, dimensions.height - this._height);
	        this._left = clamp(this._left, 0, dimensions.width - this._width);
	    }
	};
	
	Object.defineProperties(Viewport.prototype, {
	    top: getCoordinateDescriptor('top', 'height'),
	    left: getCoordinateDescriptor('left', 'width'),
	
	    width: getDimensionDescriptor('width'),
	    height: getDimensionDescriptor('height'),
	
	    bottom: {
	        get: function ()
	        {
	            return this._top + this._height;
	        }
	    },
	    right: {
	        get: function ()
	        {
	            return this._left + this._width;
	        }
	    }
	});
	
	function getCoordinateDescriptor(coord, associatedDimension)
	{
	    var privateProp = '_' + coord;
	    var source = 'scroll' + coord.charAt(0).toUpperCase() + coord.slice(1);
	
	    return {
	        get: function ()
	        {
	            return this[privateProp];
	        },
	        set: function (newValue)
	        {
	            var normalized;
	
	            if (this._innerDimensions)
	            {
	                var maxAllowed = this._innerDimensions[associatedDimension] - this[associatedDimension];
	                normalized = clamp(newValue, 0, maxAllowed);
	            }
	            else
	            {
	                normalized = clampMin(newValue, 0);
	            }
	
	            this[privateProp] = this.outer[source] = normalized;
	        }
	    };
	}
	
	function getDimensionDescriptor(dimen)
	{
	    return {
	        get: function ()
	        {
	            return this['_' + dimen];
	        }
	    };
	}
	
	function fallsBetween(point, start, end)
	{
	    return point >= start && point <= end;
	}
	
	function clamp(value, min, max)
	{
	    return clampMin(clampMax(value, max), min);
	}
	
	function clampMin(value, min)
	{
	    return Math.max(value, min);
	}
	
	function clampMax(value, max)
	{
	    return Math.min(value, max);
	}


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	
	Canvas plugin for diva.js
	Adds an adjustment icon next to each image
	
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	__webpack_require__(16);
	
	(function ($)
	{
	    module.exports = (function ()
	    {
	        var canvas = {},
	            map = {},
	            settings = {},
	            image,
	            sliders,
	            sliderMode;
	
	        // Set up some default settings (can be overridden the normal way)
	        var defaults = {
	            brightnessMax: 150,
	            brightnessMin: -100,
	            brightnessStep: 1,
	            contrastMax: 3,
	            contrastMin: -1,
	            contrastStep: 0.05,
	            localStoragePrefix: 'canvas-',
	            mobileWebkitMaxZoom: 2,
	            rgbMax: 50,
	            rgbMin: -50,
	            throbberFadeSpeed: 200,
	            throbberTimeout: 100,
	            buttons: [
	                'contrast',
	                'brightness',
	                'rotation',
	                'zoom'
	            ]
	        };
	
	        // Convert an angle from degrees to radians
	        var toRadians = function (angle)
	        {
	            return angle * Math.PI / 180;
	        };
	
	        // Determine the new center of the page after rotating by the given angle
	        var getNewCenter = function (currentCenter, angle)
	        {
	            var x = currentCenter.x - canvas.centerX;
	            // Take the negative because the rotation is counterclockwise
	            var y = -(currentCenter.y - canvas.centerY);
	
	            var theta = toRadians(sliders.rotation.previous - angle);
	            var newX = Math.cos(theta) * x - Math.sin(theta) * y + canvas.centerX;
	            var newY = -(Math.sin(theta) * x + Math.cos(theta) * y) + canvas.centerY;
	
	            return {'x': newX, 'y': newY};
	        };
	
	        // Rotates the image on the given canvas by the given angle
	        var rotateCanvas = function (aCanvas, angle)
	        {
	            var context = aCanvas.context;
	            var center = aCanvas.size / 2;
	            var startX = -(aCanvas.width / 2);
	            var startY = -(aCanvas.height / 2);
	
	            // Clear the canvas so that remnants of the old image don't show
	            context.clearRect(0, 0, aCanvas.size, aCanvas.size);
	
	            // Do the rotation
	            context.save();
	            context.translate(center, center);
	            context.rotate(toRadians(angle));
	            context.drawImage(image, startX, startY, aCanvas.width, aCanvas.height);
	            context.restore();
	
	            // Save the new pixel data so that it can later be adjusted in adjustLevels
	            aCanvas.data = context.getImageData(0, 0, aCanvas.size, aCanvas.size);
	        };
	
	        // Determine if we need to update the large canvas
	        var shouldAdjustLevels = function ()
	        {
	            var slider;
	
	            // Returns true if something has been changed
	            for (slider in sliders)
	            {
	                if (sliders[slider].current !== sliders[slider].previous)
	                {
	                    return true;
	                }
	            }
	
	            return false;
	        };
	
	        // Sets the "previous" value to the "current" value for every slider
	        var updatePreviousLevels = function ()
	        {
	            var slider;
	
	            for (slider in sliders)
	            {
	                sliders[slider].previous = sliders[slider].current;
	            }
	        };
	
	        // Update the thumbnail preview (called when a slider is moved/reset)
	        var updateMap = function ()
	        {
	            rotateCanvas(map, sliders.rotation.current);
	            adjustLevels(map);
	        };
	
	        // Update the large canvas (rotation, zooming, scrolling, pixel manipulation)
	        var updateCanvas = function ()
	        {
	            var angle = sliders.rotation.current;
	            var oldAngle = sliders.rotation.previous;
	            var zoomLevel = sliders.zoom.current;
	            var oldZoomLevel = sliders.zoom.previous;
	
	            // Scroll the user to the desired location
	            if (angle !== oldAngle || zoomLevel !== oldZoomLevel)
	            {
	                // First figure out the current center of the viewport
	                var leftScroll = $('#diva-canvas-wrapper').scrollLeft();
	                var topScroll = $('#diva-canvas-wrapper').scrollTop();
	                var leftOffset = settings.viewport.width / 2;
	                var topOffset = settings.viewport.height / 2;
	
	                // Then determine the new center (the same part of the image)
	                var newCenter = getNewCenter({x: leftScroll + leftOffset, y: topScroll + topOffset}, angle);
	
	                // Incorporate the zoom change ratio (would be 1 if no change)
	                var zoomChange = Math.pow(2, zoomLevel - oldZoomLevel);
	                var toLeftScroll = zoomChange * newCenter.x - leftOffset;
	                var toTopScroll = zoomChange * newCenter.y - topOffset;
	
	                // Rotate the large canvas
	                rotateCanvas(canvas, angle);
	
	                // Scroll to the new center
	                $('#diva-canvas-wrapper').scrollLeft(toLeftScroll);
	                $('#diva-canvas-wrapper').scrollTop(toTopScroll);
	            }
	
	            // Only call adjustLevels again if we really need to (expensive)
	            if (shouldAdjustLevels())
	            {
	                adjustLevels(canvas);
	                updatePreviousLevels();
	            }
	        };
	
	        // Copies the canvas' pixel array and returns the copy
	        var copyImageData = function (aCanvas)
	        {
	            var oldImageData = aCanvas.data;
	            var newImageData = aCanvas.context.createImageData(oldImageData);
	            var pixelArray = newImageData.data;
	            var i, length;
	
	            for (i = 0, length = pixelArray.length; i < length; i++)
	            {
	                pixelArray[i] = oldImageData.data[i];
	            }
	
	            return newImageData;
	        };
	
	        // Determines whether or not we need to adjust this level - very simple
	        var shouldAdjust = function (mode)
	        {
	            var thisChanged = sliders[mode].current !== sliders[mode].previous;
	            var thisNotDefault = sliders[mode].current !== sliders[mode].initial;
	
	            return thisChanged || thisNotDefault;
	        };
	
	        var adjustLevels = function (aCanvas)
	        {
	            // Copy the pixel array to avoid destructively modifying the original
	            var imageData = copyImageData(aCanvas);
	            var pixelArray = imageData.data;
	
	            // Store and calculate some scale factors and offsets
	            var brightness = sliders.brightness.current;
	            var contrast = sliders.contrast.current;
	
	            var brightMul = 1 + Math.min(settings.brightnessMax, Math.max(settings.brightnessMin, brightness)) / settings.brightnessMax;
	            var brightTimesContrast = brightMul * contrast;
	            var contrastOffset = 128 - (contrast * 128);
	
	            var redOffset = sliders.red.current;
	            var greenOffset = sliders.green.current;
	            var blueOffset = sliders.blue.current;
	
	            // Determine whether or not we need to adjust certain things
	            var adjustRed = shouldAdjust('red');
	            var adjustGreen = shouldAdjust('green');
	            var adjustBlue = shouldAdjust('blue');
	
	            var adjustBrightness = shouldAdjust('brightness');
	            var adjustContrast = shouldAdjust('contrast');
	            var adjustOthers = adjustBrightness || adjustContrast;
	
	            var x, y, width, height, offset, r, g, b;
	
	            for (x = 0, width = imageData.width; x < width; x++)
	            {
	                for (y = 0, height = imageData.height; y < height; y++)
	                {
	                    offset = (y * width + x) * 4;
	
	                    r = pixelArray[offset];
	                    g = pixelArray[offset + 1];
	                    b = pixelArray[offset + 2];
	
	                    // Only do something if the pixel is not black originally
	                    if (r + g + b > 0)
	                    {
	                        // Only adjust individual colour channels if necessary
	                        if (adjustRed && r)
	                            r += redOffset;
	
	                        if (adjustGreen && g)
	                            g += greenOffset;
	
	                        if (adjustBlue && b)
	                            b += blueOffset;
	
	                        // If we need to adjust brightness and/or contrast
	                        if (adjustOthers)
	                        {
	                            if (r)
	                                r = r * brightTimesContrast + contrastOffset;
	
	                            if (g)
	                                g = g * brightTimesContrast + contrastOffset;
	
	                            if (b)
	                                b = b * brightTimesContrast + contrastOffset;
	                        }
	
	                        pixelArray[offset] = r;
	                        pixelArray[offset + 1] = g;
	                        pixelArray[offset + 2] = b;
	                    }
	                }
	            }
	
	            aCanvas.context.clearRect(0, 0, width, height);
	            aCanvas.context.putImageData(imageData, 0, 0);
	        };
	
	        // Update the box in the preview showing where you currently are
	        var updateViewbox = function ()
	        {
	            // Determine the top left corner coordinates based on our current position
	            var cornerX = $('#diva-canvas-wrapper').scrollLeft() * map.scaleFactor;
	            var cornerY = $('#diva-canvas-wrapper').scrollTop() * map.scaleFactor;
	
	            // Subtract 4 to compensate for the borders
	            var height = Math.min(Math.round(settings.viewport.height * map.scaleFactor), settings.mapSize) - 4;
	            var width = Math.min(Math.round(settings.viewport.width * map.scaleFactor), settings.mapSize) - 4;
	
	            $('#diva-map-viewbox').height(height).width(width).css({top: cornerY, left: cornerX});
	        };
	
	        // Draw the thumbnail preview in the toolbar
	        var loadMap = function (image)
	        {
	            map.canvas = document.getElementById('diva-canvas-minimap');
	            map.size = settings.mapSize;
	            map.canvas.width = map.size;
	            map.canvas.height = map.size;
	
	            // Give it a black background
	            map.context = map.canvas.getContext('2d');
	            map.context.fillRect(0, 0, map.size, map.size);
	
	            // Determine the coordinates/dimensions of the preview
	            map.scaleFactor = settings.mapSize / canvas.size;
	            map.cornerX = canvas.cornerX * map.scaleFactor;
	            map.cornerY = canvas.cornerY * map.scaleFactor;
	            map.width = image.width * map.scaleFactor;
	            map.height = image.height * map.scaleFactor;
	
	            // Draw the image within the map (no adjustments) and save the pixel array
	            map.context.drawImage(image, map.cornerX, map.cornerY, map.width, map.height);
	            map.data = map.context.getImageData(0, 0, settings.mapSize, settings.mapSize);
	
	            // Show the viewbox, make it reflect where we currently are
	            $('#diva-map-viewbox').show();
	            updateViewbox();
	        };
	
	        // Load the image within the large and small canvases
	        var loadCanvas = function (imageURL, callback)
	        {
	            image = new Image();
	            image.crossOrigin = "anonymous";
	
	            image.onload = function ()
	            {
	                // Determine the size of the (square) canvas based on the hypoteneuse
	                canvas.size = Math.sqrt(image.width * image.width + image.height * image.height);
	
	                // Resize the canvas if necessary
	                canvas.canvas = document.getElementById('diva-canvas');
	                canvas.canvas.width = canvas.size;
	                canvas.canvas.height = canvas.size;
	                canvas.cornerX = (canvas.size - image.width) / 2;
	                canvas.cornerY = (canvas.size - image.height) / 2;
	                canvas.width = image.width;
	                canvas.height = image.height;
	                canvas.centerX = canvas.size / 2;
	                canvas.centerY = canvas.size / 2;
	
	                // Draw the image to the large canvas, and save the pixel array
	                canvas.context = canvas.canvas.getContext('2d');
	                canvas.context.drawImage(image, canvas.cornerX, canvas.cornerY, canvas.width, canvas.height);
	                try
	                {
	                    canvas.data = canvas.context.getImageData(0, 0, canvas.size, canvas.size);
	                }
	                catch (error)
	                {
	                    var canvasError = '<div id="diva-error" class="diva-error"><p><strong>Error</strong></p><p>' + error.message + '</p>';
	
	                    if (error.name === 'SecurityError')
	                    {
	                        canvasError += '<p>You may need to update your server configuration in order to use the image manipulation tools. ' +
	                        'For help, see the <a href="https://github.com/DDMAL/diva.js/wiki/The-API-and-Plugins#a-note-about-' +
	                        'canvas-and-cross-site-data" target="_blank">canvas cross-site data documentation</a>.</p>' +
	                        '</div>';
	                    }
	                    else
	                    {
	                        throw error;
	                    }
	
	                    canvasError += '</div>';
	                    $('#diva-canvas-backdrop').append(canvasError);
	                    hideThrobber();
	                }
	
	                // Only load the map the first time (when there is no callback)
	                if (callback === undefined) {
	                    loadMap(image);
	                }
	
	                // Update the map and the canvas if necessary
	                updateMap();
	                updateCanvas(canvas);
	
	                // Hide the throbber if it is visible
	                hideThrobber();
	
	                // If the callback function exists, execute it (for zooming)
	                if (typeof callback === 'function')
	                    callback.call(callback);
	            };
	
	            image.src = imageURL;
	
	            // make sure the load event fires for cached images too
	            if ( image.complete || image.complete === undefined ) {
	                image.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
	                image.src = imageURL;
	            }
	        };
	
	        var updateSliderLabel = function ()
	        {
	            var thisSlider = sliders[sliderMode];
	            var value = thisSlider.current;
	            var stringValue = (thisSlider.transform) ? thisSlider.transform(value) : value;
	            $('#diva-canvas-value').html(stringValue);
	        };
	
	        var updateSliderValue = function ()
	        {
	            $('#diva-canvas-slider').val(sliders[sliderMode].current);
	        };
	
	        // Returns the URL for the image at the specified zoom level
	        var getImageURL = function (zoomLevel)
	        {
	            var width = settings.zoomWidthRatio * Math.pow(2, zoomLevel);
	
	            return settings.divaInstance.getPageImageURL(settings.selectedPageIndex, { width: width });
	        };
	
	        var showThrobber = function ()
	        {
	            // Only show the throbber if it will take a long time
	            if (sliders.zoom.current > 0 || settings.mobileWebkit)
	                $(settings.selector + 'throbber').addClass('canvas-throbber').show();
	        };
	
	        // Hides the loading indicator icon
	        var hideThrobber = function ()
	        {
	            $(settings.selector + 'throbber').removeClass('canvas-throbber').hide();
	        };
	
	        // If any modifications have been applied, save them to localStorage
	        var saveSettings = function ()
	        {
	            var sliderSettings = {};
	            var changed = false;
	            var storageKey = settings.localStoragePrefix + settings.filename;
	            var slider;
	
	            for (slider in sliders)
	            {
	                if (sliders[slider].previous !== sliders[slider].initial)
	                {
	                    sliderSettings[slider] = sliders[slider].previous;
	                    changed = true;
	                }
	            }
	
	            // If modifications need to be saved, update the canvas plugin icon
	            if (changed)
	            {
	                settings.pluginIcon.addClass('new');
	                storeObject(storageKey, sliderSettings);
	            }
	            else
	            {
	                settings.pluginIcon.removeClass('new');
	                localStorage.removeItem(storageKey);
	            }
	        };
	
	        // Handles zooming in when the zoom slider is changed and the change is applied
	        var updateZoom = function (newZoomLevel, callback)
	        {
	            settings.zoomLevel = newZoomLevel;
	
	            // Figure out the URL for the image at this new zoom level
	            var imageURL = getImageURL(newZoomLevel);
	
	            loadCanvas(imageURL, function ()
	            {
	                // Set the new scale factor and update the viewbox
	                map.scaleFactor = map.size / canvas.size;
	                updateViewbox();
	
	                saveSettings();
	            });
	        };
	
	        var bindCanvasKeyEvents = function (event)
	        {
	            var upArrowKey = 38,
	                downArrowKey = 40,
	                leftArrowKey = 37,
	                rightArrowKey = 39;
	
	            switch (event.keyCode)
	            {
	                case upArrowKey:
	                    // Up arrow - scroll up
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop - settings.arrowScrollAmount);
	                    return false;
	
	                case downArrowKey:
	                    // Down arrow - scroll down
	                    $('#diva-canvas-wrapper').scrollTop(document.getElementById('diva-canvas-wrapper').scrollTop + settings.arrowScrollAmount);
	                    return false;
	
	                case leftArrowKey:
	                    // Left arrow - scroll left
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft - settings.arrowScrollAmount);
	                    return false;
	
	                case rightArrowKey:
	                    // Right arrow - scroll right
	                    $('#diva-canvas-wrapper').scrollLeft(document.getElementById('diva-canvas-wrapper').scrollLeft + settings.arrowScrollAmount);
	                    return false;
	            }
	        };
	
	        // Serialize an object to JSON and save it in localStorage
	        var storeObject = function (key, value) {
	            localStorage.setItem(key, JSON.stringify(value));
	        };
	
	        // Load and deserialize a localStorage object
	        var loadStoredObject = function (key) {
	            var value = localStorage.getItem(key);
	            return value && JSON.parse(value);
	        };
	
	        var retval =
	        {
	            init: function (divaSettings, divaInstance)
	            {
	                // If the browser does not support canvas, do nothing
	                // And, disable this plugin
	                var canvasSupported = !!window.HTMLCanvasElement;
	                if (!canvasSupported)
	                    return false;
	
	                // Override all the configurable settings defined under canvasPlugin
	                $.extend(settings, defaults, divaSettings.canvasPlugin);
	
	                settings.divaInstance = divaInstance;
	                settings.inCanvas = false;
	                settings.iipServerURL = divaSettings.iipServerURL;
	                settings.imageDir = divaSettings.imageDir;
	                settings.selector = divaSettings.selector;
	                settings.mobileWebkit = divaSettings.mobileWebkit;
	                settings.arrowScrollAmount = divaSettings.arrowScrollAmount;
	
	                // Set up the settings for the sliders/icons
	                sliders = {
	                    'contrast': {
	                        'initial': 1,
	                        'min': settings.contrastMin,
	                        'max': settings.contrastMax,
	                        'step': settings.contrastStep,
	                        'transform': function (value) {
	                            return value.toFixed(2);
	                        },
	                        'title': 'Change the contrast'
	                    },
	                    'brightness': {
	                        'initial': 0,
	                        'min': settings.brightnessMin,
	                        'max': settings.brightnessMax,
	                        'step': settings.brightnessStep,
	                        'title': 'Adjust the brightness'
	                    },
	                    'rotation': {
	                        'initial': 0,
	                        'min': 0,
	                        'max': 359,
	                        'step': 1,
	                        'transform': function (value) {
	                            return value + '&deg;';
	                        },
	                        'title': 'Rotate the image'
	                    },
	                    'zoom': {
	                        // Default, min and max values updated within setupHook
	                        'initial': 0,
	                        'min': 0,
	                        'max': 0,
	                        'step': 1,
	                        'title': 'Adjust the zoom level'
	                    },
	                    'red': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the red channel'
	                    },
	                    'green': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the green channel'
	                    },
	                    'blue': {
	                        'initial': 0,
	                        'min': settings.rgbMin,
	                        'max': settings.rgbMax,
	                        'step': 1,
	                        'title': 'Adjust the blue channel'
	                    }
	                };
	
	                // Copy the "default" value into "value" and "previous" for each slider
	                var resetSliders = function ()
	                {
	                    var defaultValue, thisSlider, slider;
	                    for (slider in sliders)
	                    {
	                        thisSlider = sliders[slider];
	                        defaultValue = thisSlider.initial;
	                        thisSlider.current = defaultValue;
	                        thisSlider.previous = defaultValue;
	                    }
	                };
	
	                resetSliders();
	
	                // Create the DOM elements if they haven't already been created
	                if ($('#diva-canvas-backdrop').length)
	                {
	                    // Return true to keep the plugin enabled
	                    return true;
	                }
	
	                var canvasButtonsList = [];
	                var buttonHTML, button, buttonTitle, i;
	
	                for (i in settings.buttons)
	                {
	                    button = settings.buttons[i];
	                    buttonTitle = sliders[button].title;
	                    buttonHTML = '<div class="' + button + '" title="' + buttonTitle + '"></div>';
	                    canvasButtonsList.push(buttonHTML);
	                }
	                var canvasButtons = canvasButtonsList.join('');
	
	                var canvasTools = '<div id="diva-canvas-tools">' +
	                    '<div id="diva-canvas-toolbar">' +
	                        '<div id="diva-canvas-close" title="Return to the document viewer"></div>' +
	                        '<div id="diva-canvas-minimise" title="Minimise the toolbar"></div>' +
	                        '<span id="diva-canvas-info">Test</span>' +
	                    '</div>' +
	                    '<div id="diva-canvas-toolwindow">' +
	                        '<div id="diva-map-viewbox"></div>' +
	                        '<canvas id="diva-canvas-minimap"></canvas>' +
	                        '<div id="diva-canvas-buttons">' +
	                            canvasButtons +
	                        '</div>' +
	                        '<div id="diva-canvas-pane">' +
	                            '<p id="diva-canvas-tooltip">' +
	                                '<span id="diva-canvas-mode">contrast</span>: ' +
	                                '<span id="diva-canvas-value">0</span> ' +
	                                '<span id="diva-canvas-reset" class="link">(Reset)</span>' +
	                            '</p>' +
	                            '<input type="range" id="diva-canvas-slider"></input>' +
	                        '</div>' +
	                        '<br />' +
	                        '<div class="action-buttons">' +
	                            '<a href="#" id="diva-canvas-reset-all">Reset all</a>' +
	                            '<a href="#" id="diva-canvas-apply">Apply</a>' +
	                        '</div>' +
	                    '</div>' +
	                '</div>';
	                var canvasWrapper = '<div id="diva-canvas-wrapper">' +
	                    '<canvas id="diva-canvas"></canvas>' +
	                '</div>';
	                var canvasString = '<div id="diva-canvas-backdrop">' +
	                    canvasTools +
	                    canvasWrapper +
	                '</div>';
	
	                $('body').append(canvasString);
	
	                // Save the size of the map, as defined in the CSS
	                settings.mapSize = $('#diva-canvas-minimap').width();
	
	                // Adjust the slider when something is clicked, and make that the current mode
	                $('#diva-canvas-buttons div').click(function ()
	                {
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider($(this).attr('class'));
	                });
	
	                var updateSlider = function (newMode)
	                {
	                    sliderMode = newMode;
	                    var sliderData = sliders[sliderMode];
	
	                    $('#diva-canvas-buttons .' + sliderMode).addClass('clicked');
	
	                    $('#diva-canvas-mode').text(sliderMode);
	
	                    var newValue = sliderData.current;
	                    var newValueString = (sliderData.transform) ? sliderData.transform(newValue) : newValue;
	
	                    var slider = document.getElementById('diva-canvas-slider');
	                    slider.min = sliderData.min;
	                    slider.max = sliderData.max;
	                    slider.step = sliderData.step;
	                    $('#diva-canvas-slider').val(newValue);
	                    $('#diva-canvas-value').html(newValueString);
	                };
	
	                updateSlider('contrast');
	
	                // Create the slider
	                $('#diva-canvas-slider').on('input', function(e){
	                    sliders[sliderMode].current = parseFloat(this.value);
	                    updateSliderLabel();
	                    updateMap();
	                });
	
	                // Reset all the sliders to the default value
	                $('#diva-canvas-reset-all').click(function ()
	                {
	                    var slider;
	
	                    for (slider in sliders)
	                    {
	                        sliders[slider].current = sliders[slider].initial;
	                    }
	
	                    // Change the value of the label
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Reset the current slider to the default value
	                $('#diva-canvas-reset').click(function ()
	                {
	                    // Update the current value and the slider
	                    sliders[sliderMode].current = sliders[sliderMode].initial;
	                    updateSliderLabel();
	                    updateSliderValue();
	
	                    // Update the preview
	                    updateMap();
	                });
	
	                // Update the large canvas when the apply button is clicked
	                $('#diva-canvas-apply').click(function ()
	                {
	                    if (shouldAdjustLevels())
	                    {
	                        showThrobber();
	
	                        setTimeout(function ()
	                        {
	                            if (sliders.zoom.current !== sliders.zoom.previous)
	                            {
	                                updateZoom(sliders.zoom.current);
	                            }
	                            else
	                            {
	                                updateCanvas();
	                                hideThrobber();
	
	                                // Save modifications to localSettings (also done in updateZoom callback)
	                                saveSettings();
	                            }
	                        }, settings.throbberTimeout);
	                    }
	                });
	
	                // Handle exiting canvas mode
	                $('#diva-canvas-close').click(function ()
	                {
	                    $('body').removeClass('overflow-hidden');
	
	                    // Clear the canvases and hide things
	                    // This needs to be improved - not done properly?
	                    canvas.context.clearRect(0, 0, canvas.size, canvas.size);
	                    map.context.clearRect(0, 0, map.size, map.size);
	                    $('#diva-canvas-wrapper').scrollTop(0).scrollLeft(0);
	                    $('#diva-canvas-backdrop').hide();
	                    $('#diva-map-viewbox').hide();
	                    hideThrobber();
	
	                    // Re-enable scrolling of diva when it is in the background
	                    divaInstance.enableScrollable();
	                    $(document).off('keydown', bindCanvasKeyEvents);
	
	                    // Reset everything
	                    resetSliders();
	                    updateSliderLabel();
	                    updateSliderValue();
	                    $('#diva-canvas-buttons .clicked').removeClass('clicked');
	                    updateSlider('contrast');
	
	                    diva.Events.publish("CanvasViewDidHide");
	                });
	
	                // Hide the toolbar when the minimise icon is clicked
	                $('#diva-canvas-minimise').click(function ()
	                {
	                    $('#diva-canvas-toolwindow').slideToggle('fast');
	                });
	
	                // Adjust the size of the canvas when the browser window is resized
	                $(window).resize(function ()
	                {
	                    settings.viewport = {
	                        height: window.innerHeight - divaSettings.scrollbarWidth,
	                        width: window.innerWidth - divaSettings.scrollbarWidth
	                    };
	
	                    // Always update the settings but only redraw if in canvas
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Update the viewbox when the large canvas is scrolled
	                $('#diva-canvas-wrapper').scroll(function ()
	                {
	                    if (settings.inCanvas)
	                        updateViewbox();
	                });
	
	                // Handle clicking/dragging of the viewbox (should scroll the large canvas)
	                $('#diva-canvas-minimap, #diva-map-viewbox').mouseup(function (event)
	                {
	                    // Consider caching this eventually (can't be done in init though)
	                    var offset = $('#diva-canvas-minimap').offset();
	
	                    var scaledX = (event.pageX - offset.left) / map.scaleFactor;
	                    var scaledY = (event.pageY - offset.top) / map.scaleFactor;
	
	                    $('#diva-canvas-wrapper').scrollTop(scaledY - settings.viewport.height / 2);
	                    $('#diva-canvas-wrapper').scrollLeft(scaledX - settings.viewport.width / 2);
	                });
	
	                // Enable drag scroll
	                $('#diva-canvas').mousedown(function ()
	                {
	                    $(this).addClass('grabbing');
	                }).mouseup(function ()
	                {
	                    $(this).removeClass('grabbing');
	                });
	
	                // touch events
	                $('#diva-canvas-wrapper').kinetic();
	
	                // mouse events
	                $('#diva-canvas-wrapper').dragscrollable({
	                    acceptPropagatedEvent: true
	                });
	
	                diva.Events.subscribe('ObjectDidLoad', this.setupHook, divaSettings.ID);
	                diva.Events.subscribe('ViewerDidTerminate', this.destroy, divaSettings.ID);
	                diva.Events.subscribe('PageDidLoad', this.onPageLoad, divaSettings.ID);
	
	                return true;
	            },
	
	            pluginName: 'canvas',
	
	            titleText: 'View the image on a canvas and adjust various settings',
	
	            setupHook: function(divaSettings)
	            {
	                settings.viewport = {
	                    height: window.innerHeight - divaSettings.scrollbarWidth,
	                    width: window.innerWidth - divaSettings.scrollbarWidth
	                };
	
	                // Save the min and max zoom level, and update the zoom slider
	                settings.minZoomLevel = divaSettings.minZoomLevel;
	                settings.maxZoomLevel = divaSettings.maxZoomLevel;
	
	                // If we're on the iPad, limit the max zoom level to 2
	                // Can't do canvas elements that are > 5 megapixels (issue #112)
	                if (settings.mobileWebkit)
	                    settings.maxZoomLevel = Math.min(settings.maxZoomLevel, settings.mobileWebkitMaxZoom);
	
	                sliders.zoom.min = settings.minZoomLevel;
	                sliders.zoom.max = settings.maxZoomLevel;
	            },
	
	            handleClick: function(event, divaSettings, divaInstance, selectedPageIndex)
	            {
	                // loadCanvas() calls all the other necessary functions to load
	                var filename = divaInstance.getFilenames()[selectedPageIndex];
	
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                    .getPageDimensions(selectedPageIndex)
	                    .width - 1;
	
	                var zoomLevel = divaSettings.zoomLevel;
	                var slider;
	
	                settings.zoomWidthRatio = width / Math.pow(2, zoomLevel);
	                settings.pluginIcon = $(this);
	
	                settings.manifest = divaSettings.manifest;
	                settings.selectedPageIndex = selectedPageIndex;
	
	                // Limit the max zoom level if we're on the iPad
	                if (settings.mobileWebkit) {
	                    zoomLevel = Math.min(settings.maxZoomLevel, zoomLevel);
	                }
	
	                settings.filename = filename;
	                sliders.zoom.initial = zoomLevel;
	                sliders.zoom.current = zoomLevel;
	
	                // Find the settings stored in localStorage, if they exist
	                var sliderSettings = loadStoredObject(settings.localStoragePrefix + settings.filename);
	                if (sliderSettings)
	                {
	                    for (slider in sliderSettings)
	                    {
	                        sliders[slider].current = sliderSettings[slider];
	
	                        // If the current slider's value has changed, update it
	                        if (slider === sliderMode)
	                        {
	                            updateSliderLabel();
	                            updateSliderValue();
	                        }
	
	                        if (slider === 'zoom')
	                        {
	                            zoomLevel = sliderSettings[slider];
	                        }
	                    }
	                }
	
	                sliders.zoom.previous = zoomLevel;
	
	                // Prevent scroll in body, and show the canvas backdrop
	                $('body').addClass('overflow-hidden');
	                $('#diva-canvas-backdrop').show();
	
	                // Disable scrolling on main diva instance
	                divaInstance.disableScrollable();
	                // Enable canvas scrolling
	                $(document).keydown(bindCanvasKeyEvents);
	
	                // Set this to true so events can be captured
	                settings.inCanvas = true;
	
	                var imageURL = getImageURL(zoomLevel);
	
	                // Change the title of the page
	                // FIXME: This is legacy behaviour. Should this be a filename/label?
	                $('#diva-canvas-info').text('Page ' + (selectedPageIndex + 1));
	
	                showThrobber();
	
	                diva.Events.publish('CanvasViewDidActivate', [selectedPageIndex]);
	
	                loadCanvas(imageURL);
	            },
	
	            onPageLoad: function(pageIndex, filename, selector)
	            {
	                // If something exists for this page in localStorage, then change icon color
	                var storageKey = settings.localStoragePrefix + filename;
	
	                if (localStorage.getItem(storageKey) !== null)
	                {
	                    $(selector).find('.diva-canvas-icon').addClass('new');
	                }
	            },
	
	            destroy: function(divaSettings, divaInstance)
	            {
	                $('#diva-canvas-backdrop').remove();
	            }
	        };
	
	        // this returns an object with all of the necessary hooks and callbacks
	        // embedded.
	        return retval;
	
	    })();
	})(jQuery);


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	Download plugin for diva.js
	Allows you to download images served by IIPImage or IIIF compatible image servers
	*/
	
	var jQuery = __webpack_require__(3);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                settings.divaInstance = divaInstance;
	                return true;
	            },
	            pluginName: 'download',
	            titleText: 'Download image at the given zoom level',
	            handleClick: function(event, divaSettings, divaInstance, pageIndex)
	            {
	                // TODO: Move rationale for -1 from Wiki (TLDR an old IIP bug)
	                var width = divaInstance
	                        .getPageDimensions(pageIndex)
	                        .width - 1;
	
	                var image = settings.divaInstance.getPageImageURL(pageIndex, { width: width });
	
	                window.open(image);
	            }
	        };
	
	        return retval;
	    })();
	})(jQuery);


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	Highlight plugin for diva.js
	Allows you to highlight regions of a page image
	*/
	
	var jQuery = __webpack_require__(3);
	var elt = __webpack_require__(9);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                var currentHighlight;
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be currently appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                * Moves the diva pane to (page) and makes a darker border on (thisDiv)
	                */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	
	                    currentHighlight = {
	                        region: thisDiv,
	                        page: page
	                    };
	
	                    diva.Events.publish("SelectedHighlightChanged", [thisDiv.id, currentHighlight.page]);
	
	                    //selects the highlight
	                    updateCurrentHighlight(divaInstance, currentHighlight);
	                    return thisDiv.id;
	                };
	
	                var getDivCenter = function(thisDiv)
	                {
	                    if (divaSettings.verticallyOriented) return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2);
	                    else return divaInstance.translateFromMaxZoomLevel(parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                var findAdjacentHighlight = function(forward)
	                {
	                    var centerOfTargetDiv;
	                    var highlightFound = false;
	                    var centerOfCurrentDiv;
	                    var currentPage;
	                    var regionArr, arrIndex;
	                    var pageDims;
	                    var centerOfDiv, targetDiv;
	
	                    var thisDiv;
	                    var compFunction;
	
	                    // If currentHighlight does not already exists,
	                    // just pretend we're starting at the northwest corner of diva-inner
	                    if (!currentHighlight)
	                    {
	                        centerOfCurrentDiv = 0;
	                        currentPage = 0;
	                    }
	                    else {
	                        currentPage = currentHighlight.page;
	
	                        //find the center of the current div
	                        centerOfCurrentDiv = getDivCenter(currentHighlight.region);
	                    }
	
	                    //if we do have a current highlight, try to find the next one in the same page
	
	                    regionArr = highlightManager.getHighlightRegions(currentPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(currentPage, divaInstance.getZoomLevel());
	
	                    //initialize the center of the div to the maximum possible value
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    if(forward)
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC > curC && thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, curC, targetC)
	                        {
	                            return (thisC < curC && thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	
	                        //if this div is farther along the main axis but closer than the current closest
	                        if (compFunction(centerOfDiv, centerOfCurrentDiv, centerOfTargetDiv))
	                        {
	                            //update targetDiv
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //if a highlight was found on the current page that was next; this can get overwritten but we're still good
	                    if (highlightFound) return gotoDiv(currentPage, targetDiv);
	                    //if it wasn't found, continue on...
	
	                    //find the minimum div on the next page with highlights and loop around if necessary
	
	                    //find the next page in the pageArr; this will be in order
	                    var pageArr = highlightManager.getHighlightedPages();
	                    var curIdx = pageArr.indexOf(currentPage.toString());
	
	                    var targetPage;
	
	                    if(forward)
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to first page, move to next if possible
	                            if (curIdx == pageArr.length - 1) targetPage = pageArr[0];
	                            else targetPage = pageArr[++curIdx];
	                        }
	                    }
	
	                    else
	                    {
	                        while (!targetPage || !divaInstance.isPageIndexValid (targetPage))
	                        {
	                            //default to last page, move to previous if possible
	                            if (curIdx === 0) targetPage = pageArr[pageArr.length - 1];
	                            else targetPage = pageArr[--curIdx];
	                        }
	                    }
	
	                    //reset regionArr and centerOfTargetDiv for the new page we're testing
	                    regionArr = highlightManager.getHighlightRegions(targetPage);
	                    arrIndex = regionArr.length;
	                    pageDims = divaInstance.getPageDimensionsAtZoomLevel(targetPage, divaInstance.getMaxZoomLevel());
	
	                    if(forward) centerOfTargetDiv = (divaSettings.verticallyOriented) ? pageDims.height : pageDims.width;
	                    else centerOfTargetDiv = 0;
	
	                    //find the minimum this time
	                    if(forward)
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC < targetC);
	                        };
	                    }
	                    else
	                    {
	                        compFunction = function(thisC, targetC)
	                        {
	                            return (thisC > targetC);
	                        };
	                    }
	
	                    while(arrIndex--)
	                    {
	                        thisDiv = regionArr[arrIndex];
	                        centerOfDiv = getDivCenter(thisDiv);
	                        if (compFunction(centerOfDiv, centerOfTargetDiv))
	                        {
	                            highlightFound = true;
	                            centerOfTargetDiv = centerOfDiv;
	                            targetDiv = thisDiv;
	                        }
	                    }
	
	                    //we've found it this time, as there'll be a region in the full regionArr to be the minimum
	                    return gotoDiv(targetPage, targetDiv);
	                };
	
	                /*
	                    Jumps to the next highlight along the primary axis of the document.
	                */
	                divaInstance.gotoNextHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(true);
	                    else
	                        return false;
	                };
	
	                /*
	                    Jumps to the previous highlight along the primary axis of the document.
	                */
	                divaInstance.gotoPreviousHighlight = function()
	                {
	                    if (highlightManager.getHighlightCount() > 0)
	                        return findAdjacentHighlight(false);
	                    else
	                        return false;
	                };
	
	                diva.Events.subscribe('ViewerWillTerminate', this.destroy, divaSettings.ID);
	
	                return true;
	            },
	            destroy: function (divaSettings)
	            {
	                var highlightManager = divaSettings.parentObject.data('highlightManager');
	                highlightManager.clear();
	                divaSettings.parentObject.removeData('highlightManager');
	            },
	            pluginName: 'highlight',
	            titleText: 'Highlight regions of pages',
	
	            // Exposed export
	            HighlightManager: HighlightManager
	        };
	        return retval;
	    })();
	})(jQuery);
	
	/** Manages the addition and removal of the page overlays which display the highlights */
	function HighlightManager(divaInstance, getCurrentHighlight)
	{
	    this._divaInstance = divaInstance;
	    this._overlays = {};
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightManager.prototype.getHighlightCount = function ()
	{
	    var count = 0;
	    Object.keys(this._overlays).forEach(function (key)
	    {
	        count += this._overlays[key].highlight.regions.length;
	    }, this);
	
	    return count;
	};
	
	HighlightManager.prototype.getHighlightRegions = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return [];
	
	    return this._overlays[pageIndex].highlight.regions;
	};
	
	HighlightManager.prototype.getHighlightedPages = function ()
	{
	    // FIXME: Conceptually awkward that these are strings
	    return Object.keys(this._overlays);
	};
	
	HighlightManager.prototype.getHighlightByRegionId = function (id)
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        var regions = this._overlays[i].highlight.regions;
	        for (var j in regions)
	        {
	            if (!regions.hasOwnProperty(j))
	                continue;
	
	            if (regions[j].divID === id)
	            {
	                return {
	                    highlight: this._overlays[i].highlight,
	                    region: regions[j]
	                };
	            }
	        }
	    }
	
	    return null;
	};
	
	HighlightManager.prototype.addHighlight = function (highlight)
	{
	    var existingOverlay = this._overlays[highlight.page];
	
	    if (existingOverlay)
	        this._divaInstance.__removePageOverlay(existingOverlay);
	
	    var overlay = new HighlightPageOverlay(highlight, this._divaInstance, this._getCurrentHighlight);
	    this._overlays[highlight.page] = overlay;
	    this._divaInstance.__addPageOverlay(overlay);
	};
	
	HighlightManager.prototype.removeHighlightsOnPage = function (pageIndex)
	{
	    if (!this._overlays[pageIndex])
	        return;
	
	    this._divaInstance.__removePageOverlay(this._overlays[pageIndex]);
	    delete this._overlays[pageIndex];
	};
	
	HighlightManager.prototype.clear = function ()
	{
	    for (var i in this._overlays)
	    {
	        if (!this._overlays.hasOwnProperty(i))
	            continue;
	
	        this._divaInstance.__removePageOverlay(this._overlays[i]);
	    }
	
	    this._overlays = {};
	};
	
	/**
	 When a new page is loaded, this overlay will be called with the
	 page index for the page. It looks at the 'highlights' data object
	 set on the diva parent element, and determines whether
	 highlights exist for that page.
	
	 If so, the overlay will create and render elements for every
	 highlighted box.
	
	 @param highlight
	 @param divaInstance
	 @param getCurrentHighlight (optional)
	 */
	function HighlightPageOverlay(highlight, divaInstance, getCurrentHighlight)
	{
	    this.page = highlight.page;
	    this.highlight = highlight;
	    this._highlightRegions = [];
	    this._divaInstance = divaInstance;
	    this._getCurrentHighlight = getCurrentHighlight;
	}
	
	HighlightPageOverlay.prototype.mount = function ()
	{
	    var divaSettings = this._divaInstance.getSettings();
	
	    var highlight = this.highlight;
	    var regions = highlight.regions;
	    var colour = highlight.colour;
	    var divClass = highlight.divClass;
	
	    var j = regions.length;
	    while (j--)
	    {
	        var region = regions[j];
	
	        // FIXME: Use CSS class instead of inline style
	        var box = elt('div', {
	            class: divClass,
	            style: {
	                background: colour,
	                border: "1px solid #555",
	                position: "absolute",
	                zIndex: 100
	            }
	        });
	
	        if (region.divID !== undefined)
	        {
	            box.setAttribute('data-highlight-id', region.divID);
	        }
	
	        // Used by IIIFHighlight
	        if (region.name !== undefined)
	        {
	            box.setAttribute('data-name', region.name);
	        }
	
	        this._highlightRegions.push({
	            element: box,
	            region: region
	        });
	    }
	
	    this.refresh();
	
	    var frag = document.createDocumentFragment();
	    this._highlightRegions.forEach(function (highlight)
	    {
	        frag.appendChild(highlight.element);
	    });
	
	    divaSettings.innerElement.appendChild(frag);
	
	    if (this._getCurrentHighlight)
	        updateCurrentHighlight(this._divaInstance, this._getCurrentHighlight());
	
	    diva.Events.publish("HighlightCompleted", [this.page, this._divaInstance.getFilenames()[this.page]]);
	};
	
	HighlightPageOverlay.prototype.unmount = function ()
	{
	    var innerElement = this._divaInstance.getSettings().innerElement;
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        innerElement.removeChild(highlight.element);
	    });
	
	    this._highlightRegions = [];
	};
	
	// FIXME: Updating a box per highlight region might be too expensive
	// Maybe stick all the elements in a container and then scale it using CSS transforms?
	HighlightPageOverlay.prototype.refresh = function ()
	{
	    var maxZoom = this._divaInstance.getMaxZoomLevel();
	
	    var maxZoomWidth = this._divaInstance.getPageDimensionsAtZoomLevel(this.page, maxZoom).width;
	    var currentWidth = this._divaInstance.getPageDimensions(this.page).width;
	    var zoomDifference = Math.log(maxZoomWidth / currentWidth) / Math.log(2);
	
	    var pageOffset = this._divaInstance.getPageOffset(this.page, {
	        excludePadding: true,
	        incorporateViewport: true
	    });
	
	    this._highlightRegions.forEach(function (highlight)
	    {
	        var region = highlight.region;
	
	        elt.setAttributes(highlight.element, {
	            style: {
	                width: incorporateZoom(region.width, zoomDifference) + "px",
	                height: incorporateZoom(region.height, zoomDifference) + "px",
	                top: pageOffset.top + incorporateZoom(region.uly, zoomDifference) + "px",
	                left: pageOffset.left + incorporateZoom(region.ulx, zoomDifference) + "px"
	            }
	        });
	    });
	};
	
	function incorporateZoom(position, zoomDifference)
	{
	    return position / Math.pow(2, zoomDifference);
	}
	
	function updateCurrentHighlight(divaInstance, currentHighlight)
	{
	    var classString = divaInstance.getInstanceId() + "selected-highlight";
	    var classElem = document.getElementsByClassName(classString);
	    var idx;
	    var box;
	    var boxes;
	
	    for (idx = 0; idx < classElem.length; idx++)
	    {
	        box = classElem[idx];
	        if (box.id !== currentHighlight.id)
	        {
	            box.className = box.className.replace(' '+classString, '');
	            box.style.border = "1px solid #555";
	        }
	    }
	
	    if (divaInstance.isPageInViewport(currentHighlight.page))
	    {
	        boxes = document.querySelectorAll("*[data-highlight-id=" + currentHighlight.id + "]");
	        for(idx = 0; idx < boxes.length; idx++)
	        {
	            box = boxes[idx];
	            box.className = box.className + " " + classString;
	            box.style.border = "2px solid #000";
	        }
	    }
	}


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	/*
	IIIF Highlight plugin for diva.js
	Allows you to highlight regions of a page image based off of annotations in a IIIF Manifest
	*/
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	var HighlightManager = __webpack_require__(45).HighlightManager;
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var settings = {};
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var highlightManager = new HighlightManager(divaInstance);
	                divaSettings.parentObject.data('highlightManager', highlightManager);
	
	                settings.highlightedPages = [];
	
	                /*
	                    Reset the highlights object and removes all highlights from the document.
	                */
	                divaInstance.resetHighlights = function()
	                {
	                    highlightManager.clear();
	                };
	
	                /*
	                    Resets the highlights for a single page.
	                */
	                divaInstance.removeHighlightsOnPage = function(pageIdx)
	                {
	                    highlightManager.removeHighlightsOnPage(pageIdx);
	                };
	
	                divaInstance.hideHighlights = function()
	                {
	                    settings.highlightsVisible = false;
	                    $(divaSettings.innerElement).addClass('annotations-hidden');
	                };
	
	                divaInstance.showHighlights = function()
	                {
	                    settings.highlightsVisible = true;
	                    $(divaSettings.innerElement).removeClass('annotations-hidden');
	                };
	
	                /*
	                    Highlights regions on multiple pages.
	                    @param pageIdxs An array of page index numbers
	                    @param regions  An array of regions
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                */
	                divaInstance.highlightOnPages = function(pageIdxs, regions, colour, divClass)
	                {
	                    var j = pageIdxs.length;
	                    while (j--)
	                    {
	                        divaInstance.highlightOnPage(pageIdxs[j], regions[j], colour, divClass);
	                    }
	                };
	
	                /*
	                    Highlights regions on a page.
	                    @param pageIdx  A page index number
	                    @param regions  An array of regions. Use {'width':i, 'height':i, 'ulx':i, 'uly': i, 'divID': str} for each region.
	                    @param colour   (optional) A colour for the highlighting, specified in RGBA CSS format
	                    @param divClass (optional) A class to identify a group of highlighted regions on a specific page by
	                */
	                divaInstance.highlightOnPage = function(pageIdx, regions, colour, divClass)
	                {
	                    if (colour === undefined)
	                    {
	                        colour = 'rgba(255, 0, 0, 0.2)';
	                    }
	
	                    if (divClass === undefined)
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight';
	                    }
	                    else
	                    {
	                        divClass = divaSettings.ID + 'highlight diva-highlight ' + divClass;
	                    }
	
	                    highlightManager.addHighlight({
	                        page: pageIdx,
	                        regions: regions,
	                        colour: colour,
	                        divClass: divClass
	                    });
	
	                    return true;
	                };
	
	                                /*
	                    Jumps to a highlight somewhere in the document.
	                    @param divID The ID of the div to jump to. This ID must be attached to the div using .highlightOnPage(s) as the highlight may not be appended to the DOM.
	                */
	                divaInstance.gotoHighlight = function(divID)
	                {
	                    var result = highlightManager.getHighlightByRegionId(divID);
	
	                    if (result)
	                        return gotoDiv(result.highlight.page, result.region);
	
	                    console.warn("Diva just tried to find a highlight that doesn't exist.");
	                    return false;
	                };
	
	                /**
	                 * Moves the diva pane to (page)
	                 */
	                var gotoDiv = function(page, thisDiv)
	                {
	                    //gets center of the div
	                    var centerYOfDiv = parseFloat(thisDiv.uly) + parseFloat(thisDiv.height) / 2;
	                    var centerXOfDiv = parseFloat(thisDiv.ulx) + parseFloat(thisDiv.width) / 2;
	
	                    var desiredY = divaInstance.translateFromMaxZoomLevel(centerYOfDiv);
	                    var desiredX = divaInstance.translateFromMaxZoomLevel(centerXOfDiv);
	
	                    //navigates to the page
	                    page = parseInt(page, 10);
	                    divaInstance.gotoPageByIndex(page);
	                    var viewportObject = divaInstance.getSettings().viewportObject;
	                    var currentTop = viewportObject.scrollTop() + desiredY - (viewportObject.height() / 2) + divaSettings.verticalPadding;
	                    var currentLeft = viewportObject.scrollLeft() + desiredX - (viewportObject.width() / 2) + divaSettings.horizontalPadding;
	
	                    //changes the scroll location to center on the div as much as is possible
	                    viewportObject.scrollTop(currentTop);
	                    viewportObject.scrollLeft(currentLeft);
	                };
	
	                var showAnnotations = function(canvasIndex)
	                {
	                    return function(data, status, jqXHR)
	                    {
	                        var canvasAnnotations = data;
	                        var numAnnotations = data.length;
	
	                        //convert annotations in annotations object to diva highlight objects
	                        var regions = [];
	
	                        //loop over annotations in a single canvas
	                        for (var k = 0; k < numAnnotations; k++)
	                        {
	                            var currentAnnotation = canvasAnnotations[k];
	                            // get text content
	                            var text = currentAnnotation.resource.chars;
	
	                            // get x,y,w,h (slice string from '#xywh=' to end)
	                            var onString = currentAnnotation.on;
	                            var coordString = onString.slice(onString.indexOf('#xywh=') + 6);
	                            var coordinates = coordString.split(',');
	
	                            var region = {
	                                ulx: parseInt(coordinates[0], 10),
	                                uly: parseInt(coordinates[1], 10),
	                                width: parseInt(coordinates[2], 10),
	                                height: parseInt(coordinates[3], 10),
	                                name: text
	                            };
	
	                            regions.push(region);
	                        }
	
	                        divaInstance.highlightOnPage(canvasIndex, regions);
	                        //flag this page's annotations as having been retrieved
	                        settings.highlightedPages.push(canvasIndex);
	                    };
	                };
	
	                var getAnnotationsList = function(pageIndex)
	                {
	                    //if page has annotationList
	                    var canvases = settings.manifest.sequences[0].canvases;
	
	                    if (canvases[pageIndex].hasOwnProperty('otherContent'))
	                    {
	                        var otherContent = canvases[pageIndex].otherContent;
	
	                        for (var j = 0; j < otherContent.length; j++)
	                        {
	                            if (otherContent[j]['@type'] === 'sc:AnnotationList')
	                            {
	                                // canvas has annotations. get the annotations:
	                                $.ajax({
	                                    url: otherContent[j]['@id'],
	                                    cache: true,
	                                    dataType: 'json',
	                                    success: showAnnotations(pageIndex)
	                                });
	                            }
	                        }
	                    }
	                };
	
	                var setManifest = function(manifest)
	                {
	                    settings.manifest = manifest;
	                };
	
	                diva.Events.subscribe('ManifestDidLoad', setManifest, divaSettings.ID);
	
	                diva.Events.subscribe('PageWillLoad', function(pageIndex)
	                {
	                    if (!settings.highlightsVisible)
	                    {
	                        return;
	                    }
	
	                    //if highlights for this page have already been checked/loaded, return
	                    for (var i = 0; i < settings.highlightedPages.length; i++)
	                    {
	                        if (settings.highlightedPages[i] === pageIndex)
	                        {
	                            return;
	                        }
	                    }
	
	                    getAnnotationsList(pageIndex, settings.manifest);
	                }, divaSettings.ID);
	
	                var activeOverlays = [];
	
	                //on mouseover, show the annotation text
	                divaSettings.innerObject.on('mouseenter', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    var annotationElement = e.target;
	                    var name = annotationElement.dataset.name;
	                    var textOverlay = document.createElement('div');
	
	                    textOverlay.style.top = (annotationElement.offsetTop + annotationElement.offsetHeight - 1) + 'px';
	                    textOverlay.style.left = annotationElement.style.left;
	                    textOverlay.style.background = '#fff';
	                    textOverlay.style.border = '1px solid #555';
	                    textOverlay.style.position = 'absolute';
	                    textOverlay.style.zIndex = 101;
	                    textOverlay.className = 'annotation-overlay';
	                    textOverlay.textContent = name;
	
	                    annotationElement.parentNode.appendChild(textOverlay);
	                    activeOverlays.push(textOverlay);
	                });
	
	                divaSettings.innerObject.on('mouseleave', '.' + divaSettings.ID + 'highlight', function(e)
	                {
	                    while (activeOverlays.length)
	                    {
	                        var textOverlay = activeOverlays.pop();
	                        textOverlay.parentNode.removeChild(textOverlay);
	                    }
	                });
	
	                diva.Events.subscribe('ViewerDidLoad', function(){
	                    //button to toggle annotations
	                    $('#' + divaSettings.ID + 'page-nav').before('<div id="' + divaSettings.ID + 'annotations-icon" class="diva-button diva-annotations-icon" title="Turn annotations on or off"></div>');
	
	                    $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	
	                    $('#' + divaSettings.ID + 'annotations-icon').on('click', function(e)
	                    {
	                        //toggle visibility of annotations
	                        if (settings.highlightsVisible)
	                        {
	                            divaInstance.hideHighlights();
	                            $(divaSettings.selector + 'annotations-icon').removeClass('annotations-icon-active');
	                        }
	                        else
	                        {
	                            divaInstance.showHighlights();
	                            $(divaSettings.selector + 'annotations-icon').addClass('annotations-icon-active');
	                        }
	                    });
	                }, divaSettings.ID);
	
	                //enable annotations by default
	                settings.highlightsVisible = true;
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	                divaSettings.parentObject.removeData('highlights');
	            },
	            pluginName: 'IIIFHighlight',
	            titleText: 'Highlight regions of pages'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	// IIIF Metadata plugin for diva.js
	// Displays object metadata from a IIIF manifest
	
	var jQuery = __webpack_require__(3);
	var diva = __webpack_require__(7);
	
	(function ($)
	{
	    module.exports = (function()
	    {
	        var retval =
	        {
	            init: function(divaSettings, divaInstance)
	            {
	                var _displayMetadata = function(manifest)
	                {
	                    var showMetadata = function(label, value)
	                    {
	                        var labelProper = label.charAt(0).toUpperCase() + label.slice(1);
	                        var labelFormatted = labelProper.replace('_', ' ');
	
	                        if (value.match(/^https?:\/\//))
	                        {
	                            value = '<a href="' + value + '" target="_blank">' + value + '</a>';
	                        }
	
	                        return '<div class="metadata-row"><span class="metadata-label">' + labelFormatted + ':</span> <span class="metadata-value">' +
	                            value  + '</span></div>';
	                    };
	
	                    var getDataForLanguage = function(data, language)
	                    {
	                        for (var i = 0; i < data.length; i++)
	                        {
	                            if (data[i]['@language'] === language)
	                            {
	                                return data[i]['@value'];
	                            }
	                        }
	
	                        // Handle the case where no language is specified, or when a single object is passed
	                        return data[0]['@value'] || data['@value'];
	                    };
	
	                    /**
	                     * Shows metadata from label names (if the metadata exists).
	                     * @param names {Array} - An array of strings representing field names to display.
	                     */
	                    var showMetadataFromLabelNames = function(names)
	                    {
	                        var elements = '';
	
	                        for (var i = 0; i < names.length; i++)
	                        {
	                            var field = names[i];
	
	                            if (manifest.hasOwnProperty(field))
	                            {
	                                if (manifest[field].constructor === Array)
	                                {
	                                    //multiple languages
	                                    var localizedData = getDataForLanguage(manifest[field], 'en');
	                                    elements += showMetadata(field, localizedData);
	                                }
	                                else
	                                {
	                                    elements += showMetadata(field, manifest[field]);
	                                }
	                            }
	                        }
	
	                        return elements;
	                    };
	
	                    var metadataElement = '<div id="' + divaSettings.ID + 'metadata" class="diva-modal">';
	                    metadataElement += showMetadataFromLabelNames(['label']);
	
	                    if (manifest.hasOwnProperty('metadata'))
	                    {
	                        var metadataField = manifest.metadata;
	
	                        for (var i = 0; i < metadataField.length; i++)
	                        {
	                            if (metadataField[i].value.constructor === Array)
	                            {
	                                var canonicalData = getDataForLanguage(metadataField[i].value, 'en');
	                                metadataElement += showMetadata(metadataField[i].label, canonicalData);
	                            }
	                            else
	                            {
	                                metadataElement += showMetadata(metadataField[i].label, metadataField[i].value);
	                            }
	                        }
	                    }
	
	                    metadataElement += showMetadataFromLabelNames([
	                        'description',
	                        'within',
	                        'see_also',
	                        'license',
	                        'attribution'
	                    ]);
	
	                    metadataElement += '</div>';
	
	                    divaSettings.parentObject.prepend(metadataElement);
	                    $(divaSettings.selector + 'metadata').hide();
	                };
	
	                //subscribe to ManifestDidLoad event, get the manifest
	                diva.Events.subscribe('ManifestDidLoad', _displayMetadata, divaSettings.ID);
	
	                divaSettings.parentObject.prepend('<div style="text-align: center; clear: both"><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	                // $(divaSettings.selector + 'title').append('<div><a href="#" id="' + divaSettings.ID + 'metadata-link" class="diva-metadata-link">Details</a></div>');
	
	                $(divaSettings.selector + 'metadata-link').on('click', function(e)
	                {
	                    $(divaSettings.selector + 'metadata').fadeToggle('fast');
	                });
	
	                return true;
	            },
	            destroy: function (divaSettings, divaInstance)
	            {
	            },
	            pluginName: 'IIIFMetadata',
	            titleText: 'Show metadata from a IIIF manifest'
	        };
	        return retval;
	    })();
	})(jQuery);


/***/ })
/******/ ])
});
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA3ZGNkYzIwOWZkOTJlMzJiZGEwNSIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcmVnaXN0ZXItYnVpbHRpbi1wbHVnaW5zLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9kaXZhLWdsb2JhbC5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwiLFwiY29tbW9uanNcIjpcImpxdWVyeVwiLFwiY29tbW9uanMyXCI6XCJqcXVlcnlcIn0iLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3V0aWxzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2luLXJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2F1dG9zY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RpdmEuanMiLCJ3ZWJwYWNrOi8vLy4vfi9hcnJheS5wcm90b3R5cGUuZmlsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvZWx0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy91dGlscy9oYXNoLXBhcmFtcy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvYWN0aXZlLWRpdmEtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW1hZ2UtbWFuaWZlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhcnNlLWlpaWYtbWFuaWZlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3Rvb2xiYXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3ZpZXdlci1jb3JlLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy91dGlscy9qcXVlcnktZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvZ2VzdHVyZS1ldmVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2RvY3VtZW50LWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9sb2Rhc2gubWF4YnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS10b29scy1vdmVybGF5LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9ncmlkLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vZGVidWcvc3JjL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL2NvbXBvc2l0ZS1pbWFnZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvZG9jdW1lbnQtbGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9pbWFnZS1jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvaW1hZ2UtcmVxdWVzdC1oYW5kbGVyLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9pbnRlcnBvbGF0ZS1hbmltYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL2Jvb2stbGF5b3V0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvcGFnZS1kaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvc2luZ2xlcy1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9ncmlkLWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvc2V0dGluZ3Mtdmlldy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvdmFsaWRhdGlvbi1ydW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3ZpZXdwb3J0LmpzIiwid2VicGFjazovLy8uL3NvdXJjZS9qcy9wbHVnaW5zL2NhbnZhcy5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2lucy9kb3dubG9hZC5qcyIsIndlYnBhY2s6Ly8vLi9zb3VyY2UvanMvcGx1Z2lucy9oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvaWlpZi1oaWdobGlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vc291cmNlL2pzL3BsdWdpbnMvaWlpZi1tZXRhZGF0YS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3RDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkIsd0JBQXVCO0FBQ3ZCLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNsREEsZ0Q7Ozs7OztBQ0FBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUFzQjtBQUN0Qix1QkFBc0I7QUFDdEIsdUJBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBc0I7QUFDdEIsMEJBQXlCO0FBQ3pCLDRCQUEyQixRQUFRLDBEQUEwRDtBQUM3RjtBQUNBLGdDQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkIsNEJBQTJCLFNBQVM7QUFDcEMsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDakJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0Isb0RBQW1ELG9EQUFvRDtBQUN2RztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFvRCxtQkFBbUI7O0FBRXZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekIsc0JBQXFCO0FBQ3JCO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7QUMxUEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTRDOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBdUQsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDRCQUEyQjtBQUMzQiwyQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUE4RTtBQUM5RSw4RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVULHNFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBeUU7QUFDekUsMEVBQXlFO0FBQ3pFLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwRUFBeUU7QUFDekUsMEVBQXlFO0FBQ3pFLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEwQixpREFBaUQ7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEIsMkJBQTJCO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVGQUFzRjtBQUN0RjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIseUJBQXlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLEVBQUM7Ozs7Ozs7QUNucENEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7Ozs7OztBQ3pERDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQzlGQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzVEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDs7Ozs7OztBQ3RFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBaUIsWUFBWTtBQUM3QjtBQUNBLHNCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxjQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN2UEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQix1QkFBdUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNFQUFxRTs7QUFFckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdFFBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBLGNBQWE7O0FBRWI7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBLDZDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRCxnQ0FBZ0M7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGtCQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQy9yQkE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsMkRBQTJEO0FBQzlHLGlEQUFnRCwyREFBMkQ7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQW9ELDZCQUE2QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF1RCxtQ0FBbUM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFvRCw2QkFBNkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ3A5Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEwQztBQUMxQyxvRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLGNBQWM7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYixpREFBZ0Q7QUFDaEQ7QUFDQSw4QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFhO0FBQ2IsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsT0FBTTs7QUFFTixFQUFDLFlBQVk7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUOztBQUVBLEVBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDanRCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDOUxBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTJELHNCQUFzQjs7QUFFakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOzs7Ozs7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFvQzs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0gsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxRQUFRO0FBQ25CLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGFBQWE7QUFDeEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLEVBQUU7QUFDYixZQUFXLFNBQVM7QUFDcEIsWUFBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsYUFBYTtBQUN4QixjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixZQUFXLFNBQVM7QUFDcEIsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLE9BQU87QUFDbEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsU0FBUztBQUNwQixZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGFBQWE7QUFDeEIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixZQUFXLE9BQU87QUFDbEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsWUFBVyxFQUFFO0FBQ2IsY0FBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsa0JBQWtCLEVBQUU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxFQUFFO0FBQ2IsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsRUFBRTtBQUNiLGNBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsYUFBYTtBQUN4QixZQUFXLEVBQUU7QUFDYixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0Esa0JBQWlCLFFBQVEsT0FBTyxTQUFTLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixZQUFXLGFBQWE7QUFDeEIsY0FBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSwyQkFBMEIsZ0JBQWdCLFNBQVMsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGNBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLEVBQUU7QUFDYixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxhQUFhO0FBQ3hCLGNBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxPQUFNLE9BQU8sU0FBUyxFQUFFO0FBQ3hCLE9BQU0sT0FBTyxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsU0FBUztBQUNwQixjQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0Esb0JBQW1CLFNBQVMsR0FBRyxTQUFTO0FBQ3hDO0FBQ0Esa0NBQWlDLFlBQVksRUFBRTtBQUMvQyxXQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN2dEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEwQyxpQ0FBaUM7QUFDM0UseUJBQXdCLHlCQUF5QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7Ozs7Ozs7QUM3RUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLDhCQUE2QixnQkFBZ0I7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7Ozs7OztBQ3pHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JHQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQWtDLDZDQUE2QztBQUMvRTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2IsVUFBUztBQUNULE1BQUs7O0FBRUwsb0JBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUEsd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFpRCxxQkFBcUI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDs7Ozs7Ozs7QUN4TEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxFQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDRCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNEIsVUFBVTs7Ozs7Ozs7QUN0THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFpQixTQUFTO0FBQzFCLDZCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLGNBQWM7QUFDekIsWUFBVyxPQUFPO0FBQ2xCLGFBQVksTUFBTTtBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdkpBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNULE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQXlCLGdCQUFnQjtBQUN6QztBQUNBLDhCQUE2QixnQkFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBaUIsV0FBVztBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUMvTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWEsT0FBTztBQUNwQixlQUFjLE9BQU87QUFDckIsZ0JBQWUsMkNBQTJDO0FBQzFELGdCQUFlLCtCQUErQjtBQUM5QyxnQkFBZSwyQkFBMkI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQixlQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7Ozs7OztBQ2hTQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxZQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNsSEE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQW9ELG1CQUFtQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ2xGQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7Ozs7Ozs7QUN2Q0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLHdCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsVUFBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNyS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0MsZ0JBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLOztBQUVMO0FBQ0E7Ozs7Ozs7QUM1QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhOztBQUViO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7Ozs7OztBQ2pHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLO0FBQ0w7Ozs7Ozs7QUM5QkE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSwyQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNuS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDaEpBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF1QjtBQUN2QixxQkFBb0I7QUFDcEIsMEJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBOEMscURBQXFEOztBQUVuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpREFBZ0QsV0FBVztBQUMzRDtBQUNBLHVEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUVBQW9FLDRCQUE0QjtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUZBQXNGLGVBQWU7QUFDckc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQsMEJBQXlCO0FBQ3pCO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFhOztBQUViOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7QUN0OEJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrRUFBOEUsZUFBZTs7QUFFN0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBSztBQUNMLEVBQUM7Ozs7Ozs7QUNwQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQThELHVEQUF1RDtBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtGQUFpRjtBQUNqRjtBQUNBOztBQUVBOztBQUVBLHlEQUF3RDtBQUN4RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxNQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM5akJBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUE4RCx1REFBdUQ7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjs7QUFFckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXVDLG9CQUFvQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdDQUF1Qyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQyxzQ0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWlCOztBQUVqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFpQjs7QUFFakI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCLGtCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsRUFBQzs7Ozs7OztBQ3ZTRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXVDLGtCQUFrQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBdUMsMEJBQTBCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtRkFBa0Y7QUFDbEY7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWlCOztBQUVqQjtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMLEVBQUMiLCJmaWxlIjoiZGl2YS5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wianF1ZXJ5XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImRpdmFcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImRpdmFcIl0gPSBmYWN0b3J5KHJvb3RbXCJqUXVlcnlcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcbnJldHVybiBcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgN2RjZGMyMDlmZDkyZTMyYmRhMDUiLCJ2YXIgZGl2YSA9IHJlcXVpcmUoJy4vZGl2YS1nbG9iYWwnKTtcblxuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvYXV0b3Njcm9sbCcpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2NhbnZhcycpKTtcbmRpdmEucmVnaXN0ZXJQbHVnaW4ocmVxdWlyZSgnLi9wbHVnaW5zL2Rvd25sb2FkJykpO1xuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvaGlnaGxpZ2h0JykpO1xuZGl2YS5yZWdpc3RlclBsdWdpbihyZXF1aXJlKCcuL3BsdWdpbnMvaWlpZi1oaWdobGlnaHQnKSk7XG5kaXZhLnJlZ2lzdGVyUGx1Z2luKHJlcXVpcmUoJy4vcGx1Z2lucy9paWlmLW1ldGFkYXRhJykpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcmVnaXN0ZXItYnVpbHRpbi1wbHVnaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbnZhciBFdmVudHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50cycpO1xudmFyIFBsdWdpblJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9wbHVnaW4tcmVnaXN0cnknKTtcblxudmFyIGRpdmEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFdmVudHM6IG5ldyBFdmVudHMoKSxcblxuICAgIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiAocGx1Z2luKVxuICAgIHtcbiAgICAgICAgUGx1Z2luUmVnaXN0cnkucmVnaXN0ZXIocGx1Z2luKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERpdmEgaW5zdGFuY2UgYXQgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50IHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAgICogQHJldHVybnMge0RpdmF9XG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucylcbiAgICB7XG4gICAgICAgIGlmIChkaXZhLmZpbmQoZWxlbWVudCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpdmEgaXMgYWxyZWFkeSBpbml0aWFsaXplZCBvbiAnICsgcmVwckVsZW0oZWxlbWVudCkpO1xuXG4gICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbWVudCk7XG4gICAgICAgICRlbGVtLmRpdmEob3B0aW9ucyk7XG5cbiAgICAgICAgcmV0dXJuICRlbGVtLmRhdGEoJ2RpdmEnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBEaXZhIGluc3RhbmNlIGF0dGFjaGVkIHRvIHRoZVxuICAgICAqIGVsZW1lbnQsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0RpdmF8bnVsbH1cbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbiAoZWxlbWVudClcbiAgICB7XG4gICAgICAgIHJldHVybiAkKGVsZW1lbnQpLmRhdGEoJ2RpdmEnKSB8fCBudWxsO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHJlcHJFbGVtKGVsZW0pXG57XG4gICAgdmFyIGlkID0gZWxlbS5pZCA/ICcjJyArIGVsZW0uaWQgOiBlbGVtLmlkO1xuICAgIHZhciBjbGFzc2VzID0gZWxlbS5jbGFzc05hbWUgPyAnLicgKyBlbGVtLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy9nKS5qb2luKCcuJykgOiAnJztcblxuICAgIHJldHVybiAoaWQgPyBpZCA6IGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpKSArIGNsYXNzZXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9kaXZhLWdsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfM19fO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIHtcInJvb3RcIjpcImpRdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCJ9XG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gRXZlbnRzO1xuXG4vKipcbiAqICAgICAgRXZlbnRzLiBQdWIvU3ViIHN5c3RlbSBmb3IgTG9vc2VseSBDb3VwbGVkIGxvZ2ljLlxuICogICAgICBCYXNlZCBvbiBQZXRlciBIaWdnaW5zJyBwb3J0IGZyb20gRG9qbyB0byBqUXVlcnlcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3BoaWdnaW5zNDIvYmxvb2R5LWpxdWVyeS1wbHVnaW5zL2Jsb2IvbWFzdGVyL3B1YnN1Yi5qc1xuICpcbiAqICAgICAgUmUtYWRhcHRlZCB0byB2YW5pbGxhIEphdmFzY3JpcHRcbiAqXG4gKiAgICAgIEBjbGFzcyBFdmVudHNcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKClcbntcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xufVxuXG4vKipcbiAqICAgICAgZGl2YS5FdmVudHMucHVibGlzaFxuICogICAgICBlLmcuOiBkaXZhLkV2ZW50cy5wdWJsaXNoKFwiUGFnZURpZExvYWRcIiwgW3BhZ2VJbmRleCwgZmlsZW5hbWUsIHBhZ2VTZWxlY3Rvcl0sIHRoaXMpO1xuICpcbiAqICAgICAgQGNsYXNzIEV2ZW50c1xuICogICAgICBAbWV0aG9kIHB1Ymxpc2hcbiAqICAgICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG4gKiAgICAgIEBwYXJhbSBhcmdzICB7QXJyYXl9XG4gKiAgICAgIEBwYXJhbSBzY29wZSB7T2JqZWN0PX0gT3B0aW9uYWwgLSBTdWJzY3JpYmVkIGZ1bmN0aW9ucyB3aWxsIGJlIGV4ZWN1dGVkIHdpdGggdGhlIHN1cHBsaWVkIG9iamVjdCBhcyBgdGhpc2AuXG4gKiAgICAgICAgICBJdCBpcyBuZWNlc3NhcnkgdG8gc3VwcGx5IHRoaXMgYXJndW1lbnQgd2l0aCB0aGUgc2VsZiB2YXJpYWJsZSB3aGVuIHdpdGhpbiBhIERpdmEgaW5zdGFuY2UuXG4gKiAgICAgICAgICBUaGUgc2NvcGUgYXJndW1lbnQgaXMgbWF0Y2hlZCB3aXRoIHRoZSBpbnN0YW5jZSBJRCBvZiBzdWJzY3JpYmVycyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5XG4gKiAgICAgICAgICAgICAgc2hvdWxkIGJlIGV4ZWN1dGVkLiAoU2VlIGluc3RhbmNlSUQgYXJndW1lbnQgb2Ygc3Vic2NyaWJlLilcbiAqL1xuRXZlbnRzLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24gKHRvcGljLCBhcmdzLCBzY29wZSlcbntcbiAgICBpZiAodGhpcy5fY2FjaGVbdG9waWNdKVxuICAgIHtcbiAgICAgICAgdmFyIHRoaXNUb3BpYyA9IHRoaXMuX2NhY2hlW3RvcGljXTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXNUb3BpYy5nbG9iYWwgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgdGhpc1RvcGljR2xvYmFsID0gdGhpc1RvcGljLmdsb2JhbDtcbiAgICAgICAgICAgIHZhciBnbG9iYWxDb3VudCA9IHRoaXNUb3BpY0dsb2JhbC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IGdsb2JhbENvdW50OyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpc1RvcGljR2xvYmFsW2ldLmFwcGx5KHNjb3BlIHx8IG51bGwsIGFyZ3MgfHwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjb3BlICYmIHR5cGVvZiBzY29wZS5nZXRJbnN0YW5jZUlkICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gZ2V0IHB1Ymxpc2hlciBpbnN0YW5jZSBJRCBmcm9tIHNjb3BlIGFyZywgY29tcGFyZSwgYW5kIGV4ZWN1dGUgaWYgbWF0Y2hcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZUlEID0gc2NvcGUuZ2V0SW5zdGFuY2VJZCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0aGlzVG9waWNJbnN0YW5jZSA9IHRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcGVkQ291bnQgPSB0aGlzVG9waWNJbnN0YW5jZS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBzY29wZWRDb3VudDsgaisrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1RvcGljSW5zdGFuY2Vbal0uYXBwbHkoc2NvcGUsIGFyZ3MgfHwgW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmVcbiAqICAgICAgZS5nLjogZGl2YS5FdmVudHMuc3Vic2NyaWJlKFwiUGFnZURpZExvYWRcIiwgaGlnaGxpZ2h0LCBzZXR0aW5ncy5JRClcbiAqXG4gKiAgICAgIEBjbGFzcyBFdmVudHNcbiAqICAgICAgQG1ldGhvZCBzdWJzY3JpYmVcbiAqICAgICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG4gKiAgICAgIEBwYXJhbSBjYWxsYmFjayB7RnVuY3Rpb259XG4gKiAgICAgIEBwYXJhbSBpbnN0YW5jZUlEIHtTdHJpbmc9fSBPcHRpb25hbCAtIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIElEIG9mIGEgRGl2YSBpbnN0YW5jZTsgaWYgcHJvdmlkZWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgb25seSBmaXJlcyBmb3IgZXZlbnRzIHB1Ymxpc2hlZCBmcm9tIHRoYXQgaW5zdGFuY2UuXG4gKiAgICAgIEByZXR1cm4gRXZlbnQgaGFuZGxlciB7QXJyYXl9XG4gKi9cbkV2ZW50cy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHRvcGljLCBjYWxsYmFjaywgaW5zdGFuY2VJRClcbntcbiAgICBpZiAoIXRoaXMuX2NhY2hlW3RvcGljXSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2NhY2hlW3RvcGljXSA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2VJRCA9PT0gJ3N0cmluZycpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlW3RvcGljXVtpbnN0YW5jZUlEXSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbdG9waWNdW2luc3RhbmNlSURdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF0ucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVbdG9waWNdLmdsb2JhbClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbdG9waWNdLmdsb2JhbCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FjaGVbdG9waWNdLmdsb2JhbC5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2VJRCA/IFt0b3BpYywgY2FsbGJhY2ssIGluc3RhbmNlSURdIDogW3RvcGljLCBjYWxsYmFja107XG5cbiAgICByZXR1cm4gaGFuZGxlO1xufTtcblxuLyoqXG4gKiAgICAgIGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlXG4gKiAgICAgIGUuZy46IHZhciBoYW5kbGUgPSBFdmVudHMuc3Vic2NyaWJlKFwiUGFnZURpZExvYWRcIiwgaGlnaGxpZ2h0KTtcbiAqICAgICAgICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoaGFuZGxlKTtcbiAqXG4gKiAgICAgIEBjbGFzcyBFdmVudHNcbiAqICAgICAgQG1ldGhvZCB1bnN1YnNjcmliZVxuICogICAgICBAcGFyYW0gaGFuZGxlIHtBcnJheX1cbiAqICAgICAgQHBhcmFtIGNvbXBsZXRlbHkge0Jvb2xlYW49fSAtIFVuc3Vic2NyaWJlIGFsbCBldmVudHMgZm9yIGEgZ2l2ZW4gdG9waWMuXG4gKiAgICAgIEByZXR1cm4gc3VjY2VzcyB7Qm9vbGVhbn1cbiAqL1xuRXZlbnRzLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGUsIGNvbXBsZXRlbHkpXG57XG4gICAgdmFyIHQgPSBoYW5kbGVbMF07XG5cbiAgICBpZiAodGhpcy5fY2FjaGVbdF0pXG4gICAge1xuICAgICAgICB2YXIgdG9waWNBcnJheTtcbiAgICAgICAgdmFyIGluc3RhbmNlSUQgPSBoYW5kbGUubGVuZ3RoID09PSAzID8gaGFuZGxlWzJdIDogJ2dsb2JhbCc7XG5cbiAgICAgICAgdG9waWNBcnJheSA9IHRoaXMuX2NhY2hlW3RdW2luc3RhbmNlSURdO1xuXG4gICAgICAgIGlmICghdG9waWNBcnJheSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBsZXRlbHkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVt0XVtpbnN0YW5jZUlEXTtcbiAgICAgICAgICAgIHJldHVybiB0b3BpY0FycmF5Lmxlbmd0aCA+IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IHRvcGljQXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodG9waWNBcnJheVtpXSA9PT0gaGFuZGxlWzFdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW3RdW2luc3RhbmNlSURdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogICAgICBkaXZhLkV2ZW50cy51bnN1YnNjcmliZUFsbFxuICogICAgICBlLmcuOiBkaXZhLkV2ZW50cy51bnN1YnNjcmliZUFsbCgnZ2xvYmFsJyk7XG4gKlxuICogICAgICBAY2xhc3MgRXZlbnRzXG4gKiAgICAgIEBwYXJhbSBpbnN0YW5jZUlEIHtTdHJpbmc9fSBPcHRpb25hbCAtIGluc3RhbmNlIElEIHRvIHJlbW92ZSBzdWJzY3JpYmVycyBmcm9tIG9yICdnbG9iYWwnIChpZiBvbWl0dGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzIGluIGFsbCBzY29wZXMgcmVtb3ZlZClcbiAqICAgICAgQG1ldGhvZCB1bnN1YnNjcmliZUFsbFxuICovXG5FdmVudHMucHJvdG90eXBlLnVuc3Vic2NyaWJlQWxsID0gZnVuY3Rpb24gKGluc3RhbmNlSUQpXG57XG4gICAgaWYgKGluc3RhbmNlSUQpXG4gICAge1xuICAgICAgICB2YXIgdG9waWNzID0gT2JqZWN0LmtleXModGhpcy5fY2FjaGUpO1xuICAgICAgICB2YXIgaSA9IHRvcGljcy5sZW5ndGg7XG4gICAgICAgIHZhciB0b3BpYztcblxuICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICB7XG4gICAgICAgICAgICB0b3BpYyA9IHRvcGljc1tpXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF0gIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZVt0b3BpY11baW5zdGFuY2VJRF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdXRpbHMvZXZlbnRzLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQG1vZHVsZVxuICogQHByaXZhdGVcbiAqIFRoZSBnbG9iYWwgcGx1Z2luIHJlZ2lzdHJ5LlxuICovXG5cbnZhciBwbHVnaW5zID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAocGx1Z2luKVxuICAgIHtcbiAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgfSxcbiAgICBnZXRBbGw6IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGx1Z2luLXJlZ2lzdHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5EaXZhLkpTIGF1dG9zY3JvbGwgcGx1Z2luXG5BdXRob3I6IEFuZHJldyBIb3J3aXR6XG5cbkxldHMgRGl2YSBzY3JvbGwgaW4gdGhlIHByaW1hcnkgZGlyZWN0aW9uIChhcyBkZXRlcm1pbmVkIGJ5XG5zZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpIGF1dG9tYXRpY2FsbHkgYXQgYSBnaXZlbi9jaGFuZ2VhYmxlIHJhdGUuXG5cblJlbGV2YW50IHNldHRpbmdzOlxuICAgIC1zY3JvbGxTcGVlZDogcGl4ZWxzIHBlciBzZWNvbmQgKGRlZmF1bHRzIHRvIDEwKVxuICAgIC1kaXNhYmxlTWFudWFsU2Nyb2xsOiBkaXNhYmxlcyBtYW51YWwgc2Nyb2xsIHdoaWxlIGF1dG9tYXRpYyBzY3JvbGwgaXMgb24gKGRlZmF1bHRzIHRvIGZhbHNlKVxuICAgIC1jdXJyZW50bHlBdXRvU2Nyb2xsaW5nOiB3aGV0aGVyIG9yIG5vdCBhdXRvc2Nyb2xsIGlzIGN1cnJlbnRseSBvblxuICAgIC1hdXRvU2Nyb2xsUmVmcmVzaDogbXMgYmV0d2VlbiBzY3JvbGxpbmcgYWN0aW9uc1xuICAgIC1kaXNhYmxlQXV0b3Njcm9sbFByZWZzOiBkaXNhYmxlcyB0aGUgYXV0b3Njcm9sbCBwcmVmZXJlbmNlcyBwYW5lbFxuXG5SZWxldmFudCBtZXRob2RzOlxuICAgIC1zdGFydFNjcm9sbGluZywgc3RvcFNjcm9sbGluZywgdG9nZ2xlU2Nyb2xsaW5nXG4gICAgLWNoYW5nZVJlZnJlc2gsIGNoYW5nZVNjcm9sbFNwZWVkIChzZXR0ZXJzIGZvciByZXNwZWN0aXZlIG9wdGlvbnMpXG4gICAgLWRpc2FibGVNYW51YWxTY3JvbGwsIGVuYWJsZU1hbnVhbFNjcm9sbFxuKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwaXhlbHNQZXJTY3JvbGw7XG4gICAgICAgICAgICAgICAgdmFyIGRpc2FibGVNYW51YWxTY3JvbGw7XG4gICAgICAgICAgICAgICAgdmFyIGF1dG9TY3JvbGxSZWZyZXNoO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0QXV0b1JlZnJlc2g7XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNwZWVkO1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbG9nMTAoeClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGgubG9nKDEwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2Uuc3RhcnRTY3JvbGxpbmcgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIllvdSBhcmUgdHJ5aW5nIHRvIHN0YXJ0IGF1dG9zY3JvbGxpbmcsIGJ1dCBpdCBpcyBhbHJlYWR5IHNjcm9sbGluZy5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXRvZ2dsZVwiKS50ZXh0KFwiVHVybiBvZmZcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlTWFudWFsU2Nyb2xsKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdGFydFNjcm9sbGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciByZXN0YXJ0U2Nyb2xsaW5nSW50ZXJ2YWwgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbFRvcChkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Quc2Nyb2xsVG9wKCkgKyBwaXhlbHNQZXJTY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYXV0b1Njcm9sbFJlZnJlc2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoKSArIHBpeGVsc1BlclNjcm9sbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBhdXRvU2Nyb2xsUmVmcmVzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0b3BTY3JvbGxpbmcgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgYXJlIHRyeWluZyB0byBzdG9wIGF1dG9zY3JvbGxpbmcsIGJ1dCBpdCBpcyBub3QgY3VycmVudGx5IGFjdGl2ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXRvZ2dsZVwiKS50ZXh0KFwiVHVybiBvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc2FibGVNYW51YWxTY3JvbGwpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UudG9nZ2xlU2Nyb2xsaW5nID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdmFTZXR0aW5ncy5jdXJyZW50bHlBdXRvU2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0b3BTY3JvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnN0YXJ0U2Nyb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5jaGFuZ2VSZWZyZXNoID0gZnVuY3Rpb24obmV3UmVmcmVzaClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gbmV3UmVmcmVzaDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGl4ZWxzUGVyU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5jaGFuZ2VTY3JvbGxTcGVlZCA9IGZ1bmN0aW9uKG5ld1NwZWVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsU3BlZWQgPSBuZXdTcGVlZDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGl4ZWxzUGVyU2Nyb2xsKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1wcHNcIikudmFsKGxvZzEwKHNjcm9sbFNwZWVkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdGFydFNjcm9sbGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZVBpeGVsc1BlclNjcm9sbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gZGVmYXVsdEF1dG9SZWZyZXNoO1xuICAgICAgICAgICAgICAgICAgICBwaXhlbHNQZXJTY3JvbGwgPSBzY3JvbGxTcGVlZCAvICgxMDAwIC8gYXV0b1Njcm9sbFJlZnJlc2gpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vc2hvdWxkIGJlIG1pbmltdW0gb2Ygb25lIG90aGVyd2lzZSBpdCB3b24ndCBjaGFuZ2UgdGhlIGFjdHVhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAvL3VzZXIgY2FuIGNoYW5nZSBhdXRvc2Nyb2xscmVmcmVzaCBvciBzY3JvbGxzcGVlZDsgdGhpcyBtYXkgb3ZlcndyaXRlIGF1dG9TY3JvbGxSZWZyZXNoXG4gICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbHNQZXJTY3JvbGwgPCAxKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2Nyb2xsUmVmcmVzaCA9IGF1dG9TY3JvbGxSZWZyZXNoICogKDEgLyBwaXhlbHNQZXJTY3JvbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzUGVyU2Nyb2xsID0gc2Nyb2xsU3BlZWQgLyAoMTAwMCAvIGF1dG9TY3JvbGxSZWZyZXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZU1hbnVhbFNjcm9sbCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpc2FibGVNYW51YWxTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmN1cnJlbnRseUF1dG9TY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5lbmFibGVNYW51YWxTY3JvbGwgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlTWFudWFsU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmVuYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuY3VycmVudGx5QXV0b1Njcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5hdXRvU2Nyb2xsSW50ZXJ2YWwgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgZGlzYWJsZU1hbnVhbFNjcm9sbCA9IGRpdmFTZXR0aW5ncy5kaXNhYmxlTWFudWFsU2Nyb2xsIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIGF1dG9TY3JvbGxSZWZyZXNoID0gZGl2YVNldHRpbmdzLmF1dG9TY3JvbGxSZWZyZXNoIHx8IDUwO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRBdXRvUmVmcmVzaCA9IGF1dG9TY3JvbGxSZWZyZXNoO1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVNjcm9sbFNwZWVkKChkaXZhU2V0dGluZ3Muc2Nyb2xsU3BlZWQgfHwgMTApKTtcblxuICAgICAgICAgICAgICAgICQod2luZG93KS5vbigna2V5dXAnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSAzMilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLnRvZ2dsZVNjcm9sbGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRpdmFTZXR0aW5ncy5kaXNhYmxlQXV0b3Njcm9sbFByZWZzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldFBvc2l0aW9uID0gZnVuY3Rpb24oaXNGdWxsc2NyZWVuKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVsbHNjcmVlblRvb2xzID0gJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAndG9vbHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9vbHNNYXJnaW4gPSBmdWxsc2NyZWVuVG9vbHMuY3NzKCdyaWdodCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyaWdodCc6IHRvb2xzTWFyZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0JzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RvcCc6IGZ1bGxzY3JlZW5Ub29scy5vZmZzZXQoKS50b3AgKyBmdWxsc2NyZWVuVG9vbHMub3V0ZXJIZWlnaHQoKSArIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3JpZ2h0JzogJCh3aW5kb3cpLndpZHRoKCkgLSAoZGl2YVNldHRpbmdzLnZpZXdwb3J0T2JqZWN0Lm9mZnNldCgpLmxlZnQgKyBkaXZhU2V0dGluZ3Mudmlld3BvcnRPYmplY3Qub3V0ZXJXaWR0aCgpKSArIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6ICcuNmVtJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLm9mZnNldCh7J3RvcCc6IGRpdmFTZXR0aW5ncy52aWV3cG9ydE9iamVjdC5vZmZzZXQoKS50b3AgKyAxfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdNb2RlRGlkU3dpdGNoJywgc2V0UG9zaXRpb24sIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRMb2FkJywgZnVuY3Rpb24ocylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9zY3JvbGxQcmVmc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIjxkaXYgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXByZWZzJyBjbGFzcz0nZGl2YS1hdXRvc2Nyb2xsLXByZWZzIGRpdmEtcG9wdXAnPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxiPkF1dG9zY3JvbGxpbmcgb3B0aW9uczo8L2I+PGJyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdGV4dCc+U3BlZWQ6PC9zcGFuPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxpbnB1dCB0eXBlPSdyYW5nZScgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLXBwcycgY2xhc3M9J2RpdmEtYXV0b3Njcm9sbC1wcHMgZGl2YS1hdXRvc2Nyb2xsLXByZWZzLWlucHV0JyB2YWx1ZT0nXCIgKyBsb2cxMChzY3JvbGxTcGVlZCkgKyBcIicgbWluPScwJyBtYXg9JzMnIHN0ZXA9JzAuMSc+PGJyPlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjxzcGFuIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdGV4dCc+QWxsb3cgbWFudWFsIHNjcm9sbDo8L3NwYW4+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiPGlucHV0IHR5cGU9J2NoZWNrYm94JyBpZD0nXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtbWFudWFsJyBjbGFzcz0nZGl2YS1hdXRvc2Nyb2xsLW1hbnVhbCBkaXZhLWF1dG9zY3JvbGwtcHJlZnMtaW5wdXQnIGNoZWNrZWQ9J2NoZWNrZWQnPjxicj5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI8YnV0dG9uIGlkPSdcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC10b2dnbGUnIGNsYXNzPSdkaXZhLWF1dG9zY3JvbGwtcHJlZnMtdG9nZ2xlIGRpdmEtYXV0b3Njcm9sbC1wcmVmcy1pbnB1dCc+IFR1cm4gb24gPC9idXR0b24+XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCI8L2Rpdj5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcInBhZ2UtbmF2XCIpLmJlZm9yZShcIjxkaXYgaWQ9J1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLWljb24nIGNsYXNzPSdkaXZhLWJ1dHRvbiBkaXZhLWF1dG9zY3JvbGwtaWNvbicgdGl0bGU9J0V4cGFuZCBhdXRvc2Nyb2xsIG9wdGlvbnMnPjwvZGl2PlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCJib2R5XCIpLnByZXBlbmQoYXV0b3Njcm9sbFByZWZzU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJChcIiNcIiArIGRpdmFTZXR0aW5ncy5JRCArIFwiYXV0b3Njcm9sbC1wcHNcIikub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmNoYW5nZVNjcm9sbFNwZWVkKE1hdGgucG93KDEwLCBlLnRhcmdldC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtbWFudWFsXCIpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnRhcmdldC5jaGVja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZW5hYmxlTWFudWFsU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZU1hbnVhbFNjcm9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtdG9nZ2xlXCIpLm9uKCdjbGljaycsIGRpdmFJbnN0YW5jZS50b2dnbGVTY3JvbGxpbmcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkKFwiI1wiICsgZGl2YVNldHRpbmdzLklEICsgXCJhdXRvc2Nyb2xsLWljb25cIikub24oJ2NsaWNrJywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5qcU9iaiA9ICQoXCIjXCIgKyBkaXZhU2V0dGluZ3MuSUQgKyBcImF1dG9zY3JvbGwtcHJlZnNcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuanFPYmouY3NzKCdkaXNwbGF5JykgPT09ICdub25lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmpxT2JqLmNzcyh7J2Rpc3BsYXknOiAnYmxvY2snfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UG9zaXRpb24oZGl2YVNldHRpbmdzLmluRnVsbHNjcmVlbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuanFPYmouY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZGl2YVNldHRpbmdzLklEKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ2F1dG9zY3JvbGwnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnQXV0b21hdGljYWxseSBzY3JvbGxzIHBhZ2UgYWxvbmcgcHJpbWFyeSBheGlzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGx1Z2lucy9hdXRvc2Nyb2xsLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5Db3B5cmlnaHQgKEMpIDIwMTEtMjAxNiBieSBXZW5keSBMaXUsIEV2YW4gTWFnb25pLCBBbmRyZXcgSGFua2luc29uLCBBbmRyZXcgSG9yd2l0eiwgTGF1cmVudCBQdWdpblxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xucmVxdWlyZSgnYXJyYXkucHJvdG90eXBlLmZpbGwnKTtcblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcbnZhciBIYXNoUGFyYW1zID0gcmVxdWlyZSgnLi91dGlscy9oYXNoLXBhcmFtcycpO1xuXG52YXIgQWN0aXZlRGl2YUNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2FjdGl2ZS1kaXZhLWNvbnRyb2xsZXInKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xudmFyIEltYWdlTWFuaWZlc3QgPSByZXF1aXJlKCcuL2ltYWdlLW1hbmlmZXN0Jyk7XG52YXIgY3JlYXRlVG9vbGJhciA9IHJlcXVpcmUoJy4vdG9vbGJhcicpO1xudmFyIFZpZXdlckNvcmUgPSByZXF1aXJlKCcuL3ZpZXdlci1jb3JlJyk7XG5cbi8vIFN0YXJ0IHRoZSBhY3RpdmUgRGl2YSB0cmFja2VyXG52YXIgYWN0aXZlRGl2YSA9IG5ldyBBY3RpdmVEaXZhQ29udHJvbGxlcigpOyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG5cbm1vZHVsZS5leHBvcnRzID0gZGl2YTtcblxuLy8gdGhpcyBwYXR0ZXJuIHdhcyB0YWtlbiBmcm9tIGh0dHA6Ly93d3cudmlyZ2VudGVjaC5jb20vYmxvZy8yMDA5LzEwL2J1aWxkaW5nLW9iamVjdC1vcmllbnRlZC1qcXVlcnktcGx1Z2luLmh0bWxcbihmdW5jdGlvbiAoJClcbntcbiAgICB2YXIgRGl2YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgLy8gR2xvYmFsIGluc3RhbmNlIHZhcmlhYmxlcyAoc2V0IHdheSBkb3duIGluIGBpbml0YClcbiAgICAgICAgdmFyIHNldHRpbmdzLCB2aWV3ZXJTdGF0ZSwgZGl2YVN0YXRlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgLy8gVGhlc2UgYXJlIGVsZW1lbnRzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gdXBvbiBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL1NldHRpbmdzIGZvciBtb3JlIGRldGFpbHNcbiAgICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgIGFkYXB0aXZlUGFkZGluZzogMC4wNSwgICAgICAvLyBUaGUgcmF0aW8gb2YgcGFkZGluZyB0byB0aGUgcGFnZSBkaW1lbnNpb25cbiAgICAgICAgICAgIGFycm93U2Nyb2xsQW1vdW50OiA0MCwgICAgICAvLyBUaGUgYW1vdW50IChpbiBwaXhlbHMpIHRvIHNjcm9sbCBieSB3aGVuIHVzaW5nIGFycm93IGtleXNcbiAgICAgICAgICAgIGJsb2NrTW9iaWxlTW92ZTogZmFsc2UsICAgICAvLyBQcmV2ZW50IG1vdmluZyBvciBzY3JvbGxpbmcgdGhlIHBhZ2Ugb24gbW9iaWxlIGRldmljZXNcbiAgICAgICAgICAgIG9iamVjdERhdGE6ICcnLCAgICAgICAgICAgICAvLyBBIElJSUYgTWFuaWZlc3Qgb3IgYSBKU09OIGZpbGUgZ2VuZXJhdGVkIGJ5IHByb2Nlc3MucHkgdGhhdCBwcm92aWRlcyB0aGUgb2JqZWN0IGRpbWVuc2lvbiBkYXRhLCBvciBhIFVSTCBwb2ludGluZyB0byBzdWNoIGRhdGEgLSAqUkVRVUlSRUQqXG4gICAgICAgICAgICBlbmFibGVBdXRvVGl0bGU6IHRydWUsICAgICAgLy8gU2hvd3MgdGhlIHRpdGxlIHdpdGhpbiBhIGRpdiBvZiBpZCBkaXZhLXRpdGxlXG4gICAgICAgICAgICBlbmFibGVGaWxlbmFtZTogdHJ1ZSwgICAgICAgLy8gVXNlcyBmaWxlbmFtZXMgYW5kIG5vdCBwYWdlIG51bWJlcnMgZm9yIGxpbmtzIChpPWJtXzAwMS50aWYsIG5vdCBwPTEpXG4gICAgICAgICAgICBlbmFibGVGdWxsc2NyZWVuOiB0cnVlLCAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZnVsbHNjcmVlbiBpY29uIChtb2RlIHN0aWxsIGF2YWlsYWJsZSlcbiAgICAgICAgICAgIGVuYWJsZUdvdG9QYWdlOiB0cnVlLCAgICAgICAvLyBBIFwiZ28gdG8gcGFnZVwiIGp1bXAgYm94XG4gICAgICAgICAgICBlbmFibGVHb3RvU3VnZ2VzdGlvbnM6IHRydWUsIC8vIENvbnRyb2xzIHdoZXRoZXIgc3VnZ2VzdGlvbnMgYXJlIHNob3duIHVuZGVyIHRoZSBpbnB1dCBmaWVsZCB3aGVuIHRoZSB1c2VyIGlzIHR5cGluZyBpbiB0aGUgJ2dvIHRvIHBhZ2UnIGZvcm1cbiAgICAgICAgICAgIGVuYWJsZUdyaWRJY29uOiB0cnVlLCAgICAgICAvLyBBIGdyaWQgdmlldyBvZiBhbGwgdGhlIHBhZ2VzXG4gICAgICAgICAgICBlbmFibGVHcmlkQ29udHJvbHM6ICdidXR0b25zJywgIC8vIFNwZWNpZnkgY29udHJvbCBvZiBwYWdlcyBwZXIgZ3JpZCByb3cgaW4gR3JpZCB2aWV3LiBQb3NzaWJsZSB2YWx1ZXM6ICdidXR0b25zJyAoKy8tKSwgJ3NsaWRlcicuIEFueSBvdGhlciB2YWx1ZSBkaXNhYmxlcyB0aGUgY29udHJvbHMuXG4gICAgICAgICAgICBlbmFibGVJbWFnZVRpdGxlczogdHJ1ZSwgICAgLy8gQWRkcyBcIlBhZ2Uge259XCIgdGl0bGUgdG8gcGFnZSBpbWFnZXMgaWYgdHJ1ZVxuICAgICAgICAgICAgZW5hYmxlS2V5U2Nyb2xsOiB0cnVlLCAgICAgIC8vIENhcHR1cmVzIHNjcm9sbGluZyB1c2luZyB0aGUgYXJyb3cgYW5kIHBhZ2UgdXAvZG93biBrZXlzIHJlZ2FyZGxlc3Mgb2YgcGFnZSBmb2N1cy4gV2hlbiBvZmYsIGRlZmVycyB0byBkZWZhdWx0IGJyb3dzZXIgc2Nyb2xsaW5nIGJlaGF2aW9yLlxuICAgICAgICAgICAgZW5hYmxlTGlua0ljb246IHRydWUsICAgICAgIC8vIENvbnRyb2xzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBsaW5rIGljb25cbiAgICAgICAgICAgIGVuYWJsZU5vblBhZ2VkVmlzaWJpbGl0eUljb246IHRydWUsIC8vIENvbnRyb2xzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBpY29uIHRvIHRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiBub24tcGFnZWQgcGFnZXMuIChBdXRvbWF0aWNhbGx5IGhpZGRlbiBpZiBubyAnbm9uLXBhZ2VkJyBwYWdlcykuXG4gICAgICAgICAgICBlbmFibGVTcGFjZVNjcm9sbDogZmFsc2UsICAgLy8gU2Nyb2xsaW5nIGRvd24gYnkgcHJlc3NpbmcgdGhlIHNwYWNlIGtleVxuICAgICAgICAgICAgZW5hYmxlVG9vbGJhcjogdHJ1ZSwgICAgICAgIC8vIEVuYWJsZXMgdGhlIHRvb2xiYXIuIE5vdGUgdGhhdCBkaXNhYmxpbmcgdGhpcyBtZWFucyB5b3UgaGF2ZSB0byBoYW5kbGUgYWxsIGNvbnRyb2xzIHlvdXJzZWxmLlxuICAgICAgICAgICAgZW5hYmxlWm9vbUNvbnRyb2xzOiAnYnV0dG9ucycsIC8vIFNwZWNpZnkgY29udHJvbHMgZm9yIHpvb21pbmcgaW4gYW5kIG91dC4gUG9zc2libGUgdmFsdWVzOiAnYnV0dG9ucycgKCsvLSksICdzbGlkZXInLiBBbnkgb3RoZXIgdmFsdWUgZGlzYWJsZXMgdGhlIGNvbnRyb2xzLlxuICAgICAgICAgICAgZmlsbFBhcmVudEhlaWdodDogdHJ1ZSwgICAgIC8vIFVzZSBhIGZsZXhib3ggbGF5b3V0IHRvIGFsbG93IERpdmEgdG8gZmlsbCBpdHMgcGFyZW50J3MgaGVpZ2h0XG4gICAgICAgICAgICBmaXhlZFBhZGRpbmc6IDEwLCAgICAgICAgICAgLy8gRmFsbGJhY2sgaWYgYWRhcHRpdmUgcGFkZGluZyBpcyBzZXQgdG8gMFxuICAgICAgICAgICAgZml4ZWRIZWlnaHRHcmlkOiB0cnVlLCAgICAgIC8vIFNvIGVhY2ggcGFnZSBpbiBncmlkIHZpZXcgaGFzIHRoZSBzYW1lIGhlaWdodCAob25seSB3aWR0aHMgZGlmZmVyKVxuICAgICAgICAgICAgZ29EaXJlY3RseVRvOiAwLCAgICAgICAgICAgIC8vIERlZmF1bHQgaW5pdGlhbCBwYWdlIHRvIHNob3cgKDAtaW5kZXhlZClcbiAgICAgICAgICAgIGhhc2hQYXJhbVN1ZmZpeDogbnVsbCwgICAgICAvLyBVc2VkIHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGRvY3VtZW50IHZpZXdlcnMgb24gYSBwYWdlXG4gICAgICAgICAgICBpaXBTZXJ2ZXJVUkw6ICcnLCAgICAgICAgICAgLy8gVGhlIFVSTCB0byB0aGUgSUlQSW1hZ2UgaW5zdGFsbGF0aW9uLCBpbmNsdWRpbmcgdGhlIGA/RklGPWAgLSAqUkVRVUlSRUQqLCB1bmxlc3MgdXNpbmcgSUlJRlxuICAgICAgICAgICAgaW5GdWxsc2NyZWVuOiBmYWxzZSwgICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGxvYWQgZnVsbHNjcmVlbiBtb2RlIGluaXRpYWxseVxuICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiBmYWxzZSwgICAgICAgLy8gU2V0IHRvIHRydWUgdG8gdmlldyB0aGUgZG9jdW1lbnQgd2l0aCBmYWNpbmcgcGFnZXMgaW4gZG9jdW1lbnQgbW9kZVxuICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSwgICAgICAgICAgICAgIC8vIFNldCB0byB0cnVlIHRvIGxvYWQgZ3JpZCB2aWV3IGluaXRpYWxseVxuICAgICAgICAgICAgaW1hZ2VEaXI6ICcnLCAgICAgICAgICAgICAgIC8vIEltYWdlIGRpcmVjdG9yeSwgZWl0aGVyIGFic29sdXRlIHBhdGggb3IgcmVsYXRpdmUgdG8gSUlQJ3MgRklMRVNZU1RFTV9QUkVGSVggLSAqUkVRVUlSRUQqLCB1bmxlc3MgdXNpbmcgSUlJRlxuICAgICAgICAgICAgbWF4UGFnZXNQZXJSb3c6IDgsICAgICAgICAgIC8vIE1heGltdW0gbnVtYmVyIG9mIHBhZ2VzIHBlciByb3cgaW4gZ3JpZCB2aWV3XG4gICAgICAgICAgICBtYXhab29tTGV2ZWw6IC0xLCAgICAgICAgICAgLy8gT3B0aW9uYWw7IGRlZmF1bHRzIHRvIHRoZSBtYXggem9vbSByZXR1cm5lZCBpbiB0aGUgSlNPTiByZXNwb25zZVxuICAgICAgICAgICAgbWluUGFnZXNQZXJSb3c6IDIsICAgICAgICAgIC8vIE1pbmltdW0gcGFnZXMgcGVyIHJvdyBpbiBncmlkIHZpZXcuIFJlY29tbWVuZGVkIGRlZmF1bHQuXG4gICAgICAgICAgICBtaW5ab29tTGV2ZWw6IDAsICAgICAgICAgICAgLy8gRGVmYXVsdHMgdG8gMCAodGhlIG1pbmltdW0gem9vbSlcbiAgICAgICAgICAgIG9uR290b1N1Ym1pdDogbnVsbCwgICAgICAgICAvLyBXaGVuIHNldCB0byBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBzdHJpbmcgYW5kIHJldHVybnMgYSBwYWdlIGluZGV4LCB0aGlzIHdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIHRoZSAnZ28gdG8gcGFnZScgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAgICBwYWdlQWxpYXNlczoge30sICAgICAgICAgICAgLy8gQW4gb2JqZWN0IG1hcHBpbmcgc3BlY2lmaWMgcGFnZSBpbmRpY2VzIHRvIGFsaWFzZXMgKGhhcyBwcmlvcml0eSBvdmVyICdwYWdlQWxpYXNGdW5jdGlvbidcbiAgICAgICAgICAgIHBhZ2VBbGlhc0Z1bmN0aW9uOiBmdW5jdGlvbigpe3JldHVybiBmYWxzZTt9LCAgLy8gQSBmdW5jdGlvbiBtYXBwaW5nIHBhZ2UgaW5kaWNlcyB0byBhbiBhbGlhcy4gSWYgZmFsc2UgaXMgcmV0dXJuZWQsIGRlZmF1bHQgcGFnZSBudW1iZXIgaXMgZGlzcGxheWVkXG4gICAgICAgICAgICBwYWdlTG9hZFRpbWVvdXQ6IDIwMCwgICAgICAgLy8gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBsb2FkaW5nIHBhZ2VzXG4gICAgICAgICAgICBwYWdlc1BlclJvdzogNSwgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgbnVtYmVyIG9mIHBhZ2VzIHBlciByb3cgaW4gZ3JpZCB2aWV3XG4gICAgICAgICAgICBzaG93Tm9uUGFnZWRQYWdlczogZmFsc2UsICAgLy8gV2hldGhlciBwYWdlcyB0YWdnZWQgYXMgJ25vbi1wYWdlZCcgKGluIElJSUYgbWFuaWZlc3RzIG9ubHkpIHNob3VsZCBiZSB2aXNpYmxlIGFmdGVyIGluaXRpYWwgbG9hZFxuICAgICAgICAgICAgdGhyb2JiZXJUaW1lb3V0OiAxMDAsICAgICAgIC8vIE51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgc2hvd2luZyB0aHJvYmJlclxuICAgICAgICAgICAgdGlsZUhlaWdodDogMjU2LCAgICAgICAgICAgIC8vIFRoZSBoZWlnaHQgb2YgZWFjaCB0aWxlLCBpbiBwaXhlbHM7IHVzdWFsbHkgMjU2XG4gICAgICAgICAgICB0aWxlV2lkdGg6IDI1NiwgICAgICAgICAgICAgLy8gVGhlIHdpZHRoIG9mIGVhY2ggdGlsZSwgaW4gcGl4ZWxzOyB1c3VhbGx5IDI1NlxuICAgICAgICAgICAgdG9vbGJhclBhcmVudE9iamVjdDogbnVsbCwgIC8vIFRoZSB0b29sYmFyIHBhcmVudCBvYmplY3QuXG4gICAgICAgICAgICB2ZXJ0aWNhbGx5T3JpZW50ZWQ6IHRydWUsICAgLy8gRGV0ZXJtaW5lcyB2ZXJ0aWNhbCB2cy4gaG9yaXpvbnRhbCBvcmllbnRhdGlvblxuICAgICAgICAgICAgdmlld3BvcnRNYXJnaW46IDIwMCwgICAgICAgIC8vIFByZXRlbmQgdGlsZXMgKy8tIDIwMHB4IGF3YXkgZnJvbSB2aWV3cG9ydCBhcmUgaW5cbiAgICAgICAgICAgIHpvb21MZXZlbDogMiAgICAgICAgICAgICAgICAvLyBUaGUgaW5pdGlhbCB6b29tIGxldmVsICh1c2VkIHRvIHN0b3JlIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwpXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIHBhZ2UgaW5kZXggYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBmaWxlbmFtZTsgbXVzdCBjYWxsZWQgYWZ0ZXIgc2V0dGluZyBzZXR0aW5ncy5tYW5pZmVzdFxuICAgICAgICB2YXIgZ2V0UGFnZUluZGV4ID0gZnVuY3Rpb24gKGZpbGVuYW1lKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGFnZUluZGV4Rm9yTWFuaWZlc3Qoc2V0dGluZ3MubWFuaWZlc3QsIGZpbGVuYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgTm90QW5JSUlGTWFuaWZlc3RFeGNlcHRpb24gPSBmdW5jdGlvbiAobWVzc2FnZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFBhZ2VJbmRleEZvck1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBmaWxlbmFtZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgbnAgPSBtYW5pZmVzdC5wYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBucDsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghbWFuaWZlc3QucGFnZXNbaV0pXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG1hbmlmZXN0LnBhZ2VzW2ldLmYgPT09IGZpbGVuYW1lKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBwYWdlIGluZGV4IGlzIHZhbGlkXG4gICAgICAgIHZhciBpc1BhZ2VWYWxpZCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5pc1BhZ2VWYWxpZChwYWdlSW5kZXgsIHNldHRpbmdzLnNob3dOb25QYWdlZFBhZ2VzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVsb2FkVmlld2VyID0gZnVuY3Rpb24gKG5ld09wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZhU3RhdGUudmlld2VyQ29yZS5yZWxvYWQobmV3T3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGNoYW5nZSB2aWV3IGljb24gaXMgY2xpY2tlZFxuICAgICAgICB2YXIgY2hhbmdlVmlldyA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvblZpZXcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZGVzdGluYXRpb25WaWV3KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5Cb29rTGF5b3V0OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2snOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdncmlkJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy90b2dnbGVzIGJldHdlZW4gb3JpZW50YXRpb25zXG4gICAgICAgIHZhciB0b2dnbGVPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbGx5T3JpZW50ZWQgPSAhc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkO1xuXG4gICAgICAgICAgICAvL2lmIGluIGdyaWQsIHN3aXRjaCBvdXQgb2YgZ3JpZFxuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsbHlPcmllbnRlZDogdmVydGljYWxseU9yaWVudGVkLFxuICAgICAgICAgICAgICAgIGdvRGlyZWN0bHlUbzogc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WU9mZnNldCgpLFxuICAgICAgICAgICAgICAgIGhvcml6b250YWxPZmZzZXQ6IGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmdldFhPZmZzZXQoKVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2ZXJ0aWNhbGx5T3JpZW50ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbGVkIHdoZW4gdGhlIGZ1bGxzY3JlZW4gaWNvbiBpcyBjbGlja2VkXG4gICAgICAgIHZhciB0b2dnbGVGdWxsc2NyZWVuID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICBpbkZ1bGxzY3JlZW46ICFzZXR0aW5ncy5pbkZ1bGxzY3JlZW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2aWV3O1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXcgPSAnZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlldyA9ICdiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3ID0gJ2QnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgICAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQoc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCwgdmlld2VyU3RhdGUudmlld3BvcnQpO1xuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgJ2YnOiBzZXR0aW5ncy5pbkZ1bGxzY3JlZW4sXG4gICAgICAgICAgICAgICAgJ3YnOiB2aWV3LFxuICAgICAgICAgICAgICAgICd6Jzogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgICduJzogc2V0dGluZ3MucGFnZXNQZXJSb3csXG4gICAgICAgICAgICAgICAgJ2knOiBzZXR0aW5ncy5lbmFibGVGaWxlbmFtZSA/IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3NldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhdLmYgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAncCc6IHNldHRpbmdzLmVuYWJsZUZpbGVuYW1lID8gZmFsc2UgOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICAneSc6IHBhZ2VPZmZzZXQgPyBwYWdlT2Zmc2V0LnkgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAneCc6IHBhZ2VPZmZzZXQgPyBwYWdlT2Zmc2V0LnggOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRMb2FkT3B0aW9uc0ZvclN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBtYW5pZmVzdClcbiAgICAgICAge1xuICAgICAgICAgICAgbWFuaWZlc3QgPSBtYW5pZmVzdCB8fCBzZXR0aW5ncy5tYW5pZmVzdDtcblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSAoJ3YnIGluIHN0YXRlKSA/IGdldFZpZXdTdGF0ZShzdGF0ZS52KSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoJ2YnIGluIHN0YXRlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5GdWxsc2NyZWVuID0gc3RhdGUuZjtcblxuICAgICAgICAgICAgaWYgKCd6JyBpbiBzdGF0ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLnpvb21MZXZlbCA9IHN0YXRlLno7XG5cbiAgICAgICAgICAgIGlmICgnbicgaW4gc3RhdGUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wYWdlc1BlclJvdyA9IHN0YXRlLm47XG5cbiAgICAgICAgICAgIC8vIE9ubHkgY2hhbmdlIHNwZWNpZnkgdGhlIHBhZ2UgaWYgc3RhdGUuaSBvciBzdGF0ZS5wIGlzIHZhbGlkXG4gICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gZ2V0UGFnZUluZGV4Rm9yTWFuaWZlc3QobWFuaWZlc3QsIHN0YXRlLmkpO1xuXG4gICAgICAgICAgICBpZiAoIShwYWdlSW5kZXggPj0gMCAmJiBwYWdlSW5kZXggPCBtYW5pZmVzdC5wYWdlcy5sZW5ndGgpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhZ2VJbmRleCA9IHN0YXRlLnAgLSAxO1xuXG4gICAgICAgICAgICAgICAgLy8gUG9zc2libHkgTmFOXG4gICAgICAgICAgICAgICAgaWYgKCEocGFnZUluZGV4ID49IDAgJiYgcGFnZUluZGV4IDwgbWFuaWZlc3QucGFnZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgcGFnZUluZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhZ2VJbmRleCAhPT0gbnVsbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9yaXpvbnRhbE9mZnNldCA9IHBhcnNlSW50KHN0YXRlLngsIDEwKTtcbiAgICAgICAgICAgICAgICB2YXIgdmVydGljYWxPZmZzZXQgPSBwYXJzZUludChzdGF0ZS55LCAxMCk7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zLmdvRGlyZWN0bHlUbyA9IHBhZ2VJbmRleDtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhvcml6b250YWxPZmZzZXQgPSBob3Jpem9udGFsT2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmVydGljYWxPZmZzZXQgPSB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFVSTEhhc2ggPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaGFzaFBhcmFtcyA9IGdldFN0YXRlKCk7XG4gICAgICAgICAgICB2YXIgaGFzaFN0cmluZ0J1aWxkZXIgPSBbXTtcbiAgICAgICAgICAgIHZhciBwYXJhbTtcblxuICAgICAgICAgICAgZm9yIChwYXJhbSBpbiBoYXNoUGFyYW1zKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChoYXNoUGFyYW1zW3BhcmFtXSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGhhc2hTdHJpbmdCdWlsZGVyLnB1c2gocGFyYW0gKyBzZXR0aW5ncy5oYXNoUGFyYW1TdWZmaXggKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoaGFzaFBhcmFtc1twYXJhbV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhc2hTdHJpbmdCdWlsZGVyLmpvaW4oJyYnKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBVUkwgdG8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGRvY3VtZW50IHZpZXdlciAoc28gaXQgc2hvdWxkIGJlIGFuIGV4YWN0IHJlcGxpY2EpXG4gICAgICAgIHZhciBnZXRDdXJyZW50VVJMID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArICcjJyArIGdldFVSTEhhc2goKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZ2V0Vmlld1N0YXRlID0gZnVuY3Rpb24odmlldylcbiAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoICh2aWV3KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQm9va0xheW91dDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5HcmlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQm9va0xheW91dDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkdyaWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbkJvb2tMYXlvdXQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2hvd0Vycm9yID0gZnVuY3Rpb24obWVzc2FnZSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnZpZXdlckNvcmUuc2hvd0Vycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhamF4RXJyb3IgPSBmdW5jdGlvbihqcXhociwgc3RhdHVzLCBlcnJvcilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gU2hvdyBhIGJhc2ljIGVycm9yIG1lc3NhZ2Ugd2l0aGluIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuXG4gICAgICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gWydJbnZhbGlkIG9iamVjdERhdGEgc2V0dGluZy4gRXJyb3IgY29kZTogJyArIGpxeGhyLnN0YXR1cyArICcgJyArIGVycm9yXTtcblxuICAgICAgICAgICAgLy8gRGV0ZWN0IGFuZCBoYW5kbGUgQ09SUyBlcnJvcnNcbiAgICAgICAgICAgIHZhciBkYXRhSGFzQWJzb2x1dGVQYXRoID0gc2V0dGluZ3Mub2JqZWN0RGF0YS5sYXN0SW5kZXhPZignaHR0cCcsIDApID09PSAwO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUhhc0Fic29sdXRlUGF0aCAmJiBlcnJvciA9PT0gJycpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGpzb25Ib3N0ID0gc2V0dGluZ3Mub2JqZWN0RGF0YS5yZXBsYWNlKC9odHRwcz86XFwvXFwvL2ksIFwiXCIpLnNwbGl0KC9bLz8jXS8pWzBdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uLmhvc3RuYW1lICE9PSBqc29uSG9zdClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZS5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgZWx0KCdwJywgJ0F0dGVtcHRlZCB0byBhY2Nlc3MgY3Jvc3Mtb3JpZ2luIGRhdGEgd2l0aG91dCBDT1JTLicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWx0KCdwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWW91IG1heSBuZWVkIHRvIHVwZGF0ZSB5b3VyIHNlcnZlciBjb25maWd1cmF0aW9uIHRvIHN1cHBvcnQgQ09SUy4gRm9yIGhlbHAsIHNlZSB0aGUgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHQoJ2EnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICdodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL0luc3RhbGxhdGlvbiNhLW5vdGUtYWJvdXQtY3Jvc3Mtc2l0ZS1yZXF1ZXN0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19ibGFuaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAnY3Jvc3Mtc2l0ZSByZXF1ZXN0IGRvY3VtZW50YXRpb24uJylcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNob3dFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb2FkT2JqZWN0RGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZURhdGEsIGhhc2hTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG1hbmlmZXN0O1xuXG4gICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgSUlJRiBkZXRlY3Rpb24gbWV0aG9kXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlRGF0YS5oYXNPd25Qcm9wZXJ0eSgnQGNvbnRleHQnKSAmJiAocmVzcG9uc2VEYXRhWydAY29udGV4dCddLmluZGV4T2YoJ2lpaWYnKSA9PT0gLTEgfHwgcmVzcG9uc2VEYXRhWydAY29udGV4dCddLmluZGV4T2YoJ3NoYXJlZC1jYW52YXMnKSA9PT0gLTEpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RBbklJSUZNYW5pZmVzdEV4Y2VwdGlvbignVGhpcyBkb2VzIG5vdCBhcHBlYXIgdG8gYmUgYSBJSUlGIE1hbmlmZXN0LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIE1hbmlmZXN0RGlkTG9hZCBldmVudFxuICAgICAgICAgICAgLy8gRklYTUU6IFdoeSBpcyB0aGlzIHRyaWdnZXJlZCBiZWZvcmUgdGhlIG1hbmlmZXN0IGlzIHBhcnNlZD8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ERE1BTC9kaXZhLmpzL2lzc3Vlcy8zNTdcbiAgICAgICAgICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2goJ01hbmlmZXN0RGlkTG9hZCcsIFtyZXNwb25zZURhdGFdLCBzZWxmKTtcblxuICAgICAgICAgICAgbWFuaWZlc3QgPSBJbWFnZU1hbmlmZXN0LmZyb21JSUlGKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICB2YXIgbG9hZE9wdGlvbnMgPSBoYXNoU3RhdGUgPyBnZXRMb2FkT3B0aW9uc0ZvclN0YXRlKGhhc2hTdGF0ZSwgbWFuaWZlc3QpIDoge307XG5cbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnNldE1hbmlmZXN0KG1hbmlmZXN0LCBsb2FkT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqIFBhcnNlIHRoZSBoYXNoIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IHVzZWQgYnkgZ2V0U3RhdGUgYW5kIHNldFN0YXRlICovXG4gICAgICAgIHZhciBnZXRIYXNoUGFyYW1TdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IHt9O1xuXG4gICAgICAgICAgICBbJ2YnLCAndicsICd6JywgJ24nLCAnaScsICdwJywgJ3knLCAneCddLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IEhhc2hQYXJhbXMuZ2V0KHBhcmFtICsgc2V0dGluZ3MuaGFzaFBhcmFtU3VmZml4KTtcblxuICAgICAgICAgICAgICAgIC8vIGBmYWxzZWAgaXMgcmV0dXJuZWQgaWYgdGhlIHZhbHVlIGlzIG1pc3NpbmdcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtwYXJhbV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBEbyBzb21lIGF3a3dhcmQgc3BlY2lhbC1jYXNpbmcsIHNpbmNlIHRoaXMgZm9ybWF0IGlzIGtpbmQgb2Ygd2VpcmQuXG5cbiAgICAgICAgICAgIC8vIEZvciBpbkZ1bGxzY3JlZW4gKGYpLCB0cnVlIGFuZCBmYWxzZSBzdHJpbmdzIHNob3VsZCBiZSBpbnRlcnByZXRlZFxuICAgICAgICAgICAgLy8gYXMgYm9vbGVhbnMuXG4gICAgICAgICAgICBpZiAoc3RhdGUuZiA9PT0gJ3RydWUnKVxuICAgICAgICAgICAgICAgIHN0YXRlLmYgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUuZiA9PT0gJ2ZhbHNlJylcbiAgICAgICAgICAgICAgICBzdGF0ZS5mID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtZXJpY2FsIHZhbHVlcyB0byBpbnRlZ2VycywgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIFsneicsICduJywgJ3AnLCAneCcsICd5J10uZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtIGluIHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZVtwYXJhbV0gPSBwYXJzZUludChzdGF0ZVtwYXJhbV0sIDEwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNoZWNrTG9hZGVkID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZpZXdlclN0YXRlLmxvYWRlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGUgdmlld2VyIGlzIG5vdCBjb21wbGV0ZWx5IGluaXRpYWxpemVkLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIGl0IGlzIHN0aWxsIGRvd25sb2FkaW5nIGRhdGEuIFRvIGZpeCB0aGlzLCBvbmx5IGNhbGwgdGhpcyBmdW5jdGlvbiBpZiB0aGUgaXNSZWFkeSgpIG1ldGhvZCByZXR1cm5zIHRydWUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gZmlsbCB0aGUgaGVpZ2h0LCB1c2UgYSB3cmFwcGVyIGRpdiBkaXNwbGF5ZWQgdXNpbmcgYSBmbGV4Ym94IGxheW91dFxuICAgICAgICAgICAgdmFyIHdyYXBwZXJFbGVtZW50ID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwiZGl2YS13cmFwcGVyXCIgKyAob3B0aW9ucy5maWxsUGFyZW50SGVpZ2h0ID8gXCIgZGl2YS13cmFwcGVyLWZsZXhib3hcIiA6IFwiXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQod3JhcHBlckVsZW1lbnQpO1xuICAgICAgICAgICAgb3B0aW9ucy50b29sYmFyUGFyZW50T2JqZWN0ID0gb3B0aW9ucy50b29sYmFyUGFyZW50T2JqZWN0IHx8ICQod3JhcHBlckVsZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgdmlld2VyQ29yZSA9IG5ldyBWaWV3ZXJDb3JlKHdyYXBwZXJFbGVtZW50LCBvcHRpb25zLCBzZWxmKTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUgPSB2aWV3ZXJDb3JlLmdldEludGVybmFsU3RhdGUoKTtcbiAgICAgICAgICAgIHNldHRpbmdzID0gdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIElEIHRvIHRoZSB3cmFwcGVyIGVsZW1lbnQgbm93IHRoYXQgdGhlIElEIGhhcyBiZWVuIGdlbmVyYXRlZCBieSB0aGUgdmlld2VyIGNvcmVcbiAgICAgICAgICAgIHdyYXBwZXJFbGVtZW50LmlkID0gc2V0dGluZ3MuSUQgKyAnd3JhcHBlcic7XG5cbiAgICAgICAgICAgIGRpdmFTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICB2aWV3ZXJDb3JlOiB2aWV3ZXJDb3JlLFxuICAgICAgICAgICAgICAgIHRvb2xiYXI6IHNldHRpbmdzLmVuYWJsZVRvb2xiYXIgPyBjcmVhdGVUb29sYmFyKHNlbGYpIDogbnVsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhhc2hTdGF0ZSA9IGdldEhhc2hQYXJhbVN0YXRlKCk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mub2JqZWN0RGF0YSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRGVmZXIgZXhlY3V0aW9uIHVudGlsIGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsb2FkT2JqZWN0RGF0YShzZXR0aW5ncy5vYmplY3REYXRhLCBoYXNoU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0ID0gJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzZXR0aW5ncy5vYmplY3REYXRhLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGFqYXhFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZE9iamVjdERhdGEocmVzcG9uc2VEYXRhLCBoYXNoU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgcGVuZGluZyByZXF1ZXN0IHNvIHRoYXQgaXQgY2FuIGJlIGNhbmNlbGxlZCBpbiB0aGUgZXZlbnQgdGhhdCBEaXZhIG5lZWRzIHRvIGJlIGRlc3Ryb3llZFxuICAgICAgICAgICAgICAgIHZpZXdlckNvcmUuc2V0UGVuZGluZ01hbmlmZXN0UmVxdWVzdChwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKiBQVUJMSUMgRlVOQ1RJT05TXG4gICAgICAgID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICovXG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgdGl0bGUgb2YgdGhlIGRvY3VtZW50LCBiYXNlZCBvbiB0aGUgZGlyZWN0b3J5IG5hbWVcbiAgICAgICAgdGhpcy5nZXRJdGVtVGl0bGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QuaXRlbVRpdGxlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdvIHRvIGEgcGFydGljdWxhciBwYWdlIGJ5IGl0cyBwYWdlIG51bWJlciAod2l0aCBpbmRleGluZyBzdGFydGluZyBhdCAxKVxuICAgICAgICAgICAgLy94QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJsZWZ0XCIsIFwicmlnaHRcIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBhbmNob3JlZCB0byB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIGRpdmEtb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgLy95QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJ0b3BcIiwgXCJib3R0b21cIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyBzYW1lIHByb2Nlc3MgYXMgeEFuY2hvci5cbiAgICAgICAgLy8gcmV0dXJucyBUcnVlIGlmIHRoZSBwYWdlIG51bWJlciBwYXNzZWQgaXMgdmFsaWQ7IGZhbHNlIGlmIGl0IGlzIG5vdC5cbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5TnVtYmVyID0gZnVuY3Rpb24gKHBhZ2VOdW1iZXIsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQuIENvbnNpZGVyIHVzaW5nIGdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhcnNlSW50KHBhZ2VOdW1iZXIsIDEwKSAtIDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgocGFnZUluZGV4LCB4QW5jaG9yLCB5QW5jaG9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHbyB0byBhIHBhcnRpY3VsYXIgcGFnZSAod2l0aCBpbmRleGluZyBzdGFydGluZyBhdCAwKVxuICAgICAgICAgICAgLy94QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJsZWZ0XCIsIFwicmlnaHRcIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIHBhZ2Ugd2lsbCBiZSBhbmNob3JlZCB0byB0aGUgKHhBbmNob3IpIHNpZGUgb2YgdGhlIGRpdmEtb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgLy95QW5jaG9yIG1heSBlaXRoZXIgYmUgXCJ0b3BcIiwgXCJib3R0b21cIiwgb3IgZGVmYXVsdCBcImNlbnRlclwiOyBzYW1lIHByb2Nlc3MgYXMgeEFuY2hvci5cbiAgICAgICAgLy8gcmV0dXJucyBUcnVlIGlmIHRoZSBwYWdlIGluZGV4IGlzIHZhbGlkOyBmYWxzZSBpZiBpdCBpcyBub3QuXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeUluZGV4ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgeEFuY2hvciwgeUFuY2hvcilcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZUluZGV4ID0gcGFyc2VJbnQocGFnZUluZGV4LCAxMCk7XG5cbiAgICAgICAgICAgIGlmIChpc1BhZ2VWYWxpZChwYWdlSW5kZXgpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WE9mZnNldChwYWdlSW5kZXgsIHhBbmNob3IpO1xuICAgICAgICAgICAgICAgIHZhciB5T2Zmc2V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0WU9mZnNldChwYWdlSW5kZXgsIHlBbmNob3IpO1xuXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIuZ290byhwYWdlSW5kZXgsIHlPZmZzZXQsIHhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXROdW1iZXJPZlBhZ2VzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjaGVja0xvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm51bVBhZ2VzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCBwYWdlIGRpbWVuc2lvbnMgaW4gdGhlIGN1cnJlbnQgdmlldyBhbmQgem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFBhZ2VEaW1lbnNpb25zID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjaGVja0xvYWRlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpLmdldFBhZ2VEaW1lbnNpb25zKHBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiBhIGdpdmVuIHBhZ2UgaW5kZXggYXQgYSBnaXZlbiB6b29tIGxldmVsXG4gICAgICAgIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnNBdFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwYWdlSWR4LCB6b29tTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tMb2FkZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICh6b29tTGV2ZWwgPiBzZXR0aW5ncy5tYXhab29tTGV2ZWwpXG4gICAgICAgICAgICAgICAgem9vbUxldmVsID0gc2V0dGluZ3MubWF4Wm9vbUxldmVsO1xuXG4gICAgICAgICAgICB2YXIgcGcgPSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1twYXJzZUludChwYWdlSWR4LCAxMCldO1xuICAgICAgICAgICAgdmFyIHBnQXRab29tID0gcGcuZFtwYXJzZUludCh6b29tTGV2ZWwsIDEwKV07XG4gICAgICAgICAgICByZXR1cm4geyd3aWR0aCc6IHBnQXRab29tLncsICdoZWlnaHQnOiBwZ0F0Wm9vbS5ofTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBkaW1lbnNpb25zIG9mIGEgZ2l2ZW4gcGFnZSBhdCB0aGUgY3VycmVudCB6b29tIGxldmVsXG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHBhZ2UgaW5kZXggd2lsbCBiZSB1c2VkIGlmIG5vIHBhZ2VJbmRleCBpcyBzcGVjaWZpZWRcbiAgICAgICAgLy8gQWxzbyB3b3JrcyBpbiBHcmlkIHZpZXdcbiAgICAgICAgdGhpcy5nZXRQYWdlRGltZW5zaW9uc0F0Q3VycmVudFpvb21MZXZlbCA9IGZ1bmN0aW9uKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZUluZGV4ID0gaXNQYWdlVmFsaWQocGFnZUluZGV4KSA/IHBhZ2VJbmRleCA6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXg7XG5cbiAgICAgICAgICAgIGlmICghaXNQYWdlVmFsaWQocGFnZUluZGV4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUGFnZSBJbmRleCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpLmdldFBhZ2VEaW1lbnNpb25zKHBhZ2VJbmRleCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmV0dXJucyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY3VycmVudCBwYWdlIGF0IHRoZSBjdXJyZW50IHpvb20gbGV2ZWxcbiAgICAgICAgLy8gQWxzbyB3b3JrcyBpbiBHcmlkIHZpZXdcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlRGltZW5zaW9uc0F0Q3VycmVudFpvb21MZXZlbChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzUmVhZHkgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUubG9hZGVkO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFBhZ2VJbmRleCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4O1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudFBhZ2VGaWxlbmFtZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1tzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4XS5mO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudENhbnZhcyA9IGZ1bmN0aW9uIChzZXR0aW5ncylcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3NldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhdLmNhbnZhcztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlTnVtYmVyID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgZ2V0Q3VycmVudFBhZ2VJbmRleCgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggKyAxO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGZpbGVuYW1lcyBpbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgdGhpcy5nZXRGaWxlbmFtZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmlsZW5hbWVzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MubnVtUGFnZXM7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWxlbmFtZXNbaV0gPSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlc1tpXS5mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmlsZW5hbWVzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFpvb21MZXZlbCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2V0cyB0aGUgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgZW50aXJlIGRvY3VtZW50XG4gICAgICAgIHRoaXMuZ2V0TWF4Wm9vbUxldmVsID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1heFpvb21MZXZlbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnZXRzIHRoZSBtYXggem9vbSBsZXZlbCBmb3IgYSBnaXZlbiBwYWdlXG4gICAgICAgIHRoaXMuZ2V0TWF4Wm9vbUxldmVsRm9yUGFnZSA9IGZ1bmN0aW9uIChwYWdlSWR4KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrTG9hZGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzW3BhZ2VJZHhdLm07XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRNaW5ab29tTGV2ZWwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzZSB0aGUgcHJvdmlkZWQgem9vbSBsZXZlbCAod2lsbCBjaGVjayBmb3IgdmFsaWRpdHkgZmlyc3QpXG4gICAgICAgIC8vIFJldHVybnMgZmFsc2UgaWYgdGhlIHpvb20gbGV2ZWwgaXMgaW52YWxpZCwgdHJ1ZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5zZXRab29tTGV2ZWwgPSBmdW5jdGlvbiAoem9vbUxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgICAgIGluR3JpZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnpvb20oem9vbUxldmVsKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEdyaWRQYWdlc1BlclJvdyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8od2FiYWluKTogQWRkIHRlc3QgY2FzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZXNQZXJSb3c7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRHcmlkUGFnZXNQZXJSb3cgPSBmdW5jdGlvbiAobmV3VmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRPRE8od2FiYWluKTogQWRkIHRlc3QgY2FzZVxuICAgICAgICAgICAgaWYgKCFkaXZhU3RhdGUudmlld2VyQ29yZS5pc1ZhbGlkT3B0aW9uKCdwYWdlc1BlclJvdycsIG5ld1ZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgIGluR3JpZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwYWdlc1BlclJvdzogbmV3VmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFpvb20gaW4uIFdpbGwgcmV0dXJuIGZhbHNlIGlmIGl0J3MgYXQgdGhlIG1heGltdW0gem9vbVxuICAgICAgICB0aGlzLnpvb21JbiA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgKyAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBab29tIG91dC4gV2lsbCByZXR1cm4gZmFsc2UgaWYgaXQncyBhdCB0aGUgbWluaW11bSB6b29tXG4gICAgICAgIHRoaXMuem9vbU91dCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgLSAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGVjayBpZiBzb21ldGhpbmcgKGUuZy4gYSBoaWdobGlnaHQgYm94IG9uIGEgcGFydGljdWxhciBwYWdlKSBpcyB2aXNpYmxlXG4gICAgICAgIHRoaXMuaXNSZWdpb25JblZpZXdwb3J0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgbGVmdE9mZnNldCwgdG9wT2Zmc2V0LCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuXG4gICAgICAgICAgICBpZiAoIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIHRvcE9mZnNldDtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gb2Zmc2V0LmxlZnQgKyBsZWZ0T2Zmc2V0O1xuXG4gICAgICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUudmlld3BvcnQuaW50ZXJzZWN0c1JlZ2lvbih7XG4gICAgICAgICAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0b3AgKyBoZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgICAgICByaWdodDogbGVmdCArIHdpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1B1YmxpYyB3cmFwcGVyIGZvciBpc1BhZ2VWaXNpYmxlXG4gICAgICAgIC8vRGV0ZXJtaW5lcyBpZiBhIHBhZ2UgaXMgY3VycmVudGx5IGluIHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLmlzUGFnZUluVmlld3BvcnQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdmlld2VyU3RhdGUucmVuZGVyZXIuaXNQYWdlVmlzaWJsZShwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUHVibGljIHdyYXBwZXIgZm9yIGlzUGFnZUxvYWRlZFxuICAgICAgICAvL0RldGVybWluZXMgaWYgYSBwYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgRE9NXG4gICAgICAgIHRoaXMuaXNQYWdlTG9hZGVkID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhpcyBtZXRob2QgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgdXNpbmcgaXNQYWdlSW5WaWV3cG9ydChwYWdlSW5kZXgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNQYWdlSW5WaWV3cG9ydChwYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFRvZ2dsZSBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsc2NyZWVuTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvZ2dsZUZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTaG93L0hpZGUgbm9uLXBhZ2VkIHBhZ2VzXG4gICAgICAgIHRoaXMudG9nZ2xlTm9uUGFnZWRQYWdlc1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoeyBzaG93Tm9uUGFnZWRQYWdlczogIXNldHRpbmdzLnNob3dOb25QYWdlZFBhZ2VzIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNob3cgbm9uLXBhZ2VkIHBhZ2VzXG4gICAgICAgIHRoaXMuc2hvd05vblBhZ2VkUGFnZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZWxvYWRWaWV3ZXIoeyBzaG93Tm9uUGFnZWRQYWdlczogdHJ1ZSB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIaWRlIG5vbi1wYWdlZCBwYWdlc1xuICAgICAgICB0aGlzLmhpZGVOb25QYWdlZFBhZ2VzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKHsgc2hvd05vblBhZ2VkUGFnZXM6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENsb3NlIHRvb2xiYXIgcG9wdXBzXG4gICAgICAgIHRoaXMuY2xvc2VQb3B1cHMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudG9vbGJhci5jbG9zZVBvcHVwcygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEVudGVyIGZ1bGxzY3JlZW4gbW9kZSBpZiBjdXJyZW50bHkgbm90IGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICAvLyBSZXR1cm5zIGZhbHNlIGlmIGluIGZ1bGxzY3JlZW4gbW9kZSBpbml0aWFsbHksIHRydWUgb3RoZXJ3aXNlXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCB3b3JrIGV2ZW4gaWYgZW5hYmxlRnVsbHNjcmVlbiBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgdGhpcy5lbnRlckZ1bGxzY3JlZW5Nb2RlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRnVsbHNjcmVlbigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTGVhdmUgZnVsbHNjcmVlbiBtb2RlIGlmIGN1cnJlbnRseSBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGluIGZ1bGxzY3JlZW4gbW9kZSBpbnRpdGlhbGx5LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5sZWF2ZUZ1bGxzY3JlZW5Nb2RlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzSW5GdWxsc2NyZWVuID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmluRnVsbHNjcmVlbjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDaGFuZ2Ugdmlld3MuIFRha2VzICdkb2N1bWVudCcsICdib29rJywgb3IgJ2dyaWQnIHRvIHNwZWNpZnkgd2hpY2ggdmlldyB0byBzd2l0Y2ggaW50b1xuICAgICAgICB0aGlzLmNoYW5nZVZpZXcgPSBmdW5jdGlvbihkZXN0aW5hdGlvblZpZXcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VWaWV3KGRlc3RpbmF0aW9uVmlldyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRW50ZXIgZ3JpZCB2aWV3IGlmIGN1cnJlbnRseSBub3QgaW4gZ3JpZCB2aWV3XG4gICAgICAgIC8vIFJldHVybnMgZmFsc2UgaWYgaW4gZ3JpZCB2aWV3IGluaXRpYWxseSwgdHJ1ZSBvdGhlcndpc2VcbiAgICAgICAgdGhpcy5lbnRlckdyaWRWaWV3ID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVmlldygnZ3JpZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTGVhdmUgZ3JpZCB2aWV3IGlmIGN1cnJlbnRseSBpbiBncmlkIHZpZXdcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGluIGdyaWQgdmlldyBpbml0aWFsbHksIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICB0aGlzLmxlYXZlR3JpZFZpZXcgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7IGluR3JpZDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBKdW1wIHRvIGEgcGFnZSBiYXNlZCBvbiBpdHMgZmlsZW5hbWVcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHN1Y2Nlc3NmdWwgYW5kIGZhbHNlIGlmIHRoZSBmaWxlbmFtZSBpcyBpbnZhbGlkXG4gICAgICAgIHRoaXMuZ290b1BhZ2VCeU5hbWUgPSBmdW5jdGlvbiAoZmlsZW5hbWUsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBnZXRQYWdlSW5kZXgoZmlsZW5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ290b1BhZ2VCeUluZGV4KHBhZ2VJbmRleCwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwYWdlc1tpXS5sLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsYWJlbC50b0xvd2VyQ2FzZSgpKSA+IC0xKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nb3RvUGFnZUJ5SW5kZXgoaSwgeEFuY2hvciwgeUFuY2hvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIG5vIGxhYmVsIHdhcyBmb3VuZCwgdHJ5IHRvIHBhcnNlIGEgcGFnZSBudW1iZXJcbiAgICAgICAgICAgIHZhciBwYWdlSW5kZXggPSBwYXJzZUludChsYWJlbCwgMTApIC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgsIHhBbmNob3IsIHlBbmNob3IpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgcGFnZSBpbmRleCAoMC1iYXNlZCkgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGZpbGVuYW1lXG4gICAgICAgIC8vIElmIHRoZSBwYWdlIGluZGV4IGRvZXNuJ3QgZXhpc3QsIHRoaXMgd2lsbCByZXR1cm4gLTFcbiAgICAgICAgdGhpcy5nZXRQYWdlSW5kZXggPSBmdW5jdGlvbiAoZmlsZW5hbWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQYWdlSW5kZXgoZmlsZW5hbWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBVUkwgKGV4cG9zZXMgdGhlIHByaXZhdGUgbWV0aG9kKVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRVUkwgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q3VycmVudFVSTCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGEgcGFnZSBpbmRleCBpcyB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICB0aGlzLmlzUGFnZUluZGV4VmFsaWQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNQYWdlVmFsaWQocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGhhc2ggcGFydCBvbmx5IG9mIHRoZSBjdXJyZW50IFVSTCAod2l0aG91dCB0aGUgbGVhZGluZyAjKVxuICAgICAgICB0aGlzLmdldFVSTEhhc2ggPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VVJMSGFzaCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEdldCBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGlzIGRpdmEgaW5zdGFuY2UgKGZvciBzZXRTdGF0ZSlcbiAgICAgICAgdGhpcy5nZXRTdGF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRTdGF0ZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsaWduIHRoaXMgZGl2YSBpbnN0YW5jZSB3aXRoIGEgc3RhdGUgb2JqZWN0IChhcyByZXR1cm5lZCBieSBnZXRTdGF0ZSlcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmVsb2FkVmlld2VyKGdldExvYWRPcHRpb25zRm9yU3RhdGUoc3RhdGUpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBHZXQgdGhlIGluc3RhbmNlIHNlbGVjdG9yIGZvciB0aGlzIGluc3RhbmNlLCBzaW5jZSBpdCdzIGF1dG8tZ2VuZXJhdGVkLlxuICAgICAgICB0aGlzLmdldEluc3RhbmNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc2VsZWN0b3I7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gR2V0IHRoZSBpbnN0YW5jZSBJRCAtLSBlc3NlbnRpYWxseSB0aGUgc2VsZWN0b3Igd2l0aG91dCB0aGUgbGVhZGluZyAnIycuXG4gICAgICAgIHRoaXMuZ2V0SW5zdGFuY2VJZCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5JRDtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qXG4gICAgICAgICAgICBUcmFuc2xhdGVzIGEgbWVhc3VyZW1lbnQgZnJvbSB0aGUgem9vbSBsZXZlbCBvbiB0aGUgbGFyZ2VzdCBzaXplXG4gICAgICAgICAgICB0byBvbmUgb24gdGhlIGN1cnJlbnQgem9vbSBsZXZlbC5cblxuICAgICAgICAgICAgRm9yIGV4YW1wbGUsIGEgcG9pbnQgMTAwMCBvbiBhbiBpbWFnZSB0aGF0IGlzIG9uIHpvb20gbGV2ZWwgMiBvZiA1XG4gICAgICAgICAgICB0cmFuc2xhdGVzIHRvIGEgcG9zaXRpb24gb2YgMTExLjExMS4uLiAoMTAwMCAvICg1IC0gMileMikuXG5cbiAgICAgICAgICAgIFdvcmtzIGZvciBhIHNpbmdsZSBwaXhlbCBjby1vcmRpbmF0ZSBvciBhIGRpbWVuc2lvbiAoZS5nLiwgdHJhbnNsYXRlcyBhIGJveFxuICAgICAgICAgICAgdGhhdCBpcyAxMDAwIHBpeGVscyB3aWRlIG9uIHRoZSBvcmlnaW5hbCB0byBvbmUgdGhhdCBpcyAxMTEuMTExIHBpeGVscyB3aWRlXG4gICAgICAgICAgICBvbiB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsID0gZnVuY3Rpb24gKHBvc2l0aW9uKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgem9vbURpZmZlcmVuY2UgPSBzZXR0aW5ncy5tYXhab29tTGV2ZWwgLSBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gLyBNYXRoLnBvdygyLCB6b29tRGlmZmVyZW5jZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICAgIFRyYW5zbGF0ZXMgYSBtZWFzdXJlbWVudCBmcm9tIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwgdG8gdGhlIHBvc2l0aW9uIG9uIHRoZVxuICAgICAgICAgICAgbGFyZ2VzdCB6b29tIGxldmVsLlxuXG4gICAgICAgICAgICBXb3JrcyBmb3IgYSBzaW5nbGUgcGl4ZWwgY28tb3JkaW5hdGUgb3IgYSBkaW1lbnNpb24gKGUuZy4sIHRyYW5zbGF0ZXMgYSBib3hcbiAgICAgICAgICAgIHRoYXQgaXMgMTExLjExMSBwaXhlbHMgd2lkZSBvbiB0aGUgY3VycmVudCBpbWFnZSB0byBvbmUgdGhhdCBpcyAxMDAwIHBpeGVscyB3aWRlXG4gICAgICAgICAgICBvbiB0aGUgY3VycmVudCB6b29tIGxldmVsKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmFuc2xhdGVUb01heFpvb21MZXZlbCA9IGZ1bmN0aW9uIChwb3NpdGlvbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21EaWZmZXJlbmNlID0gc2V0dGluZ3MubWF4Wm9vbUxldmVsIC0gc2V0dGluZ3Muem9vbUxldmVsO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBkaWZmZXJlbmNlLCBpdCdzIGEgYm94IG9uIHRoZSBtYXggem9vbSBsZXZlbCBhbmRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgcG9zaXRpb24uXG4gICAgICAgICAgICBpZiAoem9vbURpZmZlcmVuY2UgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuXG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb24gKiBNYXRoLnBvdygyLCB6b29tRGlmZmVyZW5jZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmUtZW5hYmxlcyBkb2N1bWVudCBkcmFnZ2luZywgc2Nyb2xsaW5nIChieSBrZXlib2FyZCBpZiBzZXQpLCBhbmQgem9vbWluZyBieSBkb3VibGUtY2xpY2tpbmdcbiAgICAgICAgdGhpcy5lbmFibGVTY3JvbGxhYmxlID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5lbmFibGVTY3JvbGxhYmxlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGlzYWJsZXMgZG9jdW1lbnQgZHJhZ2dpbmcsIHNjcm9sbGluZyAoYnkga2V5Ym9hcmQgaWYgc2V0KSwgYW5kIHpvb21pbmcgYnkgZG91YmxlLWNsaWNraW5nXG4gICAgICAgIHRoaXMuZGlzYWJsZVNjcm9sbGFibGUgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBkaXZhU3RhdGUudmlld2VyQ29yZS5kaXNhYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vQ2hhbmdlcyBiZXR3ZWVuIGhvcml6b250YWwgbGF5b3V0IGFuZCB2ZXJ0aWNhbCBsYXlvdXQuIFJldHVybnMgdHJ1ZSBpZiBkb2N1bWVudCBpcyBub3cgdmVydGljYWxseSBvcmllbnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICB0aGlzLnRvZ2dsZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRvZ2dsZU9yaWVudGF0aW9uKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9SZXR1cm5zIGRpc3RhbmNlIGJldHdlZW4gdGhlIG5vcnRod2VzdCBjb3JuZXJzIG9mIGRpdmEtaW5uZXIgYW5kIHBhZ2UgaW5kZXhcbiAgICAgICAgdGhpcy5nZXRQYWdlT2Zmc2V0ID0gZnVuY3Rpb24ocGFnZUluZGV4LCBvcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVnaW9uID0gZGl2YVN0YXRlLnZpZXdlckNvcmUuZ2V0UGFnZVJlZ2lvbihwYWdlSW5kZXgsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRvcDogcmVnaW9uLnRvcCxcbiAgICAgICAgICAgICAgICBsZWZ0OiByZWdpb24ubGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL3Nob3J0Y3V0IHRvIGdldFBhZ2VPZmZzZXQgZm9yIGN1cnJlbnQgcGFnZVxuICAgICAgICB0aGlzLmdldEN1cnJlbnRQYWdlT2Zmc2V0ID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUmV0dXJucyB0aGUgcGFnZSBkaW1lbnNpb25zIG9mIGdpdmVuIHBhZ2UgYXQgdGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAgICB0aGlzLmdldFBhZ2VEaW1lbnNpb25zQXRDdXJyZW50R3JpZExldmVsID0gZnVuY3Rpb24ocGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGlzIG1ldGhvZCBpcyBkZXByZWNhdGVkLiBDb25zaWRlciB1c2luZyBnZXRQYWdlRGltZW5zaW9uc0F0Q3VycmVudFpvb21MZXZlbChwYWdlSW5kZXgpIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZURpbWVuc2lvbnNBdEN1cnJlbnRab29tTGV2ZWwocGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgICAgR2l2ZW4gYSBwYWdlWCBhbmQgcGFnZVkgdmFsdWUgKGFzIGNvdWxkIGJlIHJldHJlaXZlZCBmcm9tIGEgalF1ZXJ5IGV2ZW50IG9iamVjdCksXG4gICAgICAgICAgICAgICAgcmV0dXJucyBlaXRoZXIgdGhlIHBhZ2UgdmlzaWJsZSBhdCB0aGF0ICh4LHkpIHBvc2l0aW9uIG9yIC0xIGlmIG5vIHBhZ2UgaXMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUluZGV4Rm9yUGFnZVhZVmFsdWVzID0gZnVuY3Rpb24ocGFnZVgsIHBhZ2VZKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2dldCB0aGUgZm91ciBlZGdlcyBvZiB0aGUgb3V0ZXIgZWxlbWVudFxuICAgICAgICAgICAgdmFyIG91dGVyT2Zmc2V0ID0gdmlld2VyU3RhdGUub3V0ZXJFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIG91dGVyVG9wID0gb3V0ZXJPZmZzZXQudG9wO1xuICAgICAgICAgICAgdmFyIG91dGVyTGVmdCA9IG91dGVyT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICB2YXIgb3V0ZXJCb3R0b20gPSBvdXRlck9mZnNldC5ib3R0b207XG4gICAgICAgICAgICB2YXIgb3V0ZXJSaWdodCA9IG91dGVyT2Zmc2V0LnJpZ2h0O1xuXG4gICAgICAgICAgICAvL2lmIHRoZSBjbGlja2VkIHBvc2l0aW9uIHdhcyBvdXRzaWRlIHRoZSBkaXZhLW91dGVyIG9iamVjdCwgaXQgd2FzIG5vdCBvbiBhIHZpc2libGUgcG9ydGlvbiBvZiBhIHBhZ2VcbiAgICAgICAgICAgIGlmIChwYWdlWCA8IG91dGVyTGVmdCB8fCBwYWdlWCA+IG91dGVyUmlnaHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuXG4gICAgICAgICAgICBpZiAocGFnZVkgPCBvdXRlclRvcCB8fCBwYWdlWSA+IG91dGVyQm90dG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcblxuICAgICAgICAgICAgLy9uYXZpZ2F0ZSB0aHJvdWdoIGFsbCBkaXZhIHBhZ2Ugb2JqZWN0c1xuICAgICAgICAgICAgdmFyIHBhZ2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGl2YS1wYWdlJyk7XG4gICAgICAgICAgICB2YXIgY3VyUGFnZUlkeCA9IHBhZ2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJQYWdlSWR4LS0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9nZXQgdGhlIG9mZnNldCBmb3IgZWFjaCBwYWdlXG4gICAgICAgICAgICAgICAgdmFyIGN1clBhZ2UgPSBwYWdlc1tjdXJQYWdlSWR4XTtcbiAgICAgICAgICAgICAgICB2YXIgY3VyT2Zmc2V0ID0gY3VyUGFnZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBwb2ludCBpcyBvdXRzaWRlIHRoZSBob3Jpem9udGFsIGJvdW5kYXJpZXMgb2YgdGhlIHBhZ2UsIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2VYIDwgY3VyT2Zmc2V0LmxlZnQgfHwgcGFnZVggPiBjdXJPZmZzZXQucmlnaHQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgLy9zYW1lIHdpdGggdmVydGljYWwgYm91bmRhcmllc1xuICAgICAgICAgICAgICAgIGlmIChwYWdlWSA8IGN1ck9mZnNldC50b3AgfHwgcGFnZVkgPiBjdXJPZmZzZXQuYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIC8vaWYgd2UgbWFkZSBpdCB0aHJvdWdoIHRoZSBhYm92ZSB0d28sIHdlIGZvdW5kIHRoZSBwYWdlIHdlJ3JlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1clBhZ2UuZ2V0QXR0cmlidXRlKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vaWYgd2UgbWFkZSBpdCB0aHJvdWdoIHRoYXQgZW50aXJlIHdoaWxlIGxvb3AsIHdlIGRpZG4ndCBjbGljayBvbiBhIHBhZ2VcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAqICAgR2l2ZW4gYSBzZXQgb2YgY2xpZW50WCwgY2xpZW50WSBjby1vcmRpbmF0ZXMsIHJldHVybnMgYW4gb2JqZWN0XG4gICAgICAgICpcbiAgICAgICAgKiovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUNvb3JkaW5hdGVzSGl0ID0gZnVuY3Rpb24oY2xpZW50WCwgY2xpZW50WSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nZXRQYWdlSGl0KGNsaWVudFgsIGNsaWVudFkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIFVSTCBmb3IgdGhlIGltYWdlIG9mIHRoZSBwYWdlIGF0IHRoZSBnaXZlbiBpbmRleC4gVGhlXG4gICAgICAgICAqIG9wdGlvbmFsIHNpemUgcGFyYW1ldGVyIHN1cHBvcnRzIHNldHRpbmcgdGhlIGltYWdlIHdpZHRoIG9yIGhlaWdodFxuICAgICAgICAgKiAoZGVmYXVsdCBpcyBmdWxsLXNpemVkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUltYWdlVVJMID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2l6ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0LmdldFBhZ2VJbWFnZVVSTChwYWdlSW5kZXgsIHNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vUHJldHR5IHNlbGYtZXhwbGFuYXRvcnkuXG4gICAgICAgIHRoaXMuaXNWZXJ0aWNhbGx5T3JpZW50ZWQgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5jaGFuZ2VPYmplY3QgPSBmdW5jdGlvbihvYmplY3REYXRhKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5yZW5kZXJlcilcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5kZXN0cm95KCk7XG5cbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMub2JqZWN0RGF0YSA9IG9iamVjdERhdGE7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0RGF0YSA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZE9iamVjdERhdGEob2JqZWN0RGF0YSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnRocm9iYmVyVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5zaG93KCk7XG4gICAgICAgICAgICB9LCBzZXR0aW5ncy50aHJvYmJlclRpbWVvdXQpO1xuXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogc2V0dGluZ3Mub2JqZWN0RGF0YSxcbiAgICAgICAgICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBhamF4RXJyb3IsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRPYmplY3REYXRhKHJlc3BvbnNlRGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSA9IHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaXNBY3RpdmVEaXZhID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGVzdHJveXMgdGhpcyBpbnN0YW5jZSwgdGVsbHMgcGx1Z2lucyB0byBkbyB0aGUgc2FtZSAoZm9yIHRlc3RpbmcpXG4gICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBcIlNlY3JldGx5XCIgZXhwb3NlIHRoZSBwYWdlIG92ZXJsYXkgQVBJIGZvciB0aGUgaGlnaGxpZ2h0IHBsdWdpblxuICAgICAgICB0aGlzLl9fYWRkUGFnZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGl2YVN0YXRlLnZpZXdlckNvcmUuYWRkUGFnZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX3JlbW92ZVBhZ2VPdmVybGF5ID0gZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRpdmFTdGF0ZS52aWV3ZXJDb3JlLnJlbW92ZVBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKioqIFBhZ2UgQWxpYXMgRnVuY3Rpb25zICoqKiovXG4gICAgICAgIC8qXG4gICAgICAgICBNYWluIGZ1bmN0aW9uLiBXaWxsIHJldHVybiB0aGUgZmlyc3Qgb2YgdGhlc2UgdGhyZWUgdGhhdFxuICAgICAgICAgcmVzb2x2ZXMgdG8gYm9vbGVhbiB0cnVlOlxuICAgICAgICAgLUV4cGxpY2l0IGFsaWFzIGFzIGRlZmluZWQgaW4gcGFnZUFsaWFzZXNcbiAgICAgICAgIC1SZXN1bHQgb2YgcGFnZUFsaWFzRnVuY3Rpb25cbiAgICAgICAgIC1vcmlnaW5hbFBhZ2VJbmRleCArIDEgKHRvIHNpbXVsYXRlIHRoZSBvcmlnaW5hbCBtYXBwaW5nKVxuXG4gICAgICAgICBFbHNlIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QWxpYXNGb3JQYWdlSW5kZXggPSBmdW5jdGlvbihvcmlnaW5hbFBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhcnNlSW50KG9yaWdpbmFsUGFnZUluZGV4LCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MucGFnZUFsaWFzZXNbcGFnZUluZGV4XSB8fCBzZXR0aW5ncy5wYWdlQWxpYXNGdW5jdGlvbihwYWdlSW5kZXgpIHx8IHBhZ2VJbmRleCArIDE7XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgIFJldHVybnMgdGhlIGZpcnN0IHBhZ2UgaW5kZXggZm91bmQgZm9yIGEgZ2l2ZW4gYWxpYXNlZCBudW1iZXIgb3IgZmFsc2UgaWYgbm90IGZvdW5kLlxuICAgICAgICAgVGhpcyBtYXkgY2F1c2UgaXNzdWVzIGlmIGEgc3BlY2lmaWMgYWxpYXMgaXMgZm91bmQgZm9yIG11bHRpcGxlIHBhZ2UgaW5kaWNlczsgdXNlIGdldFBhZ2VJbmRpY2VzRm9yQWxpYXMgYW5kIHJlaW1wbGVtZW50IGZ1bmN0aW9ucyBhcyBuZWNlc3NhcnkgaWYgdGhpcyBpcyB0aGUgY2FzZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0UGFnZUluZGV4Rm9yQWxpYXMgPSBmdW5jdGlvbihhbGlhc2VkTnVtYmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3IodmFyIGlkeCA9IDA7IGlkeCA8IHNldHRpbmdzLm51bVBhZ2VzOyBpZHgrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLmdldEFsaWFzRm9yUGFnZUluZGV4KGlkeCkgPT09IGFsaWFzZWROdW1iZXIpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1JldHVybnMgYXJyYXkgb2YgcGFnZSBpbmRpY2VzIGZvciBhIGdpdmVuIGFsaWFzZWQgbnVtYmVyLiBSZXR1cm5zIGFuIGVtcHR5IGFycmF5IGlmIG5vbmUgYXJlIGZvdW5kLlxuICAgICAgICB0aGlzLmdldFBhZ2VJbmRpY2VzRm9yQWxpYXMgPSBmdW5jdGlvbihhbGlhc2VkTnVtYmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgaW5kZXhBcnIgPSBbXTtcbiAgICAgICAgICAgIGZvcih2YXIgaWR4ID0gMDsgaWR4IDwgc2V0dGluZ3MubnVtUGFnZXM7IGlkeCsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKHRoaXMuZ2V0QWxpYXNGb3JQYWdlSW5kZXgoaWR4KSA9PT0gYWxpYXNlZE51bWJlcilcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4QXJyLnB1c2goaWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhBcnI7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvL01hcHMgdGhlIGN1cnJlbnQgcGFnZSBpbmRleCB0byBnZXRBbGlhc0ZvclBhZ2VJbmRleFxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBbGlhc2VkUGFnZUluZGV4ID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGlhc0ZvclBhZ2VJbmRleChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvL1dyYXBwZXIgZm9yIGdvdG9QYWdlQnlJbmRleCwga2VlcGluZyB0aGUgYWxpYXNlZCBudW1iZXJzIGluIG1pbmRcbiAgICAgICAgdGhpcy5nb3RvUGFnZUJ5QWxpYXNlZE51bWJlciA9IGZ1bmN0aW9uKGFsaWFzZWROdW1iZXIsIHhBbmNob3IsIHlBbmNob3IpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdvdG9QYWdlQnlJbmRleCh0aGlzLmdldFBhZ2VJbmRleEZvckFsaWFzKGFsaWFzZWROdW1iZXIpLCB4QW5jaG9yLCB5QW5jaG9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDYWxsIHRoZSBpbml0IGZ1bmN0aW9uIHdoZW4gdGhpcyBvYmplY3QgaXMgY3JlYXRlZC5cbiAgICAgICAgaW5pdCgpO1xuICAgIH07XG5cbiAgICAkLmZuLmRpdmEgPSBmdW5jdGlvbiAob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRpdmFQYXJlbnQgPSAkKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm4gZWFybHkgaWYgdGhpcyBlbGVtZW50IGFscmVhZHkgaGFzIGEgcGx1Z2luIGluc3RhbmNlXG4gICAgICAgICAgICBpZiAoZGl2YVBhcmVudC5kYXRhKCdkaXZhJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgZWxlbWVudCBpcyBub3QgaW4gdGhlIERPTSwgc2luY2UgaXQgY2F1c2VzIHNvbWUgcHJvYmxlbXNcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpdmEgY291bGQgbm90IGJlIGluaXRpYWxpemVkIGJlY2F1c2UgdGhpcyBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgRE9NJyk7XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaW5zdGFudGlhdGUgdGhlIGRvY3VtZW50IHZpZXdlclxuICAgICAgICAgICAgdmFyIGRpdmEgPSBuZXcgRGl2YSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGRpdmFQYXJlbnQuZGF0YSgnZGl2YScsIGRpdmEpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2RpdmEuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiKGZ1bmN0aW9uICgpIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maWxsKSByZXR1cm47XG5cbiAgdmFyIGZpbGwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyBTdGVwcyAxLTIuXG4gICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRoaXMgaXMgbnVsbCBvciBub3QgZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgTyA9IE9iamVjdCh0aGlzKTtcblxuICAgIC8vIFN0ZXBzIDMtNS5cbiAgICB2YXIgbGVuID0gTy5sZW5ndGggPj4+IDA7XG5cbiAgICAvLyBTdGVwcyA2LTcuXG4gICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gc3RhcnQgPj4gMDtcblxuICAgIC8vIFN0ZXAgOC5cbiAgICB2YXIgayA9IHJlbGF0aXZlU3RhcnQgPCAwID9cbiAgICAgIE1hdGgubWF4KGxlbiArIHJlbGF0aXZlU3RhcnQsIDApIDpcbiAgICAgIE1hdGgubWluKHJlbGF0aXZlU3RhcnQsIGxlbik7XG5cbiAgICAvLyBTdGVwcyA5LTEwLlxuICAgIHZhciBlbmQgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHJlbGF0aXZlRW5kID0gZW5kID09PSB1bmRlZmluZWQgP1xuICAgICAgbGVuIDogZW5kID4+IDA7XG5cbiAgICAvLyBTdGVwIDExLlxuICAgIHZhciBsYXN0ID0gcmVsYXRpdmVFbmQgPCAwID9cbiAgICAgIE1hdGgubWF4KGxlbiArIHJlbGF0aXZlRW5kLCAwKSA6XG4gICAgICBNYXRoLm1pbihyZWxhdGl2ZUVuZCwgbGVuKTtcblxuICAgIC8vIFN0ZXAgMTIuXG4gICAgd2hpbGUgKGsgPCBsYXN0KSB7XG4gICAgICBPW2tdID0gdmFsdWU7XG4gICAgICBrKys7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxMy5cbiAgICByZXR1cm4gTztcbiAgfTtcblxuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaWxsJywge1xuICAgICAgICB2YWx1ZTogZmlsbCxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmICghQXJyYXkucHJvdG90eXBlLmZpbGwpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsbCA9IGZpbGw7XG4gIH1cbn0pKHRoaXMpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2FycmF5LnByb3RvdHlwZS5maWxsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZWx0O1xubW9kdWxlLmV4cG9ydHMuc2V0QXR0cmlidXRlcyA9IHNldERPTUF0dHJpYnV0ZXM7XG5cbi8qKlxuICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgRE9NIGVsZW1lbnQsIHNldCBhdHRyaWJ1dGVzIG9uIGl0LCBhbmRcbiAqIGFwcGVuZCBjaGlsZHJlbi4gQWxsIGFyZ3VtZW50cyB3aGljaCBhcmUgbm90IG9mIHByaW1pdGl2ZSB0eXBlLCBhcmUgbm90XG4gKiBhcnJheXMsIGFuZCBhcmUgbm90IERPTSBub2RlcyBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGUgaGFzaGVzIGFuZCBhcmVcbiAqIGhhbmRsZWQgYXMgZGVzY3JpYmVkIGZvciBzZXRET01BdHRyaWJ1dGVzLiBDaGlsZHJlbiBjYW4gZWl0aGVyIGJlIGEgRE9NXG4gKiBub2RlIG9yIGEgcHJpbWl0aXZlIHZhbHVlLCB3aGljaCBpcyBjb252ZXJ0ZWQgdG8gYSB0ZXh0IG5vZGUuIEFycmF5cyBhcmVcbiAqIGhhbmRsZWQgcmVjdXJzaXZlbHkuIE51bGwgYW5kIHVuZGVmaW5lZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gKlxuICogSW5zcGlyZWQgYnkgdGhlIFByb3NlTWlycm9yIGhlbHBlciBvZiB0aGUgc2FtZSBuYW1lLlxuICovXG5mdW5jdGlvbiBlbHQodGFnKVxue1xuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB3aGlsZSAoYXJncy5sZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICBoYW5kbGVFbHRDb25zdHJ1Y3RvckFyZyhlbCwgYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWw7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUVsdENvbnN0cnVjdG9yQXJnKGVsLCBhcmcpXG57XG4gICAgaWYgKGFyZyA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ29iamVjdCcgJiYgdHlwZW9mIGFyZyAhPT0gJ2Z1bmN0aW9uJylcbiAgICB7XG4gICAgICAgIC8vIENvZXJjZSB0byBzdHJpbmdcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXJnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlKVxuICAgIHtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgQXJyYXkpXG4gICAge1xuICAgICAgICB2YXIgY2hpbGRDb3VudCA9IGFyZy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaGFuZGxlRWx0Q29uc3RydWN0b3JBcmcoZWwsIGFyZ1tpXSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHNldERPTUF0dHJpYnV0ZXMoZWwsIGFyZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNldCBhdHRyaWJ1dGVzIG9mIGEgRE9NIGVsZW1lbnQuIFRoZSBgc3R5bGVgIHByb3BlcnR5IGlzIHNwZWNpYWwtY2FzZWQgdG9cbiAqIGFjY2VwdCBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0IHdob3NlIG93biBhdHRyaWJ1dGVzIGFyZSBhc3NpZ25lZCB0b1xuICogZWwuc3R5bGUuXG4gKi9cbmZ1bmN0aW9uIHNldERPTUF0dHJpYnV0ZXMoZWwsIGF0dHJpYnV0ZXMpXG57XG4gICAgZm9yICh2YXIgcHJvcCBpbiBhdHRyaWJ1dGVzKVxuICAgIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHByb3ApKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgaWYgKHByb3AgPT09ICdzdHlsZScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFN0eWxlKGVsLCBhdHRyaWJ1dGVzLnN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoZWwsIHN0eWxlKVxue1xuICAgIGlmICghc3R5bGUpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmICh0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKVxuICAgIHtcbiAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgY3NzUHJvcCBpbiBzdHlsZSlcbiAgICB7XG4gICAgICAgIGlmICghc3R5bGUuaGFzT3duUHJvcGVydHkoY3NzUHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICBlbC5zdHlsZVtjc3NQcm9wXSA9IHN0eWxlW2Nzc1Byb3BdO1xuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3V0aWxzL2VsdC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cy5nZXQgPSBnZXRIYXNoUGFyYW07XG5tb2R1bGUuZXhwb3J0cy51cGRhdGUgPSB1cGRhdGVIYXNoUGFyYW07XG5cbi8vIEZvciBnZXR0aW5nIHRoZSAja2V5IHZhbHVlcyBmcm9tIHRoZSBVUkwuIEZvciBzcGVjaWZ5aW5nIGEgcGFnZSBhbmQgem9vbSBsZXZlbFxuLy8gTG9vayBpbnRvIGNhY2hpbmcsIGJlY2F1c2Ugd2Ugb25seSBuZWVkIHRvIGdldCB0aGlzIGR1cmluZyB0aGUgaW5pdGlhbCBsb2FkXG4vLyBBbHRob3VnaCBmb3IgdGhlIHRlc3RzIEkgZ3Vlc3Mgd2Ugd291bGQgbmVlZCB0byBvdmVycmlkZSBjYWNoaW5nIHNvbWVob3dcbmZ1bmN0aW9uIGdldEhhc2hQYXJhbShrZXkpIHtcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIGlmIChoYXNoICE9PSAnJykge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSBpcyBzb21ldGhpbmcgdGhhdCBsb29rcyBsaWtlIGVpdGhlciAma2V5PSBvciAja2V5PVxuICAgICAgICB2YXIgc3RhcnRJbmRleCA9IChoYXNoLmluZGV4T2YoJyYnICsga2V5ICsgJz0nKSA+IDApID8gaGFzaC5pbmRleE9mKCcmJyArIGtleSArICc9JykgOiBoYXNoLmluZGV4T2YoJyMnICsga2V5ICsgJz0nKTtcblxuICAgICAgICAvLyBJZiBzdGFydEluZGV4IGlzIHN0aWxsIC0xLCBpdCBtZWFucyBpdCBjYW4ndCBmaW5kIGVpdGhlclxuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxlbmd0aCBvZiB0aGUga2V5IHBsdXMgdGhlICYgYW5kID1cbiAgICAgICAgICAgIHN0YXJ0SW5kZXggKz0ga2V5Lmxlbmd0aCArIDI7XG5cbiAgICAgICAgICAgIC8vIEVpdGhlciB0byB0aGUgbmV4dCBhbXBlcnNhbmQgb3IgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5nXG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBoYXNoLmluZGV4T2YoJyYnLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChlbmRJbmRleCA+IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2guc3Vic3RyaW5nKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVuZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhpcyBoYXNoIHBhcmFtIGlzIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaGFzaC5zdWJzdHJpbmcoc3RhcnRJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGtleSBkb2Vzbid0IGhhdmUgYSB2YWx1ZSBJIHRoaW5rXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBjYW4ndCBmaW5kIHRoZSBrZXlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBoYXNoIHBhcmFtcyBqdXN0IHJldHVybiBmYWxzZVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIYXNoUGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgIC8vIEZpcnN0IG1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55IHdvcmsgYXQgYWxsXG4gICAgdmFyIG9yaWdpbmFsVmFsdWUgPSBnZXRIYXNoUGFyYW0oa2V5KTtcbiAgICB2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuICAgIGlmIChvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAvLyBJcyB0aGUga2V5IGFscmVhZHkgaW4gdGhlIFVSTD9cbiAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGluIHRoZSBVUkwuIEp1c3QgZ2V0IHJpZCBvZiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gKGhhc2guaW5kZXhPZignJicgKyBrZXkgKyAnPScpID4gMCkgPyBoYXNoLmluZGV4T2YoJyYnICsga2V5ICsgJz0nKSA6IGhhc2guaW5kZXhPZignIycgKyBrZXkgKyAnPScpO1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGtleS5sZW5ndGggKyAyICsgb3JpZ2luYWxWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAvLyAjIGlmIGl0J3MgdGhlIGZpcnN0LCAmIG90aGVyd2lzZVxuICAgICAgICAgICAgdmFyIHN0YXJ0VGhpbmcgPSAoc3RhcnRJbmRleCA9PT0gMCkgPyAnIycgOiAnJic7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShoYXNoLnN1YnN0cmluZygwLCBzdGFydEluZGV4KSArIHN0YXJ0VGhpbmcgKyBrZXkgKyAnPScgKyB2YWx1ZSArIGhhc2guc3Vic3RyaW5nKGVuZEluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdCdzIG5vdCBwcmVzZW50IC0gYWRkIGl0XG4gICAgICAgICAgICBpZiAoaGFzaC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSgnIycgKyBrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBpdFxuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKGhhc2ggKyAnJicgKyBrZXkgKyAnPScgKyB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy91dGlscy9oYXNoLXBhcmFtcy5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xuXG4vL1VzZWQgdG8ga2VlcCB0cmFjayBvZiB3aGV0aGVyIERpdmEgd2FzIGxhc3QgY2xpY2tlZCBvciB3aGljaCBEaXZhIHdhcyBsYXN0IGNsaWNrZWQgd2hlbiB0aGVyZSBhcmUgbXVsdGlwbGVcbnZhciBBY3RpdmVEaXZhQ29udHJvbGxlciA9IChmdW5jdGlvbiAoJClcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBhY3RpdmU7XG5cbiAgICAgICAgLy9nbG9iYWwgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdXBkYXRlQWN0aXZlKCQoZS50YXJnZXQpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy9wYXJhbWV0ZXIgc2hvdWxkIGFscmVhZHkgYmUgYSBqUXVlcnkgc2VsZWN0b3JcbiAgICAgICAgdmFyIHVwZGF0ZUFjdGl2ZSA9IGZ1bmN0aW9uICh0YXJnZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuZWFyZXN0T3V0ZXI7XG5cbiAgICAgICAgICAgIC8vdGhlc2Ugd2lsbCBmaW5kIDAgb3IgMSBvYmplY3RzLCBuZXZlciBtb3JlXG4gICAgICAgICAgICB2YXIgZmluZE91dGVyID0gdGFyZ2V0LmZpbmQoJy5kaXZhLW91dGVyJyk7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdE91dGVyID0gdGFyZ2V0LmNsb3Nlc3QoJy5kaXZhLW91dGVyJyk7XG4gICAgICAgICAgICB2YXIgb3V0ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGl2YS1vdXRlcicpO1xuICAgICAgICAgICAgdmFyIG91dGVyTGVuID0gb3V0ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBpZHg7XG5cbiAgICAgICAgICAgIC8vY2xpY2tlZCBvbiBzb21ldGhpbmcgdGhhdCB3YXMgbm90IGVpdGhlciBhIHBhcmVudCBvciBzaWJsaW5nIG9mIGEgZGl2YS1vdXRlclxuICAgICAgICAgICAgaWYgKGZpbmRPdXRlci5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5lYXJlc3RPdXRlciA9IGZpbmRPdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY2xpY2tlZCBvbiBzb21ldGhpbmcgdGhhdCB3YXMgYSBjaGlsZCBvZiBhIGRpdmEtb3V0ZXJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNsb3Nlc3RPdXRlci5sZW5ndGggPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5lYXJlc3RPdXRlciA9IGNsb3Nlc3RPdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vY2xpY2tlZCBvbiBzb21ldGhpbmcgdGhhdCB3YXMgbm90IGluIGFueSBEaXZhIHRyZWVcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL2RlYWN0aXZhdGUgZXZlcnl0aGluZyBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgZm9yIChpZHggPSAwOyBpZHggPCBvdXRlckxlbjsgaWR4KyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKG91dGVyc1tpZHhdLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCkuZGF0YSgnZGl2YScpLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2lmIHdlIGZvdW5kIG9uZSwgYWN0aXZhdGUgaXQuLi5cbiAgICAgICAgICAgIG5lYXJlc3RPdXRlci5wYXJlbnQoKS5wYXJlbnQoKS5kYXRhKCdkaXZhJykuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIGFjdGl2ZSA9IG5lYXJlc3RPdXRlci5wYXJlbnQoKTtcblxuICAgICAgICAgICAgLy8uLi5hbmQgZGVhY3RpdmF0ZSBhbGwgdGhlIG90aGVyc1xuICAgICAgICAgICAgb3V0ZXJzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGl2YS1vdXRlcicpO1xuICAgICAgICAgICAgZm9yKGlkeCA9IDA7IGlkeCA8IG91dGVyTGVuOyBpZHgrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL2dldEF0dHJpYnV0ZSB0byBhdHRyIC0gY29tcGFyaW5nIERPTSBlbGVtZW50IHRvIGpRdWVyeSBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKG91dGVyc1tpZHhdLmdldEF0dHJpYnV0ZSgnaWQnKSAhPSBuZWFyZXN0T3V0ZXIuYXR0cignaWQnKSlcbiAgICAgICAgICAgICAgICAgICAgJChvdXRlcnNbaWR4XS5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQpLmRhdGEoJ2RpdmEnKS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy9wdWJsaWMgYWNjZXNzb3IgaW4gY2FzZS4gV2lsbCByZXR1cm4gYSBqUXVlcnkgc2VsZWN0b3IuXG4gICAgICAgIHRoaXMuZ2V0QWN0aXZlID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlO1xuICAgICAgICB9O1xuICAgIH07XG59KShqUXVlcnkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFjdGl2ZURpdmFDb250cm9sbGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvYWN0aXZlLWRpdmEtY29udHJvbGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoganNoaW50IHVudXNlZDogdHJ1ZSAqL1xuXG52YXIgcGFyc2VJSUlGTWFuaWZlc3QgPSByZXF1aXJlKCcuL3BhcnNlLWlpaWYtbWFuaWZlc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZU1hbmlmZXN0O1xuXG5mdW5jdGlvbiBJbWFnZU1hbmlmZXN0KGRhdGEsIHVybEFkYXB0ZXIpXG57XG4gICAgLy8gU2F2ZSBhbGwgdGhlIGRhdGEgd2UgbmVlZFxuICAgIHRoaXMucGFnZXMgPSBkYXRhLnBncztcbiAgICB0aGlzLm1heFpvb20gPSBkYXRhLm1heF96b29tO1xuICAgIHRoaXMubWF4UmF0aW8gPSBkYXRhLmRpbXMubWF4X3JhdGlvO1xuICAgIHRoaXMubWluUmF0aW8gPSBkYXRhLmRpbXMubWluX3JhdGlvO1xuICAgIHRoaXMuaXRlbVRpdGxlID0gZGF0YS5pdGVtX3RpdGxlO1xuXG4gICAgLy8gT25seSBnaXZlbiBmb3IgSUlJRiBtYW5pZmVzdHNcbiAgICB0aGlzLnBhZ2VkID0gISFkYXRhLnBhZ2VkO1xuXG4gICAgLy8gVGhlc2UgYXJlIGFycmF5cywgdGhlIGluZGV4IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHpvb20gbGV2ZWxcbiAgICB0aGlzLl9tYXhXaWR0aHMgPSBkYXRhLmRpbXMubWF4X3c7XG4gICAgdGhpcy5fbWF4SGVpZ2h0cyA9IGRhdGEuZGltcy5tYXhfaDtcbiAgICB0aGlzLl9hdmVyYWdlV2lkdGhzID0gZGF0YS5kaW1zLmFfd2lkO1xuICAgIHRoaXMuX2F2ZXJhZ2VIZWlnaHRzID0gZGF0YS5kaW1zLmFfaGVpO1xuICAgIHRoaXMuX3RvdGFsSGVpZ2h0cyA9IGRhdGEuZGltcy50X2hlaTtcbiAgICB0aGlzLl90b3RhbFdpZHRocyA9IGRhdGEuZGltcy50X3dpZDtcblxuICAgIHRoaXMuX3VybEFkYXB0ZXIgPSB1cmxBZGFwdGVyO1xufVxuXG5JbWFnZU1hbmlmZXN0LmZyb21JSUlGID0gZnVuY3Rpb24gKGlpaWZNYW5pZmVzdClcbntcbiAgICB2YXIgZGF0YSA9IHBhcnNlSUlJRk1hbmlmZXN0KGlpaWZNYW5pZmVzdCk7XG4gICAgcmV0dXJuIG5ldyBJbWFnZU1hbmlmZXN0KGRhdGEsIG5ldyBJSUlGU291cmNlQWRhcHRlcigpKTtcbn07XG5cbkltYWdlTWFuaWZlc3QuZnJvbUxlZ2FjeU1hbmlmZXN0ID0gZnVuY3Rpb24gKGRhdGEsIGNvbmZpZylcbntcbiAgICAvLyBGb3IgSUlQIG1hbmlmZXN0cywgdXNlIHRoZSBwYWdlIG51bWJlciAoaW5kZXhlZCBzdGFydGluZyBmcm9tIDEpIGFzIGEgbGFiZWwgZm9yIGVhY2ggcGFnZVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLnBncy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgZGF0YS5wZ3NbaV0ubCA9IChpICsgMSkudG9TdHJpbmcoKTtcblxuICAgIHJldHVybiBuZXcgSW1hZ2VNYW5pZmVzdChkYXRhLCBuZXcgTGVnYWN5TWFuaWZlc3RTb3VyY2VBZGFwdGVyKGNvbmZpZykpO1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuaXNQYWdlVmFsaWQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzaG93Tm9uUGFnZWRQYWdlcylcbntcbiAgICBpZiAoIXNob3dOb25QYWdlZFBhZ2VzICYmIHRoaXMucGFnZWQgJiYgIXRoaXMucGFnZXNbcGFnZUluZGV4XS5wYWdlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHBhZ2VJbmRleCA+PSAwICYmIHBhZ2VJbmRleCA8IHRoaXMucGFnZXMubGVuZ3RoO1xufTtcblxuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0TWF4UGFnZURpbWVuc2lvbnMgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIHZhciBtYXhEaW1zID0gdGhpcy5wYWdlc1twYWdlSW5kZXhdLmRbdGhpcy5tYXhab29tXTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogbWF4RGltcy5oLFxuICAgICAgICB3aWR0aDogbWF4RGltcy53XG4gICAgfTtcbn07XG5cbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldFBhZ2VEaW1lbnNpb25zQXRab29tTGV2ZWwgPSBmdW5jdGlvbiAocGFnZUluZGV4LCB6b29tTGV2ZWwpXG57XG4gICAgdmFyIG1heERpbXMgPSB0aGlzLnBhZ2VzW3BhZ2VJbmRleF0uZFt0aGlzLm1heFpvb21dO1xuXG4gICAgdmFyIHNjYWxlUmF0aW8gPSBnZXRTY2FsZVJhdGlvKHRoaXMubWF4Wm9vbSwgem9vbUxldmVsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogbWF4RGltcy5oICogc2NhbGVSYXRpbyxcbiAgICAgICAgd2lkdGg6IG1heERpbXMudyAqIHNjYWxlUmF0aW9cbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgVVJMIGZvciB0aGUgaW1hZ2Ugb2YgdGhlIGdpdmVuIHBhZ2UuIFRoZSBvcHRpb25hbCBzaXplXG4gKiBwYXJhbWV0ZXIgc3VwcG9ydHMgc2V0dGluZyB0aGUgaW1hZ2Ugd2lkdGggb3IgaGVpZ2h0IChkZWZhdWx0IGlzXG4gKiBmdWxsLXNpemVkKS5cbiAqL1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0UGFnZUltYWdlVVJMID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2l6ZSlcbntcbiAgICByZXR1cm4gdGhpcy5fdXJsQWRhcHRlci5nZXRQYWdlSW1hZ2VVUkwodGhpcywgcGFnZUluZGV4LCBzaXplKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IG9mIHRpbGUgb2JqZWN0cyBmb3IgdGhlIHNwZWNpZmllZCBwYWdlIGFuZCBpbnRlZ2VyIHpvb20gbGV2ZWxcbiAqL1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0UGFnZUltYWdlVGlsZXMgPSBmdW5jdGlvbiAocGFnZUluZGV4LCB6b29tTGV2ZWwsIHRpbGVEaW1lbnNpb25zKVxue1xuICAgIHZhciBwYWdlID0gdGhpcy5wYWdlc1twYWdlSW5kZXhdO1xuXG4gICAgaWYgKCFpc0Zpbml0ZSh6b29tTGV2ZWwpIHx8IHpvb21MZXZlbCAlIDEgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1pvb20gbGV2ZWwgbXVzdCBiZSBhbiBpbnRlZ2VyOiAnICsgem9vbUxldmVsKTtcblxuICAgIHZhciByb3dzID0gTWF0aC5jZWlsKHBhZ2UuZFt6b29tTGV2ZWxdLmggLyB0aWxlRGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIHZhciBjb2xzID0gTWF0aC5jZWlsKHBhZ2UuZFt6b29tTGV2ZWxdLncgLyB0aWxlRGltZW5zaW9ucy53aWR0aCk7XG5cbiAgICB2YXIgdGlsZXMgPSBbXTtcblxuICAgIHZhciByb3csIGNvbCwgdXJsO1xuXG4gICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dzOyByb3crKylcbiAgICB7XG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgY29sczsgY29sKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHVybCA9IHRoaXMuX3VybEFkYXB0ZXIuZ2V0VGlsZUltYWdlVVJMKHRoaXMsIHBhZ2VJbmRleCwge1xuICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgIGNvbDogY29sLFxuICAgICAgICAgICAgICAgIHJvd0NvdW50OiByb3dzLFxuICAgICAgICAgICAgICAgIGNvbENvdW50OiBjb2xzLFxuICAgICAgICAgICAgICAgIHpvb21MZXZlbDogem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIHRpbGVEaW1lbnNpb25zOiB0aWxlRGltZW5zaW9uc1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZJWE1FOiBEaW1lbnNpb25zIHNob3VsZCBhY2NvdW50IGZvciBwYXJ0aWFsIHRpbGVzIChlLmcuIHRoZVxuICAgICAgICAgICAgLy8gbGFzdCByb3cgYW5kIGNvbHVtbiBpbiBhIHRpbGVkIGltYWdlKVxuICAgICAgICAgICAgdGlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcm93OiByb3csXG4gICAgICAgICAgICAgICAgY29sOiBjb2wsXG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHRpbGVEaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRpbGVEaW1lbnNpb25zLndpZHRoXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiByb3cgKiB0aWxlRGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbCAqIHRpbGVEaW1lbnNpb25zLndpZHRoXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB6b29tTGV2ZWw6IHpvb21MZXZlbCxcbiAgICAgICAgcm93czogcm93cyxcbiAgICAgICAgY29sczogY29scyxcbiAgICAgICAgdGlsZXM6IHRpbGVzXG4gICAgfTtcbn07XG5cbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldE1heFdpZHRoID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ19tYXhXaWR0aHMnKTtcbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldE1heEhlaWdodCA9IHpvb21lZFByb3BlcnR5R2V0dGVyKCdfbWF4SGVpZ2h0cycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0QXZlcmFnZVdpZHRoID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ19hdmVyYWdlV2lkdGhzJyk7XG5JbWFnZU1hbmlmZXN0LnByb3RvdHlwZS5nZXRBdmVyYWdlSGVpZ2h0ID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ19hdmVyYWdlSGVpZ2h0cycpO1xuSW1hZ2VNYW5pZmVzdC5wcm90b3R5cGUuZ2V0VG90YWxXaWR0aCA9IHpvb21lZFByb3BlcnR5R2V0dGVyKCdfdG90YWxXaWR0aHMnKTtcbkltYWdlTWFuaWZlc3QucHJvdG90eXBlLmdldFRvdGFsSGVpZ2h0ID0gem9vbWVkUHJvcGVydHlHZXR0ZXIoJ190b3RhbEhlaWdodHMnKTtcblxuZnVuY3Rpb24gem9vbWVkUHJvcGVydHlHZXR0ZXIocHJpdmF0ZU5hbWUpXG57XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh6b29tTGV2ZWwpXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpc1twcml2YXRlTmFtZV1bem9vbUxldmVsXTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZVJhdGlvKHNvdXJjZVpvb21MZXZlbCwgdGFyZ2V0Wm9vbUxldmVsKVxue1xuICAgIHJldHVybiAxIC8gTWF0aC5wb3coMiwgc291cmNlWm9vbUxldmVsIC0gdGFyZ2V0Wm9vbUxldmVsKTtcbn1cblxuZnVuY3Rpb24gSUlJRlNvdXJjZUFkYXB0ZXIoKVxue1xuICAgIC8vIE5vLW9wXG59XG5cbklJSUZTb3VyY2VBZGFwdGVyLnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VVUkwgPSBmdW5jdGlvbiAobWFuaWZlc3QsIHBhZ2VJbmRleCwgc2l6ZSlcbntcbiAgICB2YXIgZGltZW5zO1xuXG4gICAgaWYgKCFzaXplIHx8IChzaXplLndpZHRoID09IG51bGwgJiYgc2l6ZS5oZWlnaHQgPT0gbnVsbCkpXG4gICAgICAgIGRpbWVucyA9ICdmdWxsJztcbiAgICBlbHNlXG4gICAgICAgIGRpbWVucyA9IChzaXplLndpZHRoID09IG51bGwgPyAnJyA6IHNpemUud2lkdGgpICsgJywnICsgKHNpemUuaGVpZ2h0ID09IG51bGwgPyAnJyA6IHNpemUuaGVpZ2h0KTtcblxuICAgIHZhciBwYWdlID0gbWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XTtcbiAgICB2YXIgcXVhbGl0eSA9IChwYWdlLmFwaSA+IDEuMSkgPyAnZGVmYXVsdCcgOiAnbmF0aXZlJztcblxuICAgIHJldHVybiBlbmNvZGVVUkkocGFnZS51cmwgKyAnZnVsbC8nICsgZGltZW5zICsgJy8wLycgKyBxdWFsaXR5ICsgJy5qcGcnKTtcbn07XG5cbklJSUZTb3VyY2VBZGFwdGVyLnByb3RvdHlwZS5nZXRUaWxlSW1hZ2VVUkwgPSBmdW5jdGlvbiAobWFuaWZlc3QsIHBhZ2VJbmRleCwgcGFyYW1zKVxue1xuICAgIHZhciBwYWdlID0gbWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XTtcblxuICAgIHZhciBoZWlnaHQsIHdpZHRoO1xuXG4gICAgaWYgKHBhcmFtcy5yb3cgPT09IHBhcmFtcy5yb3dDb3VudCAtIDEpXG4gICAgICAgIGhlaWdodCA9IHBhZ2UuZFtwYXJhbXMuem9vbUxldmVsXS5oIC0gKHBhcmFtcy5yb3dDb3VudCAtIDEpICogcGFyYW1zLnRpbGVEaW1lbnNpb25zLmhlaWdodDtcbiAgICBlbHNlXG4gICAgICAgIGhlaWdodCA9IHBhcmFtcy50aWxlRGltZW5zaW9ucy5oZWlnaHQ7XG5cbiAgICBpZiAocGFyYW1zLmNvbCA9PT0gcGFyYW1zLmNvbENvdW50IC0gMSlcbiAgICAgICAgd2lkdGggPSBwYWdlLmRbcGFyYW1zLnpvb21MZXZlbF0udyAtIChwYXJhbXMuY29sQ291bnQgLSAxKSAqIHBhcmFtcy50aWxlRGltZW5zaW9ucy53aWR0aDtcbiAgICBlbHNlXG4gICAgICAgIHdpZHRoID0gcGFyYW1zLnRpbGVEaW1lbnNpb25zLndpZHRoO1xuXG4gICAgdmFyIHpvb21EaWZmZXJlbmNlID0gTWF0aC5wb3coMiwgbWFuaWZlc3QubWF4Wm9vbSAtIHBhcmFtcy56b29tTGV2ZWwpO1xuXG4gICAgdmFyIHggPSBwYXJhbXMuY29sICogcGFyYW1zLnRpbGVEaW1lbnNpb25zLndpZHRoICogem9vbURpZmZlcmVuY2U7XG4gICAgdmFyIHkgPSBwYXJhbXMucm93ICogcGFyYW1zLnRpbGVEaW1lbnNpb25zLmhlaWdodCAqIHpvb21EaWZmZXJlbmNlO1xuXG4gICAgaWYgKHBhZ2UuaGFzT3duUHJvcGVydHkoJ3hvZmZzZXQnKSlcbiAgICB7XG4gICAgICAgIHggKz0gcGFnZS54b2Zmc2V0O1xuICAgICAgICB5ICs9IHBhZ2UueW9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgcmVnaW9uID0gW3gsIHksIHdpZHRoICogem9vbURpZmZlcmVuY2UsIGhlaWdodCAqIHpvb21EaWZmZXJlbmNlXS5qb2luKCcsJyk7XG5cbiAgICB2YXIgcXVhbGl0eSA9IChwYWdlLmFwaSA+IDEuMSkgPyAnZGVmYXVsdCcgOiAnbmF0aXZlJztcblxuICAgIHJldHVybiBlbmNvZGVVUkkocGFnZS51cmwgKyByZWdpb24gKyAnLycgKyB3aWR0aCArICcsJyArIGhlaWdodCArICcvMC8nICsgcXVhbGl0eSArICcuanBnJyk7XG59O1xuXG5mdW5jdGlvbiBMZWdhY3lNYW5pZmVzdFNvdXJjZUFkYXB0ZXIoY29uZmlnKVxue1xuICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbn1cblxuTGVnYWN5TWFuaWZlc3RTb3VyY2VBZGFwdGVyLnByb3RvdHlwZS5nZXRQYWdlSW1hZ2VVUkwgPSBmdW5jdGlvbiAobWFuaWZlc3QsIHBhZ2VJbmRleCwgc2l6ZSlcbntcbiAgICAvLyBXaXRob3V0IHdpZHRoIG9yIGhlaWdodCBzcGVjaWZpZWQsIElJUEltYWdlIGRlZmF1bHRzIHRvIGZ1bGwtc2l6ZVxuICAgIHZhciBkaW1lbnMgPSAnJztcblxuICAgIGlmIChzaXplKVxuICAgIHtcbiAgICAgICAgaWYgKHNpemUud2lkdGggIT0gbnVsbClcbiAgICAgICAgICAgIGRpbWVucyArPSAnJldJRD0nICsgc2l6ZS53aWR0aDtcblxuICAgICAgICBpZiAoc2l6ZS5oZWlnaHQgIT0gbnVsbClcbiAgICAgICAgICAgIGRpbWVucyArPSAnJkhFST0nICsgc2l6ZS5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdmFyIGZpbGVuYW1lID0gbWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XS5mO1xuXG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5paXBTZXJ2ZXJVUkwgKyBcIj9GSUY9XCIgKyB0aGlzLl9jb25maWcuaW1hZ2VEaXIgKyAnLycgKyBmaWxlbmFtZSArIGRpbWVucyArICcmQ1ZUPUpQRUcnO1xufTtcblxuTGVnYWN5TWFuaWZlc3RTb3VyY2VBZGFwdGVyLnByb3RvdHlwZS5nZXRUaWxlSW1hZ2VVUkwgPSBmdW5jdGlvbiAobWFuaWZlc3QsIHBhZ2VJbmRleCwgcGFyYW1zKVxue1xuICAgIHZhciBwYWdlID0gbWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XTtcbiAgICB2YXIgcmVxdWVzdGVkWm9vbUxldmVsID0gcGFyYW1zLnpvb21MZXZlbCArIHBhZ2UubSAtIG1hbmlmZXN0Lm1heFpvb207XG4gICAgdmFyIGluZGV4ID0gKHBhcmFtcy5yb3cgKiBwYXJhbXMuY29sQ291bnQpICsgcGFyYW1zLmNvbDtcbiAgICB2YXIganRsID0gcmVxdWVzdGVkWm9vbUxldmVsICsgJywnICsgaW5kZXg7XG5cbiAgICByZXR1cm4gZW5jb2RlVVJJKHRoaXMuX2NvbmZpZy5paXBTZXJ2ZXJVUkwgKyBcIj9GSUY9XCIgKyB0aGlzLl9jb25maWcuaW1hZ2VEaXIgKyAnLycgKyBwYWdlLmYgKyAnJkpUTD0nICsganRsICsgJyZDVlQ9SlBFRycpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2ltYWdlLW1hbmlmZXN0LmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgdW51c2VkOiB0cnVlICovXG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VJSUlGTWFuaWZlc3Q7XG5cbnZhciBnZXRNYXhab29tTGV2ZWwgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodClcbntcbiAgICB2YXIgbGFyZ2VzdERpbWVuc2lvbiA9IE1hdGgubWF4KHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2coKGxhcmdlc3REaW1lbnNpb24gKyAxKSAvICgyNTYgKyAxKSkgLyBNYXRoLmxvZygyKSk7XG59O1xuXG52YXIgaW5jb3Jwb3JhdGVab29tID0gZnVuY3Rpb24gKGltYWdlRGltZW5zaW9uLCB6b29tRGlmZmVyZW5jZSlcbntcbiAgICByZXR1cm4gaW1hZ2VEaW1lbnNpb24gLyAoTWF0aC5wb3coMiwgem9vbURpZmZlcmVuY2UpKTtcbn07XG5cbnZhciBnZXRPdGhlckltYWdlRGF0YSA9IGZ1bmN0aW9uKG90aGVySW1hZ2VzLCBsb3dlc3RNYXhab29tLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KVxue1xuICAgIHJldHVybiBvdGhlckltYWdlcy5tYXAoXG4gICAgICAgIGZ1bmN0aW9uIChpdG0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB3ID0gaXRtLndpZHRoIHx8IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgdmFyIGggPSBpdG0uaGVpZ2h0IHx8IGNhbnZhc0hlaWdodDtcblxuICAgICAgICAgICAgdmFyIGRpbXMgPSBuZXcgQXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsb3dlc3RNYXhab29tICsgMTsgaisrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRpbXNbal0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGg6IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKGgsIGxvd2VzdE1heFpvb20gLSBqKSksXG4gICAgICAgICAgICAgICAgICAgIHc6IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKHcsIGxvd2VzdE1heFpvb20gLSBqKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogaXRtLmxhYmVsIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgZGltczogZGltc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIElJSUYgUHJlc2VudGF0aW9uIEFQSSBNYW5pZmVzdCBhbmQgY29udmVydHMgaXQgaW50byBhIERpdmEuanMtZm9ybWF0IG9iamVjdFxuICogKFNlZSBodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL0RldmVsb3BtZW50LW5vdGVzI2RhdGEtcmVjZWl2ZWQtdGhyb3VnaC1hamF4LXJlcXVlc3QpXG4gKiAoVGhpcyBpcyBhIGNsaWVudC1zaWRlIHJlLWltcGxlbWVudGF0aW9uIG9mIGdlbmVyYXRlX2pzb24ucHkpXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1hbmlmZXN0IC0gYW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIHZhbGlkIElJSUYgbWFuaWZlc3RcbiAqIEByZXR1cm5zIHtPYmplY3R9IGRpdmFTZXJ2aWNlQmxvY2sgLSB0aGUgZGF0YSBuZWVkZWQgYnkgRGl2YSB0byBzaG93IGEgdmlldyBvZiBhIHNpbmdsZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBwYXJzZUlJSUZNYW5pZmVzdChtYW5pZmVzdClcbntcbiAgICB2YXIgc2VxdWVuY2UgPSBtYW5pZmVzdC5zZXF1ZW5jZXNbMF07XG4gICAgdmFyIGNhbnZhc2VzID0gc2VxdWVuY2UuY2FudmFzZXM7XG4gICAgdmFyIG51bUNhbnZhc2VzID0gY2FudmFzZXMubGVuZ3RoO1xuXG4gICAgdmFyIHBhZ2VzID0gbmV3IEFycmF5KGNhbnZhc2VzLmxlbmd0aCk7XG5cbiAgICB2YXIgdGhpc0NhbnZhcywgdGhpc1Jlc291cmNlLCB0aGlzSW1hZ2UsIG90aGVySW1hZ2VzLCBjb250ZXh0LCB1cmwsIGluZm8sIGltYWdlQVBJVmVyc2lvbixcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgY2FudmFzLCBsYWJlbCwgaW1hZ2VMYWJlbCwgem9vbURpbWVuc2lvbnMsIHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsLFxuICAgICAgICBoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWw7XG5cbiAgICB2YXIgbG93ZXN0TWF4Wm9vbSA9IDEwMDtcbiAgICB2YXIgbWF4UmF0aW8gPSAwO1xuICAgIHZhciBtaW5SYXRpbyA9IDEwMDtcblxuICAgIC8vIHF1aWNrbHkgZGV0ZXJtaW5lIHRoZSBsb3dlc3QgcG9zc2libGUgbWF4IHpvb20gbGV2ZWwgKGkuZS4sIHRoZSB1cHBlciBib3VuZCBmb3IgaW1hZ2VzKSBhY3Jvc3MgYWxsIGNhbnZhc2VzLlxuICAgIC8vIHdoaWxlIHdlJ3JlIGhlcmUsIGNvbXB1dGUgdGhlIGdsb2JhbCByYXRpb3MgYXMgd2VsbC5cbiAgICBmb3IgKHZhciB6ID0gMDsgeiA8IG51bUNhbnZhc2VzOyB6KyspXG4gICAge1xuICAgICAgICB2YXIgYyA9IGNhbnZhc2VzW3pdO1xuICAgICAgICB2YXIgdyA9IGMud2lkdGg7XG4gICAgICAgIHZhciBoID0gYy5oZWlnaHQ7XG4gICAgICAgIHZhciBteiA9IGdldE1heFpvb21MZXZlbCh3LCBoKTtcbiAgICAgICAgdmFyIHJhdGlvID0gaCAvIHc7XG4gICAgICAgIG1heFJhdGlvID0gTWF0aC5tYXgocmF0aW8sIG1heFJhdGlvKTtcbiAgICAgICAgbWluUmF0aW8gPSBNYXRoLm1pbihyYXRpbywgbWluUmF0aW8pO1xuXG4gICAgICAgIGxvd2VzdE1heFpvb20gPSBNYXRoLm1pbihsb3dlc3RNYXhab29tLCBteik7XG4gICAgfVxuXG4gICAgLy8gVWludDhBcnJheXMgYXJlIHByZS1pbml0aWFsaXplZCB3aXRoIHplcm9lcy4gVGhlc2Ugb25lcyBuZWVkIHRvIGJlXG4gICAgLy8gcHJlLWluaXRpYWxpemVkIHNpbmNlIHdlIHdpbGwgZG8gYXJpdGhtZXRpYyBhbmQgdmFsdWUgY2hlY2tpbmcgb24gdGhlbVxuICAgIHZhciB0b3RhbFdpZHRocyA9IG5ldyBBcnJheShsb3dlc3RNYXhab29tICsgMSkuZmlsbCgwKTtcbiAgICB2YXIgdG90YWxIZWlnaHRzID0gbmV3IEFycmF5KGxvd2VzdE1heFpvb20gKyAxKS5maWxsKDApO1xuICAgIHZhciBtYXhXaWR0aHMgPSBuZXcgQXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpLmZpbGwoMCk7XG4gICAgdmFyIG1heEhlaWdodHMgPSBuZXcgQXJyYXkobG93ZXN0TWF4Wm9vbSArIDEpLmZpbGwoMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNhbnZhc2VzOyBpKyspXG4gICAge1xuICAgICAgICB0aGlzQ2FudmFzID0gY2FudmFzZXNbaV07XG4gICAgICAgIGNhbnZhcyA9IHRoaXNDYW52YXNbJ0BpZCddO1xuICAgICAgICBsYWJlbCA9IHRoaXNDYW52YXMubGFiZWw7XG4gICAgICAgIHRoaXNSZXNvdXJjZSA9IHRoaXNDYW52YXMuaW1hZ2VzWzBdLnJlc291cmNlO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIGEgY2FudmFzIGhhcyBtdWx0aXBsZSBpbWFnZXMgaXQgd2lsbCBiZSBlbmNvZGVkXG4gICAgICAgICAqIHdpdGggYSByZXNvdXJjZSB0eXBlIG9mIFwib2E6Q2hvaWNlXCIuIFRoZSBwcmltYXJ5IGltYWdlIHdpbGwgYmUgYXZhaWxhYmxlXG4gICAgICAgICAqIG9uIHRoZSAnZGVmYXVsdCcga2V5LCB3aXRoIG90aGVyIGltYWdlcyBhdmFpbGFibGUgdW5kZXIgJ2l0ZW0uJ1xuICAgICAgICAgKiAqL1xuICAgICAgICBpZiAodGhpc1Jlc291cmNlWydAdHlwZSddID09PSBcIm9hOkNob2ljZVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzSW1hZ2UgPSB0aGlzUmVzb3VyY2UuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXNJbWFnZSA9IHRoaXNSZXNvdXJjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByaW9yaXRpemUgdGhlIGNhbnZhcyBoZWlnaHQgLyB3aWR0aCBmaXJzdCwgc2luY2UgaW1hZ2VzIG1heSBub3QgaGF2ZSBoL3dcbiAgICAgICAgd2lkdGggPSB0aGlzQ2FudmFzLndpZHRoIHx8IHRoaXNJbWFnZS53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpc0NhbnZhcy5oZWlnaHQgfHwgdGhpc0ltYWdlLmhlaWdodDtcbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignSW52YWxpZCB3aWR0aCBvciBoZWlnaHQgZm9yIGNhbnZhcyAnICsgbGFiZWwgKyAnLiBTa2lwcGluZycpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBtYXhab29tID0gZ2V0TWF4Wm9vbUxldmVsKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzUmVzb3VyY2UuaXRlbSlcbiAgICAgICAge1xuICAgICAgICAgICAgb3RoZXJJbWFnZXMgPSBnZXRPdGhlckltYWdlRGF0YSh0aGlzUmVzb3VyY2UuaXRlbSwgbG93ZXN0TWF4Wm9vbSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZUxhYmVsID0gdGhpc0ltYWdlLmxhYmVsIHx8IG51bGw7XG5cbiAgICAgICAgaW5mbyA9IHBhcnNlSW1hZ2VJbmZvKHRoaXNJbWFnZSk7XG4gICAgICAgIHVybCA9IGluZm8udXJsLnNsaWNlKC0xKSAhPT0gJy8nID8gaW5mby51cmwgKyAnLycgOiBpbmZvLnVybDsgIC8vIGFwcGVuZCB0cmFpbGluZyBzbGFzaCB0byB1cmwgaWYgaXQncyBub3QgdGhlcmUuXG5cbiAgICAgICAgY29udGV4dCA9IHRoaXNJbWFnZS5zZXJ2aWNlWydAY29udGV4dCddO1xuXG4gICAgICAgIGlmIChjb250ZXh0ID09PSAnaHR0cDovL2lpaWYuaW8vYXBpL2ltYWdlLzIvY29udGV4dC5qc29uJylcbiAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2VBUElWZXJzaW9uID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0ID09PSAnaHR0cDovL2xpYnJhcnkuc3RhbmZvcmQuZWR1L2lpaWYvaW1hZ2UtYXBpLzEuMS9jb250ZXh0Lmpzb24nKVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUFQSVZlcnNpb24gPSAxLjE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpbWFnZUFQSVZlcnNpb24gPSAxLjA7XG4gICAgICAgIH1cblxuICAgICAgICB6b29tRGltZW5zaW9ucyA9IG5ldyBBcnJheShsb3dlc3RNYXhab29tICsgMSk7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsb3dlc3RNYXhab29tICsgMTsgaysrKVxuICAgICAgICB7XG4gICAgICAgICAgICB3aWR0aEF0Q3VycmVudFpvb21MZXZlbCA9IE1hdGguZmxvb3IoaW5jb3Jwb3JhdGVab29tKHdpZHRoLCBsb3dlc3RNYXhab29tIC0gaykpO1xuICAgICAgICAgICAgaGVpZ2h0QXRDdXJyZW50Wm9vbUxldmVsID0gTWF0aC5mbG9vcihpbmNvcnBvcmF0ZVpvb20oaGVpZ2h0LCBsb3dlc3RNYXhab29tIC0gaykpO1xuICAgICAgICAgICAgem9vbURpbWVuc2lvbnNba10gPSB7XG4gICAgICAgICAgICAgICAgaDogaGVpZ2h0QXRDdXJyZW50Wm9vbUxldmVsLFxuICAgICAgICAgICAgICAgIHc6IHdpZHRoQXRDdXJyZW50Wm9vbUxldmVsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0b3RhbFdpZHRoc1trXSArPSB3aWR0aEF0Q3VycmVudFpvb21MZXZlbDtcbiAgICAgICAgICAgIHRvdGFsSGVpZ2h0c1trXSArPSBoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWw7XG4gICAgICAgICAgICBtYXhXaWR0aHNba10gPSBNYXRoLm1heCh3aWR0aEF0Q3VycmVudFpvb21MZXZlbCwgbWF4V2lkdGhzW2tdKTtcbiAgICAgICAgICAgIG1heEhlaWdodHNba10gPSBNYXRoLm1heChoZWlnaHRBdEN1cnJlbnRab29tTGV2ZWwsIG1heEhlaWdodHNba10pO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFnZXNbaV0gPSB7XG4gICAgICAgICAgICBkOiB6b29tRGltZW5zaW9ucyxcbiAgICAgICAgICAgIG06IG1heFpvb20sXG4gICAgICAgICAgICBsOiBsYWJlbCwgICAgICAgICAvLyBjYW52YXMgbGFiZWwgKCdwYWdlIDEsIHBhZ2UgMicsIGV0Yy4pXG4gICAgICAgICAgICBpbDogaW1hZ2VMYWJlbCwgICAvLyBkZWZhdWx0IGltYWdlIGxhYmVsICgncHJpbWFyeSBpbWFnZScsICdVViBsaWdodCcsIGV0Yy4pXG4gICAgICAgICAgICBmOiBpbmZvLnVybCxcbiAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgYXBpOiBpbWFnZUFQSVZlcnNpb24sXG4gICAgICAgICAgICBwYWdlZDogdGhpc0NhbnZhcy52aWV3aW5nSGludCAhPT0gJ25vbi1wYWdlZCcsXG4gICAgICAgICAgICBmYWNpbmdQYWdlczogdGhpc0NhbnZhcy52aWV3aW5nSGludCA9PT0gJ2ZhY2luZy1wYWdlcycsXG4gICAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICAgIG90aGVySW1hZ2VzOiBvdGhlckltYWdlcyxcbiAgICAgICAgICAgIHhvZmZzZXQ6IGluZm8ueCB8fCBudWxsLFxuICAgICAgICAgICAgeW9mZnNldDogaW5mby55IHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgYXZlcmFnZVdpZHRocyA9IG5ldyBBcnJheShsb3dlc3RNYXhab29tICsgMSk7XG4gICAgdmFyIGF2ZXJhZ2VIZWlnaHRzID0gbmV3IEFycmF5KGxvd2VzdE1heFpvb20gKyAxKTtcblxuICAgIGZvciAodmFyIGEgPSAwOyBhIDwgbG93ZXN0TWF4Wm9vbSArIDE7IGErKylcbiAgICB7XG4gICAgICAgIGF2ZXJhZ2VXaWR0aHNbYV0gPSB0b3RhbFdpZHRoc1thXSAvIG51bUNhbnZhc2VzO1xuICAgICAgICBhdmVyYWdlSGVpZ2h0c1thXSA9IHRvdGFsSGVpZ2h0c1thXSAvIG51bUNhbnZhc2VzO1xuICAgIH1cblxuICAgIHZhciBkaW1zID0ge1xuICAgICAgICBhX3dpZDogYXZlcmFnZVdpZHRocyxcbiAgICAgICAgYV9oZWk6IGF2ZXJhZ2VIZWlnaHRzLFxuICAgICAgICBtYXhfdzogbWF4V2lkdGhzLFxuICAgICAgICBtYXhfaDogbWF4SGVpZ2h0cyxcbiAgICAgICAgbWF4X3JhdGlvOiBtYXhSYXRpbyxcbiAgICAgICAgbWluX3JhdGlvOiBtaW5SYXRpbyxcbiAgICAgICAgdF9oZWk6IHRvdGFsSGVpZ2h0cyxcbiAgICAgICAgdF93aWQ6IHRvdGFsV2lkdGhzXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1fdGl0bGU6IG1hbmlmZXN0LmxhYmVsLFxuICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICBtYXhfem9vbTogbG93ZXN0TWF4Wm9vbSxcbiAgICAgICAgcGdzOiBwYWdlcyxcbiAgICAgICAgcGFnZWQ6IG1hbmlmZXN0LnZpZXdpbmdIaW50ID09PSAncGFnZWQnIHx8IHNlcXVlbmNlLnZpZXdpbmdIaW50ID09PSAncGFnZWQnXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyBpbiBhIHJlc291cmNlIGJsb2NrIGZyb20gYSBjYW52YXMgYW5kIG91dHB1dHMgdGhlIGZvbGxvd2luZyBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhhdCByZXNvdXJjZTpcbiAqIC0gSW1hZ2UgVVJMXG4gKiAtIEltYWdlIHJlZ2lvbiB0byBiZSBkaXNwbGF5ZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzb3VyY2UgLSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXNvdXJjZSBibG9jayBvZiBhIGNhbnZhcyBzZWN0aW9uIGluIGEgSUlJRiBtYW5pZmVzdFxuICogQHJldHVybnMge09iamVjdH0gaW1hZ2VJbmZvIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW1hZ2UgVVJMIGFuZCByZWdpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbWFnZUluZm8ocmVzb3VyY2UpXG57XG4gICAgdmFyIHVybCA9IHJlc291cmNlWydAaWQnXTtcbiAgICB2YXIgZnJhZ21lbnRSZWdleCA9IC8jeHl3aD0oWzAtOV0rLFswLTldKyxbMC05XSssWzAtOV0rKS87XG4gICAgdmFyIHh5d2ggPSAnJztcbiAgICB2YXIgc3RyaXBVUkwgPSB0cnVlO1xuXG4gICAgaWYgKC9cXC8oWzAtOV0rLFswLTldKyxbMC05XSssWzAtOV0rKVxcLy8udGVzdCh1cmwpKVxuICAgIHtcbiAgICAgICAgLy8gaWYgcmVzb3VyY2UgaW4gaW1hZ2UgQVBJIGZvcm1hdCwgZXh0cmFjdCByZWdpb24geCx5LHcsaCBmcm9tIFVSTCAoYWZ0ZXIgNHRoIHNsYXNoIGZyb20gbGFzdClcbiAgICAgICAgLy8gbWF0Y2hlcyBjb29yZGluYXRlcyBpbiBVUkxzIG9mIHRoZSBmb3JtIGh0dHA6Ly93d3cuZXhhbXBsZS5vcmcvaWlpZi9ib29rMS1wYWdlMS80MCw1MCwxMjAwLDE4MDAvZnVsbC8wL2RlZmF1bHQuanBnXG4gICAgICAgIHZhciB1cmxBcnJheSA9IHVybC5zcGxpdCgnLycpO1xuICAgICAgICB4eXdoID0gdXJsQXJyYXlbdXJsQXJyYXkubGVuZ3RoIC0gNF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYWdtZW50UmVnZXgudGVzdCh1cmwpKVxuICAgIHtcbiAgICAgICAgLy8gbWF0Y2hlcyBjb29yZGluYXRlcyBvZiB0aGUgc3R5bGUgaHR0cDovL3d3dy5leGFtcGxlLm9yZy9paWlmL2Jvb2sxL2NhbnZhcy9wMSN4eXdoPTUwLDUwLDMyMCwyNDBcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZyYWdtZW50UmVnZXguZXhlYyh1cmwpO1xuICAgICAgICB4eXdoID0gcmVzdWx0WzFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXNvdXJjZS5zZXJ2aWNlICYmIHJlc291cmNlLnNlcnZpY2VbJ0BpZCddKVxuICAgIHtcbiAgICAgICAgLy8gYXNzdW1lIGNhbnZhcyBzaXplIGJhc2VkIG9uIGltYWdlIHNpemVcbiAgICAgICAgdXJsID0gcmVzb3VyY2Uuc2VydmljZVsnQGlkJ107XG4gICAgICAgIC8vIHRoaXMgVVJMIGV4Y2x1ZGVzIHJlZ2lvbiBwYXJhbWV0ZXJzIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVtb3ZlIHRoZW1cbiAgICAgICAgc3RyaXBVUkwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaXBVUkwpXG4gICAge1xuICAgICAgICAvLyBleHRyYWN0IFVSTCB1cCB0byBpZGVudGlmaWVyICh3ZSBlbGltaW5hdGUgdGhlIGxhc3QgNSBwYXJhbWV0ZXJzOiAvcmVnaW9uL3NpemUvcm90YXRpb24vcXVhbGl0eS5mb3JtYXQpXG4gICAgICAgIHVybCA9IHVybC5zcGxpdCgnLycpLnNsaWNlKDAsIC00KS5qb2luKCcvJyk7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlSW5mbyA9IHtcbiAgICAgICAgdXJsOiB1cmxcbiAgICB9O1xuXG4gICAgaWYgKHh5d2gubGVuZ3RoKVxuICAgIHtcbiAgICAgICAgLy8gcGFyc2UgaW50byBzZXBhcmF0ZSBjb21wb25lbnRzXG4gICAgICAgIHZhciBkaW1lbnNpb25zID0geHl3aC5zcGxpdCgnLCcpO1xuICAgICAgICBpbWFnZUluZm8ueCA9IHBhcnNlSW50KGRpbWVuc2lvbnNbMF0sIDEwKTtcbiAgICAgICAgaW1hZ2VJbmZvLnkgPSBwYXJzZUludChkaW1lbnNpb25zWzFdLCAxMCk7XG4gICAgICAgIGltYWdlSW5mby53ID0gcGFyc2VJbnQoZGltZW5zaW9uc1syXSwgMTApO1xuICAgICAgICBpbWFnZUluZm8uaCA9IHBhcnNlSW50KGRpbWVuc2lvbnNbM10sIDEwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VJbmZvO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGFyc2UtaWlpZi1tYW5pZmVzdC5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxudmFyIGRpdmEgPSByZXF1aXJlKCcuL2RpdmEtZ2xvYmFsJyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUb29sYmFyO1xuXG5mdW5jdGlvbiBjcmVhdGVUb29sYmFyKHZpZXdlcilcbntcbiAgICB2YXIgc2V0dGluZ3MgPSB2aWV3ZXIuZ2V0U2V0dGluZ3MoKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFRlbXBvcmFyaWx5IGNvcGllZCBmcm9tIHdpdGhpbiBEaXZhXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICAvKiogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc3Vic2NyaWJlIHRvIGEgRGl2YSBldmVudCAqL1xuICAgIHZhciBzdWJzY3JpYmUgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaywgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICAvLyBDcmVhdGVzIGEgdG9vbGJhciBidXR0b25cbiAgICB2YXIgY3JlYXRlQnV0dG9uRWxlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIGxhYmVsLCBjYWxsYmFjaylcbiAgICB7XG4gICAgICAgIHZhciBidXR0b24gPSBlbHQoJ2J1dHRvbicsIHtcbiAgICAgICAgICAgIHR5cGU6ICdidXR0b24nLFxuICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgbmFtZSxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS0nICsgbmFtZSArICcgZGl2YS1idXR0b24nLFxuICAgICAgICAgICAgdGl0bGU6IGxhYmVsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9O1xuXG4gICAgLy8gSGlnaGVyLWxldmVsIGZ1bmN0aW9uIGZvciBjcmVhdG9ycyBvZiB6b29tIGFuZCBncmlkIGNvbnRyb2xzXG4gICAgdmFyIGdldFJlc29sdXRpb25Db250cm9sQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWcpXG4gICAge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzW2NvbmZpZy5jb250cm9sbGVyU2V0dGluZ10pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2xpZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbHMgPSBjb25maWcuY3JlYXRlU2xpZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9ucyc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xzID0gY29uZmlnLmNyZWF0ZUJ1dHRvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkaXNwbGF5IGFueXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd3JhcHBlciA9IGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY29udHJvbHMsXG4gICAgICAgICAgICAgICAgY29uZmlnLmNyZWF0ZUxhYmVsKClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVXcmFwcGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkID09PSBjb25maWcuc2hvd0luR3JpZClcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdEaWRTd2l0Y2gnLCB1cGRhdGVXcmFwcGVyKTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnT2JqZWN0RGlkTG9hZCcsIHVwZGF0ZVdyYXBwZXIpO1xuXG4gICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdXBkYXRlV3JhcHBlcigpO1xuXG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gWm9vbSBjb250cm9sc1xuICAgIHZhciBjcmVhdGVab29tQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZVpvb21Db250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IGZhbHNlLFxuXG4gICAgICAgIGNyZWF0ZVNsaWRlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVTbGlkZXIoJ3pvb20tc2xpZGVyJywge1xuICAgICAgICAgICAgICAgIHN0ZXA6IDAuMSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluWm9vbUxldmVsLFxuICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQoZWxlbSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignY2hhbmdlJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxvYXRWYWx1ZSA9IHBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0VmFsdWUgIT09IHNldHRpbmdzLnpvb21MZXZlbClcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChmbG9hdFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlU2xpZGVyID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muem9vbUxldmVsICE9PSAkZWxlbS52YWwoKSlcbiAgICAgICAgICAgICAgICAgICAgJGVsZW0udmFsKHNldHRpbmdzLnpvb21MZXZlbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1pvb21MZXZlbERpZENoYW5nZScsIHVwZGF0ZVNsaWRlcik7XG4gICAgICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsdC5zZXRBdHRyaWJ1dGVzKGVsZW0sIHtcbiAgICAgICAgICAgICAgICAgICAgbWluOiBzZXR0aW5ncy5taW5ab29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIG1heDogc2V0dGluZ3MubWF4Wm9vbUxldmVsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXIoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVCdXR0b25zOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZWx0KCdzcGFuJyxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLW91dC1idXR0b24nLCAnWm9vbSBPdXQnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyLnNldFpvb21MZXZlbChzZXR0aW5ncy56b29tTGV2ZWwgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCd6b29tLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRab29tTGV2ZWwoc2V0dGluZ3Muem9vbUxldmVsICsgMSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlTGFiZWw6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBlbGVtID0gY3JlYXRlTGFiZWwoJ2RpdmEtem9vbS1sYWJlbCcsICd6b29tLWxhYmVsJywgJ1pvb20gbGV2ZWw6ICcsICd6b29tLWxldmVsJywgc2V0dGluZ3Muem9vbUxldmVsKTtcbiAgICAgICAgICAgIHZhciB0ZXh0U3BhbiA9ICQoZWxlbSkuZmluZChzZXR0aW5ncy5zZWxlY3RvciArICd6b29tLWxldmVsJylbMF07XG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVUZXh0ID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXh0U3Bhbi50ZXh0Q29udGVudCA9IHNldHRpbmdzLnpvb21MZXZlbC50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgc3Vic2NyaWJlKCdab29tTGV2ZWxEaWRDaGFuZ2UnLCB1cGRhdGVUZXh0KTtcbiAgICAgICAgICAgIHN1YnNjcmliZSgnVmlld2VyRGlkTG9hZCcsIHVwZGF0ZVRleHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gZWxlbTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gR3JpZCBjb250cm9sc1xuICAgIHZhciBjcmVhdGVHcmlkQ29udHJvbHMgPSBnZXRSZXNvbHV0aW9uQ29udHJvbENyZWF0b3Ioe1xuICAgICAgICBjb250cm9sbGVyU2V0dGluZzogJ2VuYWJsZUdyaWRDb250cm9scycsXG4gICAgICAgIHNob3dJbkdyaWQ6IHRydWUsXG5cbiAgICAgICAgY3JlYXRlU2xpZGVyOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGNyZWF0ZVNsaWRlcignZ3JpZC1zbGlkZXInLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNldHRpbmdzLnBhZ2VzUGVyUm93LFxuICAgICAgICAgICAgICAgIG1pbjogc2V0dGluZ3MubWluUGFnZXNQZXJSb3csXG4gICAgICAgICAgICAgICAgbWF4OiBzZXR0aW5ncy5tYXhQYWdlc1BlclJvd1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKGVsZW0pO1xuXG4gICAgICAgICAgICAkZWxlbS5vbignaW5wdXQnLCBmdW5jdGlvbigpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGludFZhbHVlID0gcGFyc2VJbnQoZWxlbS52YWx1ZSwgMTApO1xuICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coaW50VmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICRlbGVtLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBpbnRWYWx1ZSA9IHBhcnNlSW50KGVsZW0udmFsdWUsIDEwKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50VmFsdWUgIT09IHNldHRpbmdzLnBhZ2VzUGVyUm93KVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXIuc2V0R3JpZFBhZ2VzUGVyUm93KGludFZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZSB3aXRoaW4gdGhlIHNsaWRlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wYWdlc1BlclJvdyAhPT0gJGVsZW0udmFsKCkpXG4gICAgICAgICAgICAgICAgICAgICRlbGVtLnZhbChzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlQnV0dG9uczogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGVsdCgnc3BhbicsXG4gICAgICAgICAgICAgICAgY3JlYXRlQnV0dG9uRWxlbWVudCgnZ3JpZC1vdXQtYnV0dG9uJywgJ1pvb20gT3V0JywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgLSAxKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjcmVhdGVCdXR0b25FbGVtZW50KCdncmlkLWluLWJ1dHRvbicsICdab29tIEluJywgZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlci5zZXRHcmlkUGFnZXNQZXJSb3coc2V0dGluZ3MucGFnZXNQZXJSb3cgKyAxKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYWJlbDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVMYWJlbCgnZGl2YS1ncmlkLWxhYmVsJywgJ2dyaWQtbGFiZWwnLCAnUGFnZXMgcGVyIHJvdzogJywgJ3BhZ2VzLXBlci1yb3cnLCBzZXR0aW5ncy5wYWdlc1BlclJvdyk7XG4gICAgICAgICAgICB2YXIgdGV4dFNwYW4gPSAkKGVsZW0pLmZpbmQoc2V0dGluZ3Muc2VsZWN0b3IgKyAncGFnZXMtcGVyLXJvdycpWzBdO1xuXG4gICAgICAgICAgICBzdWJzY3JpYmUoJ0dyaWRSb3dOdW1iZXJEaWRDaGFuZ2UnLCBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHRTcGFuLnRleHRDb250ZW50ID0gc2V0dGluZ3MucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBjcmVhdGVWaWV3TWVudSA9IGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciB2aWV3T3B0aW9uc0xpc3QgPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndmlldy1vcHRpb25zJykpO1xuXG4gICAgICAgIHZhciBjaGFuZ2VWaWV3QnV0dG9uID0gY3JlYXRlQnV0dG9uRWxlbWVudCgndmlldy1pY29uJywgJ0NoYW5nZSB2aWV3JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLnRvZ2dsZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAkKGRvY3VtZW50KS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lciA9ICQodmlld09wdGlvbnNMaXN0KTtcblxuICAgICAgICAgICAgaWYgKCFjb250YWluZXIuaXMoZXZlbnQudGFyZ2V0KSAmJiBjb250YWluZXIuaGFzKGV2ZW50LnRhcmdldCkubGVuZ3RoID09PSAwICYmIGV2ZW50LnRhcmdldC5pZCAhPT0gc2V0dGluZ3MuSUQgKyAndmlldy1pY29uJylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VsZWN0VmlldyA9IGZ1bmN0aW9uICh2aWV3KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIuY2hhbmdlVmlldyh2aWV3KTtcblxuICAgICAgICAgICAgLy9oaWRlIHZpZXcgbWVudVxuICAgICAgICAgICAgJCh2aWV3T3B0aW9uc0xpc3QpLmhpZGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdXBkYXRlVmlld01lbnUgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2aWV3SWNvbkNsYXNzZXMgPSAnIGRpdmEtdmlldy1pY29uIGRpdmEtYnV0dG9uJztcblxuICAgICAgICAgICAgLy8gZGlzcGxheSB0aGUgaWNvbiBvZiB0aGUgbW9kZSB3ZSdyZSBjdXJyZW50bHkgaW4gKD8pXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24uY2xhc3NOYW1lID0gJ2RpdmEtZ3JpZC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmluQm9va0xheW91dClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VWaWV3QnV0dG9uLmNsYXNzTmFtZSA9ICdkaXZhLWJvb2staWNvbicgKyB2aWV3SWNvbkNsYXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hhbmdlVmlld0J1dHRvbi5jbGFzc05hbWUgPSAnZGl2YS1kb2N1bWVudC1pY29uJyArIHZpZXdJY29uQ2xhc3NlcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHZpZXdPcHRpb25zID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXG4gICAgICAgICAgICAvLyB0aGVuIGRpc3BsYXkgZG9jdW1lbnQsIGJvb2ssIGFuZCBncmlkIGJ1dHRvbnMgaW4gdGhhdCBvcmRlciwgZXhjbHVkaW5nIHRoZSBjdXJyZW50IHZpZXdcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQgfHwgc2V0dGluZ3MuaW5Cb29rTGF5b3V0KVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2RvY3VtZW50LWljb24nLCAnRG9jdW1lbnQgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnZG9jdW1lbnQnKSkpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5HcmlkIHx8ICFzZXR0aW5ncy5pbkJvb2tMYXlvdXQpXG4gICAgICAgICAgICAgICAgdmlld09wdGlvbnMuYXBwZW5kQ2hpbGQoY3JlYXRlQnV0dG9uRWxlbWVudCgnYm9vay1pY29uJywgJ0Jvb2sgVmlldycsIHNlbGVjdFZpZXcuYmluZChudWxsLCAnYm9vaycpKSk7XG5cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaW5HcmlkKVxuICAgICAgICAgICAgICAgIHZpZXdPcHRpb25zLmFwcGVuZENoaWxkKGNyZWF0ZUJ1dHRvbkVsZW1lbnQoJ2dyaWQtaWNvbicsICdHcmlkIFZpZXcnLCBzZWxlY3RWaWV3LmJpbmQobnVsbCwgJ2dyaWQnKSkpO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgb2xkIG1lbnVcbiAgICAgICAgICAgIHdoaWxlICh2aWV3T3B0aW9uc0xpc3QuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3QucmVtb3ZlQ2hpbGQodmlld09wdGlvbnNMaXN0LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgbmV3IG1lbnVcbiAgICAgICAgICAgIHZpZXdPcHRpb25zTGlzdC5hcHBlbmRDaGlsZCh2aWV3T3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdWaWV3RGlkU3dpdGNoJywgdXBkYXRlVmlld01lbnUpO1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVWaWV3TWVudSk7XG5cbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd2aWV3LW1lbnUnKSxcbiAgICAgICAgICAgIGNoYW5nZVZpZXdCdXR0b24sXG4gICAgICAgICAgICB2aWV3T3B0aW9uc0xpc3RcbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVNsaWRlciA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpXG4gICAge1xuICAgICAgICByZXR1cm4gZWx0KCdpbnB1dCcsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIG5hbWUsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIG5hbWUgKyAnIGRpdmEtc2xpZGVyJyxcbiAgICAgICAgICAgIHR5cGU6ICdyYW5nZSdcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVMYWJlbCA9IGZ1bmN0aW9uKG5hbWUsIGlkLCBsYWJlbCwgaW5uZXJOYW1lLCBpbm5lclZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBuYW1lICsgJyBkaXZhLWxhYmVsJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlubmVyTmFtZVxuICAgICAgICAgICAgICAgIH0sIGlubmVyVmFsdWUpXG4gICAgICAgICAgICBdKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZVBhZ2VOYXZpZ2F0aW9uQ29udHJvbHMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gR28gdG8gcGFnZSBmb3JtXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IHNldHRpbmdzLmVuYWJsZUdvdG9QYWdlID8gY3JlYXRlR290b1BhZ2VGb3JtKCkgOiBudWxsO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCBlbGVtQXR0cnMoJ3BhZ2UtbmF2JyksXG4gICAgICAgICAgICBjcmVhdGVQYWdlTGFiZWwoKSwgLy8gJ1BhZ2UgeCBvZiB5JyBsYWJlbFxuICAgICAgICAgICAgZ290b0Zvcm1cbiAgICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUdvdG9QYWdlRm9ybSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ290b1BhZ2VJbnB1dCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLWlucHV0JyxcbiAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1pbnB1dCBkaXZhLWdvdG8tcGFnZS1pbnB1dCcsXG4gICAgICAgICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgICAgdHlwZTogJ3RleHQnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBnb3RvUGFnZVN1Ym1pdCA9IGVsdCgnaW5wdXQnLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlLXN1Ym1pdCcsXG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtYnV0dG9uIGRpdmEtYnV0dG9uLXRleHQnLFxuICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgICB2YWx1ZTogJ0dvJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgaW5wdXRTdWdnZXN0aW9ucyA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdpbnB1dC1zdWdnZXN0aW9ucycsXG4gICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLWlucHV0LXN1Z2dlc3Rpb25zJ1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBnb3RvRm9ybSA9IGVsdCgnZm9ybScsIHtcbiAgICAgICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnZ290by1wYWdlJyxcbiAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtZ290by1mb3JtJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQsXG4gICAgICAgICAgICBnb3RvUGFnZVN1Ym1pdCxcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICAkKGdvdG9Gb3JtKS5vbignc3VibWl0JywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGRlc2lyZWRQYWdlTGFiZWwgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub25Hb3RvU3VibWl0ICYmIHR5cGVvZiBzZXR0aW5ncy5vbkdvdG9TdWJtaXQgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gc2V0dGluZ3Mub25Hb3RvU3VibWl0KGRlc2lyZWRQYWdlTGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlJbmRleChwYWdlSW5kZXgpKVxuICAgICAgICAgICAgICAgICAgICBhbGVydChcIk5vIHBhZ2UgY291bGQgYmUgZm91bmQgd2l0aCB0aGF0IGxhYmVsIG9yIHBhZ2UgbnVtYmVyXCIpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIC8vIERlZmF1bHQgaWYgbm8gZnVuY3Rpb24gaXMgc3BlY2lmaWVkIGluIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICghdmlld2VyLmdvdG9QYWdlQnlMYWJlbChkZXNpcmVkUGFnZUxhYmVsKSlcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJObyBwYWdlIGNvdWxkIGJlIGZvdW5kIHdpdGggdGhhdCBsYWJlbCBvciBwYWdlIG51bWJlclwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGlkZSB0aGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICAgICAgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb24gb2YgcmVsb2FkaW5nIHRoZSBwYWdlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoZ290b1BhZ2VJbnB1dCkub24oJ2lucHV0IGZvY3VzJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5pbm5lckhUTUwgPSAnJzsgLy8gUmVtb3ZlIGFsbCBwcmV2aW91cyBzdWdnZXN0aW9uc1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnb3RvUGFnZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdmFyIG51bVN1Z2dlc3Rpb25zID0gMDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVHb3RvU3VnZ2VzdGlvbnMgJiYgdmFsdWUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhZ2VzLmxlbmd0aDsgaSA8IGxlbiAmJiBudW1TdWdnZXN0aW9ucyA8IDEwOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXNbaV0ubC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0lucHV0U3VnZ2VzdGlvbiA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtaW5wdXQtc3VnZ2VzdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VzW2ldLmxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuYXBwZW5kQ2hpbGQobmV3SW5wdXRTdWdnZXN0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtU3VnZ2VzdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNob3cgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAobnVtU3VnZ2VzdGlvbnMgPiAwKVxuICAgICAgICAgICAgICAgICAgICBpbnB1dFN1Z2dlc3Rpb25zLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZWw7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSAxMykgLy8gJ0VudGVyJyBrZXlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBnb3RvUGFnZUlucHV0LnZhbHVlID0gYWN0aXZlLnRleHQoKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMzgpIC8vIFVwIGFycm93IGtleVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVsID0gJCgnLmFjdGl2ZScsIGlucHV0U3VnZ2VzdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2RWwgPSBlbC5wcmV2KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZFbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgICAgIHByZXZFbC5hZGRDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnLmRpdmEtaW5wdXQtc3VnZ2VzdGlvbjpsYXN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PT0gNDApIC8vIERvd24gYXJyb3cga2V5XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZWwgPSAkKCcuYWN0aXZlJywgaW5wdXRTdWdnZXN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRFbCA9IGVsLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dEVsLmxlbmd0aClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dEVsLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAkKCcuZGl2YS1pbnB1dC1zdWdnZXN0aW9uOmZpcnN0JywgaW5wdXRTdWdnZXN0aW9ucykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChpbnB1dFN1Z2dlc3Rpb25zKS5vbignbW91c2Vkb3duJywgJy5kaXZhLWlucHV0LXN1Z2dlc3Rpb24nLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGdvdG9QYWdlSW5wdXQudmFsdWUgPSB0aGlzLnRleHRDb250ZW50O1xuICAgICAgICAgICAgaW5wdXRTdWdnZXN0aW9ucy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgJChnb3RvUGFnZUlucHV0KS50cmlnZ2VyKCdzdWJtaXQnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJChnb3RvUGFnZUlucHV0KS5vbignYmx1cicsIGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEhpZGUgbGFiZWwgc3VnZ2VzdGlvbnNcbiAgICAgICAgICAgIGlucHV0U3VnZ2VzdGlvbnMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdvdG9Gb3JtO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlUGFnZUxhYmVsID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gQ3VycmVudCBwYWdlXG4gICAgICAgIHZhciBjdXJyZW50UGFnZSA9IGVsdCgnc3BhbicsIHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdjdXJyZW50LXBhZ2UnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciB1cGRhdGVDdXJyZW50UGFnZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGN1cnJlbnRQYWdlLnRleHRDb250ZW50ID0gdmlld2VyLmdldEN1cnJlbnRBbGlhc2VkUGFnZUluZGV4KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3Vic2NyaWJlKCdWaXNpYmxlUGFnZURpZENoYW5nZScsIHVwZGF0ZUN1cnJlbnRQYWdlKTtcbiAgICAgICAgc3Vic2NyaWJlKCdWaWV3ZXJEaWRMb2FkJywgdXBkYXRlQ3VycmVudFBhZ2UpO1xuXG4gICAgICAgIC8vIE51bWJlciBvZiBwYWdlc1xuICAgICAgICB2YXIgbnVtUGFnZXMgPSBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICBpZDogc2V0dGluZ3MuSUQgKyAnbnVtLXBhZ2VzJ1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdXBkYXRlTnVtUGFnZXMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBudW1QYWdlcy50ZXh0Q29udGVudCA9IHNldHRpbmdzLm51bVBhZ2VzO1xuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmliZSgnTnVtYmVyT2ZQYWdlc0RpZENoYW5nZScsIHVwZGF0ZU51bVBhZ2VzKTtcbiAgICAgICAgc3Vic2NyaWJlKCdPYmplY3REaWRMb2FkJywgdXBkYXRlTnVtUGFnZXMpO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6ICdkaXZhLXBhZ2UtbGFiZWwgZGl2YS1sYWJlbCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnUGFnZSAnLCBjdXJyZW50UGFnZSwgJyBvZiAnLCBudW1QYWdlc1xuICAgICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlVG9vbGJhckJ1dHRvbkdyb3VwID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBidXR0b25zID0gW2NyZWF0ZVZpZXdNZW51KCldO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5lbmFibGVMaW5rSWNvbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVMaW5rSWNvbigpKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlTm9uUGFnZWRWaXNpYmlsaXR5SWNvbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVUb2dnbGVOb25QYWdlZEJ1dHRvbigpKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlRnVsbHNjcmVlbilcbiAgICAgICAgICAgIGJ1dHRvbnMucHVzaChjcmVhdGVGdWxsc2NyZWVuQnV0dG9uKCkpO1xuXG4gICAgICAgIHJldHVybiBlbHQoJ3NwYW4nLCBlbGVtQXR0cnMoJ3Rvb2xiYXItYnV0dG9uLWdyb3VwJyksIGJ1dHRvbnMpO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlTGlua0ljb24gPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGVsZW0gPSBjcmVhdGVCdXR0b25FbGVtZW50KCdsaW5rLWljb24nLCAnTGluayB0byB0aGlzIHBhZ2UnKTtcbiAgICAgICAgdmFyIGxpbmtJY29uID0gJChlbGVtKTtcblxuICAgICAgICBsaW5rSWNvbi5vbignY2xpY2snLCBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCdib2R5JykucHJlcGVuZChcbiAgICAgICAgICAgICAgICBlbHQoJ2RpdicsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2RpdmEtcG9wdXAgZGl2YS1saW5rLXBvcHVwJ1xuICAgICAgICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgZWx0KCdpbnB1dCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArICdsaW5rLXBvcHVwLWlucHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnZGl2YS1pbnB1dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmlld2VyLmdldEN1cnJlbnRVUkwoKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5GdWxsc2NyZWVuKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCcpLmFkZENsYXNzKCdpbi1mdWxsc2NyZWVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBsZWZ0IGFuZCB0b3Agb2Zmc2V0c1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gbGlua0ljb24ub2Zmc2V0KCkubGVmdCAtIDIyMiArIGxpbmtJY29uLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9wT2Zmc2V0ID0gbGlua0ljb24ub2Zmc2V0KCkudG9wICsgbGlua0ljb24ub3V0ZXJIZWlnaHQoKSAtIDE7XG5cbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2xpbmstcG9wdXAnKS5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAndG9wJzogdG9wT2Zmc2V0ICsgJ3B4JyxcbiAgICAgICAgICAgICAgICAgICAgJ2xlZnQnOiBsZWZ0T2Zmc2V0ICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYXRjaCBvbm1vdXNldXAgZXZlbnRzIG91dHNpZGUgb2YgdGhpcyBkaXZcbiAgICAgICAgICAgICQoJ2JvZHknKS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SUQgPSBldmVudC50YXJnZXQuaWQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SUQgIT09IHNldHRpbmdzLklEICsgJ2xpbmstcG9wdXAnICYmIHRhcmdldElEICE9PSBzZXR0aW5ncy5JRCArICdsaW5rLXBvcHVwLWlucHV0JylcbiAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdsaW5rLXBvcHVwJykucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWxzbyBkZWxldGUgaXQgdXBvbiBzY3JvbGwgYW5kIHBhZ2UgdXAvZG93biBrZXkgZXZlbnRzXG4gICAgICAgICAgICAvLyBGSVhNRSh3YWJhaW4pOiBUaGlzIGlzIGFnZ3Jlc3NpdmVcbiAgICAgICAgICAgIHNldHRpbmdzLnZpZXdwb3J0T2JqZWN0LnNjcm9sbChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAnbGluay1wb3B1cCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2xpbmstcG9wdXAgaW5wdXQnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQodGhpcykuZm9jdXMoKS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRnVsbHNjcmVlbkJ1dHRvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnV0dG9uRWxlbWVudCgnZnVsbHNjcmVlbi1pY29uJywgJ1RvZ2dsZSBmdWxsc2NyZWVuIG1vZGUnLCBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIudG9nZ2xlRnVsbHNjcmVlbk1vZGUoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBjcmVhdGVUb2dnbGVOb25QYWdlZEJ1dHRvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgZ2V0Q2xhc3NOYW1lID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gJ3RvZ2dsZS1ub25wYWdlZC1pY29uJyArICh2aWV3ZXIuZ2V0U2V0dGluZ3MoKS5zaG93Tm9uUGFnZWRQYWdlcyA/ICctYWN0aXZlJyA6ICcnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdG9nZ2xlTm9uUGFnZWRCdXR0b24gPSBjcmVhdGVCdXR0b25FbGVtZW50KGdldENsYXNzTmFtZSgpLCAnVG9nZ2xlIHZpc2liaWxpdHkgb2Ygbm9uLXBhZ2VkIHBhZ2VzJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXIudG9nZ2xlTm9uUGFnZWRQYWdlc1Zpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIHZhciBuZXdDbGFzc05hbWUgPSAnZGl2YS0nICsgZ2V0Q2xhc3NOYW1lKCk7XG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoL2RpdmEtdG9nZ2xlLW5vbnBhZ2VkLWljb24oLWFjdGl2ZSk/LywgbmV3Q2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZU5vblBhZ2VkQnV0dG9uVmlzaWJpbGl0eSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlcyA9IHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubWFuaWZlc3QucGFnZWQgJiYgIXBhZ2VzW2ldLnBhZ2VkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgYnV0dG9uLCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgbm9uLXBhZ2VkIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlTm9uUGFnZWRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBObyBub24tcGFnZWQgcGFnZXMgd2VyZSBmb3VuZCwgaGlkZSB0aGUgYnV0dG9uXG4gICAgICAgICAgICB0b2dnbGVOb25QYWdlZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB1cGRhdGVOb25QYWdlZEJ1dHRvblZpc2liaWxpdHkpO1xuXG4gICAgICAgIHJldHVybiB0b2dnbGVOb25QYWdlZEJ1dHRvbjtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlcyBhbGwgc3RhdHVzIHVwZGF0aW5nIGV0YyAoYm90aCBmdWxsc2NyZWVuIGFuZCBub3QpXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGxlZnRUb29scyA9IFtjcmVhdGVab29tQ29udHJvbHMoKSwgY3JlYXRlR3JpZENvbnRyb2xzKCldO1xuICAgICAgICB2YXIgcmlnaHRUb29scyA9IFtjcmVhdGVQYWdlTmF2aWdhdGlvbkNvbnRyb2xzKCksIGNyZWF0ZVRvb2xiYXJCdXR0b25Hcm91cCgpXTtcblxuICAgICAgICB2YXIgdG9vbHMgPSBlbHQoJ2RpdicsIGVsZW1BdHRycygndG9vbHMnKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0b29scy1sZWZ0JyksIGxlZnRUb29scyksXG4gICAgICAgICAgICBlbHQoJ2RpdicsIGVsZW1BdHRycygndG9vbHMtcmlnaHQnKSwgcmlnaHRUb29scylcbiAgICAgICAgKTtcblxuICAgICAgICBzZXR0aW5ncy50b29sYmFyUGFyZW50T2JqZWN0LnByZXBlbmQodG9vbHMpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBlbnRyeSB0byBhbmQgZXhpdCBmcm9tIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICB2YXIgc3dpdGNoTW9kZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b29sc1JpZ2h0RWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNldHRpbmdzLklEICsgJ3Rvb2xzLXJpZ2h0Jyk7XG4gICAgICAgICAgICB2YXIgcGFnZU5hdkVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZXR0aW5ncy5JRCArICdwYWdlLW5hdicpO1xuXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmluRnVsbHNjcmVlbilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBMZWF2aW5nIGZ1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAkKHRvb2xzKS5yZW1vdmVDbGFzcygnZGl2YS1mdWxsc2NyZWVuLXRvb2xzJyk7XG5cbiAgICAgICAgICAgICAgICAvL21vdmUgSUQtcGFnZS1uYXYgdG8gYmVnaW5uaW5nIG9mIHRvb2xzIHJpZ2h0XG4gICAgICAgICAgICAgICAgdG9vbHNSaWdodEVsZW1lbnQucmVtb3ZlQ2hpbGQocGFnZU5hdkVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRvb2xzUmlnaHRFbGVtZW50Lmluc2VydEJlZm9yZShwYWdlTmF2RWxlbWVudCwgdG9vbHNSaWdodEVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRW50ZXJpbmcgZnVsbHNjcmVlblxuICAgICAgICAgICAgICAgICQodG9vbHMpLmFkZENsYXNzKCdkaXZhLWZ1bGxzY3JlZW4tdG9vbHMnKTtcblxuICAgICAgICAgICAgICAgIC8vbW92ZSBJRC1wYWdlLW5hdiB0byBlbmQgb2YgdG9vbHMgcmlnaHRcbiAgICAgICAgICAgICAgICB0b29sc1JpZ2h0RWxlbWVudC5yZW1vdmVDaGlsZChwYWdlTmF2RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdG9vbHNSaWdodEVsZW1lbnQuYXBwZW5kQ2hpbGQocGFnZU5hdkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHN1YnNjcmliZSgnTW9kZURpZFN3aXRjaCcsIHN3aXRjaE1vZGUpO1xuICAgICAgICBzdWJzY3JpYmUoJ1ZpZXdlckRpZExvYWQnLCBzd2l0Y2hNb2RlKTtcblxuICAgICAgICB2YXIgdG9vbGJhciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRvb2xzLFxuICAgICAgICAgICAgY2xvc2VQb3B1cHM6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJCgnLmRpdmEtcG9wdXAnKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0b29sYmFyO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW5pdCgpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdG9vbGJhci5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyICQgPSByZXF1aXJlKCdqcXVlcnknKTtcblxucmVxdWlyZSgnLi91dGlscy9qcXVlcnktZXh0ZW5zaW9ucycpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcbnZhciBnZXRTY3JvbGxiYXJXaWR0aCA9IHJlcXVpcmUoJy4vdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aCcpO1xuXG52YXIgZ2VzdHVyZUV2ZW50cyA9IHJlcXVpcmUoJy4vZ2VzdHVyZS1ldmVudHMnKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi9kaXZhLWdsb2JhbCcpO1xudmFyIERvY3VtZW50SGFuZGxlciA9IHJlcXVpcmUoJy4vZG9jdW1lbnQtaGFuZGxlcicpO1xudmFyIEdyaWRIYW5kbGVyID0gcmVxdWlyZSgnLi9ncmlkLWhhbmRsZXInKTtcbnZhciBQYWdlT3ZlcmxheU1hbmFnZXIgPSByZXF1aXJlKCcuL3BhZ2Utb3ZlcmxheS1tYW5hZ2VyJyk7XG52YXIgUGx1Z2luUmVnaXN0cnkgPSByZXF1aXJlKCcuL3BsdWdpbi1yZWdpc3RyeScpO1xudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIGdldFBhZ2VMYXlvdXRzID0gcmVxdWlyZSgnLi9wYWdlLWxheW91dHMnKTtcbnZhciBjcmVhdGVTZXR0aW5nc1ZpZXcgPSByZXF1aXJlKCcuL3NldHRpbmdzLXZpZXcnKTtcbnZhciBWYWxpZGF0aW9uUnVubmVyID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uLXJ1bm5lcicpO1xudmFyIFZpZXdwb3J0ID0gcmVxdWlyZSgnLi92aWV3cG9ydCcpO1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOlZpZXdlckNvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3ZXJDb3JlO1xuXG4vLyBEZWZpbmUgdmFsaWRhdGlvbnNcbnZhciBvcHRpb25zVmFsaWRhdGlvbnMgPSBbXG4gICAge1xuICAgICAgICBrZXk6ICdnb0RpcmVjdGx5VG8nLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlLCBzZXR0aW5ncylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSBzZXR0aW5ncy5tYW5pZmVzdC5wYWdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluUGFnZXNQZXJSb3cnLFxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFBhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZSwgc2V0dGluZ3MubWluUGFnZXNQZXJSb3cpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ3BhZ2VzUGVyUm93JyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGhlIG1heGltdW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblBhZ2VzUGVyUm93IHx8IHZhbHVlID4gc2V0dGluZ3MubWF4UGFnZXNQZXJSb3cpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1heFBhZ2VzUGVyUm93O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGtleTogJ21heFpvb21MZXZlbCcsXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodmFsdWUsIHNldHRpbmdzLCBjb25maWcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoaXMgdmFsdWUgaXNuJ3QgcmVhbGx5IGFuIGVycm9yLCBpdCBqdXN0IGRlcGVuZHMgb24gdGhlXG4gICAgICAgICAgICAvLyBzb3VyY2UgbWFuaWZlc3RcbiAgICAgICAgICAgIGNvbmZpZy5zdXBwcmVzc1dhcm5pbmcoKTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLm1hbmlmZXN0Lm1heFpvb207XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnbWluWm9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQ2hhbmdlcyBiYXNlZCBvbiB0aGUgbWFuaWZlc3QgdmFsdWUgc2hvdWxkbid0IHRyaWdnZXIgYVxuICAgICAgICAgICAgLy8gd2FybmluZ1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDAgfHwgdmFsdWUgPiBzZXR0aW5ncy5tYXhab29tTGV2ZWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga2V5OiAnem9vbUxldmVsJyxcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh2YWx1ZSwgc2V0dGluZ3MsIGNvbmZpZylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gc2V0dGluZ3MubWFuaWZlc3QubWF4Wm9vbSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc3VwcHJlc3NXYXJuaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IHNldHRpbmdzLm1pblpvb21MZXZlbCB8fCB2YWx1ZSA+IHNldHRpbmdzLm1heFpvb21MZXZlbClcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICB9XG4gICAgfVxuXTtcblxuZnVuY3Rpb24gVmlld2VyQ29yZShlbGVtZW50LCBvcHRpb25zLCBwdWJsaWNJbnN0YW5jZSlcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhcmVudE9iamVjdCA9ICQoZWxlbWVudCk7XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBjYW5ub3QgYmUgY2hhbmdlZCBiZWNhdXNlIG9mIHRoZSB3YXkgdGhleSBhcmUgdXNlZCBieSB0aGUgc2NyaXB0XG4gICAgLy8gTWFueSBvZiB0aGVzZSBhcmUgZGVjbGFyZWQgd2l0aCBhcmJpdHJhcnkgdmFsdWVzIHRoYXQgYXJlIGNoYW5nZWQgbGF0ZXIgb25cbiAgICB2YXIgdmlld2VyU3RhdGUgPSB7XG4gICAgICAgIGN1cnJlbnRQYWdlSW5kZXg6IDAsICAgICAgICAvLyBUaGUgY3VycmVudCBwYWdlIGluIHRoZSB2aWV3cG9ydCAoY2VudGVyLW1vc3QgcGFnZSlcbiAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogMCwgICAgICAgIC8vIERpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YSBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICBob3Jpem9udGFsUGFkZGluZzogMCwgICAgICAgLy8gRWl0aGVyIHRoZSBmaXhlZCBwYWRkaW5nIG9yIGFkYXB0aXZlIHBhZGRpbmdcbiAgICAgICAgSUQ6IG51bGwsICAgICAgICAgICAgICAgICAgIC8vIFRoZSBwcmVmaXggb2YgdGhlIElEcyBvZiB0aGUgZWxlbWVudHMgKHVzdWFsbHkgMS1kaXZhLSlcbiAgICAgICAgaW5pdGlhbEtleVNjcm9sbDogZmFsc2UsICAgIC8vIEhvbGRzIHRoZSBpbml0aWFsIHN0YXRlIG9mIGVuYWJsZUtleVNjcm9sbFxuICAgICAgICBpbml0aWFsU3BhY2VTY3JvbGw6IGZhbHNlLCAgLy8gSG9sZHMgdGhlIGluaXRpYWwgc3RhdGUgb2YgZW5hYmxlU3BhY2VTY3JvbGxcbiAgICAgICAgaW5uZXJFbGVtZW50OiBudWxsLCAgICAgICAgIC8vIFRoZSBuYXRpdmUgLmRpdmEtb3V0ZXIgRE9NIG9iamVjdFxuICAgICAgICBpbm5lck9iamVjdDoge30sICAgICAgICAgICAgLy8gJChzZXR0aW5ncy5JRCArICdpbm5lcicpLCBmb3Igc2VsZWN0aW5nIHRoZSAuZGl2YS1pbm5lciBlbGVtZW50XG4gICAgICAgIGlzQWN0aXZlRGl2YTogdHJ1ZSwgICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGF0IG11bHRpcGxlIGRpdmEgcGFuZXMgZXhpc3Qgb24gdGhlIHNhbWUgcGFnZSwgdGhpcyBzaG91bGQgaGF2ZSBldmVudHMgZnVubmVsZWQgdG8gaXQuXG4gICAgICAgIGlzU2Nyb2xsYWJsZTogdHJ1ZSwgICAgICAgICAvLyBVc2VkIGluIGVuYWJsZS9kaXNhYmxlU2Nyb2xsYWJsZSBwdWJsaWMgbWV0aG9kc1xuICAgICAgICBpc1pvb21pbmc6IGZhbHNlLCAgICAgICAgICAgLy8gRmxhZyB0byBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgem9vbWluZyBpcyBzdGlsbCBpbiBwcm9ncmVzcywgZm9yIGhhbmRsZVpvb21cbiAgICAgICAgbG9hZGVkOiBmYWxzZSwgICAgICAgICAgICAgIC8vIEEgZmxhZyBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICAgIG1hbmlmZXN0OiBudWxsLFxuICAgICAgICBtb2JpbGVXZWJraXQ6IGZhbHNlLCAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSB1c2VyIGlzIG9uIGEgdG91Y2ggZGV2aWNlIChpUGFkL2lQb2QvaVBob25lL0FuZHJvaWQpXG4gICAgICAgIG51bVBhZ2VzOiAwLCAgICAgICAgICAgICAgICAvLyBOdW1iZXIgb2YgcGFnZXMgaW4gdGhlIGFycmF5XG4gICAgICAgIG9sZFpvb21MZXZlbDogLTEsICAgICAgICAgICAvLyBIb2xkcyB0aGUgcHJldmlvdXMgem9vbSBsZXZlbCBhZnRlciB6b29taW5nIGluIG9yIG91dFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBvdXRlckVsZW1lbnQ6IG51bGwsICAgICAgICAgLy8gVGhlIG5hdGl2ZSAuZGl2YS1vdXRlciBET00gb2JqZWN0XG4gICAgICAgIG91dGVyT2JqZWN0OiB7fSwgICAgICAgICAgICAvLyAkKHNldHRpbmdzLklEICsgJ291dGVyJyksIGZvciBzZWxlY3RpbmcgdGhlIC5kaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgICAgcGFnZU92ZXJsYXlzOiBuZXcgUGFnZU92ZXJsYXlNYW5hZ2VyKCksXG4gICAgICAgIHBhZ2VUb29sczogW10sICAgICAgICAgICAgICAvLyBUaGUgcGx1Z2lucyB3aGljaCBhcmUgZW5hYmxlZCBhcyBwYWdlIHRvb2xzXG4gICAgICAgIHBhcmVudE9iamVjdDogcGFyZW50T2JqZWN0LCAvLyBKUXVlcnkgb2JqZWN0IHJlZmVyZW5jaW5nIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0OiBudWxsLCAvLyBSZWZlcmVuY2UgdG8gdGhlIHhociByZXF1ZXN0IHJldHJpZXZpbmcgdGhlIG1hbmlmZXN0LiBVc2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdCBvbiBkZXN0cm95KClcbiAgICAgICAgcGx1Z2luczogW10sICAgICAgICAgICAgICAgIC8vIEZpbGxlZCB3aXRoIHRoZSBlbmFibGVkIHBsdWdpbnMgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICAgIHJlc2l6ZVRpbWVyOiAtMSwgICAgICAgICAgICAvLyBIb2xkcyB0aGUgSUQgb2YgdGhlIHRpbWVvdXQgdXNlZCB3aGVuIHJlc2l6aW5nIHRoZSB3aW5kb3cgKGZvciBjbGVhcmluZylcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGg6IDAsICAgICAgICAgIC8vIFNldCB0byB0aGUgYWN0dWFsIHNjcm9sbGJhciB3aWR0aCBpbiBpbml0KClcbiAgICAgICAgc2VsZWN0b3I6ICcnLCAgICAgICAgICAgICAgIC8vIFVzZXMgdGhlIGdlbmVyYXRlZCBJRCBwcmVmaXggdG8gZWFzaWx5IHNlbGVjdCBlbGVtZW50c1xuICAgICAgICB0aHJvYmJlclRpbWVvdXRJRDogLTEsICAgICAgLy8gSG9sZHMgdGhlIElEIG9mIHRoZSB0aHJvYmJlciBsb2FkaW5nIHRpbWVvdXRcbiAgICAgICAgdG9vbGJhcjogbnVsbCwgICAgICAgICAgICAgIC8vIEhvbGRzIGFuIG9iamVjdCB3aXRoIHNvbWUgdG9vbGJhci1yZWxhdGVkIGZ1bmN0aW9uc1xuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogMCwgICAgICAgICAgLy8gRGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIHRoZSBkaXZhIGVsZW1lbnQgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgIHZlcnRpY2FsUGFkZGluZzogMCwgICAgICAgICAvLyBFaXRoZXIgdGhlIGZpeGVkIHBhZGRpbmcgb3IgYWRhcHRpdmUgcGFkZGluZ1xuICAgICAgICB2aWV3SGFuZGxlcjogbnVsbCxcbiAgICAgICAgdmlld3BvcnQ6IG51bGwsICAgICAgICAgICAgIC8vIE9iamVjdCBjYWNoaW5nIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zXG4gICAgICAgIHZpZXdwb3J0RWxlbWVudDogbnVsbCxcbiAgICAgICAgdmlld3BvcnRPYmplY3Q6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIHNldHRpbmdzID0gY3JlYXRlU2V0dGluZ3NWaWV3KFtvcHRpb25zLCB2aWV3ZXJTdGF0ZV0pO1xuXG4gICAgLy8gQWxpYXNlcyBmb3IgY29tcGF0aWJpbHR5XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2V0dGluZ3MsIHtcbiAgICAgICAgLy8gSGVpZ2h0IG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbEhlaWdodDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdpZHRoIG9mIHRoZSBkb2N1bWVudCB2aWV3ZXIgcGFuZVxuICAgICAgICBwYW5lbFdpZHRoOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnZpZXdwb3J0LndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgb3B0aW9uc1ZhbGlkYXRvciA9IG5ldyBWYWxpZGF0aW9uUnVubmVyKHtcbiAgICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXk6ICdtYW5pZmVzdCcsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLm1hbmlmZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcblxuICAgICAgICB2YWxpZGF0aW9uczogb3B0aW9uc1ZhbGlkYXRpb25zXG4gICAgfSk7XG5cbiAgICB2YXIgaXNWYWxpZE9wdGlvbiA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNWYWxpZGF0b3IuaXNWYWxpZChrZXksIHZhbHVlLCB2aWV3ZXJTdGF0ZS5vcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdmFyIGVsZW1BdHRycyA9IGZ1bmN0aW9uIChpZGVudCwgYmFzZSlcbiAgICB7XG4gICAgICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgICAgIGlkOiBzZXR0aW5ncy5JRCArIGlkZW50LFxuICAgICAgICAgICAgY2xhc3M6ICdkaXZhLScgKyBpZGVudFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICQuZXh0ZW5kKGF0dHJzLCBiYXNlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0UGFnZURhdGEgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhdHRyaWJ1dGUpXG4gICAge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3MubWFuaWZlc3QucGFnZXNbcGFnZUluZGV4XS5kW3NldHRpbmdzLnpvb21MZXZlbF1bYXR0cmlidXRlXTtcbiAgICB9O1xuXG4gICAgLy8gUmVzZXQgc29tZSBzZXR0aW5ncyBhbmQgZW1wdHkgdGhlIHZpZXdwb3J0XG4gICAgdmFyIGNsZWFyVmlld2VyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IDA7XG5cbiAgICAgICAgLy8gQ2xlYXIgYWxsIHRoZSB0aW1lb3V0cyB0byBwcmV2ZW50IHVuZGVzaXJlZCBwYWdlcyBmcm9tIGxvYWRpbmdcbiAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNldHRpbmdzIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gTG9hZCB0aGUgdmlld2VyLFxuICAgICAqIGZpcmUgYXBwcm9wcmlhdGUgZXZlbnRzIGZvciBjaGFuZ2VkIG9wdGlvbnMuXG4gICAgICovXG4gICAgdmFyIHJlbG9hZFZpZXdlciA9IGZ1bmN0aW9uIChuZXdPcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIHF1ZXVlZEV2ZW50cyA9IFtdO1xuXG4gICAgICAgIG5ld09wdGlvbnMgPSBvcHRpb25zVmFsaWRhdG9yLmdldFZhbGlkYXRlZE9wdGlvbnMoc2V0dGluZ3MsIG5ld09wdGlvbnMpO1xuXG4gICAgICAgIC8vIFNldCB0aGUgem9vbSBsZXZlbCBpZiB2YWxpZCBhbmQgZmlyZSBhIFpvb21MZXZlbERpZENoYW5nZSBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnem9vbUxldmVsJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9sZFpvb21MZXZlbCA9IHNldHRpbmdzLnpvb21MZXZlbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3T3B0aW9ucy56b29tTGV2ZWw7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3T3B0aW9ucy56b29tTGV2ZWxdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCB0aGUgcGFnZXMgcGVyIHJvdyBpZiB2YWxpZCBhbmQgZmlyZSBhbiBldmVudFxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAncGFnZXNQZXJSb3cnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5wYWdlc1BlclJvdyA9IG5ld09wdGlvbnMucGFnZXNQZXJSb3c7XG4gICAgICAgICAgICBxdWV1ZWRFdmVudHMucHVzaChbXCJHcmlkUm93TnVtYmVyRGlkQ2hhbmdlXCIsIG5ld09wdGlvbnMucGFnZXNQZXJSb3ddKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB2ZXJ0aWNhbGx5T3JpZW50ZWQgKG5vIGV2ZW50IGZpcmVkKVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAndmVydGljYWxseU9yaWVudGVkJykpXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLnZlcnRpY2FsbHlPcmllbnRlZCA9IG5ld09wdGlvbnMudmVydGljYWxseU9yaWVudGVkO1xuXG4gICAgICAgIC8vIFNob3cvSGlkZSBub24tcGFnZWQgcGFnZXNcbiAgICAgICAgaWYgKGhhc0NoYW5nZWRPcHRpb24obmV3T3B0aW9ucywgJ3Nob3dOb25QYWdlZFBhZ2VzJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuc2hvd05vblBhZ2VkUGFnZXMgPSBuZXdPcHRpb25zLnNob3dOb25QYWdlZFBhZ2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHBhZ2UgcG9zaXRpb24gKG5vIGV2ZW50IGZpcmVkIGhlcmUpXG4gICAgICAgIGlmICgnZ29EaXJlY3RseVRvJyBpbiBuZXdPcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmdvRGlyZWN0bHlUbyA9IG5ld09wdGlvbnMuZ29EaXJlY3RseVRvO1xuXG4gICAgICAgICAgICBpZiAoJ3ZlcnRpY2FsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0ID0gbmV3T3B0aW9ucy52ZXJ0aWNhbE9mZnNldDtcblxuICAgICAgICAgICAgaWYgKCdob3Jpem9udGFsT2Zmc2V0JyBpbiBuZXdPcHRpb25zKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBuZXdPcHRpb25zLmhvcml6b250YWxPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIGRlZmF1bHQgaXMgdG8gcmVtYWluIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkdyaWQnKSB8fCBoYXNDaGFuZ2VkT3B0aW9uKG5ld09wdGlvbnMsICdpbkJvb2tMYXlvdXQnKSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCdpbkdyaWQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkdyaWQgPSBuZXdPcHRpb25zLmluR3JpZDtcblxuICAgICAgICAgICAgaWYgKCdpbkJvb2tMYXlvdXQnIGluIG5ld09wdGlvbnMpXG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5pbkJvb2tMYXlvdXQgPSBuZXdPcHRpb25zLmluQm9va0xheW91dDtcblxuICAgICAgICAgICAgcXVldWVkRXZlbnRzLnB1c2goW1wiVmlld0RpZFN3aXRjaFwiLCBzZXR0aW5ncy5pbkdyaWRdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdGU6IHByZXBhcmVNb2RlQ2hhbmdlKCkgZGVwZW5kcyBvbiBpbkdyaWQgYW5kIHRoZSB2ZXJ0aWNhbC9ob3Jpem9udGFsT2Zmc2V0IChmb3Igbm93KVxuICAgICAgICBpZiAoaGFzQ2hhbmdlZE9wdGlvbihuZXdPcHRpb25zLCAnaW5GdWxsc2NyZWVuJykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuaW5GdWxsc2NyZWVuID0gbmV3T3B0aW9ucy5pbkZ1bGxzY3JlZW47XG4gICAgICAgICAgICBwcmVwYXJlTW9kZUNoYW5nZShuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHF1ZXVlZEV2ZW50cy5wdXNoKFtcIk1vZGVEaWRTd2l0Y2hcIiwgc2V0dGluZ3MuaW5GdWxsc2NyZWVuXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgICAgICB1cGRhdGVWaWV3SGFuZGxlckFuZFJlbmRlcmluZygpO1xuXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5yZW5kZXJlcilcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhlIHVzYWdlIG9mIHBhZGRpbmcgdmFyaWFibGVzIGlzIHN0aWxsIHJlYWxseVxuICAgICAgICAgICAgLy8gbWVzc3kgYW5kIGluY29uc2lzdGVudFxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHBhZ2VMYXlvdXRzOiBnZXRQYWdlTGF5b3V0cyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgcGFkZGluZzogZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIG1heFpvb21MZXZlbDogc2V0dGluZ3MuaW5HcmlkID8gbnVsbCA6IHZpZXdlclN0YXRlLm1hbmlmZXN0Lm1heFpvb20sXG4gICAgICAgICAgICAgICAgdmVydGljYWxseU9yaWVudGVkOiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgfHwgc2V0dGluZ3MuaW5HcmlkLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiBzZXR0aW5ncy5pbkdyaWQgPyBudWxsIDogc2V0dGluZ3Muem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmdvRGlyZWN0bHlUbyxcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQsXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNvdXJjZVByb3ZpZGVyID0gZ2V0Q3VycmVudFNvdXJjZVByb3ZpZGVyKCk7XG5cbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkID0gT2JqZWN0LmtleXMocmVuZGVyZXJDb25maWcpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgIT09ICdwYWdlTGF5b3V0cycgJiYga2V5ICE9PSAncGFkZGluZyc7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVuZGVyZXJDb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXkgKyAnOiAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcblxuICAgICAgICAgICAgICAgIGRlYnVnKCdyZWxvYWQgd2l0aCAlcycsIHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sb2FkKHJlbmRlcmVyQ29uZmlnLCB2aWV3cG9ydFBvc2l0aW9uLCBzb3VyY2VQcm92aWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICBxdWV1ZWRFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW1zKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoLmFwcGx5KG51bGwsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgaGFzQ2hhbmdlZE9wdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zLCBrZXkpXG4gICAge1xuICAgICAgICByZXR1cm4ga2V5IGluIG9wdGlvbnMgJiYgb3B0aW9uc1trZXldICE9PSBzZXR0aW5nc1trZXldO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGVzIHN3aXRjaGluZyBpbiBhbmQgb3V0IG9mIGZ1bGxzY3JlZW4gbW9kZVxuICAgIHZhciBwcmVwYXJlTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIChvcHRpb25zKVxuICAgIHtcbiAgICAgICAgLy8gVG9nZ2xlIHRoZSBjbGFzc2VzXG4gICAgICAgIHZhciBjaGFuZ2VDbGFzcyA9IG9wdGlvbnMuaW5GdWxsc2NyZWVuID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICAgIHZpZXdlclN0YXRlLm91dGVyT2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsc2NyZWVuJyk7XG4gICAgICAgICQoJ2JvZHknKVtjaGFuZ2VDbGFzc10oJ2RpdmEtaGlkZS1zY3JvbGxiYXInKTtcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0W2NoYW5nZUNsYXNzXSgnZGl2YS1mdWxsLXdpZHRoJyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IERpdmEncyBpbnRlcm5hbCBwYW5lbCBzaXplLCBrZWVwaW5nIHRoZSBvbGQgdmFsdWVzXG4gICAgICAgIHZhciBzdG9yZWRIZWlnaHQgPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgdmFyIHN0b3JlZFdpZHRoID0gc2V0dGluZ3MucGFuZWxXaWR0aDtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXNuJ3QgdGhlIG9yaWdpbmFsIGxvYWQsIHRoZSBvZmZzZXRzIG1hdHRlciwgYW5kIHRoZSBwb3NpdGlvbiBpc24ndCBiZWluZyBjaGFuZ2VkLi4uXG4gICAgICAgIGlmICghdmlld2VyU3RhdGUubG9hZGVkICYmICFzZXR0aW5ncy5pbkdyaWQgJiYgISgndmVydGljYWxPZmZzZXQnIGluIG9wdGlvbnMpKVxuICAgICAgICB7XG4gICAgICAgICAgICAvL2dldCB0aGUgdXBkYXRlZCBwYW5lbCBzaXplXG4gICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gc2V0dGluZ3MucGFuZWxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBzZXR0aW5ncy5wYW5lbFdpZHRoO1xuXG4gICAgICAgICAgICAvL2FuZCByZS1jZW50ZXIgdGhlIG5ldyBwYW5lbCBvbiB0aGUgc2FtZSBwb2ludFxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgKz0gKChzdG9yZWRIZWlnaHQgLSBuZXdIZWlnaHQpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0ICs9ICgoc3RvcmVkV2lkdGggLSBuZXdXaWR0aCkgLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdHVybiBvbi9vZmYgZXNjYXBlIGtleSBsaXN0ZW5lclxuICAgICAgICBpZiAob3B0aW9ucy5pbkZ1bGxzY3JlZW4pXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5dXAnLCBlc2NhcGVMaXN0ZW5lcik7XG4gICAgfTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdmlldyBoYW5kbGVyIGFuZCB0aGUgdmlldyByZW5kZXJpbmcgZm9yIHRoZSBjdXJyZW50IHZpZXdcbiAgICB2YXIgdXBkYXRlVmlld0hhbmRsZXJBbmRSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIEhhbmRsZXIgPSBzZXR0aW5ncy5pbkdyaWQgPyBHcmlkSGFuZGxlciA6IERvY3VtZW50SGFuZGxlcjtcblxuICAgICAgICBpZiAodmlld2VyU3RhdGUudmlld0hhbmRsZXIgJiYgISh2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciBpbnN0YW5jZW9mIEhhbmRsZXIpKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnZpZXdIYW5kbGVyKVxuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIgPSBuZXcgSGFuZGxlcihzZWxmKTtcblxuICAgICAgICBpZiAoIXZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgaW5pdGlhbGl6ZVJlbmRlcmVyKCk7XG4gICAgfTtcblxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgcHJvYmFibHkgYmUgZG9uZSB1cG9uIFZpZXdlckNvcmUgaW5pdGlhbGl6YXRpb25cbiAgICB2YXIgaW5pdGlhbGl6ZVJlbmRlcmVyID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciBjb21wYXRFcnJvcnMgPSBSZW5kZXJlci5nZXRDb21wYXRpYmlsaXR5RXJyb3JzKCk7XG5cbiAgICAgICAgaWYgKGNvbXBhdEVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgc2hvd0Vycm9yKGNvbXBhdEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB2aWV3cG9ydDogdmlld2VyU3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICAgICAgb3V0ZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5vdXRlckVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaW5uZXJFbGVtZW50OiB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBob29rcyA9IHtcbiAgICAgICAgICAgICAgICBvblZpZXdXaWxsTG9hZDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld1dpbGxMb2FkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRMb2FkOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZExvYWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uVmlld0RpZFVwZGF0ZTogZnVuY3Rpb24gKHBhZ2VzLCB0YXJnZXRQYWdlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uVmlld0RpZFVwZGF0ZShwYWdlcywgdGFyZ2V0UGFnZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblZpZXdEaWRUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlUGFnZU92ZXJsYXlzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblBhZ2VXaWxsTG9hZDogZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHB1Ymxpc2goJ1BhZ2VXaWxsTG9hZCcsIHBhZ2VJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIob3B0aW9ucywgaG9va3MpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBnZXRDdXJyZW50U291cmNlUHJvdmlkZXIgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmluR3JpZClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGdyaWRTb3VyY2VQcm92aWRlciA9IHtcbiAgICAgICAgICAgICAgICBnZXRBbGxab29tTGV2ZWxzRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2dyaWRTb3VyY2VQcm92aWRlci5nZXRCZXN0Wm9vbUxldmVsRm9yUGFnZShwYWdlKV07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXRCZXN0Wm9vbUxldmVsRm9yUGFnZTogZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdXJsID0gc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVVJMKHBhZ2UuaW5kZXgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBwYWdlLmRpbWVuc2lvbnMud2lkdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbDogMSwgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd3M6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xzOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGlsZXM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbUxldmVsOiAxLCAvLyBGSVhNRVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2w6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZS5kaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBncmlkU291cmNlUHJvdmlkZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlsZURpbWVucyA9IHtcbiAgICAgICAgICAgIHdpZHRoOiBzZXR0aW5ncy50aWxlV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLnRpbGVIZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0QmVzdFpvb21MZXZlbEZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5tYW5pZmVzdC5nZXRQYWdlSW1hZ2VUaWxlcyhwYWdlLmluZGV4LCBNYXRoLmNlaWwoc2V0dGluZ3Muem9vbUxldmVsKSwgdGlsZURpbWVucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QWxsWm9vbUxldmVsc0ZvclBhZ2U6IGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBsZXZlbHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHZhciBsZXZlbENvdW50ID0gdmlld2VyU3RhdGUubWFuaWZlc3QubWF4Wm9vbTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsZXZlbD0wOyBsZXZlbCA8PSBsZXZlbENvdW50OyBsZXZlbCsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxzLnB1c2goc2V0dGluZ3MubWFuaWZlc3QuZ2V0UGFnZUltYWdlVGlsZXMocGFnZS5pbmRleCwgbGV2ZWwsIHRpbGVEaW1lbnMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXZlbHMucmV2ZXJzZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxldmVscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIGdldFBhZGRpbmcgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcsIGxlZnRQYWRkaW5nO1xuICAgICAgICB2YXIgZG9jVlBhZGRpbmcsIGRvY0hQYWRkaW5nO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5pbkdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRvY1ZQYWRkaW5nID0gc2V0dGluZ3MuZml4ZWRQYWRkaW5nO1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IGxlZnRQYWRkaW5nID0gZG9jSFBhZGRpbmcgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdG9wUGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA6IDA7XG4gICAgICAgICAgICBsZWZ0UGFkZGluZyA9IHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCA/IDAgOiB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZztcblxuICAgICAgICAgICAgZG9jVlBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyAwIDogdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgZG9jSFBhZGRpbmcgPSBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQgPyB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA6IDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IGRvY1ZQYWRkaW5nLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogZG9jVlBhZGRpbmcsXG4gICAgICAgICAgICAgICAgbGVmdDogZG9jSFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGRvY0hQYWRkaW5nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICAgIHRvcDogdG9wUGFkZGluZyxcbiAgICAgICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdFBhZGRpbmcsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHVwZGF0ZVBhZ2VPdmVybGF5cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5wYWdlT3ZlcmxheXMudXBkYXRlT3ZlcmxheXModmlld2VyU3RhdGUucmVuZGVyZXIuZ2V0UmVuZGVyZWRQYWdlcygpKTtcbiAgICB9O1xuXG4gICAgLy9TaG9ydGN1dCBmb3IgY2xvc2luZyBmdWxsc2NyZWVuIHdpdGggdGhlIGVzY2FwZSBrZXlcbiAgICB2YXIgZXNjYXBlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZSlcbiAgICB7XG4gICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlbG9hZFZpZXdlcih7XG4gICAgICAgICAgICAgICAgaW5GdWxsc2NyZWVuOiAhc2V0dGluZ3MuaW5GdWxsc2NyZWVuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDYWxsZWQgdG8gaGFuZGxlIGFueSB6b29tIGxldmVsXG4gICAgdmFyIGhhbmRsZVpvb20gPSBmdW5jdGlvbiAobmV3Wm9vbUxldmVsLCBmb2NhbFBvaW50KVxuICAgIHtcbiAgICAgICAgLy8gSWYgdGhlIHpvb20gbGV2ZWwgcHJvdmlkZWQgaXMgaW52YWxpZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICghaXNWYWxpZE9wdGlvbignem9vbUxldmVsJywgbmV3Wm9vbUxldmVsKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvLyBJZiBubyBmb2NhbCBwb2ludCB3YXMgZ2l2ZW4sIHpvb20gb24gdGhlIGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgaWYgKGZvY2FsUG9pbnQgPT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gdmlld2VyU3RhdGUudmlld3BvcnQ7XG4gICAgICAgICAgICB2YXIgY3VycmVudFJlZ2lvbiA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlUmVnaW9uKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICBmb2NhbFBvaW50ID0ge1xuICAgICAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICh2aWV3cG9ydC53aWR0aCAvIDIpIC0gKGN1cnJlbnRSZWdpb24ubGVmdCAtIHZpZXdwb3J0LmxlZnQpLFxuICAgICAgICAgICAgICAgICAgICB0b3A6ICh2aWV3cG9ydC5oZWlnaHQgLyAyKSAtIChjdXJyZW50UmVnaW9uLnRvcCAtIHZpZXdwb3J0LnRvcClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2VSZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihmb2NhbFBvaW50LmFuY2hvclBhZ2UpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBkaXN0YW5jZSBmcm9tIGN1cnNvciBjb29yZGluYXRlcyB0byBjZW50ZXIgb2Ygdmlld3BvcnRcbiAgICAgICAgdmFyIGZvY2FsWFRvQ2VudGVyID0gKHBhZ2VSZWdpb24ubGVmdCArIGZvY2FsUG9pbnQub2Zmc2V0LmxlZnQpIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC5sZWZ0ICsgKHNldHRpbmdzLnZpZXdwb3J0LndpZHRoIC8gMikpO1xuICAgICAgICB2YXIgZm9jYWxZVG9DZW50ZXIgPSAocGFnZVJlZ2lvbi50b3AgKyBmb2NhbFBvaW50Lm9mZnNldC50b3ApIC1cbiAgICAgICAgICAgIChzZXR0aW5ncy52aWV3cG9ydC50b3AgKyAoc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0IC8gMikpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHpvb21SYXRpbyA9IE1hdGgucG93KDIsIHpvb21MZXZlbCAtIGluaXRpYWxab29tTGV2ZWwpO1xuXG4gICAgICAgICAgICAvL1RPRE8oamVyb21lcGwpOiBDYWxjdWxhdGUgcG9zaXRpb24gZnJvbSBwYWdlIHRvcCBsZWZ0IHRvIHZpZXdwb3J0IHRvcCBsZWZ0XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaG9yaXpvbnRhbC92ZXJ0aWNhbE9mZnNldDogZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXIgdG8gcGFnZSB1cHBlciBsZWZ0IGNvcm5lclxuICAgICAgICAgICAgdmFyIGhvcml6b250YWxPZmZzZXQgPSAoZm9jYWxQb2ludC5vZmZzZXQubGVmdCAqIHpvb21SYXRpbykgLSBmb2NhbFhUb0NlbnRlcjtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IChmb2NhbFBvaW50Lm9mZnNldC50b3AgKiB6b29tUmF0aW8pIC0gZm9jYWxZVG9DZW50ZXI7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsOiB6b29tTGV2ZWwsXG4gICAgICAgICAgICAgICAgYW5jaG9yUGFnZTogZm9jYWxQb2ludC5hbmNob3JQYWdlLFxuICAgICAgICAgICAgICAgIHZlcnRpY2FsT2Zmc2V0OiB2ZXJ0aWNhbE9mZnNldCxcbiAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBob3Jpem9udGFsT2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRpYWxab29tTGV2ZWwgPSB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBzZXR0aW5ncy56b29tTGV2ZWw7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuem9vbUxldmVsID0gbmV3Wm9vbUxldmVsO1xuXG4gICAgICAgIHZhciBlbmRQb3NpdGlvbiA9IGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKG5ld1pvb21MZXZlbCk7XG4gICAgICAgIHZpZXdlclN0YXRlLm9wdGlvbnMuZ29EaXJlY3RseVRvID0gZW5kUG9zaXRpb24uYW5jaG9yUGFnZTtcbiAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxPZmZzZXQgPSBlbmRQb3NpdGlvbi52ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldCA9IGVuZFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQ7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIudHJhbnNpdGlvblZpZXdwb3J0UG9zaXRpb24oe1xuICAgICAgICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWw6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogaW5pdGlhbFpvb21MZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG5ld1pvb21MZXZlbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBhcmFtZXRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uRm9yWm9vbUxldmVsKHBhcmFtZXRlcnMuem9vbUxldmVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGluZm8pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Quc2Nyb2xsKHNjcm9sbEZ1bmN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmludGVycnVwdGVkKVxuICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPSBuZXdab29tTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc2xpZGVyXG4gICAgICAgIHB1Ymxpc2goXCJab29tTGV2ZWxEaWRDaGFuZ2VcIiwgbmV3Wm9vbUxldmVsKTtcblxuICAgICAgICAvLyBXaGlsZSB6b29taW5nLCBkb24ndCB1cGRhdGUgc2Nyb2xsIG9mZnNldHMgYmFzZWQgb24gdGhlIHNjYWxlZCB2ZXJzaW9uIG9mIGRpdmEtaW5uZXJcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3Qub2ZmKCdzY3JvbGwnKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLypcbiAgICAgR2V0cyB0aGUgWS1vZmZzZXQgZm9yIGEgc3BlY2lmaWMgcG9pbnQgb24gYSBzcGVjaWZpYyBwYWdlXG4gICAgIEFjY2VwdGFibGUgdmFsdWVzIGZvciBcImFuY2hvclwiOlxuICAgICBcInRvcFwiIChkZWZhdWx0KSAtIHdpbGwgYW5jaG9yIHRvcCBvZiB0aGUgcGFnZSB0byB0aGUgdG9wIG9mIHRoZSBkaXZhLW91dGVyIGVsZW1lbnRcbiAgICAgXCJib3R0b21cIiAtIHRvcCwgcy90b3AvYm90dG9tXG4gICAgIFwiY2VudGVyXCIgLSB3aWxsIGNlbnRlciB0aGUgcGFnZSBvbiB0aGUgZGl2YSBlbGVtZW50XG4gICAgIFJldHVybmVkIHZhbHVlIHdpbGwgYmUgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgZGl2YS1vdXRlciBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIGN1cnJlbnQgcGFnZSBmb3IgdGhlIHNwZWNpZmllZCBhbmNob3JcbiAgICAgKi9cbiAgICB2YXIgZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIGFuY2hvcilcbiAgICB7XG4gICAgICAgIHBhZ2VJbmRleCA9ICh0eXBlb2YocGFnZUluZGV4KSA9PT0gXCJ1bmRlZmluZWRcIiA/IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXggOiBwYWdlSW5kZXgpO1xuXG4gICAgICAgIGlmIChhbmNob3IgPT09IFwiY2VudGVyXCIgfHwgYW5jaG9yID09PSBcImNlbnRyZVwiKSAvL2hvdyB5b3UgY2FuIHRlbGwgYW4gQW1lcmljYW4gY29kZWQgdGhpc1xuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcImJvdHRvbVwiKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcImhcIikgLSBzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzZXR0aW5ncy5wYW5lbEhlaWdodCAvIDIsIDEwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvL1NhbWUgYXMgZ2V0WU9mZnNldCB3aXRoIFwibGVmdFwiIGFuZCBcInJpZ2h0XCIgYXMgYWNjZXB0YWJsZSB2YWx1ZXMgaW5zdGVhZCBvZiBcInRvcFwiIGFuZCBcImJvdHRvbVwiXG4gICAgdmFyIGdldFhPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBhbmNob3IpXG4gICAge1xuICAgICAgICBwYWdlSW5kZXggPSAodHlwZW9mKHBhZ2VJbmRleCkgPT09IFwidW5kZWZpbmVkXCIgPyBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4IDogcGFnZUluZGV4KTtcblxuICAgICAgICBpZiAoYW5jaG9yID09PSBcImxlZnRcIilcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW5jaG9yID09PSBcInJpZ2h0XCIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChnZXRQYWdlRGF0YShwYWdlSW5kZXgsIFwid1wiKSAtIHNldHRpbmdzLnBhbmVsV2lkdGggLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoZ2V0UGFnZURhdGEocGFnZUluZGV4LCBcIndcIikgLyAyLCAxMCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gdXBkYXRlcyBwYW5lbEhlaWdodC9wYW5lbFdpZHRoIG9uIHJlc2l6ZVxuICAgIHZhciB1cGRhdGVQYW5lbFNpemUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIC8vIEZJWE1FKHdhYmFpbik6IFRoaXMgc2hvdWxkIHJlYWxseSBvbmx5IGJlIGNhbGxlZCBhZnRlciBpbml0aWFsIGxvYWRcbiAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5nb3RvKHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZlcnRpY2FsT2Zmc2V0LCB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB2YXIgdXBkYXRlT2Zmc2V0cyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG5cbiAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmhvcml6b250YWxPZmZzZXQgPSBwYWdlT2Zmc2V0Lng7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbE9mZnNldCA9IHBhZ2VPZmZzZXQueTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBCaW5kIG1vdXNlIGV2ZW50cyAoZHJhZyB0byBzY3JvbGwsIGRvdWJsZS1jbGljaylcbiAgICB2YXIgYmluZE1vdXNlRXZlbnRzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gU2V0IGRyYWcgc2Nyb2xsIG9uIGZpcnN0IGRlc2NlbmRhbnQgb2YgY2xhc3MgZHJhZ2dlciBvbiBib3RoIHNlbGVjdGVkIGVsZW1lbnRzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHZpZXdlclN0YXRlLmlubmVyT2JqZWN0LmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6ICcuZGl2YS1kcmFnZ2VyJywgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZUNsaWNrKHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LCBmdW5jdGlvbiAoZXZlbnQsIGNvb3JkcylcbiAgICAgICAge1xuICAgICAgICAgICAgZGVidWcoJ0RvdWJsZSBjbGljayBhdCAlcywgJXMnLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3SGFuZGxlci5vbkRvdWJsZUNsaWNrKGV2ZW50LCBjb29yZHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIG9uUmVzaXplID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdXBkYXRlUGFuZWxTaXplKCk7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcHJldmlvdXNseS1zZXQgcmVzaXplIHRpbWVvdXRzXG4gICAgICAgIGNsZWFyVGltZW91dCh2aWV3ZXJTdGF0ZS5yZXNpemVUaW1lcik7XG5cbiAgICAgICAgdmlld2VyU3RhdGUucmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYWdlT2Zmc2V0ID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0LmdldFBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0KHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsIHZpZXdlclN0YXRlLnZpZXdwb3J0KTtcblxuICAgICAgICAgICAgaWYgKHBhZ2VPZmZzZXQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVsb2FkVmlld2VyKHtcbiAgICAgICAgICAgICAgICAgICAgZ29EaXJlY3RseVRvOiBzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbE9mZnNldDogcGFnZU9mZnNldC55LFxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsT2Zmc2V0OiBwYWdlT2Zmc2V0LnhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZWxvYWRWaWV3ZXIoe1xuICAgICAgICAgICAgICAgICAgICBnb0RpcmVjdGx5VG86IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9O1xuXG4gICAgLy8gQmluZCB0b3VjaCBhbmQgb3JpZW50YXRpb24gY2hhbmdlIGV2ZW50c1xuICAgIHZhciBiaW5kVG91Y2hFdmVudHMgPSBmdW5jdGlvbigpXG4gICAge1xuICAgICAgICAvLyBCbG9jayB0aGUgdXNlciBmcm9tIG1vdmluZyB0aGUgd2luZG93IG9ubHkgaWYgaXQncyBub3QgaW50ZWdyYXRlZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYmxvY2tNb2JpbGVNb3ZlKVxuICAgICAgICB7XG4gICAgICAgICAgICAkKCdib2R5JykuYmluZCgndG91Y2htb3ZlJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBlID0gZXZlbnQub3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvdWNoIGV2ZW50cyBmb3Igc3dpcGluZyBpbiB0aGUgdmlld3BvcnQgdG8gc2Nyb2xsIHBhZ2VzXG4gICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0T2JqZWN0LmtpbmV0aWMoe1xuICAgICAgICAgICAgdHJpZ2dlckhhcmR3YXJlOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdlc3R1cmVFdmVudHMub25QaW5jaCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMsIHN0YXJ0LCBlbmQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdQaW5jaCAlcyBhdCAlcywgJXMnLCBlbmQgLSBzdGFydCwgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld0hhbmRsZXIub25QaW5jaChldmVudCwgY29vcmRzLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2VzdHVyZUV2ZW50cy5vbkRvdWJsZVRhcCh2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdCwgZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGRlYnVnKCdEb3VibGUgdGFwIGF0ICVzLCAlcycsIGNvb3Jkcy5sZWZ0LCBjb29yZHMudG9wKTtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdIYW5kbGVyLm9uRG91YmxlQ2xpY2soZXZlbnQsIGNvb3Jkcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGhlIHNjcm9sbFxuICAgIHZhciBzY3JvbGxGdW5jdGlvbiA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICB2YXIgcHJldmlvdXNUb3BTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBwcmV2aW91c0xlZnRTY3JvbGwgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC5sZWZ0O1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb247XG5cbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgIHZhciBuZXdTY3JvbGxUb3AgPSB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3A7XG4gICAgICAgIHZhciBuZXdTY3JvbGxMZWZ0ID0gdmlld2VyU3RhdGUudmlld3BvcnQubGVmdDtcblxuICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkIHx8IHNldHRpbmdzLmluR3JpZClcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IG5ld1Njcm9sbFRvcCAtIHByZXZpb3VzVG9wU2Nyb2xsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSBuZXdTY3JvbGxMZWZ0IC0gcHJldmlvdXNMZWZ0U2Nyb2xsO1xuXG4gICAgICAgIC8vZ2l2ZSBhZGp1c3QgdGhlIGRpcmVjdGlvbiB3ZSBjYXJlIGFib3V0XG4gICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmFkanVzdChkaXJlY3Rpb24pO1xuXG4gICAgICAgIHZhciBwcmltYXJ5U2Nyb2xsID0gKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCB8fCBzZXR0aW5ncy5pbkdyaWQpID8gbmV3U2Nyb2xsVG9wIDogbmV3U2Nyb2xsTGVmdDtcblxuICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsXCIsIHByaW1hcnlTY3JvbGwpO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPiAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsRG93blwiLCBwcmltYXJ5U2Nyb2xsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPCAwKVxuICAgICAgICB7XG4gICAgICAgICAgICBwdWJsaXNoKFwiVmlld2VyRGlkU2Nyb2xsVXBcIiwgcHJpbWFyeVNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXRzKCk7XG4gICAgfTtcblxuICAgIC8vIEJpbmRzIG1vc3Qgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIChzb21lIG1vcmUgaW4gY3JlYXRlVG9vbGJhcilcbiAgICB2YXIgaGFuZGxlRXZlbnRzID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIC8vIENoYW5nZSB0aGUgY3Vyc29yIGZvciBkcmFnZ2luZ1xuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5tb3VzZWRvd24oZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QuYWRkQ2xhc3MoJ2RpdmEtZ3JhYmJpbmcnKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJPYmplY3QubW91c2V1cChmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC5yZW1vdmVDbGFzcygnZGl2YS1ncmFiYmluZycpO1xuICAgICAgICB9KTtcblxuICAgICAgICBiaW5kTW91c2VFdmVudHMoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydE9iamVjdC5zY3JvbGwoc2Nyb2xsRnVuY3Rpb24pO1xuXG4gICAgICAgIHZhciB1cEFycm93S2V5ID0gMzgsXG4gICAgICAgICAgICBkb3duQXJyb3dLZXkgPSA0MCxcbiAgICAgICAgICAgIGxlZnRBcnJvd0tleSA9IDM3LFxuICAgICAgICAgICAgcmlnaHRBcnJvd0tleSA9IDM5LFxuICAgICAgICAgICAgc3BhY2VLZXkgPSAzMixcbiAgICAgICAgICAgIHBhZ2VVcEtleSA9IDMzLFxuICAgICAgICAgICAgcGFnZURvd25LZXkgPSAzNCxcbiAgICAgICAgICAgIGhvbWVLZXkgPSAzNixcbiAgICAgICAgICAgIGVuZEtleSA9IDM1O1xuXG4gICAgICAgIC8vIENhdGNoIHRoZSBrZXkgcHJlc3NlcyBpbiBkb2N1bWVudFxuICAgICAgICAkKGRvY3VtZW50KS5vbigna2V5ZG93bi5kaXZhJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXZpZXdlclN0YXRlLmlzQWN0aXZlRGl2YSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gU3BhY2Ugb3IgcGFnZSBkb3duIC0gZ28gdG8gdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5lbmFibGVTcGFjZVNjcm9sbCAmJiAhZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpIHx8IChzZXR0aW5ncy5lbmFibGVLZXlTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gcGFnZURvd25LZXkpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5wYW5lbEhlaWdodDtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGwgJiYgZXZlbnQua2V5Q29kZSA9PT0gc3BhY2VLZXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVuYWJsZUtleVNjcm9sbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGVhbCBrZXlib2FyZCBzaG9ydGN1dHMgKG1ldGFLZXkgPSBjb21tYW5kIFtPUyBYXSwgc3VwZXIgW1dpbi9MaW51eF0pXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIHBhZ2VVcEtleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZ2UgdXAgLSBnbyB0byB0aGUgcHJldmlvdXMgcGFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQudG9wIC09IHNldHRpbmdzLnBhbmVsSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdXBBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwIGFycm93IC0gc2Nyb2xsIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgLT0gc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBkb3duQXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb3duIGFycm93IC0gc2Nyb2xsIGRvd25cbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGxlZnRBcnJvd0tleTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYXJyb3cgLSBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCAtPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIHJpZ2h0QXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSaWdodCBhcnJvdyAtIHNjcm9sbCByaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCArPSBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVLZXk6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIb21lIGtleSAtIGdvIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydC50b3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgZW5kS2V5OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW5kIGtleSAtIGdvIHRvIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBvbiB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSB2YWx1ZSBiZWluZyBub3JtYWxpemVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0LmxlZnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRUZXJtaW5hdGUnLCBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLm9mZigna2V5ZG93bi5kaXZhJyk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICBiaW5kVG91Y2hFdmVudHMoKTtcblxuICAgICAgICAvLyBIYW5kbGUgd2luZG93IHJlc2l6aW5nIGV2ZW50c1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKTtcblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgIH0sIHNldHRpbmdzLklEKTtcblxuICAgICAgICAvLyBIYW5kbGUgb3JpZW50YXRpb24gY2hhbmdlIHNlcGFyYXRlbHlcbiAgICAgICAgaWYgKCdvbm9yaWVudGF0aW9uY2hhbmdlJyBpbiB3aW5kb3cpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24oKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplLCBmYWxzZSk7XG4gICAgICAgICAgICB9LCBzZXR0aW5ncy5JRCk7XG4gICAgICAgIH1cblxuICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1BhbmVsU2l6ZURpZENoYW5nZScsIHVwZGF0ZVBhbmVsU2l6ZSwgc2V0dGluZ3MuSUQpO1xuXG4gICAgICAgIC8vIENsZWFyIHBhZ2UgYW5kIHJlc2l6ZSB0aW1lb3V0cyB3aGVuIHRoZSB2aWV3ZXIgaXMgZGVzdHJveWVkXG4gICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnVmlld2VyRGlkVGVybWluYXRlJywgZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLnJlbmRlcmVyKVxuICAgICAgICAgICAgICAgIHZpZXdlclN0YXRlLnJlbmRlcmVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHZpZXdlclN0YXRlLnJlc2l6ZVRpbWVyKTtcbiAgICAgICAgfSwgc2V0dGluZ3MuSUQpO1xuICAgIH07XG5cbiAgICB2YXIgaW5pdFBsdWdpbnMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gQWRkIGFsbCB0aGUgcGx1Z2lucyB0aGF0IGhhdmUgbm90IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCB0b1xuICAgICAgICAvLyBzZXR0aW5ncy5wbHVnaW5zXG4gICAgICAgIFBsdWdpblJlZ2lzdHJ5LmdldEFsbCgpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBsdWdpblByb3Blck5hbWUgPSBwbHVnaW4ucGx1Z2luTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgcGx1Z2luLnBsdWdpbk5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NbJ2VuYWJsZScgKyBwbHVnaW5Qcm9wZXJOYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBpbml0IGZ1bmN0aW9uIGFuZCBjaGVjayByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICB2YXIgZW5hYmxlUGx1Z2luID0gcGx1Z2luLmluaXQoc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIGludCByZXR1cm5zIGZhbHNlLCBjb25zaWRlciB0aGUgcGx1Z2luIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFlbmFibGVQbHVnaW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGFnZVRvb2xzIGJhciBpZiBoYW5kbGVDbGljayBpcyBzZXQgdG8gYSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmhhbmRsZUNsaWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmlld2VyU3RhdGUucGFnZVRvb2xzLnB1c2gocGx1Z2luKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gc2V0dGluZ3MucGx1Z2lucyBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyIHNob3dUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS50aHJvYmJlclRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICd0aHJvYmJlcicpLnNob3coKTtcbiAgICAgICAgfSwgc2V0dGluZ3MudGhyb2JiZXJUaW1lb3V0KTtcbiAgICB9O1xuXG4gICAgdmFyIGhpZGVUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICAvLyBDbGVhciB0aGUgdGltZW91dCwgaWYgaXQgaGFzbid0IGV4ZWN1dGVkIHlldFxuICAgICAgICBjbGVhclRpbWVvdXQodmlld2VyU3RhdGUudGhyb2JiZXJUaW1lb3V0SUQpO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIHRocm9iYmVyIGlmIGl0IGhhcyBhbHJlYWR5IGV4ZWN1dGVkXG4gICAgICAgICQoc2V0dGluZ3Muc2VsZWN0b3IgKyAndGhyb2JiZXInKS5oaWRlKCk7XG4gICAgfTtcblxuICAgIHZhciBzaG93RXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgdmFyIGVycm9yRWxlbWVudCA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdlcnJvcicpLCBbXG4gICAgICAgICAgICBlbHQoJ2J1dHRvbicsIGVsZW1BdHRycygnZXJyb3ItY2xvc2UnLCB7J2FyaWEtbGFiZWwnOiAnQ2xvc2UgZGlhbG9nJ30pKSxcbiAgICAgICAgICAgIGVsdCgncCcsXG4gICAgICAgICAgICAgICAgZWx0KCdzdHJvbmcnLCAnRXJyb3InKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgbWVzc2FnZSlcbiAgICAgICAgXSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QuYXBwZW5kKGVycm9yRWxlbWVudCk7XG5cbiAgICAgICAgLy9iaW5kIGRpYWxvZyBjbG9zZSBidXR0b25cbiAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICdlcnJvci1jbG9zZScpLm9uKCdjbGljaycsIGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZXJyb3JFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciBzZXRNYW5pZmVzdCA9IGZ1bmN0aW9uIChtYW5pZmVzdCwgbG9hZE9wdGlvbnMpXG4gICAge1xuICAgICAgICB2aWV3ZXJTdGF0ZS5tYW5pZmVzdCA9IG1hbmlmZXN0O1xuXG4gICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgIC8vIENvbnZlbmllbmNlIHZhbHVlXG4gICAgICAgIHZpZXdlclN0YXRlLm51bVBhZ2VzID0gc2V0dGluZ3MubWFuaWZlc3QucGFnZXMubGVuZ3RoO1xuXG4gICAgICAgIG9wdGlvbnNWYWxpZGF0b3IudmFsaWRhdGUodmlld2VyU3RhdGUub3B0aW9ucyk7XG5cbiAgICAgICAgcHVibGlzaCgnTnVtYmVyT2ZQYWdlc0RpZENoYW5nZScsIHNldHRpbmdzLm51bVBhZ2VzKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZW5hYmxlQXV0b1RpdGxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoJChzZXR0aW5ncy5zZWxlY3RvciArICd0aXRsZScpLmxlbmd0aClcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3RpdGxlJykuaHRtbChzZXR0aW5ncy5tYW5pZmVzdC5pdGVtVGl0bGUpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBhcmVudE9iamVjdC5wcmVwZW5kKGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0aXRsZScpLCBbc2V0dGluZ3MubWFuaWZlc3QuaXRlbVRpdGxlXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBpbnRlci1wYWdlIHBhZGRpbmcgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGF2ZXJhZ2Ugem9vbSBsZXZlbFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWRhcHRpdmVQYWRkaW5nID4gMClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmZsb29yKChzZXR0aW5ncy5taW5ab29tTGV2ZWwgKyBzZXR0aW5ncy5tYXhab29tTGV2ZWwpIC8gMik7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHBhcnNlSW50KHNldHRpbmdzLm1hbmlmZXN0LmdldEF2ZXJhZ2VXaWR0aCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nID0gcGFyc2VJbnQoc2V0dGluZ3MubWFuaWZlc3QuZ2V0QXZlcmFnZUhlaWdodCh6KSAqIHNldHRpbmdzLmFkYXB0aXZlUGFkZGluZywgMTApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSXQncyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMDsgdXNlIGZpeGVkUGFkZGluZyBpbnN0ZWFkXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZlcnRpY2FsUGFkZGluZyA9IHNldHRpbmdzLmZpeGVkUGFkZGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGljYWwgcGFkZGluZyBpcyBhdCBsZWFzdCA0MCwgaWYgcGx1Z2luIGljb25zIGFyZSBlbmFibGVkXG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5wYWdlVG9vbHMubGVuZ3RoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbFBhZGRpbmcgPSBNYXRoLm1heCg0MCwgdmlld2VyU3RhdGUudmVydGljYWxQYWRkaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGRldGVjdCBhIHZpZXdpbmdIaW50IG9mICdwYWdlZCcgaW4gdGhlIG1hbmlmZXN0IG9yIHNlcXVlbmNlLCBlbmFibGUgYm9vayB2aWV3IGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHNldHRpbmdzLm1hbmlmZXN0LnBhZ2VkKVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmluQm9va0xheW91dCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQbHVnaW4gc2V0dXAgaG9va3Mgc2hvdWxkIGJlIGJvdW5kIHRvIHRoZSBPYmplY3REaWRMb2FkIGV2ZW50XG4gICAgICAgIHB1Ymxpc2goJ09iamVjdERpZExvYWQnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSBkb2N1bWVudCBwYW5lbCBkaW1lbnNpb25zXG4gICAgICAgIHVwZGF0ZVBhbmVsU2l6ZSgpO1xuXG4gICAgICAgIHZhciBuZWVkc1hDb29yZCwgbmVlZHNZQ29vcmQ7XG5cbiAgICAgICAgdmFyIGFuY2hvcmVkVmVydGljYWxseSA9IGZhbHNlO1xuICAgICAgICB2YXIgYW5jaG9yZWRIb3Jpem9udGFsbHkgPSBmYWxzZTtcblxuICAgICAgICAvLyBOQjogYD09YCBoZXJlIHdpbGwgY2hlY2sgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgaWYgKGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbyA9PSBudWxsKVxuICAgICAgICB7XG4gICAgICAgICAgICBsb2FkT3B0aW9ucy5nb0RpcmVjdGx5VG8gPSBzZXR0aW5ncy5nb0RpcmVjdGx5VG87XG4gICAgICAgICAgICBuZWVkc1hDb29yZCA9IG5lZWRzWUNvb3JkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5lZWRzWENvb3JkID0gbG9hZE9wdGlvbnMuaG9yaXpvbnRhbE9mZnNldCA9PSBudWxsIHx8IGlzTmFOKGxvYWRPcHRpb25zLmhvcml6b250YWxPZmZzZXQpO1xuICAgICAgICAgICAgbmVlZHNZQ29vcmQgPSBsb2FkT3B0aW9ucy52ZXJ0aWNhbE9mZnNldCA9PSBudWxsIHx8IGlzTmFOKGxvYWRPcHRpb25zLnZlcnRpY2FsT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIG9mZnNldHNcbiAgICAgICAgaWYgKG5lZWRzWENvb3JkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBGSVhNRTogV2hhdCBpZiBpbkJvb2tMYXlvdXQvdmVydGljYWxseU9yaWVudGVkIGlzIGNoYW5nZWQgYnkgbG9hZE9wdGlvbnM/XG4gICAgICAgICAgICBpZiAobG9hZE9wdGlvbnMuZ29EaXJlY3RseVRvID09PSAwICYmIHNldHRpbmdzLmluQm9va0xheW91dCAmJiBzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaW4gYm9vayBsYXlvdXQsIGNlbnRlciB0aGUgZmlyc3Qgb3BlbmluZyBieSBkZWZhdWx0XG4gICAgICAgICAgICAgICAgbG9hZE9wdGlvbnMuaG9yaXpvbnRhbE9mZnNldCA9IHZpZXdlclN0YXRlLmhvcml6b250YWxQYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFuY2hvcmVkSG9yaXpvbnRhbGx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBsb2FkT3B0aW9ucy5ob3Jpem9udGFsT2Zmc2V0ID0gZ2V0WE9mZnNldChsb2FkT3B0aW9ucy5nb0RpcmVjdGx5VG8sIFwiY2VudGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzWUNvb3JkKVxuICAgICAgICB7XG4gICAgICAgICAgICBhbmNob3JlZFZlcnRpY2FsbHkgPSB0cnVlO1xuICAgICAgICAgICAgbG9hZE9wdGlvbnMudmVydGljYWxPZmZzZXQgPSBnZXRZT2Zmc2V0KGxvYWRPcHRpb25zLmdvRGlyZWN0bHlUbywgXCJ0b3BcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZWxvYWRWaWV3ZXIobG9hZE9wdGlvbnMpO1xuXG4gICAgICAgIC8vcHJlcCBkaW1lbnNpb25zIG9uZSBsYXN0IHRpbWUgbm93IHRoYXQgcGFnZXMgaGF2ZSBsb2FkZWRcbiAgICAgICAgdXBkYXRlUGFuZWxTaXplKCk7XG5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgaXMgYSBoYWNrIHRvIGVuc3VyZSB0aGF0IHRoZSBvdXRlckVsZW1lbnQgc2Nyb2xsYmFycyBhcmUgdGFrZW4gaW50byBhY2NvdW50XG4gICAgICAgIGlmIChzZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lckVsZW1lbnQuc3R5bGUubWluV2lkdGggPSBzZXR0aW5ncy5wYW5lbFdpZHRoICsgJ3B4JztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJFbGVtZW50LnN0eWxlLm1pbkhlaWdodCA9IHNldHRpbmdzLnBhbmVsSGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAvLyBGSVhNRTogSWYgdGhlIHBhZ2Ugd2FzIHN1cHBvc2VkIHRvIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcmVjYWxjdWxhdGUgaXQgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhlIHNjcm9sbGJhcnNcbiAgICAgICAgaWYgKGFuY2hvcmVkVmVydGljYWxseSB8fCBhbmNob3JlZEhvcml6b250YWxseSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGFuY2hvcmVkVmVydGljYWxseSlcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbE9mZnNldCA9IGdldFlPZmZzZXQoc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCwgXCJ0b3BcIik7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3JlZEhvcml6b250YWxseSlcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5ob3Jpem9udGFsT2Zmc2V0ID0gZ2V0WE9mZnNldChzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCBcImNlbnRlclwiKTtcblxuICAgICAgICAgICAgdmlld2VyU3RhdGUucmVuZGVyZXIuZ290byhzZXR0aW5ncy5jdXJyZW50UGFnZUluZGV4LCB2aWV3ZXJTdGF0ZS52ZXJ0aWNhbE9mZnNldCwgdmlld2VyU3RhdGUuaG9yaXpvbnRhbE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaWduYWwgdGhhdCBldmVyeXRoaW5nIHNob3VsZCBiZSBzZXQgdXAgYW5kIHJlYWR5IHRvIGdvLlxuICAgICAgICB2aWV3ZXJTdGF0ZS5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAgIHB1Ymxpc2goXCJWaWV3ZXJEaWRMb2FkXCIsIHNldHRpbmdzKTtcbiAgICB9O1xuXG4gICAgdmFyIHB1Ymxpc2ggPSBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2goZXZlbnQsIGFyZ3MsIHB1YmxpY0luc3RhbmNlKTtcbiAgICB9O1xuXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gRmlyc3QgZmlndXJlIG91dCB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbGJhciBpbiB0aGlzIGJyb3dzZXJcbiAgICAgICAgLy8gVE9ETyh3YWJhaW4pOiBDYWNoZSB0aGlzIHNvbWV3aGVyZSBlbHNlXG4gICAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgcGx1Z2lucyByZWx5IG9uIHRoaXMgbm93XG4gICAgICAgIHZpZXdlclN0YXRlLnNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGgoKTtcblxuICAgICAgICAvLyBJZiB3aW5kb3cub3JpZW50YXRpb24gaXMgZGVmaW5lZCwgdGhlbiBpdCdzIHByb2JhYmx5IG1vYmlsZVdlYmtpdFxuICAgICAgICB2aWV3ZXJTdGF0ZS5tb2JpbGVXZWJraXQgPSB3aW5kb3cub3JpZW50YXRpb24gIT09IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBhbiBJRCB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgcHJlZml4IGZvciBhbGwgdGhlIG90aGVyIElEc1xuICAgICAgICB2YXIgaWROdW1iZXIgPSBnZW5lcmF0ZUlkKCk7XG4gICAgICAgIHZpZXdlclN0YXRlLklEID0gJ2RpdmEtJyArIGlkTnVtYmVyICsgJy0nO1xuICAgICAgICB2aWV3ZXJTdGF0ZS5zZWxlY3RvciA9ICcjJyArIHNldHRpbmdzLklEO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmhhc2hQYXJhbVN1ZmZpeCA9PT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gT21pdCB0aGUgc3VmZml4IGZyb20gdGhlIGZpcnN0IGluc3RhbmNlXG4gICAgICAgICAgICBpZiAoaWROdW1iZXIgPT09IDEpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oYXNoUGFyYW1TdWZmaXggPSAnJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhhc2hQYXJhbVN1ZmZpeCA9IGlkTnVtYmVyICsgJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGlubmVyIGFuZCBvdXRlciBwYW5lbHNcbiAgICAgICAgdmFyIGlubmVyRWxlbSA9IGVsdCgnZGl2JywgZWxlbUF0dHJzKCdpbm5lcicsIHsgY2xhc3M6ICdkaXZhLWlubmVyIGRpdmEtZHJhZ2dlcicgfSkpO1xuICAgICAgICB2YXIgdmlld3BvcnRFbGVtID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ3ZpZXdwb3J0JyksIGlubmVyRWxlbSk7XG4gICAgICAgIHZhciBvdXRlckVsZW0gPSBlbHQoJ2RpdicsIGVsZW1BdHRycygnb3V0ZXInKSxcbiAgICAgICAgICAgIHZpZXdwb3J0RWxlbSxcbiAgICAgICAgICAgIGVsdCgnZGl2JywgZWxlbUF0dHJzKCd0aHJvYmJlcicpKSk7XG5cbiAgICAgICAgdmlld2VyU3RhdGUuaW5uZXJFbGVtZW50ID0gaW5uZXJFbGVtO1xuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydEVsZW1lbnQgPSB2aWV3cG9ydEVsZW07XG4gICAgICAgIHZpZXdlclN0YXRlLm91dGVyRWxlbWVudCA9IG91dGVyRWxlbTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdCA9ICQoaW5uZXJFbGVtKTtcbiAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRPYmplY3QgPSAkKHZpZXdwb3J0RWxlbSk7XG4gICAgICAgIHZpZXdlclN0YXRlLm91dGVyT2JqZWN0ID0gJChvdXRlckVsZW0pO1xuXG4gICAgICAgIHNldHRpbmdzLnBhcmVudE9iamVjdC5hcHBlbmQob3V0ZXJFbGVtKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS52aWV3cG9ydCA9IG5ldyBWaWV3cG9ydCh2aWV3ZXJTdGF0ZS52aWV3cG9ydEVsZW1lbnQsIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblRvbGVyYW5jZTogc2V0dGluZ3Mudmlld3BvcnRNYXJnaW5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRG8gYWxsIHRoZSBwbHVnaW4gaW5pdGlhbGlzYXRpb25cbiAgICAgICAgaW5pdFBsdWdpbnMoKTtcblxuICAgICAgICBoYW5kbGVFdmVudHMoKTtcblxuICAgICAgICAvLyBTaG93IHRoZSB0aHJvYmJlciB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbWFuaWZlc3QgdG8gbG9hZFxuICAgICAgICBzaG93VGhyb2JiZXIoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfTtcblxuICAgIC8vIFRlbXBvcmFyeSBhY2Nlc3NvciBmb3IgdGhlIHN0YXRlIG9mIHRoZSB2aWV3ZXIgY29yZVxuICAgIC8vIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGEgbW9yZSByZXN0cmljdGVkIHZpZXcgb2Ygd2hhdGV2ZXIgbmVlZHNcbiAgICAvLyBiZSBleHBvc2VkIHRocm91Z2ggc2V0dGluZ3MgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICB0aGlzLmdldEludGVybmFsU3RhdGUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFB1YmxpY0luc3RhbmNlID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0YW5jZTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRQYWdlVG9vbHMgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHZpZXdlclN0YXRlLnBhZ2VUb29scztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDdXJyZW50TGF5b3V0ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5yZW5kZXJlciA/IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dCA6IG51bGw7XG4gICAgfTtcblxuICAgIC8qKiBHZXQgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHZpZXdwb3J0IGRpbWVuc2lvbnMgKi9cbiAgICB0aGlzLmdldFZpZXdwb3J0ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHZhciB2aWV3cG9ydCA9IHZpZXdlclN0YXRlLnZpZXdwb3J0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHZpZXdwb3J0LnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHZpZXdwb3J0LmxlZnQsXG4gICAgICAgICAgICBib3R0b206IHZpZXdwb3J0LmJvdHRvbSxcbiAgICAgICAgICAgIHJpZ2h0OiB2aWV3cG9ydC5yaWdodCxcblxuICAgICAgICAgICAgd2lkdGg6IHZpZXdwb3J0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRQYWdlT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxuICAgIHtcbiAgICAgICAgdmlld2VyU3RhdGUucGFnZU92ZXJsYXlzLmFkZE92ZXJsYXkob3ZlcmxheSk7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlUGFnZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnBhZ2VPdmVybGF5cy5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VSZWdpb24gPSBmdW5jdGlvbiAocGFnZUluZGV4LCBvcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHZpZXdlclN0YXRlLnJlbmRlcmVyLmxheW91dDtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IGxheW91dC5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNvcnBvcmF0ZVZpZXdwb3J0KVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2Vjb25kYXJ5RGltID0gc2V0dGluZ3MudmVydGljYWxseU9yaWVudGVkID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgICAgICAgICBpZiAodmlld2VyU3RhdGUudmlld3BvcnRbc2Vjb25kYXJ5RGltXSA+IGxheW91dC5kaW1lbnNpb25zW3NlY29uZGFyeURpbV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY09mZnNldCA9ICh2aWV3ZXJTdGF0ZS52aWV3cG9ydFtzZWNvbmRhcnlEaW1dIC0gbGF5b3V0LmRpbWVuc2lvbnNbc2Vjb25kYXJ5RGltXSkgLyAyO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJlZ2lvbi50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHJlZ2lvbi5ib3R0b20sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IHJlZ2lvbi5sZWZ0ICsgZG9jT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJlZ2lvbi5yaWdodCArIGRvY09mZnNldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiByZWdpb24udG9wICsgZG9jT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByZWdpb24uYm90dG9tICsgZG9jT2Zmc2V0LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWdpb24ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiByZWdpb24ucmlnaHRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VQb3NpdGlvbkF0Vmlld3BvcnRPZmZzZXQgPSBmdW5jdGlvbiAoY29vcmRzKVxuICAgIHtcbiAgICAgICAgdmFyIGRvY0Nvb3JkcyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IGNvb3Jkcy5sZWZ0ICsgdmlld2VyU3RhdGUudmlld3BvcnQubGVmdCxcbiAgICAgICAgICAgIHRvcDogY29vcmRzLnRvcCArIHZpZXdlclN0YXRlLnZpZXdwb3J0LnRvcFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW5kZXJlZFBhZ2VzID0gdmlld2VyU3RhdGUucmVuZGVyZXIuZ2V0UmVuZGVyZWRQYWdlcygpO1xuICAgICAgICB2YXIgcGFnZUNvdW50ID0gcmVuZGVyZWRQYWdlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgcGFnZSBvbiB3aGljaCB0aGUgY29vcmRzIG9jY3VyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHBhZ2VDb3VudDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFnZUluZGV4ID0gcmVuZGVyZWRQYWdlc1tpXTtcbiAgICAgICAgICAgIHZhciByZWdpb24gPSB2aWV3ZXJTdGF0ZS5yZW5kZXJlci5sYXlvdXQuZ2V0UGFnZVJlZ2lvbihwYWdlSW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAocmVnaW9uLmxlZnQgPD0gZG9jQ29vcmRzLmxlZnQgJiYgcmVnaW9uLnJpZ2h0ID49IGRvY0Nvb3Jkcy5sZWZ0ICYmXG4gICAgICAgICAgICAgICAgcmVnaW9uLnRvcCA8PSBkb2NDb29yZHMudG9wICYmIHJlZ2lvbi5ib3R0b20gPj0gZG9jQ29vcmRzLnRvcClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhbmNob3JQYWdlOiBwYWdlSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogZG9jQ29vcmRzLmxlZnQgLSByZWdpb24ubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZG9jQ29vcmRzLnRvcCAtIHJlZ2lvbi50b3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gY3VycmVudCBwYWdlXG4gICAgICAgIC8vIEZJWE1FOiBXb3VsZCBiZSBiZXR0ZXIgdG8gdXNlIHRoZSBjbG9zZXN0IHBhZ2Ugb3Igc29tZXRoaW5nXG4gICAgICAgIHZhciBjdXJyZW50UmVnaW9uID0gdmlld2VyU3RhdGUucmVuZGVyZXIubGF5b3V0LmdldFBhZ2VSZWdpb24oc2V0dGluZ3MuY3VycmVudFBhZ2VJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuY2hvclBhZ2U6IHNldHRpbmdzLmN1cnJlbnRQYWdlSW5kZXgsXG4gICAgICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiBkb2NDb29yZHMubGVmdCAtIGN1cnJlbnRSZWdpb24ubGVmdCxcbiAgICAgICAgICAgICAgICB0b3A6IGRvY0Nvb3Jkcy50b3AgLSBjdXJyZW50UmVnaW9uLnRvcFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB0aGlzLnNldE1hbmlmZXN0ID0gZnVuY3Rpb24gKG1hbmlmZXN0LCBsb2FkT3B0aW9ucylcbiAgICB7XG4gICAgICAgIHNldE1hbmlmZXN0KG1hbmlmZXN0LCBsb2FkT3B0aW9ucyB8fCB7fSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY3VycmVudCBwYWdlIHRvIHRoZSBnaXZlbiBpbmRleCwgZmlyaW5nIFZpc2libGVQYWdlRGlkQ2hhbmdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFnZUluZGV4XG4gICAgICovXG4gICAgdGhpcy5zZXRDdXJyZW50UGFnZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuY3VycmVudFBhZ2VJbmRleCAhPT0gcGFnZUluZGV4KVxuICAgICAgICB7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5jdXJyZW50UGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgICAgcHVibGlzaChcIlZpc2libGVQYWdlRGlkQ2hhbmdlXCIsIHBhZ2VJbmRleCwgdGhpcy5nZXRQYWdlTmFtZShwYWdlSW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldFBhZ2VOYW1lID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIHJldHVybiB2aWV3ZXJTdGF0ZS5tYW5pZmVzdC5wYWdlc1twYWdlSW5kZXhdLmY7XG4gICAgfTtcblxuICAgIHRoaXMucmVsb2FkID0gZnVuY3Rpb24gKG5ld09wdGlvbnMpXG4gICAge1xuICAgICAgICByZWxvYWRWaWV3ZXIobmV3T3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbSA9IGZ1bmN0aW9uICh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpXG4gICAge1xuICAgICAgICByZXR1cm4gaGFuZGxlWm9vbSh6b29tTGV2ZWwsIGZvY2FsUG9pbnQpO1xuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZVNjcm9sbGFibGUgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgaWYgKCF2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJpbmRNb3VzZUV2ZW50cygpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVLZXlTY3JvbGwgPSB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IHZpZXdlclN0YXRlLmluaXRpYWxTcGFjZVNjcm9sbDtcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLnZpZXdwb3J0RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICAgICAgICAgIHZpZXdlclN0YXRlLmlzU2Nyb2xsYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsYWJsZSA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBpZiAodmlld2VyU3RhdGUuaXNTY3JvbGxhYmxlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBibG9jayBkcmFnZ2luZy9kb3VibGUtY2xpY2sgem9vbWluZ1xuICAgICAgICAgICAgaWYgKHZpZXdlclN0YXRlLmlubmVyT2JqZWN0Lmhhc0NsYXNzKCdkaXZhLWRyYWdnZXInKSlcbiAgICAgICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbm5lck9iamVjdC51bmJpbmQoJ21vdXNlZG93bicpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdkYmxjbGljaycpO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3V0ZXJPYmplY3QudW5iaW5kKCdjb250ZXh0bWVudScpO1xuXG4gICAgICAgICAgICAvLyBkaXNhYmxlIGFsbCBvdGhlciBzY3JvbGxpbmcgYWN0aW9uc1xuICAgICAgICAgICAgdmlld2VyU3RhdGUudmlld3BvcnRFbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgICAgIC8vIGJsb2NrIHNjcm9sbGluZyBrZXlzIGJlaGF2aW9yLCByZXNwZWN0aW5nIGluaXRpYWwgc2Nyb2xsIHNldHRpbmdzXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pbml0aWFsS2V5U2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlS2V5U2Nyb2xsO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUuaW5pdGlhbFNwYWNlU2Nyb2xsID0gc2V0dGluZ3MuZW5hYmxlU3BhY2VTY3JvbGw7XG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5vcHRpb25zLmVuYWJsZUtleVNjcm9sbCA9IGZhbHNlO1xuICAgICAgICAgICAgdmlld2VyU3RhdGUub3B0aW9ucy5lbmFibGVTcGFjZVNjcm9sbCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB2aWV3ZXJTdGF0ZS5pc1Njcm9sbGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmlzVmFsaWRPcHRpb24gPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkT3B0aW9uKGtleSwgdmFsdWUpO1xuICAgIH07XG5cbiAgICB0aGlzLnNob3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKVxuICAgIHtcbiAgICAgICAgLy8gRklYTUU6IE5vdCB0b3RhbGx5IHN1cmUgaXQgbWFrZXMgc2Vuc2UgdG8gYWx3YXlzIGRvIHRoYXQgaGVyZVxuICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICB2YXIgZXJyb3JFbGVtZW50ID0gZWx0KCdkaXYnLCBlbGVtQXR0cnMoJ2Vycm9yJyksIFtcbiAgICAgICAgICAgIGVsdCgnYnV0dG9uJywgZWxlbUF0dHJzKCdlcnJvci1jbG9zZScsIHsnYXJpYS1sYWJlbCc6ICdDbG9zZSBkaWFsb2cnfSkpLFxuICAgICAgICAgICAgZWx0KCdwJyxcbiAgICAgICAgICAgICAgICBlbHQoJ3N0cm9uZycsICdFcnJvcicpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgZWx0KCdkaXYnLCBtZXNzYWdlKVxuICAgICAgICBdKTtcblxuICAgICAgICB2aWV3ZXJTdGF0ZS5vdXRlck9iamVjdC5hcHBlbmQoZXJyb3JFbGVtZW50KTtcblxuICAgICAgICAvL2JpbmQgZGlhbG9nIGNsb3NlIGJ1dHRvblxuICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ2Vycm9yLWNsb3NlJykub24oJ2NsaWNrJywgZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBlcnJvckVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlcnJvckVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRYT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgeEFuY2hvcilcbiAgICB7XG4gICAgICAgIHJldHVybiBnZXRYT2Zmc2V0KHBhZ2VJbmRleCwgeEFuY2hvcik7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0WU9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHlBbmNob3IpXG4gICAge1xuICAgICAgICByZXR1cm4gZ2V0WU9mZnNldChwYWdlSW5kZXgsIHlBbmNob3IpO1xuICAgIH07XG5cbiAgICB0aGlzLnB1Ymxpc2ggPSBwdWJsaXNoO1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICBjbGVhclZpZXdlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBmdW5jdGlvbiAocGVuZGluZ01hbmlmZXN0UmVxdWVzdClcbiAgICB7XG4gICAgICAgIHZpZXdlclN0YXRlLnBlbmRpbmdNYW5pZmVzdFJlcXVlc3QgPSBwZW5kaW5nTWFuaWZlc3RSZXF1ZXN0O1xuICAgIH07XG5cbiAgICAvLyBEZXN0cm95cyB0aGlzIGluc3RhbmNlLCB0ZWxscyBwbHVnaW5zIHRvIGRvIHRoZSBzYW1lIChmb3IgdGVzdGluZylcbiAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgLy8gVXNlZnVsIGV2ZW50IHRvIGFjY2VzcyBlbGVtZW50cyBpbiBkaXZhIGJlZm9yZSB0aGV5IGdldCBkZXN0cm95ZWQuIFVzZWQgYnkgdGhlIGhpZ2hsaWdodCBwbHVnaW4uXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlcldpbGxUZXJtaW5hdGUnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3QgcmV0cmlldmluZyBhIG1hbmlmZXN0XG4gICAgICAgIGlmIChzZXR0aW5ncy5wZW5kaW5nTWFuaWZlc3RSZXF1ZXN0KVxuICAgICAgICAgICAgc2V0dGluZ3MucGVuZGluZ01hbmlmZXN0UmVxdWVzdC5hYm9ydCgpO1xuXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIGhpZGUtc2Nyb2xsYmFyIGNsYXNzIGZyb20gdGhlIGJvZHlcbiAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdkaXZhLWhpZGUtc2Nyb2xsYmFyJyk7XG5cbiAgICAgICAgLy8gRW1wdHkgdGhlIHBhcmVudCBjb250YWluZXIgYW5kIHJlbW92ZSBhbnkgZGl2YS1yZWxhdGVkIGRhdGFcbiAgICAgICAgc2V0dGluZ3MucGFyZW50T2JqZWN0LnBhcmVudCgpLmVtcHR5KCkucmVtb3ZlRGF0YSgnZGl2YScpO1xuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgYWRkaXRpb25hbCBzdHlsaW5nIG9uIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICBzZXR0aW5ncy5wYXJlbnRPYmplY3QucGFyZW50KCkucmVtb3ZlQXR0cignc3R5bGUnKS5yZW1vdmVBdHRyKCdjbGFzcycpO1xuXG4gICAgICAgIHB1Ymxpc2goJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIHNldHRpbmdzKTtcblxuICAgICAgICAvLyBDbGVhciB0aGUgRXZlbnRzIGNhY2hlXG4gICAgICAgIGRpdmEuRXZlbnRzLnVuc3Vic2NyaWJlQWxsKHNldHRpbmdzLklEKTtcbiAgICB9O1xuXG4gICAgLy8gQ2FsbCB0aGUgaW5pdCBmdW5jdGlvbiB3aGVuIHRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQuXG4gICAgaW5pdCgpO1xufVxuXG5nZW5lcmF0ZUlkLmNvdW50ZXIgPSAxO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICAgIHJldHVybiBnZW5lcmF0ZUlkLmNvdW50ZXIrKztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3ZpZXdlci1jb3JlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiBqc2hpbnQgdW51c2VkOiBmYWxzZSAqL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IFRoaXMgaXMgYSB2ZW5kb3JlZCBkZXBlbmRlbmN5ICovXG4vKlxuICogalF1ZXJ5IGRyYWdzY3JvbGxhYmxlIFBsdWdpblxuICogdmVyc2lvbjogMS4wICgyNS1KdW4tMjAwOSlcbiAqIENvcHlyaWdodCAoYykgMjAwOSBNaXF1ZWwgSGVycmVyYVxuICogaHR0cDovL3BsdWdpbnMuanF1ZXJ5LmNvbS9wcm9qZWN0L0RyYWdzY3JvbGxhYmxlXG4gKlxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXM6XG4gKiAgIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gKiAgIGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy9ncGwuaHRtbFxuICpcbiAqL1xuKGZ1bmN0aW9uICgkKSB7IC8vIHNlY3VyZSAkIGpRdWVyeSBhbGlhc1xuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYWJpbGl0eSB0byBtYW5hZ2UgZWxlbWVudHMgc2Nyb2xsIGJ5IGRyYWdnaW5nXG4gICAgICogb25lIG9yIG1vcmUgb2YgaXRzIGRlc2NlbmRhbnQgZWxlbWVudHMuIE9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICogYWxsb3cgdG8gc3BlY2lmaWNhbGx5IHNlbGVjdCB3aGljaCBpbm5lciBlbGVtZW50cyB3aWxsXG4gICAgICogcmVzcG9uZCB0byB0aGUgZHJhZyBldmVudHMuXG4gICAgICpcbiAgICAgKiBvcHRpb25zIHByb3BlcnRpZXM6XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIGRyYWdTZWxlY3RvciAgICAgICAgIHwganF1ZXJ5IHNlbGVjdG9yIHRvIGFwcGx5IHRvIGVhY2ggd3JhcHBlZCBlbGVtZW50XG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgdG8gZmluZCB3aGljaCB3aWxsIGJlIHRoZSBkcmFnZ2luZyBlbGVtZW50cy5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgfCBEZWZhdWx0cyB0byAnPjpmaXJzdCcgd2hpY2ggaXMgdGhlIGZpcnN0IGNoaWxkIG9mXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgc2Nyb2xsYWJsZSBlbGVtZW50XG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogIGFjY2VwdFByb3BhZ2F0ZWRFdmVudHwgV2lsbCB0aGUgZHJhZ2dpbmcgZWxlbWVudCBhY2NlcHQgcHJvcGFnYXRlZFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGV2ZW50cz8gZGVmYXVsdCBpcyB5ZXMsIGEgcHJvcGFnYXRlZCBtb3VzZSBldmVudFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IG9uIGEgaW5uZXIgZWxlbWVudCB3aWxsIGJlIGFjY2VwdGVkIGFuZCBwcm9jZXNzZWQuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgIHwgSWYgc2V0IHRvIGZhbHNlLCBvbmx5IGV2ZW50cyBvcmlnaW5hdGVkIG9uIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGRyYWdnYWJsZSBlbGVtZW50cyB3aWxsIGJlIHByb2Nlc3NlZC5cbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgcHJldmVudERlZmF1bHQgICAgICAgfCBQcmV2ZW50cyB0aGUgZXZlbnQgdG8gcHJvcGFnYXRlIGZ1cnRoZXIgZWZmZWN0aXZleVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICB8IGRpc3NhYmxpbmcgb3RoZXIgZGVmYXVsdCBhY3Rpb25zLiBEZWZhdWx0cyB0byB0cnVlXG4gICAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKiAgdXNhZ2UgZXhhbXBsZXM6XG4gICAgICpcbiAgICAgKiAgVG8gYWRkIHRoZSBzY3JvbGwgYnkgZHJhZyB0byB0aGUgZWxlbWVudCBpZD12aWV3cG9ydCB3aGVuIGRyYWdnaW5nIGl0c1xuICAgICAqICBmaXJzdCBjaGlsZCBhY2NlcHRpbmcgYW55IHByb3BhZ2F0ZWQgZXZlbnRzXG4gICAgICogICQoJyN2aWV3cG9ydCcpLmRyYWdzY3JvbGxhYmxlKCk7XG4gICAgICpcbiAgICAgKiAgVG8gYWRkIHRoZSBzY3JvbGwgYnkgZHJhZyBhYmlsaXR5IHRvIGFueSBlbGVtZW50IGRpdiBvZiBjbGFzcyB2aWV3cG9ydFxuICAgICAqICB3aGVuIGRyYWdnaW5nIGl0cyBmaXJzdCBkZXNjZW5kYW50IG9mIGNsYXNzIGRyYWdNZSByZXNwb25kaW5nIG9ubHkgdG9cbiAgICAgKiAgZXZjZW50cyBvcmlnaW5hdGVkIG9uIHRoZSAnLmRyYWdNZScgZWxlbWVudHMuXG4gICAgICogICQoJ2Rpdi52aWV3cG9ydCcpLmRyYWdzY3JvbGxhYmxlKHtkcmFnU2VsZWN0b3I6Jy5kcmFnTWU6Zmlyc3QnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRQcm9wYWdhdGVkRXZlbnQ6IGZhbHNlfSk7XG4gICAgICpcbiAgICAgKiAgTm90aWNlIHRoYXQgc29tZSAndmlld3BvcnRzJyBjb3VsZCBiZSBuZXN0ZWQgd2l0aGluIG90aGVycyBidXQgZXZlbnRzXG4gICAgICogIHdvdWxkIG5vdCBpbnRlcmZlcmUgYXMgYWNjZXB0UHJvcGFnYXRlZEV2ZW50IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKlxuICAgICAqL1xuICAgICQuZm4uZHJhZ3Njcm9sbGFibGUgPSBmdW5jdGlvbiggb3B0aW9ucyApe1xuXG4gICAgICAgIHZhciBzZXR0aW5ncyA9ICQuZXh0ZW5kKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRyYWdTZWxlY3RvcjonPjpmaXJzdCcsXG4gICAgICAgICAgICAgICAgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgICB9LG9wdGlvbnMgfHwge30pO1xuXG5cbiAgICAgICAgdmFyIGRyYWdzY3JvbGw9IHtcbiAgICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgIC8vIG1vdXNlZG93biwgbGVmdCBjbGljaywgY2hlY2sgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQud2hpY2ghPTEgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFldmVudC5kYXRhLmFjY2VwdFByb3BhZ2F0ZWRFdmVudCAmJiBldmVudC50YXJnZXQgIT0gdGhpcykpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbCBjb29yZGluYXRlcyB3aWxsIGJlIHRoZSBsYXN0IHdoZW4gZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmxhc3RDb29yZCA9IHtsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFl9O1xuXG4gICAgICAgICAgICAgICAgJC5ldmVudC5hZGQoIGRvY3VtZW50LCBcIm1vdXNldXBcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ3Njcm9sbC5tb3VzZVVwSGFuZGxlciwgZXZlbnQuZGF0YSApO1xuICAgICAgICAgICAgICAgICQuZXZlbnQuYWRkKCBkb2N1bWVudCwgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgZHJhZ3Njcm9sbC5tb3VzZU1vdmVIYW5kbGVyLCBldmVudC5kYXRhICk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtb3VzZU1vdmVIYW5kbGVyIDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gVXNlciBpcyBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIC8vIEhvdyBtdWNoIGRpZCB0aGUgbW91c2UgbW92ZT9cbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSB7bGVmdDogKGV2ZW50LmNsaWVudFggLSBldmVudC5kYXRhLmxhc3RDb29yZC5sZWZ0KSxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAoZXZlbnQuY2xpZW50WSAtIGV2ZW50LmRhdGEubGFzdENvb3JkLnRvcCl9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gcmVsYXRpdmUgdG8gd2hhdCBldmVyIHRoZSBzY3JvbGwgaXMgbm93XG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5zY3JvbGxhYmxlLnNjcm9sbExlZnQoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0KCkgLSBkZWx0YS5sZWZ0KTtcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLnNjcm9sbGFibGUuc2Nyb2xsVG9wKFxuICAgICAgICAgICAgICAgICAgICBldmVudC5kYXRhLnNjcm9sbGFibGUuc2Nyb2xsVG9wKCkgLSBkZWx0YS50b3ApO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB3aGVyZSB0aGUgY3Vyc29yIGlzXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5sYXN0Q29vcmQ9e2xlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WX07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1vdXNlVXBIYW5kbGVyIDogZnVuY3Rpb24oZXZlbnQpIHsgLy8gU3RvcCBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICAkLmV2ZW50LnJlbW92ZSggZG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIGRyYWdzY3JvbGwubW91c2VNb3ZlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgJC5ldmVudC5yZW1vdmUoIGRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ3Njcm9sbC5tb3VzZVVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGEucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGluaXRpYWwgZXZlbnRzXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGNsb3N1cmUgb2JqZWN0IGRhdGEgZm9yIGVhY2ggc2Nyb2xsYWJsZSBlbGVtZW50XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtzY3JvbGxhYmxlIDogJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBhY2NlcHRQcm9wYWdhdGVkRXZlbnQgOiBzZXR0aW5ncy5hY2NlcHRQcm9wYWdhdGVkRXZlbnQsXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQgOiBzZXR0aW5ncy5wcmV2ZW50RGVmYXVsdCB9O1xuICAgICAgICAgICAgLy8gU2V0IG1vdXNlIGluaXRpYXRpbmcgZXZlbnQgb24gdGhlIGRlc2lyZWQgZGVzY2VuZGFudFxuICAgICAgICAgICAgJCh0aGlzKS5maW5kKHNldHRpbmdzLmRyYWdTZWxlY3RvcikuXG4gICAgICAgICAgICBiaW5kKCdtb3VzZWRvd24nLCBkYXRhLCBkcmFnc2Nyb2xsLm1vdXNlRG93bkhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9OyAvL2VuZCBwbHVnaW4gZHJhZ3Njcm9sbGFibGVcblxufSkoIGpRdWVyeSApOyAvLyBjb25maW5lIHNjb3BlXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IFRoaXMgaXMgYSB2ZW5kb3JlZCBkZXBlbmRlbmN5ICovXG4vKipcbiBqUXVlcnkua2luZXRpYyB2Mi4yLjFcbiBEYXZlIFRheWxvciBodHRwOi8vZGF2ZXRheWxzLm1lXG5cbiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiBAcHJlc2VydmUgQ29weXJpZ2h0IChjKSAyMDEyIERhdmUgVGF5bG9yIGh0dHA6Ly9kYXZldGF5bHMubWVcbiAqL1xuKGZ1bmN0aW9uICgkKXtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgQUNUSVZFX0NMQVNTID0gJ2tpbmV0aWMtYWN0aXZlJztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBpbiBhIGNyb3NzIGJyb3dzZXIgd2F5LlxuICAgICAqIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXG4gICAgICovXG4gICAgaWYgKCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKXtcblxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKCBmdW5jdGlvbiAoKXtcblxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoLyogZnVuY3Rpb24gRnJhbWVSZXF1ZXN0Q2FsbGJhY2sgKi8gY2FsbGJhY2ssIC8qIERPTUVsZW1lbnQgRWxlbWVudCAqLyBlbGVtZW50KXtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICB9KCkpO1xuXG4gICAgfVxuXG4gICAgLy8gYWRkIHRvdWNoIGNoZWNrZXIgdG8galF1ZXJ5LnN1cHBvcnRcbiAgICAkLnN1cHBvcnQgPSAkLnN1cHBvcnQgfHwge307XG4gICAgJC5leHRlbmQoJC5zdXBwb3J0LCB7XG4gICAgICAgIHRvdWNoOiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnRcbiAgICB9KTtcblxuXG4gICAgLy8gS0lORVRJQyBDTEFTUyBERUZJTklUSU9OXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxuXG4gICAgdmFyIEtpbmV0aWMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLmVsICAgICAgID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy4kZWwgICAgICA9ICQoZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5faW5pdEVsZW1lbnRzKCk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIEtpbmV0aWMuREFUQV9LRVkgPSAna2luZXRpYyc7XG4gICAgS2luZXRpYy5ERUZBVUxUUyA9IHtcbiAgICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICAgIGRlY2VsZXJhdGU6IHRydWUsXG4gICAgICAgIHRyaWdnZXJIYXJkd2FyZTogZmFsc2UsXG4gICAgICAgIHRocmVzaG9sZDogMCxcbiAgICAgICAgeTogdHJ1ZSxcbiAgICAgICAgeDogdHJ1ZSxcbiAgICAgICAgc2xvd2Rvd246IDAuOSxcbiAgICAgICAgbWF4dmVsb2NpdHk6IDQwLFxuICAgICAgICB0aHJvdHRsZUZQUzogNjAsXG4gICAgICAgIGludmVydDogZmFsc2UsXG4gICAgICAgIG1vdmluZ0NsYXNzOiB7XG4gICAgICAgICAgICB1cDogJ2tpbmV0aWMtbW92aW5nLXVwJyxcbiAgICAgICAgICAgIGRvd246ICdraW5ldGljLW1vdmluZy1kb3duJyxcbiAgICAgICAgICAgIGxlZnQ6ICdraW5ldGljLW1vdmluZy1sZWZ0JyxcbiAgICAgICAgICAgIHJpZ2h0OiAna2luZXRpYy1tb3ZpbmctcmlnaHQnXG4gICAgICAgIH0sXG4gICAgICAgIGRlY2VsZXJhdGluZ0NsYXNzOiB7XG4gICAgICAgICAgICB1cDogJ2tpbmV0aWMtZGVjZWxlcmF0aW5nLXVwJyxcbiAgICAgICAgICAgIGRvd246ICdraW5ldGljLWRlY2VsZXJhdGluZy1kb3duJyxcbiAgICAgICAgICAgIGxlZnQ6ICdraW5ldGljLWRlY2VsZXJhdGluZy1sZWZ0JyxcbiAgICAgICAgICAgIHJpZ2h0OiAna2luZXRpYy1kZWNlbGVyYXRpbmctcmlnaHQnXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBQdWJsaWMgZnVuY3Rpb25zXG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChvcHRpb25zKXtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9ICQuZXh0ZW5kKHRoaXMuc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gb3B0aW9ucy52ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IG9wdGlvbnMudmVsb2NpdHlZIHx8IHRoaXMudmVsb2NpdHlZO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW92ZSgpO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSAwO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSB0cnVlO1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RvcHBlZCkpe1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5zdG9wcGVkLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuZGV0YWNoID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuX2RldGFjaExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLiRlbFxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKEFDVElWRV9DTEFTUylcbiAgICAgICAgICAgIC5jc3MoJ2N1cnNvcicsICcnKTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIGlmICh0aGlzLiRlbC5oYXNDbGFzcyhBQ1RJVkVfQ0xBU1MpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXR0YWNoTGlzdGVuZXJzKHRoaXMuJGVsKTtcbiAgICAgICAgdGhpcy4kZWxcbiAgICAgICAgICAgIC5hZGRDbGFzcyhBQ1RJVkVfQ0xBU1MpXG4gICAgICAgICAgICAuY3NzKCdjdXJzb3InLCB0aGlzLnNldHRpbmdzLmN1cnNvcik7XG4gICAgfTtcblxuXG4gICAgLy8gSW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5faW5pdEVsZW1lbnRzID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKEFDVElWRV9DTEFTUyk7XG5cbiAgICAgICAgJC5leHRlbmQodGhpcywge1xuICAgICAgICAgICAgeHBvczogbnVsbCxcbiAgICAgICAgICAgIHByZXZYUG9zOiBmYWxzZSxcbiAgICAgICAgICAgIHlwb3M6IG51bGwsXG4gICAgICAgICAgICBwcmV2WVBvczogZmFsc2UsXG4gICAgICAgICAgICBtb3VzZURvd246IGZhbHNlLFxuICAgICAgICAgICAgdGhyb3R0bGVUaW1lb3V0OiAxMDAwIC8gdGhpcy5zZXR0aW5ncy50aHJvdHRsZUZQUyxcbiAgICAgICAgICAgIGxhc3RNb3ZlOiBudWxsLFxuICAgICAgICAgICAgZWxlbWVudEZvY3VzZWQ6IG51bGxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gMDtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgcmVzZXQgZXZlcnl0aGluZyB3aGVuIG1vdXNlIHVwXG4gICAgICAgICQoZG9jdW1lbnQpXG4gICAgICAgICAgICAubW91c2V1cCgkLnByb3h5KHRoaXMuX3Jlc2V0TW91c2UsIHRoaXMpKVxuICAgICAgICAgICAgLmNsaWNrKCQucHJveHkodGhpcy5fcmVzZXRNb3VzZSwgdGhpcykpO1xuXG4gICAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcblxuICAgICAgICB0aGlzLiRlbC5jc3MoJ2N1cnNvcicsIHRoaXMuc2V0dGluZ3MuY3Vyc29yKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50cmlnZ2VySGFyZHdhcmUpe1xuICAgICAgICAgICAgdGhpcy4kZWwuY3NzKHtcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiAndHJhbnNsYXRlM2QoMCwwLDApJyxcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC1wZXJzcGVjdGl2ZSc6ICcxMDAwJyxcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5JzogJ2hpZGRlbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9pbml0RXZlbnRzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnNldHRpbmdzLmV2ZW50cyA9IHtcbiAgICAgICAgICAgIHRvdWNoU3RhcnQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkpe1xuICAgICAgICAgICAgICAgICAgICB0b3VjaCA9IGUub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRocmVzaG9sZCA9IHNlbGYuX3RocmVzaG9sZChlLnRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N0YXJ0KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3VjaE1vdmU6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2g7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duKXtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2ggPSBlLm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXRtb3ZlKHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXREb3duOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuX3VzZVRhcmdldChlLnRhcmdldCwgZSkpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnRocmVzaG9sZCA9IHNlbGYuX3RocmVzaG9sZChlLnRhcmdldCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3N0YXJ0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbGVtZW50Rm9jdXNlZCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQubm9kZU5hbWUgPT09ICdJTUcnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dEVuZDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLl91c2VUYXJnZXQoZS50YXJnZXQsIGUpKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWxlbWVudEZvY3VzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5wdXRNb3ZlOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5wdXRtb3ZlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjcm9sbDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2VsZi5zZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHRpbmdzLm1vdmVkLmNhbGwoc2VsZiwgc2VsZi5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dENsaWNrOiBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNlbGYudmVsb2NpdHkpID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRyYWcgYW5kIGRyb3AgaW1hZ2VzIGluIGllXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5fdXNlVGFyZ2V0KGUudGFyZ2V0LCBlKSAmJiBzZWxmLmVsZW1lbnRGb2N1c2VkKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHNlbGVjdGlvbiB3aGVuIGRyYWdnaW5nXG4gICAgICAgICAgICBzZWxlY3RTdGFydDogZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oc2VsZi5zZXR0aW5ncy5zZWxlY3RTdGFydCkpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zZXR0aW5ncy5zZWxlY3RTdGFydC5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZi5fdXNlVGFyZ2V0KGUudGFyZ2V0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2F0dGFjaExpc3RlbmVycyh0aGlzLiRlbCwgdGhpcy5zZXR0aW5ncyk7XG5cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2lucHV0bW92ZSA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKXtcbiAgICAgICAgdmFyICR0aGlzID0gdGhpcy4kZWw7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxhc3RNb3ZlIHx8IG5ldyBEYXRlKCkgPiBuZXcgRGF0ZSh0aGlzLmxhc3RNb3ZlLmdldFRpbWUoKSArIHRoaXMudGhyb3R0bGVUaW1lb3V0KSl7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3ZlID0gbmV3IERhdGUoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubW91c2VEb3duICYmICh0aGlzLnhwb3MgfHwgdGhpcy55cG9zKSl7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkWCA9IChjbGllbnRYIC0gdGhpcy54cG9zKTtcbiAgICAgICAgICAgICAgICB2YXIgbW92ZWRZID0gKGNsaWVudFkgLSB0aGlzLnlwb3MpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmludmVydCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZFggKj0gLTE7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkWSAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGhpcy50aHJlc2hvbGQgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdmVkID0gTWF0aC5zcXJ0KG1vdmVkWCAqIG1vdmVkWCArIG1vdmVkWSAqIG1vdmVkWSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMudGhyZXNob2xkID4gbW92ZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJlc2hvbGQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRGb2N1c2VkKXtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzLmVsZW1lbnRGb2N1c2VkKS5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuZGVjZWxlcmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5WSA9IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0KHRoaXMuc2V0dGluZ3MueCA/IHNjcm9sbExlZnQgLSBtb3ZlZFggOiBzY3JvbGxMZWZ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCh0aGlzLnNldHRpbmdzLnkgPyBzY3JvbGxUb3AgLSBtb3ZlZFkgOiBzY3JvbGxUb3ApO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2WFBvcyA9IHRoaXMueHBvcztcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZZUG9zID0gdGhpcy55cG9zO1xuICAgICAgICAgICAgICAgIHRoaXMueHBvcyA9IGNsaWVudFg7XG4gICAgICAgICAgICAgICAgdGhpcy55cG9zID0gY2xpZW50WTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGN1bGF0ZVZlbG9jaXRpZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRNb3ZlQ2xhc3Nlcyh0aGlzLnNldHRpbmdzLm1vdmluZ0NsYXNzKTtcblxuICAgICAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5zZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLm1vdmVkLmNhbGwodGhpcywgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9jYWxjdWxhdGVWZWxvY2l0aWVzID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLl9jYXBWZWxvY2l0eSh0aGlzLnByZXZYUG9zIC0gdGhpcy54cG9zLCB0aGlzLnNldHRpbmdzLm1heHZlbG9jaXR5KTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eVkgPSB0aGlzLl9jYXBWZWxvY2l0eSh0aGlzLnByZXZZUG9zIC0gdGhpcy55cG9zLCB0aGlzLnNldHRpbmdzLm1heHZlbG9jaXR5KTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaW52ZXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ICo9IC0xO1xuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eVkgKj0gLTE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2VuZCA9IGZ1bmN0aW9uICgpe1xuICAgICAgICBpZiAodGhpcy54cG9zICYmIHRoaXMucHJldlhQb3MgJiYgdGhpcy5zZXR0aW5ncy5kZWNlbGVyYXRlID09PSBmYWxzZSl7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmRlY2VsZXJhdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY2FsY3VsYXRlVmVsb2NpdGllcygpO1xuICAgICAgICAgICAgdGhpcy54cG9zID0gdGhpcy5wcmV2WFBvcyA9IHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9tb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX3VzZVRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KXtcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLmZpbHRlclRhcmdldCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuZmlsdGVyVGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBldmVudCkgIT09IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fdGhyZXNob2xkID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnQpe1xuICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3MudGhyZXNob2xkKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50aHJlc2hvbGQuY2FsbCh0aGlzLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50aHJlc2hvbGQ7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKXtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSB0cnVlO1xuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy5wcmV2WFBvcyA9IDA7XG4gICAgICAgIHRoaXMudmVsb2NpdHlZID0gdGhpcy5wcmV2WVBvcyA9IDA7XG4gICAgICAgIHRoaXMueHBvcyA9IGNsaWVudFg7XG4gICAgICAgIHRoaXMueXBvcyA9IGNsaWVudFk7XG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9yZXNldE1vdXNlID0gZnVuY3Rpb24gKCl7XG4gICAgICAgIHRoaXMueHBvcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlwb3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2RlY2VsZXJhdGVWZWxvY2l0eSA9IGZ1bmN0aW9uICh2ZWxvY2l0eSwgc2xvd2Rvd24pe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmFicyh2ZWxvY2l0eSkpID09PSAwID8gMCAvLyBpcyB2ZWxvY2l0eSBsZXNzIHRoYW4gMT9cbiAgICAgICAgICAgIDogdmVsb2NpdHkgKiBzbG93ZG93bjsgLy8gcmVkdWNlIHNsb3dkb3duXG4gICAgfTtcblxuICAgIEtpbmV0aWMucHJvdG90eXBlLl9jYXBWZWxvY2l0eSA9IGZ1bmN0aW9uICh2ZWxvY2l0eSwgbWF4KXtcbiAgICAgICAgdmFyIG5ld1ZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gICAgICAgIGlmICh2ZWxvY2l0eSA+IDApe1xuICAgICAgICAgICAgaWYgKHZlbG9jaXR5ID4gbWF4KXtcbiAgICAgICAgICAgICAgICBuZXdWZWxvY2l0eSA9IG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2ZWxvY2l0eSA8ICgwIC0gbWF4KSl7XG4gICAgICAgICAgICAgICAgbmV3VmVsb2NpdHkgPSAoMCAtIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1ZlbG9jaXR5O1xuICAgIH07XG5cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fc2V0TW92ZUNsYXNzZXMgPSBmdW5jdGlvbiAoY2xhc3Nlcyl7XG4gICAgICAgIC8vIEZJWE1FOiBjb25zaWRlciBpZiB3ZSB3YW50IHRvIGFwcGx5IFBMICM0NCwgdGhpcyBzaG91bGQgbm90IHJlbW92ZVxuICAgICAgICAvLyBjbGFzc2VzIHdlIGhhdmUgbm90IGRlZmluZWQgb24gdGhlIGVsZW1lbnQhXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuXG4gICAgICAgICR0aGlzLnJlbW92ZUNsYXNzKHNldHRpbmdzLm1vdmluZ0NsYXNzLnVwKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLm1vdmluZ0NsYXNzLmRvd24pXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MubW92aW5nQ2xhc3MubGVmdClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5tb3ZpbmdDbGFzcy5yaWdodClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcy51cClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcy5kb3duKVxuICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHNldHRpbmdzLmRlY2VsZXJhdGluZ0NsYXNzLmxlZnQpXG4gICAgICAgICAgICAucmVtb3ZlQ2xhc3Moc2V0dGluZ3MuZGVjZWxlcmF0aW5nQ2xhc3MucmlnaHQpO1xuXG4gICAgICAgIGlmICh0aGlzLnZlbG9jaXR5ID4gMCl7XG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhjbGFzc2VzLnJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eSA8IDApe1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3MoY2xhc3Nlcy5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52ZWxvY2l0eVkgPiAwKXtcbiAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKGNsYXNzZXMuZG93bik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmVsb2NpdHlZIDwgMCl7XG4gICAgICAgICAgICAkdGhpcy5hZGRDbGFzcyhjbGFzc2VzLnVwKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgLy8gZG8gdGhlIGFjdHVhbCBraW5ldGljIG1vdmVtZW50XG4gICAgS2luZXRpYy5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiAoKXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuX2dldFNjcm9sbGVyKCk7XG4gICAgICAgIHZhciBzY3JvbGxlciA9ICRzY3JvbGxlclswXTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBzZWxmLnNldHRpbmdzO1xuXG4gICAgICAgIC8vIHNldCBzY3JvbGxMZWZ0XG4gICAgICAgIGlmIChzZXR0aW5ncy54ICYmIHNjcm9sbGVyLnNjcm9sbFdpZHRoID4gMCl7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQodGhpcy5zY3JvbGxMZWZ0KCkgKyB0aGlzLnZlbG9jaXR5KTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnZlbG9jaXR5KSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBzZXR0aW5ncy5kZWNlbGVyYXRlID9cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVjZWxlcmF0ZVZlbG9jaXR5KHRoaXMudmVsb2NpdHksIHNldHRpbmdzLnNsb3dkb3duKSA6IHRoaXMudmVsb2NpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBzY3JvbGxUb3BcbiAgICAgICAgaWYgKHNldHRpbmdzLnkgJiYgc2Nyb2xsZXIuc2Nyb2xsSGVpZ2h0ID4gMCl7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCh0aGlzLnNjcm9sbFRvcCgpICsgdGhpcy52ZWxvY2l0eVkpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMudmVsb2NpdHlZKSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHlZID0gc2V0dGluZ3MuZGVjZWxlcmF0ZSA/XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2RlY2VsZXJhdGVWZWxvY2l0eSh0aGlzLnZlbG9jaXR5WSwgc2V0dGluZ3Muc2xvd2Rvd24pIDogdGhpcy52ZWxvY2l0eVk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9zZXRNb3ZlQ2xhc3NlcyhzZXR0aW5ncy5kZWNlbGVyYXRpbmdDbGFzcyk7XG5cbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihzZXR0aW5ncy5tb3ZlZCkpe1xuICAgICAgICAgICAgc2V0dGluZ3MubW92ZWQuY2FsbCh0aGlzLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy52ZWxvY2l0eSkgPiAwIHx8IE1hdGguYWJzKHRoaXMudmVsb2NpdHlZKSA+IDApe1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyB0aWNrIGZvciBuZXh0IG1vdmVtZW50XG4gICAgICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5tb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gZ2V0IGN1cnJlbnQgc2Nyb2xsZXIgdG8gYXBwbHkgcG9zaXRpb25pbmcgdG9cbiAgICBLaW5ldGljLnByb3RvdHlwZS5fZ2V0U2Nyb2xsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgJHNjcm9sbGVyID0gdGhpcy4kZWw7XG4gICAgICAgIGlmICh0aGlzLiRlbC5pcygnYm9keScpIHx8IHRoaXMuJGVsLmlzKCdodG1sJykpe1xuICAgICAgICAgICAgJHNjcm9sbGVyID0gJCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkc2Nyb2xsZXI7XG4gICAgfTtcblxuICAgIC8vIHNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgS2luZXRpYy5wcm90b3R5cGUuc2Nyb2xsTGVmdCA9IGZ1bmN0aW9uKGxlZnQpe1xuICAgICAgICB2YXIgJHNjcm9sbGVyID0gdGhpcy5fZ2V0U2Nyb2xsZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsZWZ0ID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAkc2Nyb2xsZXIuc2Nyb2xsTGVmdChsZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc2Nyb2xsTGVmdCA9IGxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJHNjcm9sbGVyLnNjcm9sbExlZnQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgS2luZXRpYy5wcm90b3R5cGUuc2Nyb2xsVG9wID0gZnVuY3Rpb24odG9wKXtcbiAgICAgICAgdmFyICRzY3JvbGxlciA9IHRoaXMuX2dldFNjcm9sbGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdG9wID09PSAnbnVtYmVyJyl7XG4gICAgICAgICAgICAkc2Nyb2xsZXIuc2Nyb2xsVG9wKHRvcCk7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnNjcm9sbFRvcCA9IHRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAkc2Nyb2xsZXIuc2Nyb2xsVG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2F0dGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcblxuICAgICAgICBpZiAoJC5zdXBwb3J0LnRvdWNoKXtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAuYmluZCgndG91Y2hlbmQnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5tb3VzZWRvd24oc2V0dGluZ3MuZXZlbnRzLmlucHV0RG93bilcbiAgICAgICAgICAgIC5tb3VzZXVwKHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgIC5tb3VzZW1vdmUoc2V0dGluZ3MuZXZlbnRzLmlucHV0TW92ZSk7XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5jbGljayhzZXR0aW5ncy5ldmVudHMuaW5wdXRDbGljaylcbiAgICAgICAgICAgIC5zY3JvbGwoc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC5iaW5kKCdzZWxlY3RzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5zZWxlY3RTdGFydClcbiAgICAgICAgICAgIC5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xuXG4gICAgS2luZXRpYy5wcm90b3R5cGUuX2RldGFjaExpc3RlbmVycyA9IGZ1bmN0aW9uICgpe1xuICAgICAgICB2YXIgJHRoaXMgPSB0aGlzLiRlbDtcbiAgICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgICAgaWYgKCQuc3VwcG9ydC50b3VjaCl7XG4gICAgICAgICAgICAkdGhpc1xuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaGVuZCcsIHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgICAgICAudW5iaW5kKCd0b3VjaG1vdmUnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hNb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAudW5iaW5kKCdtb3VzZWRvd24nLCBzZXR0aW5ncy5ldmVudHMuaW5wdXREb3duKVxuICAgICAgICAgICAgLnVuYmluZCgnbW91c2V1cCcsIHNldHRpbmdzLmV2ZW50cy5pbnB1dEVuZClcbiAgICAgICAgICAgIC51bmJpbmQoJ21vdXNlbW92ZScsIHNldHRpbmdzLmV2ZW50cy5pbnB1dE1vdmUpO1xuXG4gICAgICAgICR0aGlzXG4gICAgICAgICAgICAudW5iaW5kKCdjbGljaycsIHNldHRpbmdzLmV2ZW50cy5pbnB1dENsaWNrKVxuICAgICAgICAgICAgLnVuYmluZCgnc2Nyb2xsJywgc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC51bmJpbmQoJ3NlbGVjdHN0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLnNlbGVjdFN0YXJ0KVxuICAgICAgICAgICAgLnVuYmluZCgnZHJhZ3N0YXJ0Jywgc2V0dGluZ3MuZXZlbnRzLmRyYWdTdGFydCk7XG4gICAgfTtcblxuXG4gICAgLy8gRVhQT1NFIEtJTkVUSUMgQ09OU1RSVUNUT1JcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICQuS2luZXRpYyA9IEtpbmV0aWM7XG5cbiAgICAvLyBLSU5FVElDIFBMVUdJTiBERUZJTklUSU9OXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgICQuZm4ua2luZXRpYyA9IGZ1bmN0aW9uIChvcHRpb24sIGNhbGxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzICAgID0gJCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9ICR0aGlzLmRhdGEoS2luZXRpYy5EQVRBX0tFWSk7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyAgPSAkLmV4dGVuZCh7fSwgS2luZXRpYy5ERUZBVUxUUywgJHRoaXMuZGF0YSgpLCB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0JyAmJiBvcHRpb24pO1xuXG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YShLaW5ldGljLkRBVEFfS0VZLCAoaW5zdGFuY2UgPSBuZXcgS2luZXRpYyh0aGlzLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVtvcHRpb25dKGNhbGxPcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9O1xuXG59KGpRdWVyeSkpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIFdlIHNob3VsZCBtYXliZSBiZSB0ZXN0aW5nIHRoaXMsIGJ1dCByZWFsaXN0aWNhbGx5IHRoYXQgd291bGQgbWVhbiBtYWludGFpbmluZyBhIHJlYWwgZm9yayAqL1xuXG4vLyBqUXVlcnkua2luZXRpYyBjb3JlIG1vZGlmaWNhdGlvbnMgZm9yIGRpdmEuanMgKGNvbXBhdGlibGUgd2l0aCBqUXVlcnkua2luZXRpYyAyLjIuMSlcbi8vIHVzZSBqUXVlcnkua2luZXRpYyBmb3IgdG91Y2ggaGFuZGxlcnMgb25seSBzaW5jZSB3ZSBhcmUgdXNpbmcgZHJhZ3Njcm9sbGFibGUgZm9yIG1vdXNlIGhhbmRsZXJzXG4vLyAgICAtIChraW5ldGljIHByb3ZpZGVzIGluZXJ0aWFsIHNjcm9sbGluZyBbZWFzZSBpbnRvIHN0b3BwZWQgc3RhdGUgb24gcmVsZWFzZV0gZm9yIHRvdWNoIGV2ZW50cyBhbmQgZHJhZ3Njcm9sbGFibGVcbi8vICAgICAgYWxsb3dzIG5vbi1pbmVydGlhbCBzY3JvbGxpbmcgd2hpY2ggd2UgbGlrZSBmb3IgbWljZSlcblxuKGZ1bmN0aW9uKCQpXG57XG4gICAgJC5LaW5ldGljLnByb3RvdHlwZS5fYXR0YWNoTGlzdGVuZXJzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gYXR0YWNoIG9ubHkgdG91Y2ggbGlzdGVuZXJzXG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgICAgIGlmICgkLnN1cHBvcnQudG91Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNoc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMudG91Y2hTdGFydClcbiAgICAgICAgICAgICAgICAuYmluZCgndG91Y2hlbmQnLCBzZXR0aW5ncy5ldmVudHMuaW5wdXRFbmQpXG4gICAgICAgICAgICAgICAgLmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC5jbGljayhzZXR0aW5ncy5ldmVudHMuaW5wdXRDbGljaylcbiAgICAgICAgICAgIC5zY3JvbGwoc2V0dGluZ3MuZXZlbnRzLnNjcm9sbClcbiAgICAgICAgICAgIC5iaW5kKCdzZWxlY3RzdGFydCcsIHNldHRpbmdzLmV2ZW50cy5zZWxlY3RTdGFydClcbiAgICAgICAgICAgIC5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xuXG4gICAgJC5LaW5ldGljLnByb3RvdHlwZS5fZGV0YWNoTGlzdGVuZXJzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gZGV0YWNoIG9ubHkgdG91Y2ggbGlzdGVuZXJzXG4gICAgICAgIHZhciAkdGhpcyA9IHRoaXMuJGVsO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuXG4gICAgICAgIGlmICgkLnN1cHBvcnQudG91Y2gpXG4gICAgICAgIHtcbiAgICAgICAgICAgICR0aGlzXG4gICAgICAgICAgICAgICAgLnVuYmluZCgndG91Y2hzdGFydCcsIHNldHRpbmdzLmV2ZW50cy50b3VjaFN0YXJ0KVxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNoZW5kJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0RW5kKVxuICAgICAgICAgICAgICAgIC51bmJpbmQoJ3RvdWNobW92ZScsIHNldHRpbmdzLmV2ZW50cy50b3VjaE1vdmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHRoaXNcbiAgICAgICAgICAgIC51bmJpbmQoJ2NsaWNrJywgc2V0dGluZ3MuZXZlbnRzLmlucHV0Q2xpY2spXG4gICAgICAgICAgICAudW5iaW5kKCdzY3JvbGwnLCBzZXR0aW5ncy5ldmVudHMuc2Nyb2xsKVxuICAgICAgICAgICAgLnVuYmluZCgnc2VsZWN0c3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuc2VsZWN0U3RhcnQpXG4gICAgICAgICAgICAudW5iaW5kKCdkcmFnc3RhcnQnLCBzZXR0aW5ncy5ldmVudHMuZHJhZ1N0YXJ0KTtcbiAgICB9O1xufSkoalF1ZXJ5KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3V0aWxzL2pxdWVyeS1leHRlbnNpb25zLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBGcm9tIGh0dHA6Ly93d3cuYWxleGFuZHJlLWdvbWVzLmNvbS8/cD0xMTUsIG1vZGlmaWVkIHNsaWdodGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgIHZhciBpbm5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICBpbm5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBpbm5lci5zdHlsZS5oZWlnaHQgPSAnMjAwcHgnO1xuXG4gICAgdmFyIG91dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgb3V0ZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIG91dGVyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIG91dGVyLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBvdXRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMjAwcHgnO1xuICAgIG91dGVyLnN0eWxlLmhlaWdodCA9ICcxNTBweCc7XG4gICAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICBvdXRlci5hcHBlbmRDaGlsZChpbm5lcik7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG91dGVyKTtcblxuICAgIHZhciB3MSA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIG91dGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgdmFyIHcyID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gICAgaWYgKHcxID09IHcyKSB7XG4gICAgICAgIHcyID0gb3V0ZXIuY2xpZW50V2lkdGg7IC8vIGZvciBJRSBpIHRoaW5rXG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgcmV0dXJuIHcxIC0gdzI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvdXRpbHMvZ2V0LXNjcm9sbGJhci13aWR0aC5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Eb3VibGVDbGljazogb25Eb3VibGVDbGljayxcbiAgICBvblBpbmNoOiBvblBpbmNoLFxuICAgIG9uRG91YmxlVGFwOiBvbkRvdWJsZVRhcFxufTtcblxudmFyIERPVUJMRV9DTElDS19USU1FT1VUID0gNTAwO1xuXG52YXIgRE9VQkxFX1RBUF9ESVNUQU5DRV9USFJFU0hPTEQgPSA1MDtcbnZhciBET1VCTEVfVEFQX1RJTUVPVVQgPSAyNTA7XG5cbmZ1bmN0aW9uIG9uRG91YmxlQ2xpY2soZWxlbSwgY2FsbGJhY2spXG57XG4gICAgZWxlbS5vbignZGJsY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpXG4gICAge1xuICAgICAgICBpZiAoIWV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBIYW5kbGUgdGhlIGNvbnRyb2wga2V5IGZvciBtYWNzIChpbiBjb25qdW5jdGlvbiB3aXRoIGRvdWJsZS1jbGlja2luZylcbiAgICAvLyBGSVhNRTogRG9lcyBhIGNsaWNrIGdldCBoYW5kbGVkIHdpdGggY3RybCBwcmVzc2VkIG9uIG5vbi1NYWNzP1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9DTElDS19USU1FT1VUKTtcblxuICAgIGVsZW0ub24oJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRyYWNrZXIuaXNUcmlnZ2VyZWQoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0cmFja2VyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsIGdldFJlbGF0aXZlT2Zmc2V0KGV2ZW50LmN1cnJlbnRUYXJnZXQsIGV2ZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHJhY2tlci50cmlnZ2VyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gb25QaW5jaChlbGVtLCBjYWxsYmFjaylcbntcbiAgICB2YXIgc3RhcnREaXN0YW5jZSA9IDA7XG5cbiAgICBlbGVtLm9uKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZShcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMV0uY2xpZW50WVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgZWxlbS5vbigndG91Y2htb3ZlJywgZnVuY3Rpb24oZXZlbnQpXG4gICAge1xuICAgICAgICAvLyBQcmV2ZW50IG1vdXNlIGV2ZW50IGZyb20gZmlyaW5nXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGVzID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzO1xuXG4gICAgICAgICAgICB2YXIgbW92ZURpc3RhbmNlID0gZGlzdGFuY2UoXG4gICAgICAgICAgICAgICAgdG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHRvdWNoZXNbMF0uY2xpZW50WSxcbiAgICAgICAgICAgICAgICB0b3VjaGVzWzFdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgdG91Y2hlc1sxXS5jbGllbnRZXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB2YXIgem9vbURlbHRhID0gbW92ZURpc3RhbmNlIC0gc3RhcnREaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHpvb21EZWx0YSkgPiAwKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaENlbnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZVg6ICh0b3VjaGVzWzBdLmNsaWVudFggKyB0b3VjaGVzWzFdLmNsaWVudFgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgcGFnZVk6ICh0b3VjaGVzWzBdLmNsaWVudFkgKyB0b3VjaGVzWzFdLmNsaWVudFkpIC8gMlxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhldmVudCwgZ2V0UmVsYXRpdmVPZmZzZXQoZXZlbnQuY3VycmVudFRhcmdldCwgdG91Y2hDZW50ZXIpLCBzdGFydERpc3RhbmNlLCBtb3ZlRGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uRG91YmxlVGFwKGVsZW0sIGNhbGxiYWNrKVxue1xuICAgIHZhciB0cmFja2VyID0gY3JlYXRlRG91YmxlRXZlbnRUcmFja2VyKERPVUJMRV9UQVBfVElNRU9VVCk7XG4gICAgdmFyIGZpcnN0VGFwID0gbnVsbDtcblxuICAgIGVsZW0ub24oJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgIHtcbiAgICAgICAgLy8gUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGZpcmluZ1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0cmFja2VyLmlzVHJpZ2dlcmVkKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyYWNrZXIucmVzZXQoKTtcblxuICAgICAgICAgICAgLy8gRG91YmxldGFwIGhhcyBvY2N1cnJlZFxuICAgICAgICAgICAgdmFyIHNlY29uZFRhcCA9IHtcbiAgICAgICAgICAgICAgICBwYWdlWDogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiBldmVudC5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIElmIGZpcnN0IHRhcCBpcyBjbG9zZSB0byBzZWNvbmQgdGFwIChwcmV2ZW50cyBpbnRlcmZlcmVuY2Ugd2l0aCBzY2FsZSBldmVudClcbiAgICAgICAgICAgIHZhciB0YXBEaXN0YW5jZSA9IGRpc3RhbmNlKGZpcnN0VGFwLnBhZ2VYLCBmaXJzdFRhcC5wYWdlWSwgc2Vjb25kVGFwLnBhZ2VYLCBzZWNvbmRUYXAucGFnZVkpO1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBDb3VsZCBnaXZlIHNvbWV0aGluZyBoaWdoZXItbGV2ZWwgdGhhbiBzZWNvbmRUYXAgdG8gY2FsbGJhY2tcbiAgICAgICAgICAgIGlmICh0YXBEaXN0YW5jZSA8IERPVUJMRV9UQVBfRElTVEFOQ0VfVEhSRVNIT0xEKVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV2ZW50LCBnZXRSZWxhdGl2ZU9mZnNldChldmVudC5jdXJyZW50VGFyZ2V0LCBzZWNvbmRUYXApKTtcblxuICAgICAgICAgICAgZmlyc3RUYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZmlyc3RUYXAgPSB7XG4gICAgICAgICAgICAgICAgcGFnZVg6IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogZXZlbnQub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0cmFja2VyLnRyaWdnZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vLyBQeXRoYWdvcmVhbiB0aGVvcmVtIHRvIGdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzICh1c2VkIGZvclxuLy8gY2FsY3VsYXRpbmcgZmluZ2VyIGRpc3RhbmNlIGZvciBkb3VibGUtdGFwIGFuZCBwaW5jaC16b29tKVxuZnVuY3Rpb24gZGlzdGFuY2UoeDEsIHkxLCB4MiwgeTIpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xufVxuXG4vLyBVdGlsaXR5IHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBhbiBldmVudCBoYXMgYmVlbiB0cmlnZ2VyZWQgdHdpY2Vcbi8vIGR1cmluZyBhIGEgZ2l2ZW4gZHVyYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZURvdWJsZUV2ZW50VHJhY2tlcih0aW1lb3V0RHVyYXRpb24pXG57XG4gICAgdmFyIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc2V0VGltZW91dCgpO1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBpc1RyaWdnZXJlZDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJlZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzZXRUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcmVzZXRUaW1lb3V0KClcbiAgICB7XG4gICAgICAgIGlmICh0aW1lb3V0SWQgIT09IG51bGwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGltZW91dElkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVPZmZzZXQoZWxlbSwgcGFnZUNvb3JkcylcbntcbiAgICB2YXIgYm91bmRzID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBhZ2VDb29yZHMucGFnZVggLSBib3VuZHMubGVmdCxcbiAgICAgICAgdG9wOiBwYWdlQ29vcmRzLnBhZ2VZIC0gYm91bmRzLnRvcFxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9nZXN0dXJlLWV2ZW50cy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1heEJ5ID0gcmVxdWlyZSgnbG9kYXNoLm1heGJ5Jyk7XG52YXIgUGFnZVRvb2xzT3ZlcmxheSA9IHJlcXVpcmUoJy4vcGFnZS10b29scy1vdmVybGF5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRG9jdW1lbnRIYW5kbGVyO1xuXG5mdW5jdGlvbiBEb2N1bWVudEhhbmRsZXIodmlld2VyQ29yZSlcbntcbiAgICB0aGlzLl92aWV3ZXJDb3JlID0gdmlld2VyQ29yZTtcbiAgICB0aGlzLl92aWV3ZXJTdGF0ZSA9IHZpZXdlckNvcmUuZ2V0SW50ZXJuYWxTdGF0ZSgpO1xuICAgIHRoaXMuX292ZXJsYXlzID0gW107XG5cbiAgICBpZiAodmlld2VyQ29yZS5nZXRQYWdlVG9vbHMoKS5sZW5ndGgpXG4gICAge1xuICAgICAgICB2YXIgbnVtUGFnZXMgPSB2aWV3ZXJDb3JlLmdldFNldHRpbmdzKCkubnVtUGFnZXM7XG5cbiAgICAgICAgZm9yICh2YXIgaT0wOyBpIDwgbnVtUGFnZXM7IGkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgUGFnZVRvb2xzT3ZlcmxheShpLCB2aWV3ZXJDb3JlKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlzLnB1c2gob3ZlcmxheSk7XG4gICAgICAgICAgICB2aWV3ZXJDb3JlLmFkZFBhZ2VPdmVybGF5KG92ZXJsYXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBVU0VSIEVWRU5UU1xuRG9jdW1lbnRIYW5kbGVyLnByb3RvdHlwZS5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCBjb29yZHMpXG57XG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuICAgIHZhciBuZXdab29tTGV2ZWwgPSBldmVudC5jdHJsS2V5ID8gc2V0dGluZ3Muem9vbUxldmVsIC0gMSA6IHNldHRpbmdzLnpvb21MZXZlbCArIDE7XG5cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl92aWV3ZXJDb3JlLmdldFBhZ2VQb3NpdGlvbkF0Vmlld3BvcnRPZmZzZXQoY29vcmRzKTtcblxuICAgIHRoaXMuX3ZpZXdlckNvcmUuem9vbShuZXdab29tTGV2ZWwsIHBvc2l0aW9uKTtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25QaW5jaCA9IGZ1bmN0aW9uIChldmVudCwgY29vcmRzLCBzdGFydERpc3RhbmNlLCBlbmREaXN0YW5jZSlcbntcbiAgICAvLyBGSVhNRTogRG8gdGhpcyBjaGVjayBpbiBhIHdheSB3aGljaCBpcyBsZXNzIHNwYWdoZXR0aSBjb2RlLXlcbiAgICB2YXIgdmlld2VyU3RhdGUgPSB0aGlzLl92aWV3ZXJDb3JlLmdldEludGVybmFsU3RhdGUoKTtcbiAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLl92aWV3ZXJDb3JlLmdldFNldHRpbmdzKCk7XG5cbiAgICB2YXIgbmV3Wm9vbUxldmVsID0gTWF0aC5sb2coTWF0aC5wb3coMiwgc2V0dGluZ3Muem9vbUxldmVsKSAqIGVuZERpc3RhbmNlIC8gKHN0YXJ0RGlzdGFuY2UgKiBNYXRoLmxvZygyKSkpIC8gTWF0aC5sb2coMik7XG4gICAgbmV3Wm9vbUxldmVsID0gTWF0aC5tYXgoc2V0dGluZ3MubWluWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpO1xuICAgIG5ld1pvb21MZXZlbCA9IE1hdGgubWluKHNldHRpbmdzLm1heFpvb21MZXZlbCwgbmV3Wm9vbUxldmVsKTtcblxuICAgIGlmIChuZXdab29tTGV2ZWwgPT09IHNldHRpbmdzLnpvb21MZXZlbClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fdmlld2VyQ29yZS5nZXRQYWdlUG9zaXRpb25BdFZpZXdwb3J0T2Zmc2V0KGNvb3Jkcyk7XG5cbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5fdmlld2VyQ29yZS5nZXRDdXJyZW50TGF5b3V0KCk7XG4gICAgdmFyIGNlbnRlck9mZnNldCA9IGxheW91dC5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldChwb3NpdGlvbi5hbmNob3JQYWdlLCB2aWV3ZXJTdGF0ZS52aWV3cG9ydCk7XG4gICAgdmFyIHNjYWxlUmF0aW8gPSAxIC8gTWF0aC5wb3coMiwgc2V0dGluZ3Muem9vbUxldmVsIC0gbmV3Wm9vbUxldmVsKTtcblxuICAgIHRoaXMuX3ZpZXdlckNvcmUucmVsb2FkKHtcbiAgICAgICAgem9vbUxldmVsOiBuZXdab29tTGV2ZWwsXG4gICAgICAgIGdvRGlyZWN0bHlUbzogcG9zaXRpb24uYW5jaG9yUGFnZSxcbiAgICAgICAgaG9yaXpvbnRhbE9mZnNldDogKGNlbnRlck9mZnNldC54IC0gcG9zaXRpb24ub2Zmc2V0LmxlZnQpICsgcG9zaXRpb24ub2Zmc2V0LmxlZnQgKiBzY2FsZVJhdGlvLFxuICAgICAgICB2ZXJ0aWNhbE9mZnNldDogKGNlbnRlck9mZnNldC55IC0gcG9zaXRpb24ub2Zmc2V0LnRvcCkgKyBwb3NpdGlvbi5vZmZzZXQudG9wICogc2NhbGVSYXRpb1xuICAgIH0pO1xufTtcblxuLy8gVklFVyBFVkVOVFNcbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25WaWV3V2lsbExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaCgnRG9jdW1lbnRXaWxsTG9hZCcsIHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKSk7XG59O1xuXG5Eb2N1bWVudEhhbmRsZXIucHJvdG90eXBlLm9uVmlld0RpZExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIFRPRE86IFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSB0byBoYW5kbGUgY2hhbmdlcyBvbiB2aWV3IHVwZGF0ZSwgbm90XG4gICAgLy8gaW5pdGlhbCBsb2FkXG4gICAgdGhpcy5faGFuZGxlWm9vbUxldmVsQ2hhbmdlKCk7XG5cbiAgICB2YXIgY3VycmVudFBhZ2VJbmRleCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5jdXJyZW50UGFnZUluZGV4O1xuICAgIHZhciBmaWxlTmFtZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZU5hbWUoY3VycmVudFBhZ2VJbmRleCk7XG4gICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiRG9jdW1lbnREaWRMb2FkXCIsIGN1cnJlbnRQYWdlSW5kZXgsIGZpbGVOYW1lKTtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUub25WaWV3RGlkVXBkYXRlID0gZnVuY3Rpb24gKHJlbmRlcmVkUGFnZXMsIHRhcmdldFBhZ2UpXG57XG4gICAgdmFyIGN1cnJlbnRQYWdlID0gKHRhcmdldFBhZ2UgIT09IG51bGwpID9cbiAgICAgICAgdGFyZ2V0UGFnZSA6XG4gICAgICAgIGdldENlbnRlcm1vc3RQYWdlKHJlbmRlcmVkUGFnZXMsIHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpLCB0aGlzLl92aWV3ZXJDb3JlLmdldFZpZXdwb3J0KCkpO1xuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBjdXJyZW50IHBhZ2UgaWYgdGhlcmUgaXMgbm8gcGFnZSBpbiB0aGUgdmlld3BvcnRcbiAgICAvLyBGSVhNRTogV291bGQgYmUgYmV0dGVyIHRvIGZhbGwgYmFjayB0byB0aGUgcGFnZSBjbG9zZXN0IHRvIHRoZSB2aWV3cG9ydFxuICAgIGlmIChjdXJyZW50UGFnZSAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5zZXRDdXJyZW50UGFnZShjdXJyZW50UGFnZSk7XG5cbiAgICBpZiAodGFyZ2V0UGFnZSAhPT0gbnVsbClcbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkSnVtcFwiLCB0YXJnZXRQYWdlKTtcblxuICAgIHRoaXMuX2hhbmRsZVpvb21MZXZlbENoYW5nZSgpO1xufTtcblxuRG9jdW1lbnRIYW5kbGVyLnByb3RvdHlwZS5faGFuZGxlWm9vbUxldmVsQ2hhbmdlID0gZnVuY3Rpb24gKClcbntcbiAgICB2YXIgdmlld2VyU3RhdGUgPSB0aGlzLl92aWV3ZXJTdGF0ZTtcbiAgICB2YXIgem9vbUxldmVsID0gdmlld2VyU3RhdGUub3B0aW9ucy56b29tTGV2ZWw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIG5vdCB0aGUgaW5pdGlhbCBsb2FkLCB0cmlnZ2VyIHRoZSB6b29tIGV2ZW50c1xuICAgIGlmICh2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgIT09IHpvb21MZXZlbCAmJiB2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPj0gMClcbiAgICB7XG4gICAgICAgIGlmICh2aWV3ZXJTdGF0ZS5vbGRab29tTGV2ZWwgPCB6b29tTGV2ZWwpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucHVibGlzaChcIlZpZXdlckRpZFpvb21JblwiLCB6b29tTGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkWm9vbU91dFwiLCB6b29tTGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5wdWJsaXNoKFwiVmlld2VyRGlkWm9vbVwiLCB6b29tTGV2ZWwpO1xuICAgIH1cblxuICAgIHZpZXdlclN0YXRlLm9sZFpvb21MZXZlbCA9IHpvb21MZXZlbDtcbn07XG5cbkRvY3VtZW50SGFuZGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fb3ZlcmxheXMuZm9yRWFjaChmdW5jdGlvbiAob3ZlcmxheSlcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUucmVtb3ZlUGFnZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgfSwgdGhpcyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDZW50ZXJtb3N0UGFnZShyZW5kZXJlZFBhZ2VzLCBsYXlvdXQsIHZpZXdwb3J0KVxue1xuICAgIHZhciBjZW50ZXJZID0gdmlld3BvcnQudG9wICsgKHZpZXdwb3J0LmhlaWdodCAvIDIpO1xuICAgIHZhciBjZW50ZXJYID0gdmlld3BvcnQubGVmdCArICh2aWV3cG9ydC53aWR0aCAvIDIpO1xuXG4gICAgLy8gRmluZCB0aGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSB2aWV3cG9ydCBjZW50ZXIgdG8gYSBwYWdlLlxuICAgIC8vIENvbXB1dGUgbWludXMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB2aWV3cG9ydCBjZW50ZXIgdG8gdGhlIHBhZ2UncyBib3JkZXIuXG4gICAgLy8gaHR0cDovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzQ0NDgzL2hvdy1kby1pLWNhbGN1bGF0ZS1kaXN0YW5jZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWFuLWF4aXMtYWxpZ25lZC1yZWN0YW5nbGVcbiAgICB2YXIgY2VudGVyUGFnZSA9IG1heEJ5KHJlbmRlcmVkUGFnZXMsIGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgZGltcyA9IGxheW91dC5nZXRQYWdlRGltZW5zaW9ucyhwYWdlSW5kZXgpO1xuICAgICAgICB2YXIgaW1hZ2VPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgsIHtleGNsdWRlUGFkZGluZzogZmFsc2V9KTtcblxuICAgICAgICB2YXIgbWlkWCA9IGltYWdlT2Zmc2V0LmxlZnQgKyAoZGltcy53aWR0aCAvIDIpO1xuICAgICAgICB2YXIgbWlkWSA9IGltYWdlT2Zmc2V0LnRvcCArIChkaW1zLmhlaWdodCAvIDIpO1xuXG4gICAgICAgIHZhciBkeCA9IE1hdGgubWF4KE1hdGguYWJzKGNlbnRlclggLSBtaWRYKSAtIChkaW1zLndpZHRoIC8gMiksIDApO1xuICAgICAgICB2YXIgZHkgPSBNYXRoLm1heChNYXRoLmFicyhjZW50ZXJZIC0gbWlkWSkgLSAoZGltcy5oZWlnaHQgLyAyKSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIC0oZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNlbnRlclBhZ2UgIT0gbnVsbCA/IGNlbnRlclBhZ2UgOiBudWxsO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvZG9jdW1lbnQtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNvbXBhcmlzb24gc3R5bGVzLiAqL1xudmFyIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgPSAxLFxuICAgIFBBUlRJQUxfQ09NUEFSRV9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZUxlYWRpbmdEb3QgPSAvXlxcLi8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID8gdmFsdWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICkpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gaXNLZXkocGF0aCwgb2JqZWN0KSA/IFtwYXRoXSA6IGNhc3RQYXRoKHBhdGgpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JpdG1hc2tdIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuXG4gKiAgVGhlIGJpdG1hc2sgbWF5IGJlIGNvbXBvc2VkIG9mIHRoZSBmb2xsb3dpbmcgZmxhZ3M6XG4gKiAgICAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgICAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3QodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiYXNlSXNFcXVhbCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYFxuICogIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IGFycmF5VGFnLFxuICAgICAgb3RoVGFnID0gYXJyYXlUYWc7XG5cbiAgaWYgKCFvYmpJc0Fycikge1xuICAgIG9ialRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICB9XG4gIGlmICghb3RoSXNBcnIpIHtcbiAgICBvdGhUYWcgPSBnZXRUYWcob3RoZXIpO1xuICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICB9XG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcgJiYgIWlzSG9zdE9iamVjdChvYmplY3QpLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob3RoZXIpLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBjdXN0b21pemVyLCBVTk9SREVSRURfQ09NUEFSRV9GTEFHIHwgUEFSVElBTF9DT01QQVJFX0ZMQUcsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIHVuZGVmaW5lZCwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IHN0cmluZ1RvUGF0aCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLmFkZChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IFVOT1JERVJFRF9DT01QQVJFX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgcmVzdWx0LFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0ID8gb2JqZWN0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gQXNzaWduIGNhY2hlIHRvIGBfLm1lbW9pemVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieSB3aGljaFxuICogdGhlIHZhbHVlIGlzIHJhbmtlZC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDEgfSwgeyAnbic6IDIgfV07XG4gKlxuICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICogLy8gPT4geyAnbic6IDIgfVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXhCeShvYmplY3RzLCAnbicpO1xuICogLy8gPT4geyAnbic6IDIgfVxuICovXG5mdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGJhc2VHdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXhCeTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9sb2Rhc2gubWF4YnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XHJcblx0aWYoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcclxuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0bW9kdWxlLnBhdGhzID0gW107XHJcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcclxuXHRcdG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XHJcblx0fVxyXG5cdHJldHVybiBtb2R1bGU7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlVG9vbHNPdmVybGF5O1xuXG5mdW5jdGlvbiBQYWdlVG9vbHNPdmVybGF5KHBhZ2VJbmRleCwgdmlld2VyQ29yZSlcbntcbiAgICB0aGlzLnBhZ2UgPSBwYWdlSW5kZXg7XG5cbiAgICB0aGlzLl92aWV3ZXJDb3JlID0gdmlld2VyQ29yZTtcblxuICAgIHRoaXMuX2lubmVyRWxlbWVudCA9IHZpZXdlckNvcmUuZ2V0U2V0dGluZ3MoKS5pbm5lckVsZW1lbnQ7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbSA9IG51bGw7XG59XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodGhpcy5fcGFnZVRvb2xzRWxlbSA9PT0gbnVsbClcbiAgICB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5faW5pdGlhbGl6ZVBhZ2VUb29sQnV0dG9ucygpO1xuXG4gICAgICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0gPSBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scy13cmFwcGVyJ30sXG4gICAgICAgICAgICBlbHQoJ2RpdicsIHtjbGFzczogJ2RpdmEtcGFnZS10b29scyd9LCBidXR0b25zKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHRoaXMuX2lubmVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9wYWdlVG9vbHNFbGVtKTtcbn07XG5cblBhZ2VUb29sc092ZXJsYXkucHJvdG90eXBlLl9pbml0aWFsaXplUGFnZVRvb2xCdXR0b25zID0gZnVuY3Rpb24gKClcbntcbiAgICAvLyBDYWxsYmFjayBwYXJhbWV0ZXJzXG4gICAgdmFyIHNldHRpbmdzID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpO1xuICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICB2YXIgcGFnZUluZGV4ID0gdGhpcy5wYWdlO1xuXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVRvb2xzKCkubWFwKGZ1bmN0aW9uIChwbHVnaW4pXG4gICAge1xuICAgICAgICAvLyBJZiB0aGUgdGl0bGUgdGV4dCBpcyB1bmRlZmluZWQsIHVzZSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luXG4gICAgICAgIHZhciB0aXRsZVRleHQgPSBwbHVnaW4udGl0bGVUZXh0IHx8IHBsdWdpbi5wbHVnaW5OYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBwbHVnaW4ucGx1Z2luTmFtZS5zdWJzdHJpbmcoMSkgKyBcIiBwbHVnaW5cIjtcblxuICAgICAgICB2YXIgYnV0dG9uID0gZWx0KCdkaXYnLCB7XG4gICAgICAgICAgICBjbGFzczogJ2RpdmEtJyArIHBsdWdpbi5wbHVnaW5OYW1lICsgJy1pY29uJyxcbiAgICAgICAgICAgIHRpdGxlOiB0aXRsZVRleHRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICBwbHVnaW4uaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBldmVudCwgc2V0dGluZ3MsIHB1YmxpY0luc3RhbmNlLCBwYWdlSW5kZXgpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgZnVuY3Rpb24gKGV2ZW50KVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGZpcmluZyBvZiBlbXVsYXRlZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIHBsdWdpbi5oYW5kbGVDbGljay5jYWxsKHRoaXMsIGV2ZW50LCBzZXR0aW5ncywgcHVibGljSW5zdGFuY2UsIHBhZ2VJbmRleCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH0sIHRoaXMpO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5faW5uZXJFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX3BhZ2VUb29sc0VsZW0pO1xufTtcblxuUGFnZVRvb2xzT3ZlcmxheS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIHBvcyA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVJlZ2lvbih0aGlzLnBhZ2UsIHtcbiAgICAgICAgZXhjbHVkZVBhZGRpbmc6IHRydWUsXG4gICAgICAgIGluY29ycG9yYXRlVmlld3BvcnQ6IHRydWVcbiAgICB9KTtcblxuICAgIHRoaXMuX3BhZ2VUb29sc0VsZW0uc3R5bGUudG9wID0gcG9zLnRvcCArICdweCc7XG4gICAgdGhpcy5fcGFnZVRvb2xzRWxlbS5zdHlsZS5sZWZ0ID0gcG9zLmxlZnQgKyAncHgnO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtdG9vbHMtb3ZlcmxheS5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIG1heEJ5ID0gcmVxdWlyZSgnbG9kYXNoLm1heGJ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZEhhbmRsZXI7XG5cbmZ1bmN0aW9uIEdyaWRIYW5kbGVyKHZpZXdlckNvcmUpXG57XG4gICAgdGhpcy5fdmlld2VyQ29yZSA9IHZpZXdlckNvcmU7XG59XG5cbi8vIFVTRVIgRVZFTlRTXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25Eb3VibGVDbGljayA9IGZ1bmN0aW9uIChldmVudCwgY29vcmRzKVxue1xuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0UGFnZVBvc2l0aW9uQXRWaWV3cG9ydE9mZnNldChjb29yZHMpO1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Vmlld3BvcnQoKTtcbiAgICB2YXIgcGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQgPSBsYXlvdXQuZ2V0UGFnZVRvVmlld3BvcnRDZW50ZXJPZmZzZXQocG9zaXRpb24uYW5jaG9yUGFnZSwgdmlld3BvcnQpO1xuXG4gICAgdGhpcy5fdmlld2VyQ29yZS5yZWxvYWQoe1xuICAgICAgICBpbkdyaWQ6IGZhbHNlLFxuICAgICAgICBnb0RpcmVjdGx5VG86IHBvc2l0aW9uLmFuY2hvclBhZ2UsXG4gICAgICAgIGhvcml6b250YWxPZmZzZXQ6IHBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0LnggKyBwb3NpdGlvbi5vZmZzZXQubGVmdCxcbiAgICAgICAgdmVydGljYWxPZmZzZXQ6IHBhZ2VUb1ZpZXdwb3J0Q2VudGVyT2Zmc2V0LnkgKyBwb3NpdGlvbi5vZmZzZXQudG9wXG4gICAgfSk7XG59O1xuXG5HcmlkSGFuZGxlci5wcm90b3R5cGUub25QaW5jaCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdGhpcy5fdmlld2VyQ29yZS5yZWxvYWQoeyBpbkdyaWQ6IGZhbHNlIH0pO1xufTtcblxuLy8gVklFVyBFVkVOVFNcbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdXaWxsTG9hZCA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUUod2FiYWluKTogU2hvdWxkIHNvbWV0aGluZyBoYXBwZW4gaGVyZT9cbiAgICAvKiBOby1vcCAqL1xufTtcblxuR3JpZEhhbmRsZXIucHJvdG90eXBlLm9uVmlld0RpZExvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIEZJWE1FKHdhYmFpbik6IFNob3VsZCBzb21ldGhpbmcgaGFwcGVuIGhlcmU/XG4gICAgLyogTm8tb3AgKi9cbn07XG5cbkdyaWRIYW5kbGVyLnByb3RvdHlwZS5vblZpZXdEaWRVcGRhdGUgPSBmdW5jdGlvbiAocmVuZGVyZWRQYWdlcywgdGFyZ2V0UGFnZSlcbntcbiAgICAvLyByZXR1cm4gZWFybHkgaWYgdGhlcmUgYXJlIG5vIHJlbmRlcmVkIHBhZ2VzIGluIHZpZXcuXG4gICAgaWYgKHJlbmRlcmVkUGFnZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBpZiAodGFyZ2V0UGFnZSAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHRoaXMuX3ZpZXdlckNvcmUuc2V0Q3VycmVudFBhZ2UodGFyZ2V0UGFnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTZWxlY3QgdGhlIGN1cnJlbnQgcGFnZSBmcm9tIHRoZSBmaXJzdCByb3cgaWYgaXQgaXMgZnVsbHkgdmlzaWJsZSwgb3IgZnJvbVxuICAgIC8vIHRoZSBzZWNvbmQgcm93IGlmIGl0IGlzIGZ1bGx5IHZpc2libGUsIG9yIGZyb20gdGhlIGNlbnRlcm1vc3Qgcm93IG90aGVyd2lzZS5cbiAgICAvLyBJZiB0aGUgY3VycmVudCBwYWdlIGlzIGluIHRoYXQgZ3JvdXAgdGhlbiBkb24ndCBjaGFuZ2UgaXQuIE90aGVyd2lzZSwgc2V0XG4gICAgLy8gdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgZ3JvdXAncyBmaXJzdCBwYWdlLlxuXG4gICAgdmFyIGxheW91dCA9IHRoaXMuX3ZpZXdlckNvcmUuZ2V0Q3VycmVudExheW91dCgpO1xuICAgIHZhciBncm91cHMgPSBbXTtcblxuICAgIHJlbmRlcmVkUGFnZXMuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgdmFyIGdyb3VwID0gbGF5b3V0LmdldFBhZ2VJbmZvKHBhZ2VJbmRleCkuZ3JvdXA7XG4gICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwIHx8IGdyb3VwICE9PSBncm91cHNbZ3JvdXBzLmxlbmd0aCAtIDFdKVxuICAgICAgICAgICAgZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgIH0pO1xuXG4gICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld2VyQ29yZS5nZXRWaWV3cG9ydCgpO1xuICAgIHZhciBjaG9zZW5Hcm91cDtcblxuICAgIGlmIChncm91cHMubGVuZ3RoID09PSAxIHx8IGdyb3Vwc1swXS5yZWdpb24udG9wID49IHZpZXdwb3J0LnRvcClcbiAgICAgICAgY2hvc2VuR3JvdXAgPSBncm91cHNbMF07XG4gICAgZWxzZSBpZiAoZ3JvdXBzWzFdLnJlZ2lvbi5ib3R0b20gPD0gdmlld3BvcnQuYm90dG9tKVxuICAgICAgICBjaG9zZW5Hcm91cCA9IGdyb3Vwc1sxXTtcbiAgICBlbHNlXG4gICAgICAgIGNob3Nlbkdyb3VwID0gZ2V0Q2VudGVybW9zdEdyb3VwKGdyb3Vwcywgdmlld3BvcnQpO1xuXG4gICAgdmFyIGN1cnJlbnRQYWdlID0gdGhpcy5fdmlld2VyQ29yZS5nZXRTZXR0aW5ncygpLmN1cnJlbnRQYWdlSW5kZXg7XG5cbiAgICB2YXIgaGFzQ3VycmVudFBhZ2UgPSBjaG9zZW5Hcm91cC5wYWdlcy5zb21lKGZ1bmN0aW9uIChwYWdlKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHBhZ2UuaW5kZXggPT09IGN1cnJlbnRQYWdlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFoYXNDdXJyZW50UGFnZSlcbiAgICAgICAgdGhpcy5fdmlld2VyQ29yZS5zZXRDdXJyZW50UGFnZShjaG9zZW5Hcm91cC5wYWdlc1swXS5pbmRleCk7XG59O1xuXG5HcmlkSGFuZGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gTm8tb3Bcbn07XG5cbmZ1bmN0aW9uIGdldENlbnRlcm1vc3RHcm91cChncm91cHMsIHZpZXdwb3J0KVxue1xuICAgIHZhciB2aWV3cG9ydE1pZGRsZSA9IHZpZXdwb3J0LnRvcCArIHZpZXdwb3J0LmhlaWdodCAvIDI7XG5cbiAgICByZXR1cm4gbWF4QnkoZ3JvdXBzLCBmdW5jdGlvbiAoZ3JvdXApXG4gICAge1xuICAgICAgICB2YXIgZ3JvdXBNaWRkbGUgPSBncm91cC5yZWdpb24udG9wICsgZ3JvdXAuZGltZW5zaW9ucy5oZWlnaHQgLyAyO1xuICAgICAgICByZXR1cm4gLU1hdGguYWJzKHZpZXdwb3J0TWlkZGxlIC0gZ3JvdXBNaWRkbGUpO1xuICAgIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvZ3JpZC1oYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFBhZ2VPdmVybGF5TWFuYWdlcjtcblxuLyoqXG4gKiBNYW5hZ2VzIGEgY29sbGVjdGlvbiBvZiBwYWdlIG92ZXJsYXlzLCB3aGljaCBpbXBsZW1lbnQgYSBsb3ctbGV2ZWxcbiAqIEFQSSBmb3Igc3luY2hyb25pemluZyBIVE1MIHBhZ2VzIHRvIHRoZSBjYW52YXMuIEVhY2ggb3ZlcmxheSBuZWVkc1xuICogdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvdG9jb2w6XG4gKlxuICogICBtb3VudCgpOiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgZmlyc3QgcmVuZGVyZWRcbiAqICAgcmVmcmVzaCgpOiBDYWxsZWQgd2hlbiBhIHBhZ2UgaXMgbW92ZWRcbiAqICAgdW5tb3VudCgpOiBDYWxsZWQgd2hlbiBhIHByZXZpb3VzbHkgcmVuZGVyZWQgcGFnZSBoYXMgc3RvcHBlZCBiZWluZyByZW5kZXJlZFxuICpcbiAqIEBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIFBhZ2VPdmVybGF5TWFuYWdlcigpXG57XG4gICAgdGhpcy5fcGFnZXMgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzID0gW107XG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlTWFwID0ge307XG59XG5cblBhZ2VPdmVybGF5TWFuYWdlci5wcm90b3R5cGUuYWRkT3ZlcmxheSA9IGZ1bmN0aW9uIChvdmVybGF5KVxue1xuICAgIHZhciBvdmVybGF5c0J5UGFnZSA9IHRoaXMuX3BhZ2VzW292ZXJsYXkucGFnZV0gfHwgKHRoaXMuX3BhZ2VzW292ZXJsYXkucGFnZV0gPSBbXSk7XG5cbiAgICBvdmVybGF5c0J5UGFnZS5wdXNoKG92ZXJsYXkpO1xuXG4gICAgaWYgKHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtvdmVybGF5LnBhZ2VdKVxuICAgICAgICBvdmVybGF5Lm1vdW50KCk7XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnJlbW92ZU92ZXJsYXkgPSBmdW5jdGlvbiAob3ZlcmxheSlcbntcbiAgICB2YXIgcGFnZSA9IG92ZXJsYXkucGFnZTtcbiAgICB2YXIgb3ZlcmxheXNCeVBhZ2UgPSB0aGlzLl9wYWdlc1twYWdlXTtcblxuICAgIGlmICghb3ZlcmxheXNCeVBhZ2UpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciBvdmVybGF5SW5kZXggPSBvdmVybGF5c0J5UGFnZS5pbmRleE9mKG92ZXJsYXkpO1xuXG4gICAgaWYgKG92ZXJsYXlJbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmICh0aGlzLl9yZW5kZXJlZFBhZ2VNYXBbcGFnZV0pXG4gICAgICAgIG92ZXJsYXlzQnlQYWdlW292ZXJsYXlJbmRleF0udW5tb3VudCgpO1xuXG4gICAgb3ZlcmxheXNCeVBhZ2Uuc3BsaWNlKG92ZXJsYXlJbmRleCwgMSk7XG5cbiAgICBpZiAob3ZlcmxheXNCeVBhZ2UubGVuZ3RoID09PSAwKVxuICAgICAgICBkZWxldGUgdGhpcy5fcGFnZXNbcGFnZV07XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZU92ZXJsYXlzID0gZnVuY3Rpb24gKHJlbmRlcmVkUGFnZXMpXG57XG4gICAgdmFyIHByZXZpb3VzbHlSZW5kZXJlZCA9IHRoaXMuX3JlbmRlcmVkUGFnZXM7XG4gICAgdmFyIG5ld1JlbmRlcmVkTWFwID0ge307XG5cbiAgICByZW5kZXJlZFBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICB7XG4gICAgICAgIG5ld1JlbmRlcmVkTWFwW3BhZ2VJbmRleF0gPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZWRQYWdlTWFwW3BhZ2VJbmRleF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtwYWdlSW5kZXhdID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5faW52b2tlT25PdmVybGF5cyhwYWdlSW5kZXgsIGZ1bmN0aW9uIChvdmVybGF5KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG92ZXJsYXkubW91bnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBwcmV2aW91c2x5UmVuZGVyZWQuZm9yRWFjaChmdW5jdGlvbiAocGFnZUluZGV4KVxuICAgIHtcbiAgICAgICAgaWYgKG5ld1JlbmRlcmVkTWFwW3BhZ2VJbmRleF0pXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZU9uT3ZlcmxheXMocGFnZUluZGV4LCBmdW5jdGlvbiAob3ZlcmxheSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3JlbmRlcmVkUGFnZU1hcFtwYWdlSW5kZXhdO1xuXG4gICAgICAgICAgICB0aGlzLl9pbnZva2VPbk92ZXJsYXlzKHBhZ2VJbmRleCwgZnVuY3Rpb24gKG92ZXJsYXkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheS51bm1vdW50KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcyA9IHJlbmRlcmVkUGFnZXM7XG59O1xuXG5QYWdlT3ZlcmxheU1hbmFnZXIucHJvdG90eXBlLl9pbnZva2VPbk92ZXJsYXlzID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgZnVuYylcbntcbiAgICB2YXIgb3ZlcmxheXMgPSB0aGlzLl9wYWdlc1twYWdlSW5kZXhdO1xuICAgIGlmIChvdmVybGF5cylcbiAgICAgICAgb3ZlcmxheXMuZm9yRWFjaChmdW5jLCB0aGlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wYWdlLW92ZXJsYXktbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOlJlbmRlcmVyJyk7XG52YXIgZGVidWdQYWludHMgPSByZXF1aXJlKCdkZWJ1ZycpKCdkaXZhOlJlbmRlcmVyOnBhaW50cycpO1xuXG52YXIgZWx0ID0gcmVxdWlyZSgnLi91dGlscy9lbHQnKTtcblxudmFyIENvbXBvc2l0ZUltYWdlID0gcmVxdWlyZSgnLi9jb21wb3NpdGUtaW1hZ2UnKTtcbnZhciBEb2N1bWVudExheW91dCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQtbGF5b3V0Jyk7XG52YXIgSW1hZ2VDYWNoZSA9IHJlcXVpcmUoJy4vaW1hZ2UtY2FjaGUnKTtcbnZhciBJbWFnZVJlcXVlc3RIYW5kbGVyID0gcmVxdWlyZSgnLi9pbWFnZS1yZXF1ZXN0LWhhbmRsZXInKTtcbnZhciBJbnRlcnBvbGF0ZUFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJwb2xhdGUtYW5pbWF0aW9uJyk7XG5cbnZhciBSRVFVRVNUX0RFQk9VTkNFX0lOVEVSVkFMID0gMjUwO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMsIGhvb2tzKVxue1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gb3B0aW9ucy52aWV3cG9ydDtcbiAgICB0aGlzLl9vdXRlckVsZW1lbnQgPSBvcHRpb25zLm91dGVyRWxlbWVudDtcbiAgICB0aGlzLl9kb2N1bWVudEVsZW1lbnQgPSBvcHRpb25zLmlubmVyRWxlbWVudDtcblxuICAgIHRoaXMuX2hvb2tzID0gaG9va3MgfHwge307XG5cbiAgICB0aGlzLl9jYW52YXMgPSBlbHQoJ2NhbnZhcycsIHsgY2xhc3M6ICdkaXZhLXZpZXdlci1jYW52YXMnLCB0YWJpbmRleDogJzEnIH0pO1xuICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgdGhpcy5sYXlvdXQgPSBudWxsO1xuXG4gICAgdGhpcy5fc291cmNlUmVzb2x2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkUGFnZXMgPSBudWxsO1xuICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgdGhpcy5fem9vbUxldmVsID0gbnVsbDtcbiAgICB0aGlzLl9jb21wb3NpdGVJbWFnZXMgPSBudWxsO1xuICAgIHRoaXMuX3JlbmRlcmVkVGlsZXMgPSBudWxsO1xuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG5cbiAgICAvLyBGSVhNRSh3YWJhaW4pOiBXaGF0IGxldmVsIHNob3VsZCB0aGlzIGJlIG1haW50YWluZWQgYXQ/XG4gICAgLy8gRGl2YSBnbG9iYWw/XG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgSW1hZ2VDYWNoZSgpO1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IHt9O1xufVxuXG5SZW5kZXJlci5nZXRDb21wYXRpYmlsaXR5RXJyb3JzID0gZnVuY3Rpb24gKClcbntcbiAgICBpZiAodHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAnWW91ciBicm93c2VyIGxhY2tzIHN1cHBvcnQgZm9yIHRoZSAnLCBlbHQoJ3ByZScsICdjYW52YXMnKSxcbiAgICAgICAgJyBlbGVtZW50LiBQbGVhc2UgdXBncmFkZSB5b3VyIGJyb3dzZXIuJ1xuICAgIF07XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZ2V0UGFnZUhpdCA9IGZ1bmN0aW9uIChjbGllbnRYLCBjbGllbnRZKVxue1xuICAgIHZhciBib3VuZHMgPSB0aGlzLl9vdXRlckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKGNsaWVudFggPCBib3VuZHMubGVmdCB8fCBjbGllbnRZIDwgYm91bmRzLnRvcCB8fFxuICAgICAgICBjbGllbnRYID4gYm91bmRzLmxlZnQgKyBib3VuZHMud2lkdGggfHwgY2xpZW50WSA+IGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY2xpZW50WCAtPSBib3VuZHMubGVmdDtcbiAgICBjbGllbnRZIC09IGJvdW5kcy50b3A7XG5cbiAgICB2YXIgbnVtUmVuZGVyZWRQYWdlcyA9IHRoaXMuX3JlbmRlcmVkUGFnZXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1SZW5kZXJlZFBhZ2VzOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcGFnZUluZGV4ID0gdGhpcy5fcmVuZGVyZWRQYWdlc1tpXTtcbiAgICAgICAgdmFyIHBhZ2VJbmZvID0gdGhpcy5sYXlvdXQuZ2V0UGFnZUluZm8ocGFnZUluZGV4KTtcbiAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSB0aGlzLl9nZXRJbWFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgICAgIHZhciB2aWV3cG9ydFBhZGRpbmdYID0gTWF0aC5tYXgoMCwgKHRoaXMuX3ZpZXdwb3J0LndpZHRoIC0gdGhpcy5sYXlvdXQuZGltZW5zaW9ucy53aWR0aCkgLyAyKTtcbiAgICAgICAgdmFyIHZpZXdwb3J0UGFkZGluZ1kgPSBNYXRoLm1heCgwLCAodGhpcy5fdmlld3BvcnQuaGVpZ2h0IC0gdGhpcy5sYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQpIC8gMik7XG5cbiAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0WCA9IHBhZ2VPZmZzZXQubGVmdCAtIHRoaXMuX3ZpZXdwb3J0LmxlZnQgKyB2aWV3cG9ydFBhZGRpbmdYO1xuICAgICAgICB2YXIgdmlld3BvcnRPZmZzZXRZID0gcGFnZU9mZnNldC50b3AgLSB0aGlzLl92aWV3cG9ydC50b3AgKyB2aWV3cG9ydFBhZGRpbmdZO1xuXG4gICAgICAgIHZhciBkZXN0WE9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0WCA8IDAgPyAtdmlld3BvcnRPZmZzZXRYIDogMDtcbiAgICAgICAgdmFyIGRlc3RZT2Zmc2V0ID0gdmlld3BvcnRPZmZzZXRZIDwgMCA/IC12aWV3cG9ydE9mZnNldFkgOiAwO1xuXG4gICAgICAgIHZhciBjYW52YXNYID0gTWF0aC5tYXgoMCwgdmlld3BvcnRPZmZzZXRYKTtcbiAgICAgICAgdmFyIGNhbnZhc1kgPSBNYXRoLm1heCgwLCB2aWV3cG9ydE9mZnNldFkpO1xuXG4gICAgICAgIHZhciBkZXN0V2lkdGggPSBwYWdlSW5mby5kaW1lbnNpb25zLndpZHRoIC0gZGVzdFhPZmZzZXQ7XG4gICAgICAgIHZhciBkZXN0SGVpZ2h0ID0gcGFnZUluZm8uZGltZW5zaW9ucy5oZWlnaHQgLSBkZXN0WU9mZnNldDtcblxuICAgICAgICBpZiAoY2xpZW50WCA+PSBjYW52YXNYICYmIGNsaWVudFggPD0gY2FudmFzWCArIGRlc3RXaWR0aCAmJiBjbGllbnRZID49IGNhbnZhc1kgJiYgY2xpZW50WSA8PSBjYW52YXNZICsgZGVzdEhlaWdodClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHhocCA9ICgoY2xpZW50WCArIGRlc3RYT2Zmc2V0KSAtIGNhbnZhc1gpO1xuICAgICAgICAgICAgdmFyIHlocCA9ICgoY2xpZW50WSArIGRlc3RZT2Zmc2V0KSAtIGNhbnZhc1kpO1xuICAgICAgICAgICAgLy8gdG8gZ2V0IHRoZSBwZXJjZW50YWdlIHggYW5kIHkgeW91IG5lZWQgdG8gYWRqdXN0IHRoZSBieSB0aGUgc2Nyb2xsIG9mZnNldCBhbmQgdGhlIGNhbnZhcyBwb3NpdGlvblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwZzogcGFnZUluZGV4LFxuICAgICAgICAgICAgICAgIHBjdHg6IHhocCAvIHBhZ2VJbmZvLmRpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgICAgICAgICAgcGN0eTogeWhwIC8gcGFnZUluZm8uZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgeDogIHhocCxcbiAgICAgICAgICAgICAgICB5OiB5aHBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGNvbmZpZywgdmlld3BvcnRQb3NpdGlvbiwgc291cmNlUmVzb2x2ZXIpXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblZpZXdXaWxsTG9hZClcbiAgICAgICAgdGhpcy5faG9va3Mub25WaWV3V2lsbExvYWQoKTtcblxuICAgIHRoaXMuX3NvdXJjZVJlc29sdmVyID0gc291cmNlUmVzb2x2ZXI7XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX2NvbXBvc2l0ZUltYWdlcyA9IHt9O1xuICAgIHRoaXMuX3NldExheW91dFRvWm9vbUxldmVsKHZpZXdwb3J0UG9zaXRpb24uem9vbUxldmVsKTtcblxuICAgIC8vIEZJWE1FKHdhYmFpbik6IFJlbW92ZSB0aGlzIHdoZW4gdGhlcmUncyBtb3JlIGNvbmZpZGVuY2UgdGhlIGNoZWNrIHNob3VsZG4ndCBiZSBuZWVkZWRcbiAgICBpZiAoIXRoaXMubGF5b3V0LmdldFBhZ2VJbmZvKHZpZXdwb3J0UG9zaXRpb24uYW5jaG9yUGFnZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwYWdlOiAnICsgdmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlKTtcblxuICAgIGlmICh0aGlzLl9jYW52YXMud2lkdGggIT09IHRoaXMuX3ZpZXdwb3J0LndpZHRoIHx8IHRoaXMuX2NhbnZhcy5oZWlnaHQgIT09IHRoaXMuX3ZpZXdwb3J0LmhlaWdodClcbiAgICB7XG4gICAgICAgIGRlYnVnKCdDYW52YXMgZGltZW5zaW9uIGNoYW5nZTogKCVzLCAlcykgLT4gKCVzLCAlcyknLCB0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICB0aGlzLl92aWV3cG9ydC53aWR0aCwgdGhpcy5fdmlld3BvcnQuaGVpZ2h0KTtcblxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLl92aWV3cG9ydC53aWR0aDtcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IHRoaXMuX3ZpZXdwb3J0LmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnUmVsb2FkLCBubyBzaXplIGNoYW5nZScpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiBXaGF0IGhvb2tzIHNob3VsZCBiZSBjYWxsZWQgaGVyZT9cbiAgICB0aGlzLmdvdG8odmlld3BvcnRQb3NpdGlvbi5hbmNob3JQYWdlLCB2aWV3cG9ydFBvc2l0aW9uLnZlcnRpY2FsT2Zmc2V0LCB2aWV3cG9ydFBvc2l0aW9uLmhvcml6b250YWxPZmZzZXQpO1xuXG4gICAgaWYgKHRoaXMuX2NhbnZhcy5wYXJlbnROb2RlICE9PSB0aGlzLl9vdXRlckVsZW1lbnQpXG4gICAgICAgIHRoaXMuX291dGVyRWxlbWVudC5pbnNlcnRCZWZvcmUodGhpcy5fY2FudmFzLCB0aGlzLl9vdXRlckVsZW1lbnQuZmlyc3RDaGlsZCk7XG5cbiAgICBpZiAodGhpcy5faG9va3Mub25WaWV3RGlkTG9hZClcbiAgICAgICAgdGhpcy5faG9va3Mub25WaWV3RGlkTG9hZCgpO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLl9zZXRWaWV3cG9ydFBvc2l0aW9uID0gZnVuY3Rpb24gKHZpZXdwb3J0UG9zaXRpb24pXG57XG4gICAgaWYgKHZpZXdwb3J0UG9zaXRpb24uem9vbUxldmVsICE9PSB0aGlzLl96b29tTGV2ZWwpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fem9vbUxldmVsID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGN1cnJlbnQgdmlldyBpcyBub3Qgem9vbWFibGUnKTtcbiAgICAgICAgZWxzZSBpZiAodmlld3BvcnRQb3NpdGlvbi56b29tTGV2ZWwgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY3VycmVudCB2aWV3IHJlcXVpcmVzIGEgem9vbSBsZXZlbCcpO1xuXG4gICAgICAgIHRoaXMuX3NldExheW91dFRvWm9vbUxldmVsKHZpZXdwb3J0UG9zaXRpb24uem9vbUxldmVsKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nb3RvKHZpZXdwb3J0UG9zaXRpb24uYW5jaG9yUGFnZSwgdmlld3BvcnRQb3NpdGlvbi52ZXJ0aWNhbE9mZnNldCwgdmlld3BvcnRQb3NpdGlvbi5ob3Jpem9udGFsT2Zmc2V0KTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5fc2V0TGF5b3V0VG9ab29tTGV2ZWwgPSBmdW5jdGlvbiAoem9vbUxldmVsKVxue1xuICAgIHRoaXMubGF5b3V0ID0gbmV3IERvY3VtZW50TGF5b3V0KHRoaXMuX2NvbmZpZywgem9vbUxldmVsKTtcbiAgICB0aGlzLl96b29tTGV2ZWwgPSB6b29tTGV2ZWw7XG5cbiAgICBlbHQuc2V0QXR0cmlidXRlcyh0aGlzLl9kb2N1bWVudEVsZW1lbnQsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5sYXlvdXQuZGltZW5zaW9ucy5oZWlnaHQgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMubGF5b3V0LmRpbWVuc2lvbnMud2lkdGggKyAncHgnXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX3ZpZXdwb3J0LnNldElubmVyRGltZW5zaW9ucyh0aGlzLmxheW91dC5kaW1lbnNpb25zKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5hZGp1c3QgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKVxue1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uKCk7XG5cbiAgICB0aGlzLl9yZW5kZXIoZGlyZWN0aW9uKTtcblxuICAgIGlmICh0aGlzLl9ob29rcy5vblZpZXdEaWRVcGRhdGUpXG4gICAge1xuICAgICAgICB0aGlzLl9ob29rcy5vblZpZXdEaWRVcGRhdGUodGhpcy5fcmVuZGVyZWRQYWdlcy5zbGljZSgpLCBudWxsKTtcbiAgICB9XG59O1xuXG5cblxuLy8gRklYTUUod2FiYWluKTogUmVtb3ZlIHRoZSBkaXJlY3Rpb24gYXJndW1lbnQgaWYgaXQgZG9lc24ndCBlbmQgdXAgYmVpbmcgbmVlZGVkLlxuUmVuZGVyZXIucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbntcbiAgICB2YXIgbmV3UmVuZGVyZWRQYWdlcyA9IFtdO1xuICAgIHRoaXMubGF5b3V0LnBhZ2VHcm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdwb3J0LmludGVyc2VjdHNSZWdpb24oZ3JvdXAucmVnaW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgdmlzaWJsZVBhZ2VzID0gZ3JvdXAucGFnZXNcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNQYWdlVmlzaWJsZShwYWdlLmluZGV4KTtcbiAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChwYWdlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWdlLmluZGV4O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3UmVuZGVyZWRQYWdlcy5wdXNoLmFwcGx5KG5ld1JlbmRlcmVkUGFnZXMsIHZpc2libGVQYWdlcyk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5fcGFpbnRPdXRsaW5lKG5ld1JlbmRlcmVkUGFnZXMpO1xuXG4gICAgbmV3UmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFnZSA9IHRoaXMubGF5b3V0LmdldFBhZ2VJbmZvKHBhZ2VJbmRleCk7XG4gICAgICAgICAgICB2YXIgem9vbUxldmVscyA9IHRoaXMuX3NvdXJjZVJlc29sdmVyLmdldEFsbFpvb21MZXZlbHNGb3JQYWdlKHBhZ2UpO1xuICAgICAgICAgICAgdmFyIGNvbXBvc2l0ZSA9IG5ldyBDb21wb3NpdGVJbWFnZSh6b29tTGV2ZWxzKTtcbiAgICAgICAgICAgIGNvbXBvc2l0ZS51cGRhdGVGcm9tQ2FjaGUodGhpcy5fY2FjaGUpO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF0gPSBjb21wb3NpdGU7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2luaXRpYXRlVGlsZVJlcXVlc3RzKG5ld1JlbmRlcmVkUGFnZXMpO1xuXG4gICAgdmFyIGNoYW5nZXMgPSBmaW5kQ2hhbmdlcyh0aGlzLl9yZW5kZXJlZFBhZ2VzIHx8IFtdLCBuZXdSZW5kZXJlZFBhZ2VzKTtcblxuICAgIGNoYW5nZXMucmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBkZWxldGUgdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF07XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzID0gbmV3UmVuZGVyZWRQYWdlcztcbiAgICB0aGlzLl9wYWludCgpO1xuXG4gICAgaWYgKHRoaXMuX2hvb2tzLm9uUGFnZVdpbGxMb2FkKVxuICAgIHtcbiAgICAgICAgY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hvb2tzLm9uUGFnZVdpbGxMb2FkKHBhZ2VJbmRleCk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5fcGFpbnQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGRlYnVnKCdSZXBhaW50aW5nJyk7XG5cbiAgICB2YXIgcmVuZGVyZWRUaWxlcyA9IFtdO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRQYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB0aGlzLl9jb21wb3NpdGVJbWFnZXNbcGFnZUluZGV4XS5nZXRUaWxlcyh0aGlzLl96b29tTGV2ZWwpLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNjYWxlZCA9IGdldFNjYWxlZFRpbGVSZWNvcmQoc291cmNlLCB0aGlzLl96b29tTGV2ZWwpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlVmlzaWJsZShwYWdlSW5kZXgsIHNjYWxlZCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRUaWxlcy5wdXNoKHNvdXJjZS51cmwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdUaWxlKHBhZ2VJbmRleCwgc2NhbGVkLCB0aGlzLl9jYWNoZS5nZXQoc291cmNlLnVybCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBjYWNoZSA9IHRoaXMuX2NhY2hlO1xuXG4gICAgdmFyIGNoYW5nZXMgPSBmaW5kQ2hhbmdlcyh0aGlzLl9yZW5kZXJlZFRpbGVzIHx8IFtdLCByZW5kZXJlZFRpbGVzKTtcblxuICAgIGNoYW5nZXMuYWRkZWQuZm9yRWFjaChmdW5jdGlvbiAodXJsKVxuICAgIHtcbiAgICAgICAgY2FjaGUuYWNxdWlyZSh1cmwpO1xuICAgIH0pO1xuXG4gICAgY2hhbmdlcy5yZW1vdmVkLmZvckVhY2goZnVuY3Rpb24gKHVybClcbiAgICB7XG4gICAgICAgIGNhY2hlLnJlbGVhc2UodXJsKTtcbiAgICB9KTtcblxuICAgIGlmIChjaGFuZ2VzLnJlbW92ZWQpXG4gICAge1xuICAgICAgICAvLyBGSVhNRTogU2hvdWxkIG9ubHkgbmVlZCB0byB1cGRhdGUgdGhlIGNvbXBvc2l0ZSBpbWFnZXNcbiAgICAgICAgLy8gZm9yIHdoaWNoIHRpbGVzIHdlcmUgcmVtb3ZlZFxuICAgICAgICB0aGlzLl9yZW5kZXJlZFBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2VJbmRleClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF0udXBkYXRlRnJvbUNhY2hlKHRoaXMuX2NhY2hlKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVuZGVyZWRUaWxlcyA9IHJlbmRlcmVkVGlsZXM7XG59O1xuXG4vLyBQYWludCBhIHBhZ2Ugb3V0bGluZSB3aGlsZSB0aGUgdGlsZXMgYXJlIGxvYWRpbmcuXG5SZW5kZXJlci5wcm90b3R5cGUuX3BhaW50T3V0bGluZSA9IGZ1bmN0aW9uIChwYWdlcylcbntcbiAgICBwYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgcGFnZUluZm8gPSB0aGlzLmxheW91dC5nZXRQYWdlSW5mbyhwYWdlSW5kZXgpO1xuICAgICAgICB2YXIgcGFnZU9mZnNldCA9IHRoaXMuX2dldEltYWdlT2Zmc2V0KHBhZ2VJbmRleCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoZSBkb2N1bWVudCBpcyBkcmF3biB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydFxuICAgICAgICB2YXIgdmlld3BvcnRQYWRkaW5nWCA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC53aWR0aCAtIHRoaXMubGF5b3V0LmRpbWVuc2lvbnMud2lkdGgpIC8gMik7XG4gICAgICAgIHZhciB2aWV3cG9ydFBhZGRpbmdZID0gTWF0aC5tYXgoMCwgKHRoaXMuX3ZpZXdwb3J0LmhlaWdodCAtIHRoaXMubGF5b3V0LmRpbWVuc2lvbnMuaGVpZ2h0KSAvIDIpO1xuXG4gICAgICAgIHZhciB2aWV3cG9ydE9mZnNldFggPSBwYWdlT2Zmc2V0LmxlZnQgLSB0aGlzLl92aWV3cG9ydC5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nWDtcbiAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0WSA9IHBhZ2VPZmZzZXQudG9wIC0gdGhpcy5fdmlld3BvcnQudG9wICsgdmlld3BvcnRQYWRkaW5nWTtcblxuICAgICAgICB2YXIgZGVzdFhPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFggPCAwID8gLXZpZXdwb3J0T2Zmc2V0WCA6IDA7XG4gICAgICAgIHZhciBkZXN0WU9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0WSA8IDAgPyAtdmlld3BvcnRPZmZzZXRZIDogMDtcblxuICAgICAgICB2YXIgY2FudmFzWCA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WCk7XG4gICAgICAgIHZhciBjYW52YXNZID0gTWF0aC5tYXgoMCwgdmlld3BvcnRPZmZzZXRZKTtcblxuICAgICAgICB2YXIgZGVzdFdpZHRoID0gcGFnZUluZm8uZGltZW5zaW9ucy53aWR0aCAtIGRlc3RYT2Zmc2V0O1xuICAgICAgICB2YXIgZGVzdEhlaWdodCA9IHBhZ2VJbmZvLmRpbWVuc2lvbnMuaGVpZ2h0IC0gZGVzdFlPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVN0eWxlID0gJyNBQUEnO1xuICAgICAgICAvLyBJbiBvcmRlciB0byBnZXQgYSAxcHggd2lkZSBsaW5lIHVzaW5nIHN0cm9rZXMsIHdlIG5lZWQgdG8gc3RhcnQgYXQgYSAnaGFsZiBwaXhlbCdcbiAgICAgICAgdGhpcy5fY3R4LnN0cm9rZVJlY3QoY2FudmFzWCArIDAuNSwgY2FudmFzWSArIDAuNSwgZGVzdFdpZHRoLCBkZXN0SGVpZ2h0KTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbi8vIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBzZW50IGFsbCB2aXNpYmxlIHBhZ2VzIGF0IG9uY2UgYmVjYXVzZSBpdCB3aWxsIGluaXRpYXRlXG4vLyBhbGwgaW1hZ2UgcmVxdWVzdHMgYW5kIGNhbmNlbCBhbnkgcmVtYWluaW5nIGltYWdlIHJlcXVlc3RzLiBJbiB0aGUgY2FzZSB0aGF0XG4vLyBhIHJlcXVlc3QgaXMgb25nb2luZyBhbmQgdGhlIHRpbGUgaXMgc3RpbGwgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQsIHRoZSBvbGQgcmVxdWVzdFxuLy8gaXMga2VwdCBhY3RpdmUgaW5zdGVhZCBvZiByZXN0YXJ0aW5nIGl0LiBUaGUgaW1hZ2UgcmVxdWVzdHMgYXJlIGdpdmVuIGEgdGltZW91dFxuLy8gYmVmb3JlIGxvYWRpbmcgaW4gb3JkZXIgdG8gZGVib3VuY2UgdGhlbSBhbmQgaGF2ZSBhIHNtYWxsIHJlYWN0aW9uIHRpbWVcbi8vIHRvIGNhbmNlbCB0aGVtIGFuZCBhdm9pZCB1c2VsZXNzIHJlcXVlc3RzLlxuUmVuZGVyZXIucHJvdG90eXBlLl9pbml0aWF0ZVRpbGVSZXF1ZXN0cyA9IGZ1bmN0aW9uKHBhZ2VzKVxue1xuICAgIC8vIE9ubHkgcmVxdWVzdHMgaW4gdGhpcyBvYmplY3QgYXJlIGtlcHQgYWxpdmUsIHNpbmNlIGFsbCBvdGhlcnMgYXJlIG5vdCB2aXNpYmxlIGluIHRoZSB2aWV3cG9ydFxuICAgIHZhciBuZXdQZW5kaW5nUmVxdWVzdHMgPSB7fTtcblxuICAgIC8vIFVzZWQgbGF0ZXIgYXMgYSBjbG9zdXJlIHRvIGluaXRpYXRlIHRoZSBpbWFnZSByZXF1ZXN0cyB3aXRoIHRoZSByaWdodCBzb3VyY2UgYW5kIHBhZ2VJbmRleFxuICAgIHZhciBpbml0aWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoc291cmNlLCBwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgY29tcG9zaXRlID0gdGhpcy5fY29tcG9zaXRlSW1hZ2VzW3BhZ2VJbmRleF07XG5cbiAgICAgICAgbmV3UGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdID0gbmV3IEltYWdlUmVxdWVzdEhhbmRsZXIoe1xuICAgICAgICAgICAgdXJsOiBzb3VyY2UudXJsLFxuICAgICAgICAgICAgdGltZW91dFRpbWU6IFJFUVVFU1RfREVCT1VOQ0VfSU5URVJWQUwsXG4gICAgICAgICAgICBsb2FkOiBmdW5jdGlvbiAoaW1nKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF07XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUucHV0KHNvdXJjZS51cmwsIGltZyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBd2t3YXJkIHdheSB0byBjaGVjayBmb3IgdXBkYXRlc1xuICAgICAgICAgICAgICAgIGlmIChjb21wb3NpdGUgPT09IHRoaXMuX2NvbXBvc2l0ZUltYWdlc1twYWdlSW5kZXhdKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9zaXRlLnVwZGF0ZVdpdGhMb2FkZWRVcmxzKFtzb3VyY2UudXJsXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZUZvclNvdXJjZVZpc2libGUocGFnZUluZGV4LCBzb3VyY2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFpbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdQYWludHMoJ1BhZ2UgJXMsIHRpbGUgJXMgbm8gbG9uZ2VyIHZpc2libGUgb24gaW1hZ2UgbG9hZCcsIHBhZ2VJbmRleCwgc291cmNlLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ291bGQgbWFrZSBhIGxpbWl0ZWQgbnVtYmVyIG9mIHJldHJpZXMsIGV0Yy5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3NvdXJjZS51cmxdO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICAgIH0pO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB2YXIgcGFnZUluZGV4ID0gcGFnZXNbaV07XG4gICAgICAgIHZhciB0aWxlcyA9IHRoaXMuX3NvdXJjZVJlc29sdmVyLmdldEJlc3Rab29tTGV2ZWxGb3JQYWdlKHRoaXMubGF5b3V0LmdldFBhZ2VJbmZvKHBhZ2VJbmRleCkpLnRpbGVzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGlsZXMubGVuZ3RoOyBqKyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aWxlc1tqXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWNoZS5oYXMoc291cmNlLnVybCkgfHwgIXRoaXMuX2lzVGlsZUZvclNvdXJjZVZpc2libGUocGFnZUluZGV4LCBzb3VyY2UpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBjcmVhdGUgYSBuZXcgcmVxdWVzdCBpZiB0aGUgdGlsZSBpcyBhbHJlYWR5IGJlaW5nIGxvYWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuZXdQZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF0gPSB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbc291cmNlLnVybF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tzb3VyY2UudXJsXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGEgY2xvc3VyZSBzaW5jZSB0aGUgbG9hZCBhbmQgZXJyb3IgbWV0aG9kcyBhcmUgZ29pbmcgdG8gYmUgY2FsbGVkIGxhdGVyIGFuZFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBrZWVwIHRoZSByaWdodCByZWZlcmVuY2UgdG8gdGhlIHNvdXJjZSBhbmQgdGhlIHBhZ2UgaW5kZXhcbiAgICAgICAgICAgIGluaXRpYXRlUmVxdWVzdChzb3VyY2UsIHBhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciB1cmwgaW4gdGhpcy5fcGVuZGluZ1JlcXVlc3RzKVxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHNbdXJsXS5hYm9ydCgpO1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IG5ld1BlbmRpbmdSZXF1ZXN0cztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5fZHJhd1RpbGUgPSBmdW5jdGlvbiAocGFnZUluZGV4LCBzY2FsZWRUaWxlLCBpbWcpXG57XG4gICAgdmFyIHRpbGVPZmZzZXQgPSB0aGlzLl9nZXRUaWxlVG9Eb2N1bWVudE9mZnNldChwYWdlSW5kZXgsIHNjYWxlZFRpbGUpO1xuXG4gICAgLy8gRW5zdXJlIHRoZSBkb2N1bWVudCBpcyBkcmF3biB0byB0aGUgY2VudGVyIG9mIHRoZSB2aWV3cG9ydFxuICAgIHZhciB2aWV3cG9ydFBhZGRpbmdYID0gTWF0aC5tYXgoMCwgKHRoaXMuX3ZpZXdwb3J0LndpZHRoIC0gdGhpcy5sYXlvdXQuZGltZW5zaW9ucy53aWR0aCkgLyAyKTtcbiAgICB2YXIgdmlld3BvcnRQYWRkaW5nWSA9IE1hdGgubWF4KDAsICh0aGlzLl92aWV3cG9ydC5oZWlnaHQgLSB0aGlzLmxheW91dC5kaW1lbnNpb25zLmhlaWdodCkgLyAyKTtcblxuICAgIHZhciB2aWV3cG9ydE9mZnNldFggPSB0aWxlT2Zmc2V0LmxlZnQgLSB0aGlzLl92aWV3cG9ydC5sZWZ0ICsgdmlld3BvcnRQYWRkaW5nWDtcbiAgICB2YXIgdmlld3BvcnRPZmZzZXRZID0gdGlsZU9mZnNldC50b3AgLSB0aGlzLl92aWV3cG9ydC50b3AgKyB2aWV3cG9ydFBhZGRpbmdZO1xuXG4gICAgdmFyIGRlc3RYT2Zmc2V0ID0gdmlld3BvcnRPZmZzZXRYIDwgMCA/IC12aWV3cG9ydE9mZnNldFggOiAwO1xuICAgIHZhciBkZXN0WU9mZnNldCA9IHZpZXdwb3J0T2Zmc2V0WSA8IDAgPyAtdmlld3BvcnRPZmZzZXRZIDogMDtcblxuICAgIHZhciBzb3VyY2VYT2Zmc2V0ID0gZGVzdFhPZmZzZXQgLyBzY2FsZWRUaWxlLnNjYWxlUmF0aW87XG4gICAgdmFyIHNvdXJjZVlPZmZzZXQgPSBkZXN0WU9mZnNldCAvIHNjYWxlZFRpbGUuc2NhbGVSYXRpbztcblxuICAgIHZhciBjYW52YXNYID0gTWF0aC5tYXgoMCwgdmlld3BvcnRPZmZzZXRYKTtcbiAgICB2YXIgY2FudmFzWSA9IE1hdGgubWF4KDAsIHZpZXdwb3J0T2Zmc2V0WSk7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc3BlY2lmaWVkIGRpbWVuc2lvbnMgYXJlIG5vIGdyZWF0ZXIgdGhhbiB0aGUgYWN0dWFsXG4gICAgLy8gc2l6ZSBvZiB0aGUgaW1hZ2UuIFNhZmFyaSB3b24ndCBkaXNwbGF5IHRoZSB0aWxlIGlmIHRoZXkgYXJlLlxuICAgIHZhciBkZXN0V2lkdGggPSBNYXRoLm1pbihzY2FsZWRUaWxlLmRpbWVuc2lvbnMud2lkdGgsIGltZy53aWR0aCAqIHNjYWxlZFRpbGUuc2NhbGVSYXRpbykgLSBkZXN0WE9mZnNldDtcbiAgICB2YXIgZGVzdEhlaWdodCA9IE1hdGgubWluKHNjYWxlZFRpbGUuZGltZW5zaW9ucy5oZWlnaHQsIGltZy5oZWlnaHQgKiBzY2FsZWRUaWxlLnNjYWxlUmF0aW8pIC0gZGVzdFlPZmZzZXQ7XG5cbiAgICBkZXN0V2lkdGggPSBNYXRoLm1heCgxLCBkZXN0V2lkdGgpO1xuICAgIGRlc3RIZWlnaHQgPSBNYXRoLm1heCgxLCBkZXN0SGVpZ2h0KTtcblxuICAgIHZhciBzb3VyY2VXaWR0aCA9IE1hdGguYWJzKGRlc3RXaWR0aCAvIHNjYWxlZFRpbGUuc2NhbGVSYXRpbyk7XG4gICAgdmFyIHNvdXJjZUhlaWdodCA9IE1hdGguYWJzKGRlc3RIZWlnaHQgLyBzY2FsZWRUaWxlLnNjYWxlUmF0aW8pO1xuXG4gICAgaWYgKGRlYnVnUGFpbnRzLmVuYWJsZWQpXG4gICAge1xuICAgICAgICBkZWJ1Z1BhaW50cygnRHJhd2luZyBwYWdlICVzLCB0aWxlICVzeCAoJXMsICVzKSBmcm9tICVzLCAlcyB0byB2aWV3cG9ydCBhdCAlcywgJXMsIHNjYWxlICVzJSUnLFxuICAgICAgICAgICAgcGFnZUluZGV4LFxuICAgICAgICAgICAgc2NhbGVkVGlsZS5zb3VyY2Vab29tTGV2ZWwsIHNjYWxlZFRpbGUucm93LCBzY2FsZWRUaWxlLmNvbCxcbiAgICAgICAgICAgIHNvdXJjZVhPZmZzZXQsIHNvdXJjZVlPZmZzZXQsXG4gICAgICAgICAgICBjYW52YXNYLCBjYW52YXNZLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChzY2FsZWRUaWxlLnNjYWxlUmF0aW8gKiAxMDApKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdHguZHJhd0ltYWdlKFxuICAgICAgICBpbWcsXG4gICAgICAgIHNvdXJjZVhPZmZzZXQsIHNvdXJjZVlPZmZzZXQsXG4gICAgICAgIHNvdXJjZVdpZHRoLCBzb3VyY2VIZWlnaHQsXG4gICAgICAgIGNhbnZhc1gsIGNhbnZhc1ksXG4gICAgICAgIGRlc3RXaWR0aCwgZGVzdEhlaWdodCk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2lzVGlsZUZvclNvdXJjZVZpc2libGUgPSBmdW5jdGlvbiAocGFnZUluZGV4LCB0aWxlU291cmNlKVxue1xuICAgIHJldHVybiB0aGlzLl9pc1RpbGVWaXNpYmxlKHBhZ2VJbmRleCwgZ2V0U2NhbGVkVGlsZVJlY29yZCh0aWxlU291cmNlLCB0aGlzLl96b29tTGV2ZWwpKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5faXNUaWxlVmlzaWJsZSA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHNjYWxlZFRpbGUpXG57XG4gICAgdmFyIHRpbGVPZmZzZXQgPSB0aGlzLl9nZXRUaWxlVG9Eb2N1bWVudE9mZnNldChwYWdlSW5kZXgsIHNjYWxlZFRpbGUpO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogVGhpcyBjaGVjayBpcyBpbnN1ZmZpY2llbnQgZHVyaW5nIGEgem9vbSB0cmFuc2l0aW9uXG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0LmludGVyc2VjdHNSZWdpb24oe1xuICAgICAgICB0b3A6IHRpbGVPZmZzZXQudG9wLFxuICAgICAgICBib3R0b206IHRpbGVPZmZzZXQudG9wICsgc2NhbGVkVGlsZS5kaW1lbnNpb25zLmhlaWdodCxcbiAgICAgICAgbGVmdDogdGlsZU9mZnNldC5sZWZ0LFxuICAgICAgICByaWdodDogdGlsZU9mZnNldC5sZWZ0ICsgc2NhbGVkVGlsZS5kaW1lbnNpb25zLndpZHRoXG4gICAgfSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2dldFRpbGVUb0RvY3VtZW50T2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgc2NhbGVkVGlsZSlcbntcbiAgICB2YXIgaW1hZ2VPZmZzZXQgPSB0aGlzLl9nZXRJbWFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiBpbWFnZU9mZnNldC50b3AgKyBzY2FsZWRUaWxlLm9mZnNldC50b3AsXG4gICAgICAgIGxlZnQ6IGltYWdlT2Zmc2V0LmxlZnQgKyBzY2FsZWRUaWxlLm9mZnNldC5sZWZ0XG4gICAgfTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5fZ2V0SW1hZ2VPZmZzZXQgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIHJldHVybiB0aGlzLmxheW91dC5nZXRQYWdlT2Zmc2V0KHBhZ2VJbmRleCwge2V4Y2x1ZGVQYWRkaW5nOiB0cnVlfSk7XG59O1xuXG4vLyBUT0RPOiBVcGRhdGUgc2lnbmF0dXJlXG5SZW5kZXJlci5wcm90b3R5cGUuZ290byA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHZlcnRpY2FsT2Zmc2V0LCBob3Jpem9udGFsT2Zmc2V0KVxue1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5fZ290byhwYWdlSW5kZXgsIHZlcnRpY2FsT2Zmc2V0LCBob3Jpem9udGFsT2Zmc2V0KTtcbiAgICBpZiAodGhpcy5faG9va3Mub25WaWV3RGlkVXBkYXRlKVxuICAgIHtcbiAgICAgICAgdGhpcy5faG9va3Mub25WaWV3RGlkVXBkYXRlKHRoaXMuX3JlbmRlcmVkUGFnZXMuc2xpY2UoKSwgcGFnZUluZGV4KTtcbiAgICB9XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuX2dvdG8gPSBmdW5jdGlvbiAocGFnZUluZGV4LCB2ZXJ0aWNhbE9mZnNldCwgaG9yaXpvbnRhbE9mZnNldClcbntcbiAgICAvLyBGSVhNRSh3YWJhaW4pOiBNb3ZlIHRoaXMgbG9naWMgdG8gdGhlIHZpZXdlclxuICAgIHZhciBwYWdlT2Zmc2V0ID0gdGhpcy5sYXlvdXQuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgdmFyIGRlc2lyZWRWZXJ0aWNhbENlbnRlciA9IHBhZ2VPZmZzZXQudG9wICsgdmVydGljYWxPZmZzZXQ7XG4gICAgdmFyIHRvcCA9IGRlc2lyZWRWZXJ0aWNhbENlbnRlciAtIHBhcnNlSW50KHRoaXMuX3ZpZXdwb3J0LmhlaWdodCAvIDIsIDEwKTtcblxuICAgIHZhciBkZXNpcmVkSG9yaXpvbnRhbENlbnRlciA9IHBhZ2VPZmZzZXQubGVmdCArIGhvcml6b250YWxPZmZzZXQ7XG4gICAgdmFyIGxlZnQgPSBkZXNpcmVkSG9yaXpvbnRhbENlbnRlciAtIHBhcnNlSW50KHRoaXMuX3ZpZXdwb3J0LndpZHRoIC8gMiwgMTApO1xuXG4gICAgdGhpcy5fdmlld3BvcnQudG9wID0gdG9wO1xuICAgIHRoaXMuX3ZpZXdwb3J0LmxlZnQgPSBsZWZ0O1xuXG4gICAgdGhpcy5fcmVuZGVyKDApO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRyYW5zaXRpb25WaWV3cG9ydFBvc2l0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpXG57XG4gICAgdGhpcy5fY2xlYXJBbmltYXRpb24oKTtcblxuICAgIHZhciBnZXRQb3NpdGlvbiA9IG9wdGlvbnMuZ2V0UG9zaXRpb247XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIG9uVmlld0RpZFRyYW5zaXRpb24gPSB0aGlzLl9ob29rcy5vblZpZXdEaWRUcmFuc2l0aW9uO1xuXG4gICAgdGhpcy5fYW5pbWF0aW9uID0gSW50ZXJwb2xhdGVBbmltYXRpb24uYW5pbWF0ZSh7XG4gICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICBwYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnMsXG4gICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAodmFsdWVzKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyBpbWFnZSBwcmVsb2FkaW5nLCB3b3JrIHdpdGggdGhhdFxuICAgICAgICAgICAgc2VsZi5fc2V0Vmlld3BvcnRQb3NpdGlvbihnZXRQb3NpdGlvbih2YWx1ZXMpKTtcblxuICAgICAgICAgICAgaWYgKG9uVmlld0RpZFRyYW5zaXRpb24pXG4gICAgICAgICAgICAgICAgb25WaWV3RGlkVHJhbnNpdGlvbigpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGluZm8pXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm9uRW5kKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25FbmQoaW5mbyk7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLl9ob29rcy5vblZpZXdEaWRVcGRhdGUgJiYgIWluZm8uaW50ZXJydXB0ZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2VsZi5faG9va3Mub25WaWV3RGlkVXBkYXRlKHNlbGYuX3JlbmRlcmVkUGFnZXMuc2xpY2UoKSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5fY2xlYXJBbmltYXRpb24gPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9hbmltYXRpb24pXG4gICAge1xuICAgICAgICB0aGlzLl9hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XG4gICAgfVxufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnByZWxvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIC8vIFRPRE9cbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5pc1BhZ2VWaXNpYmxlID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICBpZiAoIXRoaXMubGF5b3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgcGFnZSA9IHRoaXMubGF5b3V0LmdldFBhZ2VJbmZvKHBhZ2VJbmRleCk7XG5cbiAgICBpZiAoIXBhZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydC5pbnRlcnNlY3RzUmVnaW9uKHRoaXMubGF5b3V0LmdldFBhZ2VSZWdpb24ocGFnZUluZGV4KSk7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZ2V0UmVuZGVyZWRQYWdlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVkUGFnZXMuc2xpY2UoKTtcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKClcbntcbiAgICB0aGlzLl9jbGVhckFuaW1hdGlvbigpO1xuXG4gICAgLy8gRklYTUUod2FiYWluKTogSSBkb24ndCBrbm93IGlmIHdlIHNob3VsZCBhY3R1YWxseSBkbyB0aGlzXG4gICAgT2JqZWN0LmtleXModGhpcy5fcGVuZGluZ1JlcXVlc3RzKS5mb3JFYWNoKGZ1bmN0aW9uIChyZXEpXG4gICAge1xuICAgICAgICB2YXIgaGFuZGxlciA9IHRoaXMuX3BlbmRpbmdSZXF1ZXN0c1tyZXFdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcXVlc3RzW3JlcV07XG5cbiAgICAgICAgaGFuZGxlci5hYm9ydCgpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzKTtcbn07XG5cbmZ1bmN0aW9uIGdldFNjYWxlZFRpbGVSZWNvcmQoc291cmNlLCBzY2FsZUZhY3RvcilcbntcbiAgICB2YXIgc2NhbGVSYXRpbztcblxuICAgIGlmIChzY2FsZUZhY3RvciA9PT0gbnVsbClcbiAgICAgICAgc2NhbGVSYXRpbyA9IDE7XG4gICAgZWxzZVxuICAgICAgICBzY2FsZVJhdGlvID0gTWF0aC5wb3coMiwgc2NhbGVGYWN0b3IgLSBzb3VyY2Uuem9vbUxldmVsKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZVpvb21MZXZlbDogc291cmNlLnpvb21MZXZlbCxcbiAgICAgICAgc2NhbGVSYXRpbzogc2NhbGVSYXRpbyxcbiAgICAgICAgcm93OiBzb3VyY2Uucm93LFxuICAgICAgICBjb2w6IHNvdXJjZS5jb2wsXG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgIHdpZHRoOiBzb3VyY2UuZGltZW5zaW9ucy53aWR0aCAqIHNjYWxlUmF0aW8sXG4gICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZS5kaW1lbnNpb25zLmhlaWdodCAqIHNjYWxlUmF0aW9cbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICBsZWZ0OiBzb3VyY2Uub2Zmc2V0LmxlZnQgKiBzY2FsZVJhdGlvLFxuICAgICAgICAgICAgdG9wOiBzb3VyY2Uub2Zmc2V0LnRvcCAqIHNjYWxlUmF0aW9cbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiBzb3VyY2UudXJsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZmluZENoYW5nZXMob2xkQXJyYXksIG5ld0FycmF5KVxue1xuICAgIGlmIChvbGRBcnJheSA9PT0gbmV3QXJyYXkpXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkZWQ6IFtdLFxuICAgICAgICAgICAgcmVtb3ZlZDogW11cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZCA9IG9sZEFycmF5LmZpbHRlcihmdW5jdGlvbiAob2xkRW50cnkpXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3QXJyYXkuaW5kZXhPZihvbGRFbnRyeSkgPT09IC0xO1xuICAgIH0pO1xuXG4gICAgdmFyIGFkZGVkID0gbmV3QXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChuZXdFbnRyeSlcbiAgICB7XG4gICAgICAgIHJldHVybiBvbGRBcnJheS5pbmRleE9mKG5ld0VudHJ5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcmVuZGVyZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9kZWJ1Zy9zcmMvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZGVidWcvc3JjL2RlYnVnLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vbXMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRlSW1hZ2U7XG5cbi8qKlxuICogQGNsYXNzIENvbXBvc2l0ZUltYWdlXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFV0aWxpdHkgY2xhc3MgdG8gY29tcG9zaXRlIHRpbGVzIGludG8gYSBjb21wbGV0ZSBpbWFnZVxuICogYW5kIHRyYWNrIHRoZSByZW5kZXJlZCBzdGF0ZSBvZiBhbiBpbWFnZSBhcyBuZXcgdGlsZXNcbiAqIGxvYWQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gbGV2ZWxzIHtBcnJheS48QXJyYXkuPFRpbGU+Pn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb21wb3NpdGVJbWFnZShsZXZlbHMpXG57XG4gICAgdGhpcy5fbGV2ZWxzID0gbGV2ZWxzOyAgLy8gQXNzdW1lIGxldmVscyBzb3J0ZWQgaGlnaC1yZXMgZmlyc3RcbiAgICB2YXIgdXJsc1RvVGlsZXMgPSB0aGlzLl91cmxzVG9UaWxlcyA9IHt9O1xuXG4gICAgbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgbGV2ZWwudGlsZXMuZm9yRWFjaChmdW5jdGlvbiAodGlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdXJsc1RvVGlsZXNbdGlsZS51cmxdID0ge1xuICAgICAgICAgICAgICAgIHpvb21MZXZlbDogbGV2ZWwuem9vbUxldmVsLFxuICAgICAgICAgICAgICAgIHJvdzogdGlsZS5yb3csXG4gICAgICAgICAgICAgICAgY29sOiB0aWxlLmNvbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbkNvbXBvc2l0ZUltYWdlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGxvYWRlZEJ5TGV2ZWwgPSB0aGlzLl9sb2FkZWRCeUxldmVsID0ge307XG5cbiAgICB0aGlzLl9sZXZlbHMuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpXG4gICAge1xuICAgICAgICBsb2FkZWRCeUxldmVsW2xldmVsLnpvb21MZXZlbF0gPSBuZXcgVGlsZUNvdmVyYWdlTWFwKGxldmVsLnJvd3MsIGxldmVsLmNvbHMpO1xuICAgIH0pO1xufTtcblxuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLmdldFRpbGVzID0gZnVuY3Rpb24gKGJhc2Vab29tTGV2ZWwpXG57XG4gICAgdmFyIHRvUmVuZGVyQnlMZXZlbCA9IFtdO1xuICAgIHZhciBoaWdoZXN0Wm9vbUxldmVsID0gdGhpcy5fbGV2ZWxzWzBdLnpvb21MZXZlbDtcbiAgICB2YXIgY292ZXJlZCA9IG5ldyBUaWxlQ292ZXJhZ2VNYXAodGhpcy5fbGV2ZWxzWzBdLnJvd3MsIHRoaXMuX2xldmVsc1swXS5jb2xzKTtcblxuICAgIHZhciBiZXN0TGV2ZWxJbmRleDtcblxuICAgIC8vIERlZmF1bHQgdG8gdGhlIGxvd2VzdCB6b29tIGxldmVsXG4gICAgaWYgKGJhc2Vab29tTGV2ZWwgPT09IG51bGwpXG4gICAge1xuICAgICAgICBiZXN0TGV2ZWxJbmRleCA9IDA7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHZhciBjZWlsTGV2ZWwgPSBNYXRoLmNlaWwoYmFzZVpvb21MZXZlbCk7XG4gICAgICAgIGJlc3RMZXZlbEluZGV4ID0gZmluZEluZGV4KHRoaXMuX2xldmVscywgZnVuY3Rpb24gKGxldmVsKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWwuem9vbUxldmVsIDw9IGNlaWxMZXZlbDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvLyBUaGUgYmVzdCBsZXZlbCwgZm9sbG93ZWQgYnkgaGlnaGVyLXJlcyBsZXZlbHMgaW4gYXNjZW5kaW5nIG9yZGVyIG9mIHJlc29sdXRpb24sXG4gICAgLy8gZm9sbG93ZWQgYnkgbG93ZXItcmVzIGxldmVscyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHJlc29sdXRpb25cbiAgICB2YXIgbGV2ZWxzQnlQcmVmZXJlbmNlID0gdGhpcy5fbGV2ZWxzLnNsaWNlKDAsIGJlc3RMZXZlbEluZGV4ICsgMSkucmV2ZXJzZSgpXG4gICAgICAgIC5jb25jYXQodGhpcy5fbGV2ZWxzLnNsaWNlKGJlc3RMZXZlbEluZGV4ICsgMSkpO1xuXG4gICAgbGV2ZWxzQnlQcmVmZXJlbmNlLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMuX2xvYWRlZEJ5TGV2ZWxbbGV2ZWwuem9vbUxldmVsXTtcblxuICAgICAgICB2YXIgYWRkaXRpb25hbFRpbGVzID0gbGV2ZWwudGlsZXMuZmlsdGVyKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gbG9hZGVkLmlzTG9hZGVkKHRpbGUucm93LCB0aWxlLmNvbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEZpbHRlciBvdXQgZW50aXJlbHkgY292ZXJlZCB0aWxlc1xuXG4gICAgICAgIC8vIEZJWE1FOiBJcyBpdCBiZXR0ZXIgdG8gZHJhdyBhbGwgb2YgYSBwYXJ0aWFsbHkgY292ZXJlZCB0aWxlLFxuICAgICAgICAvLyB3aXRoIHNvbWUgb2YgaXQgdWx0aW1hdGVseSBjb3ZlcmVkLCBvciB0byBwaWNrIG91dCB0aGUgcmVnaW9uXG4gICAgICAgIC8vIHdoaWNoIG5lZWRzIHRvIGJlIGRyYXduP1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0RETUFML2RpdmEuanMvaXNzdWVzLzM1OFxuXG4gICAgICAgIHZhciBzY2FsZVJhdGlvID0gTWF0aC5wb3coMiwgaGlnaGVzdFpvb21MZXZlbCAtIGxldmVsLnpvb21MZXZlbCk7XG5cbiAgICAgICAgYWRkaXRpb25hbFRpbGVzID0gYWRkaXRpb25hbFRpbGVzLmZpbHRlcihmdW5jdGlvbiAodGlsZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGlzTmVlZGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBoaWdoUmVzUm93ID0gdGlsZS5yb3cgKiBzY2FsZVJhdGlvO1xuICAgICAgICAgICAgdmFyIGhpZ2hSZXNDb2wgPSB0aWxlLmNvbCAqIHNjYWxlUmF0aW87XG5cbiAgICAgICAgICAgIGZvciAodmFyIGk9MDsgaSA8IHNjYWxlUmF0aW87IGkrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqPTA7IGogPCBzY2FsZVJhdGlvOyBqKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvdmVyZWQuaXNMb2FkZWQoaGlnaFJlc1JvdyArIGksIGhpZ2hSZXNDb2wgKyBqKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY292ZXJlZC5zZXQoaGlnaFJlc1JvdyArIGksIGhpZ2hSZXNDb2wgKyBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGlzTmVlZGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICB0b1JlbmRlckJ5TGV2ZWwucHVzaChhZGRpdGlvbmFsVGlsZXMpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gTGVzcy1wcmVmZXJyZWQgdGlsZXMgc2hvdWxkIGNvbWUgZmlyc3RcbiAgICB0b1JlbmRlckJ5TGV2ZWwucmV2ZXJzZSgpO1xuXG4gICAgdmFyIHRpbGVzID0gW107XG5cbiAgICB0b1JlbmRlckJ5TGV2ZWwuZm9yRWFjaChmdW5jdGlvbiAoYnlMZXZlbClcbiAgICB7XG4gICAgICAgIHRpbGVzLnB1c2guYXBwbHkodGlsZXMsIGJ5TGV2ZWwpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRpbGVzO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgdGhlIGNvbXBvc2l0ZSBpbWFnZSB0byB0YWtlIGludG8gYWNjb3VudCBhbGwgdGhlIFVSTHNcbiAqIGxvYWRlZCBpbiBhbiBpbWFnZSBjYWNoZS5cbiAqXG4gKiBAcGFyYW0gY2FjaGUge0ltYWdlQ2FjaGV9XG4gKi9cbkNvbXBvc2l0ZUltYWdlLnByb3RvdHlwZS51cGRhdGVGcm9tQ2FjaGUgPSBmdW5jdGlvbiAoY2FjaGUpXG57XG4gICAgdGhpcy5jbGVhcigpO1xuXG4gICAgdGhpcy5fbGV2ZWxzLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKVxuICAgIHtcbiAgICAgICAgdmFyIGxvYWRlZCA9IHRoaXMuX2xvYWRlZEJ5TGV2ZWxbbGV2ZWwuem9vbUxldmVsXTtcblxuICAgICAgICBsZXZlbC50aWxlcy5mb3JFYWNoKGZ1bmN0aW9uICh0aWxlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY2FjaGUuaGFzKHRpbGUudXJsKSlcbiAgICAgICAgICAgICAgICBsb2FkZWQuc2V0KHRpbGUucm93LCB0aWxlLmNvbCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xufTtcblxuQ29tcG9zaXRlSW1hZ2UucHJvdG90eXBlLnVwZGF0ZVdpdGhMb2FkZWRVcmxzID0gZnVuY3Rpb24gKHVybHMpXG57XG4gICAgdXJscy5mb3JFYWNoKGZ1bmN0aW9uICh1cmwpXG4gICAge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl91cmxzVG9UaWxlc1t1cmxdO1xuICAgICAgICB0aGlzLl9sb2FkZWRCeUxldmVsW2VudHJ5Lnpvb21MZXZlbF0uc2V0KGVudHJ5LnJvdywgZW50cnkuY29sLCB0cnVlKTtcbiAgICB9LCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIFRpbGVDb3ZlcmFnZU1hcChyb3dzLCBjb2xzKVxue1xuICAgIHRoaXMuX3Jvd3MgPSByb3dzO1xuICAgIHRoaXMuX2NvbHMgPSBjb2xzO1xuXG4gICAgdGhpcy5fbWFwID0gZmlsbChyb3dzKS5tYXAoZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBmaWxsKGNvbHMsIGZhbHNlKTtcbiAgICB9KTtcbn1cblxuVGlsZUNvdmVyYWdlTWFwLnByb3RvdHlwZS5pc0xvYWRlZCA9IGZ1bmN0aW9uIChyb3csIGNvbClcbntcbiAgICAvLyBSZXR1cm4gdHJ1ZSBmb3Igb3V0IG9mIGJvdW5kcyB0aWxlcyBiZWNhdXNlIHRoZXlcbiAgICAvLyBkb24ndCBuZWVkIHRvIGxvYWQuIChVbmZvcnR1bmF0ZWx5IHRoaXMgd2lsbCBhbHNvXG4gICAgLy8gbWFzayBsb2dpY2FsIGVycm9ycy4pXG4gICAgaWYgKHJvdyA+PSB0aGlzLl9yb3dzIHx8IGNvbCA+PSB0aGlzLl9jb2xzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzLl9tYXBbcm93XVtjb2xdO1xufTtcblxuVGlsZUNvdmVyYWdlTWFwLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocm93LCBjb2wsIHZhbHVlKVxue1xuICAgIHRoaXMuX21hcFtyb3ddW2NvbF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIGZpbGwoY291bnQsIHZhbHVlKVxue1xuICAgIHZhciBhcnIgPSBuZXcgQXJyYXkoY291bnQpO1xuXG4gICAgZm9yICh2YXIgaT0wOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgYXJyW2ldID0gdmFsdWU7XG5cbiAgICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSlcbntcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldLCBpKSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL2NvbXBvc2l0ZS1pbWFnZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBEb2N1bWVudExheW91dDtcblxuLyoqXG4gKiBUcmFuc2xhdGUgcGFnZSBsYXlvdXRzLCBhcyBnZW5lcmF0ZWQgYnkgcGFnZS1sYXlvdXRzLCBpbnRvIGFuXG4gKiBvYmplY3Qgd2hpY2ggY29tcHV0ZXMgbGF5b3V0IGluZm9ybWF0aW9uIGZvciB0aGUgZG9jdW1lbnQgYXNcbiAqIGEgd2hvbGUuXG4gKi9cbmZ1bmN0aW9uIERvY3VtZW50TGF5b3V0KGNvbmZpZywgem9vbUxldmVsKVxue1xuICAgIHZhciBjb21wdXRlZExheW91dCA9IGdldENvbXB1dGVkTGF5b3V0KGNvbmZpZywgem9vbUxldmVsKTtcblxuICAgIHRoaXMuZGltZW5zaW9ucyA9IGNvbXB1dGVkTGF5b3V0LmRpbWVuc2lvbnM7XG4gICAgdGhpcy5wYWdlR3JvdXBzID0gY29tcHV0ZWRMYXlvdXQucGFnZUdyb3VwcztcbiAgICB0aGlzLl9wYWdlTG9va3VwID0gZ2V0UGFnZUxvb2t1cChjb21wdXRlZExheW91dC5wYWdlR3JvdXBzKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYWdlSW5mb1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XG4gKiBAcHJvcGVydHkge3tpbmRleCwgZGltZW5zaW9ucywgcGFnZXMsIHJlZ2lvbiwgcGFkZGluZ319IGdyb3VwXG4gKiBAcHJvcGVydHkge3toZWlnaHQ6IG51bWJlciwgd2lkdGg6IG51bWJlcn19IGRpbWVuc2lvbnNcbiAqIEBwcm9wZXJ0eSB7e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBncm91cE9mZnNldFxuICovXG5cbi8qKlxuICogQHBhcmFtIHBhZ2VJbmRleFxuICogQHJldHVybnMge1BhZ2VJbmZvfG51bGx9XG4gKi9cbkRvY3VtZW50TGF5b3V0LnByb3RvdHlwZS5nZXRQYWdlSW5mbyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VMb29rdXBbcGFnZUluZGV4XSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGRpbWVuc2lvbnMgb2YgYSBwYWdlXG4gKlxuICogQHBhcmFtIHBhZ2VJbmRleFxuICogQHJldHVybnMge3toZWlnaHQ6IG51bWJlciwgd2lkdGg6IG51bWJlcn19XG4gKi9cbkRvY3VtZW50TGF5b3V0LnByb3RvdHlwZS5nZXRQYWdlRGltZW5zaW9ucyA9IGZ1bmN0aW9uIChwYWdlSW5kZXgpXG57XG4gICAgaWYgKCF0aGlzLl9wYWdlTG9va3VwIHx8ICF0aGlzLl9wYWdlTG9va3VwW3BhZ2VJbmRleF0pXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJlZ2lvbiA9IGdldFBhZ2VSZWdpb25Gcm9tUGFnZUluZm8odGhpcy5fcGFnZUxvb2t1cFtwYWdlSW5kZXhdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGhlaWdodDogcmVnaW9uLmJvdHRvbSAtIHJlZ2lvbi50b3AsXG4gICAgICAgIHdpZHRoOiByZWdpb24ucmlnaHQgLSByZWdpb24ubGVmdFxuICAgIH07XG59O1xuXG4vLyBUT0RPKHdhYmFpbik6IEdldCByaWQgb2YgdGhpczsgaXQncyBhIHN1YnNldCBvZiB0aGUgcGFnZSByZWdpb24sIHNvXG4vLyBnaXZlIHRoYXQgaW5zdGVhZFxuLyoqXG4gKiBHZXQgdGhlIHRvcC1sZWZ0IGNvb3JkaW5hdGVzIG9mIGEgcGFnZSwgaW5jbHVkaW5nKioqIHBhZGRpbmdcbiAqXG4gKiBAcGFyYW0gcGFnZUluZGV4XG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMge3t0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyfSB8IG51bGx9XG4gKi9cbkRvY3VtZW50TGF5b3V0LnByb3RvdHlwZS5nZXRQYWdlT2Zmc2V0ID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgb3B0aW9ucylcbntcbiAgICB2YXIgcmVnaW9uID0gdGhpcy5nZXRQYWdlUmVnaW9uKHBhZ2VJbmRleCwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXJlZ2lvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHJlZ2lvbi50b3AsXG4gICAgICAgIGxlZnQ6IHJlZ2lvbi5sZWZ0XG4gICAgfTtcbn07XG5cbkRvY3VtZW50TGF5b3V0LnByb3RvdHlwZS5nZXRQYWdlUmVnaW9uID0gZnVuY3Rpb24gKHBhZ2VJbmRleCwgb3B0aW9ucylcbntcbiAgICB2YXIgcGFnZUluZm8gPSB0aGlzLl9wYWdlTG9va3VwW3BhZ2VJbmRleF07XG5cbiAgICBpZiAoIXBhZ2VJbmZvKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHZhciByZWdpb24gPSBnZXRQYWdlUmVnaW9uRnJvbVBhZ2VJbmZvKHBhZ2VJbmZvKTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjbHVkZVBhZGRpbmcpXG4gICAge1xuICAgICAgICAvLyBGSVhNRT9cbiAgICAgICAgdmFyIHBhZGRpbmcgPSBwYWdlSW5mby5ncm91cC5wYWRkaW5nO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IHJlZ2lvbi50b3AgKyBwYWRkaW5nLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJlZ2lvbi5sZWZ0ICsgcGFkZGluZy5sZWZ0LFxuICAgICAgICAgICAgYm90dG9tOiByZWdpb24uYm90dG9tLFxuICAgICAgICAgICAgcmlnaHQ6IHJlZ2lvbi5yaWdodFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZWdpb247XG59O1xuXG4vKipcbiAqIEdldCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLXJpZ2h0IG9mIHRoZSBwYWdlIHRvIHRoZSBjZW50ZXIgb2YgdGhlXG4gKiBzcGVjaWZpZWQgdmlld3BvcnQgcmVnaW9uXG4gKlxuICogQHBhcmFtIHBhZ2VJbmRleFxuICogQHBhcmFtIHZpZXdwb3J0IHt7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fVxuICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gKi9cbkRvY3VtZW50TGF5b3V0LnByb3RvdHlwZS5nZXRQYWdlVG9WaWV3cG9ydENlbnRlck9mZnNldCA9IGZ1bmN0aW9uIChwYWdlSW5kZXgsIHZpZXdwb3J0KVxue1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gdmlld3BvcnQubGVmdDtcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdmlld3BvcnQucmlnaHQgLSB2aWV3cG9ydC5sZWZ0O1xuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuZ2V0UGFnZU9mZnNldChwYWdlSW5kZXgpO1xuXG4gICAgdmFyIHggPSBzY3JvbGxMZWZ0IC0gb2Zmc2V0LmxlZnQgKyBwYXJzZUludChlbGVtZW50V2lkdGggLyAyLCAxMCk7XG5cbiAgICB2YXIgc2Nyb2xsVG9wID0gdmlld3BvcnQudG9wO1xuICAgIHZhciBlbGVtZW50SGVpZ2h0ID0gdmlld3BvcnQuYm90dG9tIC0gdmlld3BvcnQudG9wO1xuXG4gICAgdmFyIHkgPSBzY3JvbGxUb3AgLSBvZmZzZXQudG9wICsgcGFyc2VJbnQoZWxlbWVudEhlaWdodCAvIDIsIDEwKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0UGFnZVJlZ2lvbkZyb21QYWdlSW5mbyhwYWdlKVxue1xuICAgIHZhciB0b3AgICAgPSBwYWdlLmdyb3VwT2Zmc2V0LnRvcCAgKyBwYWdlLmdyb3VwLnJlZ2lvbi50b3A7XG4gICAgdmFyIGJvdHRvbSA9IHRvcCArIHBhZ2UuZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgdmFyIGxlZnQgICA9IHBhZ2UuZ3JvdXBPZmZzZXQubGVmdCArIHBhZ2UuZ3JvdXAucmVnaW9uLmxlZnQ7XG4gICAgdmFyIHJpZ2h0ICA9IGxlZnQgKyBwYWdlLmRpbWVuc2lvbnMud2lkdGg7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhZ2VMb29rdXAocGFnZUdyb3VwcylcbntcbiAgICB2YXIgcGFnZUxvb2t1cCA9IHt9O1xuXG4gICAgcGFnZUdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChncm91cClcbiAgICB7XG4gICAgICAgIGdyb3VwLnBhZ2VzLmZvckVhY2goZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VMb29rdXBbcGFnZS5pbmRleF0gPSB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhZ2UuZGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBncm91cE9mZnNldDogcGFnZS5ncm91cE9mZnNldFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcGFnZUxvb2t1cDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRMYXlvdXQoY29uZmlnLCB6b29tTGV2ZWwpXG57XG4gICAgdmFyIHNjYWxlZExheW91dHMgPSB6b29tTGV2ZWwgPT09IG51bGwgPyBjb25maWcucGFnZUxheW91dHMgOiBnZXRTY2FsZWRQYWdlTGF5b3V0cyhjb25maWcsIHpvb21MZXZlbCk7XG5cbiAgICB2YXIgZG9jdW1lbnRTZWNvbmRhcnlFeHRlbnQgPSBnZXRFeHRlbnRBbG9uZ1NlY29uZGFyeUF4aXMoY29uZmlnLCBzY2FsZWRMYXlvdXRzKTtcblxuICAgIC8vIFRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzXG4gICAgdmFyIHByaW1hcnlEb2NQb3NpdGlvbiA9IGNvbmZpZy52ZXJ0aWNhbGx5T3JpZW50ZWQgP1xuICAgICAgICBjb25maWcucGFkZGluZy5kb2N1bWVudC50b3AgOlxuICAgICAgICBjb25maWcucGFkZGluZy5kb2N1bWVudC5sZWZ0O1xuXG4gICAgdmFyIHBhZ2VHcm91cHMgPSBbXTtcblxuICAgIC8vIFRPRE86IFVzZSBib3R0b20sIHJpZ2h0IGFzIHdlbGxcbiAgICB2YXIgcGFnZVBhZGRpbmcgPSB7XG4gICAgICAgIHRvcDogY29uZmlnLnBhZGRpbmcucGFnZS50b3AsXG4gICAgICAgIGxlZnQ6IGNvbmZpZy5wYWRkaW5nLnBhZ2UubGVmdFxuICAgIH07XG5cbiAgICBzY2FsZWRMYXlvdXRzLmZvckVhY2goZnVuY3Rpb24gKGxheW91dCwgaW5kZXgpXG4gICAge1xuICAgICAgICB2YXIgdG9wLCBsZWZ0O1xuXG4gICAgICAgIGlmIChjb25maWcudmVydGljYWxseU9yaWVudGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0b3AgPSBwcmltYXJ5RG9jUG9zaXRpb247XG4gICAgICAgICAgICBsZWZ0ID0gKGRvY3VtZW50U2Vjb25kYXJ5RXh0ZW50IC0gbGF5b3V0LmRpbWVuc2lvbnMud2lkdGgpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRvcCA9IChkb2N1bWVudFNlY29uZGFyeUV4dGVudCAtIGxheW91dC5kaW1lbnNpb25zLmhlaWdodCkgLyAyO1xuICAgICAgICAgICAgbGVmdCA9IHByaW1hcnlEb2NQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWdpb24gPSB7XG4gICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogdG9wICsgcGFnZVBhZGRpbmcudG9wICsgbGF5b3V0LmRpbWVuc2lvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiBsZWZ0ICsgcGFnZVBhZGRpbmcubGVmdCArIGxheW91dC5kaW1lbnNpb25zLndpZHRoXG4gICAgICAgIH07XG5cbiAgICAgICAgcGFnZUdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IGxheW91dC5kaW1lbnNpb25zLFxuICAgICAgICAgICAgcGFnZXM6IGxheW91dC5wYWdlcyxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICAgICAgcGFkZGluZzogcGFnZVBhZGRpbmdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJpbWFyeURvY1Bvc2l0aW9uID0gY29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZCA/IHJlZ2lvbi5ib3R0b20gOiByZWdpb24ucmlnaHQ7XG4gICAgfSk7XG5cbiAgICB2YXIgaGVpZ2h0LCB3aWR0aDtcblxuICAgIGlmIChjb25maWcudmVydGljYWxseU9yaWVudGVkKVxuICAgIHtcbiAgICAgICAgaGVpZ2h0ID0gcHJpbWFyeURvY1Bvc2l0aW9uICsgcGFnZVBhZGRpbmcudG9wO1xuICAgICAgICB3aWR0aCA9IGRvY3VtZW50U2Vjb25kYXJ5RXh0ZW50O1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICBoZWlnaHQgPSBkb2N1bWVudFNlY29uZGFyeUV4dGVudDtcbiAgICAgICAgd2lkdGggPSBwcmltYXJ5RG9jUG9zaXRpb24gKyBwYWdlUGFkZGluZy5sZWZ0O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIHBhZ2VHcm91cHM6IHBhZ2VHcm91cHNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY2FsZWRQYWdlTGF5b3V0cyhjb25maWcsIHpvb21MZXZlbClcbntcbiAgICB2YXIgc2NhbGVSYXRpbyA9IE1hdGgucG93KDIsIHpvb21MZXZlbCAtIGNvbmZpZy5tYXhab29tTGV2ZWwpO1xuXG4gICAgcmV0dXJuIGNvbmZpZy5wYWdlTGF5b3V0cy5tYXAoZnVuY3Rpb24gKGdyb3VwKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHNjYWxlRGltZW5zaW9ucyhncm91cC5kaW1lbnNpb25zLCBzY2FsZVJhdGlvKSxcbiAgICAgICAgICAgIHBhZ2VzOiBncm91cC5wYWdlcy5tYXAoZnVuY3Rpb24gKHBhZ2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IE1hdGguZmxvb3IocGFnZS5ncm91cE9mZnNldC50b3AgKiBzY2FsZVJhdGlvKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IE1hdGguZmxvb3IocGFnZS5ncm91cE9mZnNldC5sZWZ0ICogc2NhbGVSYXRpbylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogc2NhbGVEaW1lbnNpb25zKHBhZ2UuZGltZW5zaW9ucywgc2NhbGVSYXRpbylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gc2NhbGVEaW1lbnNpb25zKGRpbWVuc2lvbnMsIHNjYWxlUmF0aW8pXG57XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGRpbWVuc2lvbnMuaGVpZ2h0ICogc2NhbGVSYXRpbyksXG4gICAgICAgIHdpZHRoOiBNYXRoLmZsb29yKGRpbWVuc2lvbnMud2lkdGggKiBzY2FsZVJhdGlvKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldEV4dGVudEFsb25nU2Vjb25kYXJ5QXhpcyhjb25maWcsIHNjYWxlZExheW91dHMpXG57XG4gICAgLy8gR2V0IHRoZSBleHRlbnQgb2YgdGhlIGRvY3VtZW50IGFsb25nIHRoZSBzZWNvbmRhcnkgYXhpc1xuICAgIHZhciBzZWNvbmRhcnlEaW0sIHNlY29uZGFyeVBhZGRpbmc7XG4gICAgdmFyIGRvY1BhZGRpbmcgPSBjb25maWcucGFkZGluZy5kb2N1bWVudDtcblxuICAgIGlmIChjb25maWcudmVydGljYWxseU9yaWVudGVkKVxuICAgIHtcbiAgICAgICAgc2Vjb25kYXJ5RGltID0gJ3dpZHRoJztcbiAgICAgICAgc2Vjb25kYXJ5UGFkZGluZyA9IGRvY1BhZGRpbmcubGVmdCArIGRvY1BhZGRpbmcucmlnaHQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHNlY29uZGFyeURpbSA9ICdoZWlnaHQnO1xuICAgICAgICBzZWNvbmRhcnlQYWRkaW5nID0gZG9jUGFkZGluZy50b3AgKyBkb2NQYWRkaW5nLmJvdHRvbTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2Vjb25kYXJ5UGFkZGluZyArIHNjYWxlZExheW91dHMucmVkdWNlKGZ1bmN0aW9uIChtYXhEaW0sIGxheW91dClcbiAgICB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChsYXlvdXQuZGltZW5zaW9uc1tzZWNvbmRhcnlEaW1dLCBtYXhEaW0pO1xuICAgIH0sIDApO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvZG9jdW1lbnQtbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2RpdmE6SW1hZ2VDYWNoZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEltYWdlQ2FjaGU7XG5cbi8qIEZJWE1FKHdhYmFpbik6IFRoZSBjYWNoaW5nIHN0cmF0ZWd5IGhlcmUgaXMgY29tcGxldGVseVxuICogYXJiaXRyYXJ5IGFuZCB0aGUgaW1wbGVtZW50YXRpb24gaXNuJ3QgZXNwZWNpYWxseSBlZmZpY2llbnQuXG4gKi9cblxudmFyIERFRkFVTFRfTUFYX0tFWVMgPSAxMDA7XG5cbmZ1bmN0aW9uIEltYWdlQ2FjaGUob3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7IG1heEtleXM6IERFRkFVTFRfTUFYX0tFWVMgfTtcbiAgICB0aGlzLm1heEtleXMgPSBvcHRpb25zLm1heEtleXMgfHwgREVGQVVMVF9NQVhfS0VZUztcblxuICAgIHRoaXMuX2hlbGQgPSB7fTtcbiAgICB0aGlzLl91cmxzID0ge307XG4gICAgdGhpcy5fbHJ1ID0gW107XG59XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh1cmwpXG57XG4gICAgdmFyIHJlY29yZCA9IHRoaXMuX3VybHNbdXJsXTtcbiAgICByZXR1cm4gcmVjb3JkID8gcmVjb3JkLmltZyA6IG51bGw7XG59O1xuXG5JbWFnZUNhY2hlLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAodXJsKVxue1xuICAgIHJldHVybiAhIXRoaXMuX3VybHNbdXJsXTtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGltZylcbntcbiAgICB2YXIgcmVjb3JkID0gdGhpcy5fdXJsc1t1cmxdO1xuICAgIGlmIChyZWNvcmQpXG4gICAge1xuICAgICAgICAvLyBGSVhNRTogRG9lcyB0aGlzIG1ha2Ugc2Vuc2UgZm9yIHRoaXMgdXNlIGNhc2U/XG4gICAgICAgIHJlY29yZC5pbWcgPSBpbWc7XG4gICAgICAgIHRoaXMuX3Byb21vdGUocmVjb3JkKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmVjb3JkID0ge1xuICAgICAgICAgICAgaW1nOiBpbWcsXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX3VybHNbdXJsXSA9IHJlY29yZDtcbiAgICAgICAgdGhpcy5fdHJ5RXZpY3QoMSk7XG4gICAgICAgIHRoaXMuX2xydS51bnNoaWZ0KHJlY29yZCk7XG4gICAgfVxufTtcblxuSW1hZ2VDYWNoZS5wcm90b3R5cGUuX3Byb21vdGUgPSBmdW5jdGlvbiAocmVjb3JkKVxue1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2xydS5pbmRleE9mKHJlY29yZCk7XG4gICAgdGhpcy5fbHJ1LnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5fbHJ1LnVuc2hpZnQocmVjb3JkKTtcbn07XG5cbkltYWdlQ2FjaGUucHJvdG90eXBlLl90cnlFdmljdCA9IGZ1bmN0aW9uIChleHRyYUNhcGFjaXR5KVxue1xuICAgIHZhciBhbGxvd2VkRW50cnlDb3VudCA9IHRoaXMubWF4S2V5cyAtIGV4dHJhQ2FwYWNpdHk7XG5cbiAgICBpZiAodGhpcy5fbHJ1Lmxlbmd0aCA8PSBhbGxvd2VkRW50cnlDb3VudClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIGV2aWN0aW9uSW5kZXggPSB0aGlzLl9scnUubGVuZ3RoIC0gMTtcblxuICAgIGZvciAoOzspXG4gICAge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy5fbHJ1W2V2aWN0aW9uSW5kZXhdO1xuXG4gICAgICAgIGlmICghdGhpcy5faGVsZFt0YXJnZXQudXJsXSlcbiAgICAgICAge1xuICAgICAgICAgICAgZGVidWcoJ0V2aWN0aW5nIGltYWdlICVzJywgdGFyZ2V0LnVybCk7XG4gICAgICAgICAgICB0aGlzLl9scnUuc3BsaWNlKGV2aWN0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VybHNbdGFyZ2V0LnVybF07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9scnUubGVuZ3RoIDw9IGFsbG93ZWRFbnRyeUNvdW50KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2aWN0aW9uSW5kZXggPT09IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBkZWJ1Zy5lbmFibGVkICYmIGRlYnVnKCdDYWNoZSBvdmVyZnVsbCBieSAlcyAoYWxsIGVudHJpZXMgYXJlIGJlaW5nIGhlbGQpJyxcbiAgICAgICAgICAgICAgICB0aGlzLl9scnUubGVuZ3RoIC0gYWxsb3dlZEVudHJ5Q291bnQpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGV2aWN0aW9uSW5kZXgtLTtcbiAgICB9XG59O1xuXG5JbWFnZUNhY2hlLnByb3RvdHlwZS5hY3F1aXJlID0gZnVuY3Rpb24gKHVybClcbntcbiAgICB0aGlzLl9oZWxkW3VybF0gPSAodGhpcy5faGVsZFt1cmxdIHx8IDApICsgMTtcbiAgICB0aGlzLl9wcm9tb3RlKHRoaXMuX3VybHNbdXJsXSk7XG59O1xuXG5JbWFnZUNhY2hlLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKHVybClcbntcbiAgICB2YXIgY291bnQgPSB0aGlzLl9oZWxkW3VybF07XG5cbiAgICBpZiAoY291bnQgPiAxKVxuICAgICAgICB0aGlzLl9oZWxkW3VybF0tLTtcbiAgICBlbHNlXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9oZWxkW3VybF07XG5cbiAgICB0aGlzLl90cnlFdmljdCgwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9pbWFnZS1jYWNoZS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZGl2YTpJbWFnZVJlcXVlc3RIYW5kbGVyJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gSW1hZ2VSZXF1ZXN0SGFuZGxlcjtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciB0aGUgcmVxdWVzdCBmb3IgYW4gaW1hZ2UgdGlsZVxuICpcbiAqIEBwYXJhbSB1cmxcbiAqIEBwYXJhbSBjYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEltYWdlUmVxdWVzdEhhbmRsZXIob3B0aW9ucylcbntcbiAgICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG9wdGlvbnMubG9hZDtcbiAgICB0aGlzLl9lcnJvckNhbGxiYWNrID0gb3B0aW9ucy5lcnJvcjtcbiAgICB0aGlzLnRpbWVvdXRUaW1lID0gb3B0aW9ucy50aW1lb3V0VGltZSB8fCAwO1xuICAgIHRoaXMuX2Fib3J0ZWQgPSB0aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xuXG4gICAgLy9Vc2UgYSB0aW1lb3V0IHRvIGFsbG93IHRoZSByZXF1ZXN0cyB0byBiZSBkZWJvdW5jZWQgKGFzIHRoZXkgYXJlIGluIHJlbmRlcmVyKVxuICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgLy8gSW5pdGlhdGUgdGhlIHJlcXVlc3RcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgdGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgICAgICB0aGlzLl9pbWFnZS5vbmxvYWQgPSB0aGlzLl9oYW5kbGVMb2FkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2ltYWdlLm9uZXJyb3IgPSB0aGlzLl9oYW5kbGVFcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9pbWFnZS5zcmMgPSBvcHRpb25zLnVybDtcblxuICAgICAgICBkZWJ1ZygnUmVxdWVzdGluZyBpbWFnZSAlcycsIG9wdGlvbnMudXJsKTtcbiAgICB9LmJpbmQodGhpcyksIHRoaXMudGltZW91dFRpbWUpO1xufVxuXG5JbWFnZVJlcXVlc3RIYW5kbGVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpXG57XG4gICAgZGVidWcoJ0Fib3J0aW5nIHJlcXVlc3QgdG8gJXMnLCB0aGlzLl91cmwpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG5cbiAgICAvLyBGSVhNRVxuICAgIC8vIFBlb3BsZSBvbiB0aGUgSW50ZXJuZXQgc2F5IHRoYXQgZG9pbmcgdGhpcyB7e3Nob3VsZC9zaG91bGQgbm90fX0gYWJvcnQgdGhlIHJlcXVlc3QuIEkgYmVsaWV2ZVxuICAgIC8vIGl0IGNvcnJlc3BvbmRzIHRvIHdoYXQgdGhlIFdIQVRXRyBIVE1MIHNwZWMgc2F5cyBzaG91bGQgaGFwcGVuIHdoZW4gdGhlIFVBXG4gICAgLy8gdXBkYXRlcyB0aGUgaW1hZ2UgZGF0YSBpZiBzZWxlY3RlZCBzb3VyY2UgaXMgbnVsbC5cbiAgICAvL1xuICAgIC8vIFNvdXJjZXM6XG4gICAgLy9cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9lbWJlZGRlZC1jb250ZW50Lmh0bWwjdGhlLWltZy1lbGVtZW50XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzkwODg4L2RvZXMtY2hhbmdpbmctdGhlLXNyYy1hdHRyaWJ1dGUtb2YtYW4taW1hZ2Utc3RvcC10aGUtaW1hZ2UtZnJvbS1kb3dubG9hZGluZ1xuICAgIGlmICh0aGlzLl9pbWFnZSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2ltYWdlLm9ubG9hZCA9IHRoaXMuX2ltYWdlLm9uZXJyb3IgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2ltYWdlLnNyYyA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlO1xufTtcblxuSW1hZ2VSZXF1ZXN0SGFuZGxlci5wcm90b3R5cGUuX2hhbmRsZUxvYWQgPSBmdW5jdGlvbiAoKVxue1xuICAgIGlmICh0aGlzLl9hYm9ydGVkKVxuICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2VSZXF1ZXN0SGFuZGxlciBpbnZva2VkIG9uIGNhbmNlbGxlZCByZXF1ZXN0IGZvciAnICsgdGhpcy5fdXJsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb21wbGV0ZSlcbiAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ltYWdlUmVxdWVzdEhhbmRsZXIgaW52b2tlZCBvbiBjb21wbGV0ZWQgcmVxdWVzdCBmb3IgJyArIHRoaXMuX3VybCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XG5cbiAgICBkZWJ1ZygnUmVjZWl2ZWQgaW1hZ2UgJXMnLCB0aGlzLl91cmwpO1xuICAgIHRoaXMuX2NhbGxiYWNrKHRoaXMuX2ltYWdlKTtcbn07XG5cbkltYWdlUmVxdWVzdEhhbmRsZXIucHJvdG90eXBlLl9oYW5kbGVFcnJvciA9IGZ1bmN0aW9uICgpXG57XG4gICAgZGVidWcoJ0ZhaWxlZCB0byBsb2FkIGltYWdlICVzJywgdGhpcy5fdXJsKTtcbiAgICB0aGlzLl9lcnJvckNhbGxiYWNrKHRoaXMuX2ltYWdlKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9pbWFnZS1yZXF1ZXN0LWhhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIGdsb2JhbCBwZXJmb3JtYW5jZSAqL1xuXG4vLyBUT0RPOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZmFsbGJhY2tcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYW5pbWF0ZTogYW5pbWF0ZSxcbiAgICBlYXNpbmc6IHtcbiAgICAgICAgbGluZWFyOiBsaW5lYXJFYXNpbmdcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhbmltYXRlKG9wdGlvbnMpXG57XG4gICAgdmFyIGR1cmF0aW9uTXMgPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIHZhciBwYXJhbWV0ZXJzID0gb3B0aW9ucy5wYXJhbWV0ZXJzO1xuICAgIHZhciBvblVwZGF0ZSA9IG9wdGlvbnMub25VcGRhdGU7XG4gICAgdmFyIG9uRW5kID0gb3B0aW9ucy5vbkVuZDtcblxuICAgIC8vIFNldHVwXG4gICAgLy8gVGltZXMgYXJlIGluIG1pbGxpc2Vjb25kcyBmcm9tIGEgYmFzaWNhbGx5IGFyYml0cmFyeSBzdGFydFxuICAgIHZhciBzdGFydCA9IG5vdygpO1xuICAgIHZhciBlbmQgPSBzdGFydCArIGR1cmF0aW9uTXM7XG5cbiAgICB2YXIgdHdlZW5GbnMgPSB7fTtcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgdmFyIHBhcmFtS2V5cyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlcnMpO1xuXG4gICAgcGFyYW1LZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSlcbiAgICB7XG4gICAgICAgIHZhciBjb25maWcgPSBwYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIHR3ZWVuRm5zW2tleV0gPSBpbnRlcnBvbGF0ZShjb25maWcuZnJvbSwgY29uZmlnLnRvLCBjb25maWcuZWFzaW5nIHx8IGxpbmVhckVhc2luZyk7XG4gICAgfSk7XG5cbiAgICAvLyBSdW4gaXQhXG4gICAgdmFyIHJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdElkICE9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlcXVlc3RJZCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQW5pbWF0aW9uQ29tcGxldGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGludGVycnVwdGVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKClcbiAgICB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbm93KCk7XG4gICAgICAgIHZhciBlbGFwc2VkID0gTWF0aC5taW4oKGN1cnJlbnQgLSBzdGFydCkgLyBkdXJhdGlvbk1zLCAxKTtcblxuICAgICAgICB1cGRhdGVWYWx1ZXMoZWxhcHNlZCk7XG4gICAgICAgIG9uVXBkYXRlKHZhbHVlcyk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPCBlbmQpXG4gICAgICAgICAgICByZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGFuZGxlQW5pbWF0aW9uQ29tcGxldGlvbih7XG4gICAgICAgICAgICAgICAgaW50ZXJydXB0ZWQ6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVWYWx1ZXMoZWxhcHNlZClcbiAgICB7XG4gICAgICAgIHBhcmFtS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhbHVlc1trZXldID0gdHdlZW5GbnNba2V5XShlbGFwc2VkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlQW5pbWF0aW9uQ29tcGxldGlvbihpbmZvKVxuICAgIHtcbiAgICAgICAgcmVxdWVzdElkID0gbnVsbDtcblxuICAgICAgICBpZiAob25FbmQpXG4gICAgICAgICAgICBvbkVuZChpbmZvKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHN0YXJ0LCBlbmQsIGVhc2luZylcbntcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsYXBzZWQpXG4gICAge1xuICAgICAgICByZXR1cm4gc3RhcnQgKyAoZW5kIC0gc3RhcnQpICogZWFzaW5nKGVsYXBzZWQpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGxpbmVhckVhc2luZyhlKVxue1xuICAgIHJldHVybiBlO1xufVxuXG52YXIgbm93O1xuXG5pZiAodHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiBwZXJmb3JtYW5jZS5ub3cpXG57XG4gICAgbm93ID0gZnVuY3Rpb24gKClcbiAgICB7XG4gICAgICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9O1xufVxuZWxzZVxue1xuICAgIG5vdyA9IGZ1bmN0aW9uICgpXG4gICAge1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgICB9O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvaW50ZXJwb2xhdGUtYW5pbWF0aW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZ2V0Qm9va0xheW91dEdyb3VwcyA9IHJlcXVpcmUoJy4vYm9vay1sYXlvdXQnKTtcbnZhciBnZXRTaW5nbGVzTGF5b3V0R3JvdXBzID0gcmVxdWlyZSgnLi9zaW5nbGVzLWxheW91dCcpO1xudmFyIGdldEdyaWRMYXlvdXRHcm91cHMgPSByZXF1aXJlKCcuL2dyaWQtbGF5b3V0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UGFnZUxheW91dHM7XG5cbi8qKiBHZXQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uaW5nIG9mIHBhZ2VzIGZvciB0aGUgY3VycmVudCB2aWV3ICovXG5mdW5jdGlvbiBnZXRQYWdlTGF5b3V0cyhzZXR0aW5ncylcbntcbiAgICBpZiAoc2V0dGluZ3MuaW5HcmlkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGdldEdyaWRMYXlvdXRHcm91cHMocGx1Y2soc2V0dGluZ3MsIFtcbiAgICAgICAgICAgICdtYW5pZmVzdCcsXG4gICAgICAgICAgICAndmlld3BvcnQnLFxuICAgICAgICAgICAgJ3BhZ2VzUGVyUm93JyxcbiAgICAgICAgICAgICdmaXhlZEhlaWdodEdyaWQnLFxuICAgICAgICAgICAgJ2ZpeGVkUGFkZGluZycsXG4gICAgICAgICAgICAnc2hvd05vblBhZ2VkUGFnZXMnXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHBsdWNrKHNldHRpbmdzLCBbJ21hbmlmZXN0JywgJ3ZlcnRpY2FsbHlPcmllbnRlZCcsICdzaG93Tm9uUGFnZWRQYWdlcyddKTtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuaW5Cb29rTGF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuIGdldEJvb2tMYXlvdXRHcm91cHMoY29uZmlnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGdldFNpbmdsZXNMYXlvdXRHcm91cHMoY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBsdWNrKG9iaiwga2V5cylcbntcbiAgICB2YXIgb3V0ID0ge307XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBvdXRba2V5XSA9IG9ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnZXRQYWdlRGltZW5zaW9ucyA9IHJlcXVpcmUoJy4vcGFnZS1kaW1lbnNpb25zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Qm9va0xheW91dEdyb3VwcztcblxuZnVuY3Rpb24gZ2V0Qm9va0xheW91dEdyb3Vwcyh2aWV3ZXJDb25maWcpXG57XG4gICAgdmFyIGdyb3VwaW5ncyA9IGdldEdyb3VwaW5ncyh2aWV3ZXJDb25maWcpO1xuXG4gICAgcmV0dXJuIGdyb3VwaW5ncy5tYXAoZnVuY3Rpb24gKGdyb3VwaW5nKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGdldEdyb3VwTGF5b3V0c0Zyb21QYWdlR3JvdXBpbmcodmlld2VyQ29uZmlnLCBncm91cGluZyk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwaW5ncyh2aWV3ZXJDb25maWcpXG57XG4gICAgdmFyIG1hbmlmZXN0ID0gdmlld2VyQ29uZmlnLm1hbmlmZXN0O1xuXG4gICAgdmFyIHBhZ2VzQnlHcm91cCA9IFtdO1xuICAgIHZhciBsZWZ0UGFnZSA9IG51bGw7XG4gICAgdmFyIG5vblBhZ2VkUGFnZXMgPSBbXTsgLy8gUGFnZXMgdG8gZGlzcGxheSBiZWxvdyB0aGUgY3VycmVudCBncm91cFxuXG4gICAgdmFyIF9hZGROb25QYWdlZFBhZ2VzID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25QYWdlZFBhZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBwYWdlc0J5R3JvdXAucHVzaChbIG5vblBhZ2VkUGFnZXNbaV0gXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9uUGFnZWRQYWdlcyA9IFtdO1xuICAgIH07XG5cbiAgICBtYW5pZmVzdC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlLCBpbmRleClcbiAgICB7XG4gICAgICAgIHZhciBwYWdlUmVjb3JkID0ge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgZGltZW5zaW9uczogZ2V0UGFnZURpbWVuc2lvbnMoaW5kZXgsIG1hbmlmZXN0KSxcbiAgICAgICAgICAgIHBhZ2VkOiAoIW1hbmlmZXN0LnBhZ2VkIHx8IHBhZ2UucGFnZWQpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gT25seSBkaXNwbGF5IG5vbi1wYWdlZCBwYWdlcyBpZiBzcGVjaWZpZWQgaW4gdGhlIHNldHRpbmdzXG4gICAgICAgIGlmICghdmlld2VyQ29uZmlnLnNob3dOb25QYWdlZFBhZ2VzICYmICFwYWdlUmVjb3JkLnBhZ2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmICghcGFnZVJlY29yZC5wYWdlZClcbiAgICAgICAge1xuICAgICAgICAgICAgbm9uUGFnZWRQYWdlcy5wdXNoKHBhZ2VSZWNvcmQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSAwIHx8IHBhZ2UuZmFjaW5nUGFnZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBwYWdlIGlzIHBsYWNlZCBvbiBpdHMgb3duXG4gICAgICAgICAgICBwYWdlc0J5R3JvdXAucHVzaChbcGFnZVJlY29yZF0pO1xuICAgICAgICAgICAgX2FkZE5vblBhZ2VkUGFnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZWZ0UGFnZSA9PT0gbnVsbClcbiAgICAgICAge1xuICAgICAgICAgICAgbGVmdFBhZ2UgPSBwYWdlUmVjb3JkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgcGFnZXNCeUdyb3VwLnB1c2goW2xlZnRQYWdlLCBwYWdlUmVjb3JkXSk7XG4gICAgICAgICAgICBsZWZ0UGFnZSA9IG51bGw7XG4gICAgICAgICAgICBfYWRkTm9uUGFnZWRQYWdlcygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBGbHVzaCBhIGZpbmFsIGxlZnQgcGFnZVxuICAgIGlmIChsZWZ0UGFnZSAhPT0gbnVsbClcbiAgICB7XG4gICAgICAgIHBhZ2VzQnlHcm91cC5wdXNoKFtsZWZ0UGFnZV0pO1xuICAgICAgICBfYWRkTm9uUGFnZWRQYWdlcygpO1xuICAgIH1cblxuICAgIHJldHVybiBwYWdlc0J5R3JvdXA7XG59XG5cbmZ1bmN0aW9uIGdldEdyb3VwTGF5b3V0c0Zyb21QYWdlR3JvdXBpbmcodmlld2VyQ29uZmlnLCBncm91cGluZylcbntcbiAgICB2YXIgdmVydGljYWxseU9yaWVudGVkID0gdmlld2VyQ29uZmlnLnZlcnRpY2FsbHlPcmllbnRlZDtcblxuICAgIGlmIChncm91cGluZy5sZW5ndGggPT09IDIpXG4gICAgICAgIHJldHVybiBnZXRGYWNpbmdQYWdlR3JvdXAoZ3JvdXBpbmdbMF0sIGdyb3VwaW5nWzFdLCB2ZXJ0aWNhbGx5T3JpZW50ZWQpO1xuXG4gICAgdmFyIHBhZ2UgPSBncm91cGluZ1swXTtcbiAgICB2YXIgcGFnZURpbXMgPSBwYWdlLmRpbWVuc2lvbnM7XG5cbiAgICAvLyBUaGUgZmlyc3QgcGFnZSBpcyBwbGFjZWQgb24gaXRzIG93biB0byB0aGUgcmlnaHQgaW4gdmVydGljYWwgb3JpZW50YXRpb24uXG4gICAgLy8gTkIgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIHRoZSBwYWdlIHdpdGggaW5kZXggMDsgaWYgdGhlIGZpcnN0IHBhZ2UgaXMgZXhjbHVkZWRcbiAgICAvLyBmcm9tIHRoZSBsYXlvdXQgdGhlbiB0aGlzIHNwZWNpYWwgY2FzZSBzaG91bGRuJ3QgYXBwbHkuXG4gICAgLy8gSWYgdGhlIHBhZ2UgaXMgdGFnZ2VkIGFzICdub24tcGFnZWQnLCBjZW50ZXIgaXQgaG9yaXpvbnRhbGx5XG4gICAgdmFyIGxlZnRPZmZzZXQ7XG4gICAgaWYgKHBhZ2UucGFnZWQpXG4gICAgICAgIGxlZnRPZmZzZXQgPSAocGFnZS5pbmRleCA9PT0gMCAmJiB2ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMud2lkdGggOiAwO1xuICAgIGVsc2VcbiAgICAgICAgbGVmdE9mZnNldCA9ICh2ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMud2lkdGggLyAyIDogMDtcblxuICAgIHZhciBzaG91bGRCZUhvcml6b250YWxseUFkanVzdGVkID1cbiAgICAgICAgdmVydGljYWxseU9yaWVudGVkICYmICF2aWV3ZXJDb25maWcubWFuaWZlc3QucGFnZXNbcGFnZS5pbmRleF0uZmFjaW5nUGFnZXM7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGxlZnQtYWxpZ24gdGhlIHBhZ2UgaW4gdmVydGljYWwgb3JpZW50YXRpb24sIHNvIHdlIGRvdWJsZVxuICAgIC8vIHRoZSBncm91cCB3aWR0aFxuICAgIHJldHVybiB7XG4gICAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgICAgIGhlaWdodDogcGFnZURpbXMuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHNob3VsZEJlSG9yaXpvbnRhbGx5QWRqdXN0ZWQgPyBwYWdlRGltcy53aWR0aCAqIDIgOiBwYWdlRGltcy53aWR0aFxuICAgICAgICB9LFxuICAgICAgICBwYWdlczogW3tcbiAgICAgICAgICAgIGluZGV4OiBwYWdlLmluZGV4LFxuICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogbGVmdE9mZnNldFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHBhZ2VEaW1zXG4gICAgICAgIH1dXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RmFjaW5nUGFnZUdyb3VwKGxlZnRQYWdlLCByaWdodFBhZ2UsIHZlcnRpY2FsbHlPcmllbnRlZClcbntcbiAgICB2YXIgbGVmdERpbXMgPSBsZWZ0UGFnZS5kaW1lbnNpb25zO1xuICAgIHZhciByaWdodERpbXMgPSByaWdodFBhZ2UuZGltZW5zaW9ucztcblxuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsZWZ0RGltcy5oZWlnaHQsIHJpZ2h0RGltcy5oZWlnaHQpO1xuXG4gICAgdmFyIHdpZHRoLCBmaXJzdExlZnRPZmZzZXQsIHNlY29uZExlZnRPZmZzZXQ7XG5cbiAgICBpZiAodmVydGljYWxseU9yaWVudGVkKVxuICAgIHtcbiAgICAgICAgdmFyIG1pZFdpZHRoID0gTWF0aC5tYXgobGVmdERpbXMud2lkdGgsIHJpZ2h0RGltcy53aWR0aCk7XG5cbiAgICAgICAgd2lkdGggPSBtaWRXaWR0aCAqIDI7XG5cbiAgICAgICAgZmlyc3RMZWZ0T2Zmc2V0ID0gbWlkV2lkdGggLSBsZWZ0RGltcy53aWR0aDtcbiAgICAgICAgc2Vjb25kTGVmdE9mZnNldCA9IG1pZFdpZHRoO1xuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgICB3aWR0aCA9IGxlZnREaW1zLndpZHRoICsgcmlnaHREaW1zLndpZHRoO1xuICAgICAgICBmaXJzdExlZnRPZmZzZXQgPSAwO1xuICAgICAgICBzZWNvbmRMZWZ0T2Zmc2V0ID0gbGVmdERpbXMud2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpbmRleDogbGVmdFBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogbGVmdERpbXMsXG4gICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmaXJzdExlZnRPZmZzZXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGluZGV4OiByaWdodFBhZ2UuaW5kZXgsXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcmlnaHREaW1zLFxuICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogc2Vjb25kTGVmdE9mZnNldFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvYm9vay1sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UGFnZURpbWVuc2lvbnMocGFnZUluZGV4LCBtYW5pZmVzdClcbntcbiAgICB2YXIgZGltcyA9IG1hbmlmZXN0LmdldE1heFBhZ2VEaW1lbnNpb25zKHBhZ2VJbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogTWF0aC5mbG9vcihkaW1zLndpZHRoKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmZsb29yKGRpbXMuaGVpZ2h0KVxuICAgIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGFnZS1sYXlvdXRzL3BhZ2UtZGltZW5zaW9ucy5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGdldFBhZ2VEaW1lbnNpb25zID0gcmVxdWlyZSgnLi9wYWdlLWRpbWVuc2lvbnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaW5nbGVzTGF5b3V0R3JvdXBzKHZpZXdlckNvbmZpZylcbntcbiAgICB2YXIgbWFuaWZlc3QgPSB2aWV3ZXJDb25maWcubWFuaWZlc3Q7XG5cbiAgICAvLyBSZW5kZXIgZWFjaCBwYWdlIGFsb25lIGluIGEgZ3JvdXBcbiAgICB2YXIgcGFnZXMgPSBbXTtcbiAgICBtYW5pZmVzdC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlLCBpbmRleClcbiAgICB7XG4gICAgICAgIGlmICghdmlld2VyQ29uZmlnLnNob3dOb25QYWdlZFBhZ2VzICYmIG1hbmlmZXN0LnBhZ2VkICYmICFwYWdlLnBhZ2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIHZhciBwYWdlRGltcyA9IGdldFBhZ2VEaW1lbnNpb25zKGluZGV4LCBtYW5pZmVzdCk7XG5cbiAgICAgICAgcGFnZXMucHVzaCh7XG4gICAgICAgICAgICBkaW1lbnNpb25zOiBwYWdlRGltcyxcbiAgICAgICAgICAgIHBhZ2VzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7dG9wOiAwLCBsZWZ0OiAwfSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZURpbXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhZ2VzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3BhZ2UtbGF5b3V0cy9zaW5nbGVzLWxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBnZXRHcmlkTGF5b3V0R3JvdXBzO1xuXG5mdW5jdGlvbiBnZXRHcmlkTGF5b3V0R3JvdXBzKHZpZXdlckNvbmZpZylcbntcbiAgICB2YXIgdmlld3BvcnRXaWR0aCA9IHZpZXdlckNvbmZpZy52aWV3cG9ydC53aWR0aDtcbiAgICB2YXIgbWFuaWZlc3QgPSB2aWV3ZXJDb25maWcubWFuaWZlc3Q7XG4gICAgdmFyIHBhZ2VzUGVyUm93ID0gdmlld2VyQ29uZmlnLnBhZ2VzUGVyUm93O1xuICAgIHZhciBmaXhlZEhlaWdodEdyaWQgPSB2aWV3ZXJDb25maWcuZml4ZWRIZWlnaHRHcmlkO1xuICAgIHZhciBmaXhlZFBhZGRpbmcgPSB2aWV3ZXJDb25maWcuZml4ZWRQYWRkaW5nO1xuICAgIHZhciBzaG93Tm9uUGFnZWRQYWdlcyA9IHZpZXdlckNvbmZpZy5zaG93Tm9uUGFnZWRQYWdlcztcblxuICAgIHZhciBob3Jpem9udGFsUGFkZGluZyA9IGZpeGVkUGFkZGluZyAqIChwYWdlc1BlclJvdyArIDEpO1xuICAgIHZhciBwYWdlV2lkdGggPSAodmlld3BvcnRXaWR0aCAtIGhvcml6b250YWxQYWRkaW5nKSAvIHBhZ2VzUGVyUm93O1xuICAgIHZhciBncmlkUGFnZVdpZHRoID0gcGFnZVdpZHRoO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByb3cgaGVpZ2h0IGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gZml4IHRoZSB3aWR0aCBvciB0aGUgaGVpZ2h0XG4gICAgdmFyIHJvd0hlaWdodCA9IChmaXhlZEhlaWdodEdyaWQpID8gZml4ZWRQYWRkaW5nICsgbWFuaWZlc3QubWluUmF0aW8gKiBwYWdlV2lkdGggOiBmaXhlZFBhZGRpbmcgKyBtYW5pZmVzdC5tYXhSYXRpbyAqIHBhZ2VXaWR0aDtcblxuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICB2YXIgY3VycmVudFBhZ2VzID0gW107XG5cbiAgICB2YXIgZ2V0R3JpZFBhZ2VEaW1lbnNpb25zID0gZnVuY3Rpb24gKHBhZ2VEYXRhKVxuICAgIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBob3Jpem9udGFsIHBsYWNlbWVudCBvZiB0aGlzIHBhZ2VcbiAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgYXQgbWF4IHpvb20gbGV2ZWwsIGFsdGhvdWdoIGFueSBsZXZlbCBzaG91bGQgYmUgZmluZVxuICAgICAgICB2YXIgcGFnZURpbWVuRGF0YSA9IHBhZ2VEYXRhLmRbcGFnZURhdGEuZC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGhlaWdodFRvV2lkdGhSYXRpbyA9IHBhZ2VEaW1lbkRhdGEuaCAvIHBhZ2VEaW1lbkRhdGEudztcblxuICAgICAgICB2YXIgcGFnZVdpZHRoLCBwYWdlSGVpZ2h0O1xuXG4gICAgICAgIGlmIChmaXhlZEhlaWdodEdyaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCA9IChyb3dIZWlnaHQgLSBmaXhlZFBhZGRpbmcpIC8gaGVpZ2h0VG9XaWR0aFJhdGlvO1xuICAgICAgICAgICAgcGFnZUhlaWdodCA9IHJvd0hlaWdodCAtIGZpeGVkUGFkZGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIHBhZ2VXaWR0aCA9IGdyaWRQYWdlV2lkdGg7XG4gICAgICAgICAgICBwYWdlSGVpZ2h0ID0gcGFnZVdpZHRoICogaGVpZ2h0VG9XaWR0aFJhdGlvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKHBhZ2VXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQocGFnZUhlaWdodClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHJvd0RpbWVuc2lvbnMgPSB7XG4gICAgICAgIGhlaWdodDogcm93SGVpZ2h0LFxuICAgICAgICB3aWR0aDogdmlld3BvcnRXaWR0aFxuICAgIH07XG5cbiAgICBtYW5pZmVzdC5wYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChwYWdlLCBwYWdlSW5kZXgpXG4gICAge1xuICAgICAgICBpZiAoIXNob3dOb25QYWdlZFBhZ2VzICYmIG1hbmlmZXN0LnBhZ2VkICYmICFwYWdlLnBhZ2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgd2lkdGgsIGhlaWdodCBhbmQgaG9yaXpvbnRhbCBwbGFjZW1lbnQgb2YgdGhpcyBwYWdlXG4gICAgICAgIHZhciBwYWdlRGltZW5zID0gZ2V0R3JpZFBhZ2VEaW1lbnNpb25zKHBhZ2UpO1xuICAgICAgICB2YXIgbGVmdE9mZnNldCA9IE1hdGguZmxvb3IoY3VycmVudFBhZ2VzLmxlbmd0aCAqIChmaXhlZFBhZGRpbmcgKyBncmlkUGFnZVdpZHRoKSArIGZpeGVkUGFkZGluZyk7XG5cbiAgICAgICAgLy8gQ2VudGVyIHRoZSBwYWdlIGlmIHRoZSBoZWlnaHQgaXMgZml4ZWQgKG90aGVyd2lzZSwgdGhlcmUgaXMgbm8gaG9yaXpvbnRhbCBwYWRkaW5nKVxuICAgICAgICBpZiAoZml4ZWRIZWlnaHRHcmlkKVxuICAgICAgICB7XG4gICAgICAgICAgICBsZWZ0T2Zmc2V0ICs9IChncmlkUGFnZVdpZHRoIC0gcGFnZURpbWVucy53aWR0aCkgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogUHJlY29tcHV0ZSBwYWdlIGRpbWVuc2lvbnMgZXZlcnl3aGVyZVxuICAgICAgICBjdXJyZW50UGFnZXMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogcGFnZUluZGV4LFxuICAgICAgICAgICAgZGltZW5zaW9uczogcGFnZURpbWVucyxcbiAgICAgICAgICAgIGdyb3VwT2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnRPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRQYWdlcy5sZW5ndGggPT09IHBhZ2VzUGVyUm93KVxuICAgICAgICB7XG4gICAgICAgICAgICBncm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9uczogcm93RGltZW5zaW9ucyxcbiAgICAgICAgICAgICAgICBwYWdlczogY3VycmVudFBhZ2VzXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3VycmVudFBhZ2VzID0gW107XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjdXJyZW50UGFnZXMubGVuZ3RoID4gMClcbiAgICB7XG4gICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHJvd0RpbWVuc2lvbnMsXG4gICAgICAgICAgICBwYWdlczogY3VycmVudFBhZ2VzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBncm91cHM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wYWdlLWxheW91dHMvZ3JpZC1sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0dGluZ3NWaWV3O1xuXG5mdW5jdGlvbiBjcmVhdGVTZXR0aW5nc1ZpZXcoc291cmNlcylcbntcbiAgICB2YXIgb2JqID0ge307XG5cbiAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSlcbiAgICB7XG4gICAgICAgIHJlZ2lzdGVyTWl4aW4ob2JqLCBzb3VyY2UpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJNaXhpbihvYmosIG1peGluKVxue1xuICAgIE9iamVjdC5rZXlzKG1peGluKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpXG4gICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWl4aW5ba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWFrZSBldmVyeXRoaW5nIHN0cmljdCBtb2RlIHNvIHRoaXMgaXNuJ3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IHNldCBzZXR0aW5ncy4nICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9zZXR0aW5ncy12aWV3LmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgZXh0ZW5kID0gcmVxdWlyZSgnanF1ZXJ5JykuZXh0ZW5kO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRpb25SdW5uZXI7XG5cbmZ1bmN0aW9uIFZhbGlkYXRpb25SdW5uZXIob3B0aW9ucylcbntcbiAgICB0aGlzLndoaXRlbGlzdGVkS2V5cyA9IG9wdGlvbnMud2hpdGVsaXN0ZWRLZXlzIHx8IFtdO1xuICAgIHRoaXMuYWRkaXRpb25hbFByb3BlcnRpZXMgPSBvcHRpb25zLmFkZGl0aW9uYWxQcm9wZXJ0aWVzIHx8IFtdO1xuICAgIHRoaXMudmFsaWRhdGlvbnMgPSBvcHRpb25zLnZhbGlkYXRpb25zO1xufVxuXG5WYWxpZGF0aW9uUnVubmVyLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIHNldHRpbmdzKVxue1xuICAgIC8vIEdldCB0aGUgdmFsaWRhdGlvbiBpbmRleFxuICAgIHZhciB2YWxpZGF0aW9uSW5kZXggPSBudWxsO1xuXG4gICAgdGhpcy52YWxpZGF0aW9ucy5zb21lKGZ1bmN0aW9uICh2YWxpZGF0aW9uLCBpbmRleClcbiAgICB7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uLmtleSAhPT0ga2V5KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhbGlkYXRpb25JbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICh2YWxpZGF0aW9uSW5kZXggPT09IG51bGwpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUnVuIHRoZSB2YWxpZGF0aW9uXG4gICAgdmFyIGR1bW15Q2hhbmdlcyA9IHt9O1xuICAgIGR1bW15Q2hhbmdlc1trZXldID0gdmFsdWU7XG4gICAgdmFyIHByb3hpZXIgPSBjcmVhdGVTZXR0aW5nc1Byb3hpZXIoc2V0dGluZ3MsIGR1bW15Q2hhbmdlcywgdGhpcyk7XG5cbiAgICByZXR1cm4gIXRoaXMuX3J1blZhbGlkYXRpb24odmFsaWRhdGlvbkluZGV4LCB2YWx1ZSwgcHJveGllcik7XG59O1xuXG5WYWxpZGF0aW9uUnVubmVyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIChzZXR0aW5ncylcbntcbiAgICB0aGlzLl92YWxpZGF0ZU9wdGlvbnMoe30sIHNldHRpbmdzKTtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLmdldFZhbGlkYXRlZE9wdGlvbnMgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdGlvbnMpXG57XG4gICAgdmFyIGNsb25lZCA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gICAgdGhpcy5fdmFsaWRhdGVPcHRpb25zKHNldHRpbmdzLCBjbG9uZWQpO1xuICAgIHJldHVybiBjbG9uZWQ7XG59O1xuXG5WYWxpZGF0aW9uUnVubmVyLnByb3RvdHlwZS5fdmFsaWRhdGVPcHRpb25zID0gZnVuY3Rpb24gKHNldHRpbmdzLCBvcHRpb25zKVxue1xuICAgIHZhciBzZXR0aW5nc1Byb3hpZXIgPSBjcmVhdGVTZXR0aW5nc1Byb3hpZXIoc2V0dGluZ3MsIG9wdGlvbnMsIHRoaXMpO1xuICAgIHRoaXMuX2FwcGx5VmFsaWRhdGlvbnMob3B0aW9ucywgc2V0dGluZ3NQcm94aWVyKTtcbn07XG5cblZhbGlkYXRpb25SdW5uZXIucHJvdG90eXBlLl9hcHBseVZhbGlkYXRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHByb3hpZXIpXG57XG4gICAgdGhpcy52YWxpZGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2YWxpZGF0aW9uLCBpbmRleClcbiAgICB7XG4gICAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh2YWxpZGF0aW9uLmtleSkpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGlucHV0ID0gb3B0aW9uc1t2YWxpZGF0aW9uLmtleV07XG4gICAgICAgIHZhciBjb3JyZWN0ZWQgPSB0aGlzLl9ydW5WYWxpZGF0aW9uKGluZGV4LCBpbnB1dCwgcHJveGllcik7XG5cbiAgICAgICAgaWYgKGNvcnJlY3RlZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFjb3JyZWN0ZWQud2FybmluZ1N1cHByZXNzZWQpXG4gICAgICAgICAgICAgICAgZW1pdFdhcm5pbmcodmFsaWRhdGlvbi5rZXksIGlucHV0LCBjb3JyZWN0ZWQudmFsdWUpO1xuXG4gICAgICAgICAgICBvcHRpb25zW3ZhbGlkYXRpb24ua2V5XSA9IGNvcnJlY3RlZC52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xufTtcblxuVmFsaWRhdGlvblJ1bm5lci5wcm90b3R5cGUuX3J1blZhbGlkYXRpb24gPSBmdW5jdGlvbiAoaW5kZXgsIGlucHV0LCBwcm94aWVyKVxue1xuICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0aW9uc1tpbmRleF07XG5cbiAgICBwcm94aWVyLmluZGV4ID0gaW5kZXg7XG5cbiAgICB2YXIgd2FybmluZ1N1cHByZXNzZWQgPSBmYWxzZTtcbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBzdXBwcmVzc1dhcm5pbmc6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHdhcm5pbmdTdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb3V0cHV0VmFsdWUgPSB2YWxpZGF0aW9uLnZhbGlkYXRlKGlucHV0LCBwcm94aWVyLnByb3h5LCBjb25maWcpO1xuXG4gICAgaWYgKG91dHB1dFZhbHVlID09PSB1bmRlZmluZWQgfHwgb3V0cHV0VmFsdWUgPT09IGlucHV0KVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBvdXRwdXRWYWx1ZSxcbiAgICAgICAgd2FybmluZ1N1cHByZXNzZWQ6IHdhcm5pbmdTdXBwcmVzc2VkXG4gICAgfTtcbn07XG5cbi8qKlxuICogVGhlIHNldHRpbmdzIHByb3h5IHdyYXBzIHRoZSBzZXR0aW5ncyBvYmplY3QgYW5kIGVuc3VyZXMgdGhhdFxuICogb25seSB2YWx1ZXMgd2hpY2ggaGF2ZSBwcmV2aW91c2x5IGJlZW4gdmFsaWRhdGVkIGFyZSBhY2Nlc3NlZCxcbiAqIHRocm93aW5nIGEgVHlwZUVycm9yIG90aGVyd2lzZS5cbiAqXG4gKiBGSVhNRSh3YWJhaW4pOiBJcyBpdCB3b3J0aCBrZWVwaW5nIHRoaXM/IFdoZW4gSSB3cm90ZSBpdCBJIGhhZFxuICogbXVsdGlwbGUgdmFsaWRhdGlvbiBzdGFnZXMgYW5kIGl0IHdhcyBhIGxvdCBoYXJkZXIgdG8ga2VlcCB0cmFja1xuICogb2YgZXZlcnl0aGluZywgc28gdGhpcyB3YXMgbW9yZSB2YWx1YWJsZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NQcm94aWVyKHNldHRpbmdzLCBvcHRpb25zLCBydW5uZXIpXG57XG4gICAgdmFyIHByb3hpZXIgPSB7XG4gICAgICAgIHByb3h5OiB7fSxcbiAgICAgICAgaW5kZXg6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIGxvb2t1cCA9IGxvb2t1cFZhbHVlLmJpbmQobnVsbCwgc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG4gICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcblxuICAgIHJ1bm5lci53aGl0ZWxpc3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAod2hpdGVsaXN0ZWQpXG4gICAge1xuICAgICAgICBwcm9wZXJ0aWVzW3doaXRlbGlzdGVkXSA9IHtcbiAgICAgICAgICAgIGdldDogbG9va3VwLmJpbmQobnVsbCwgd2hpdGVsaXN0ZWQpXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICBydW5uZXIuYWRkaXRpb25hbFByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoYWRkaXRpb25hbClcbiAgICB7XG4gICAgICAgIHByb3BlcnRpZXNbYWRkaXRpb25hbC5rZXldID0ge1xuICAgICAgICAgICAgZ2V0OiBhZGRpdGlvbmFsLmdldFxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcnVubmVyLnZhbGlkYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKHZhbGlkYXRpb24sIHZhbGlkYXRpb25JbmRleClcbiAgICB7XG4gICAgICAgIHByb3BlcnRpZXNbdmFsaWRhdGlvbi5rZXldID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uSW5kZXggPCBwcm94aWVyLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9va3VwKHZhbGlkYXRpb24ua2V5KTtcblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50S2V5ID0gcnVubmVyLnZhbGlkYXRpb25zW3Byb3hpZXIuaW5kZXhdLmtleTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWNjZXNzIHNldHRpbmcgJyArIHZhbGlkYXRpb24ua2V5ICsgJyB3aGlsZSB2YWxpZGF0aW5nICcgKyBjdXJyZW50S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHByb3hpZXIucHJveHksIHByb3BlcnRpZXMpO1xuXG4gICAgcmV0dXJuIHByb3hpZXI7XG59XG5cbmZ1bmN0aW9uIGVtaXRXYXJuaW5nKGtleSwgb3JpZ2luYWwsIGNvcnJlY3RlZClcbntcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgdmFsdWUgZm9yICcgKyBrZXkgKyAnOiAnICsgb3JpZ2luYWwgKyAnLiBVc2luZyAnICsgY29ycmVjdGVkICsgJyBpbnN0ZWFkLicpO1xufVxuXG5mdW5jdGlvbiBsb29rdXBWYWx1ZShiYXNlLCBleHRlbnNpb24sIGtleSlcbntcbiAgICBpZiAoa2V5IGluIGV4dGVuc2lvbilcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbltrZXldO1xuXG4gICAgcmV0dXJuIGJhc2Vba2V5XTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3ZhbGlkYXRpb24tcnVubmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFZpZXdwb3J0O1xuXG5mdW5jdGlvbiBWaWV3cG9ydChvdXRlciwgb3B0aW9ucylcbntcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuaW50ZXJzZWN0aW9uVG9sZXJhbmNlID0gb3B0aW9ucy5pbnRlcnNlY3Rpb25Ub2xlcmFuY2UgfHwgMDtcbiAgICB0aGlzLm1heEV4dGVudCA9IG9wdGlvbnMubWF4RXh0ZW50IHx8IDIwMDA7XG5cbiAgICB0aGlzLm91dGVyID0gb3V0ZXI7XG5cbiAgICB0aGlzLl90b3AgPSB0aGlzLl9sZWZ0ID0gdGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSB0aGlzLl9pbm5lckRpbWVuc2lvbnMgPSBudWxsO1xuXG4gICAgdGhpcy5pbnZhbGlkYXRlKCk7XG59XG5cblZpZXdwb3J0LnByb3RvdHlwZS5pbnRlcnNlY3RzUmVnaW9uID0gZnVuY3Rpb24gKHJlZ2lvbilcbntcbiAgICByZXR1cm4gdGhpcy5oYXNIb3Jpem9udGFsT3ZlcmxhcChyZWdpb24pICYmIHRoaXMuaGFzVmVydGljYWxPdmVybGFwKHJlZ2lvbik7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuaGFzVmVydGljYWxPdmVybGFwID0gZnVuY3Rpb24gKHJlZ2lvbilcbntcbiAgICB2YXIgdG9wID0gdGhpcy50b3AgLSB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcbiAgICB2YXIgYm90dG9tID0gdGhpcy5ib3R0b20gKyB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIGZhbGxzQmV0d2VlbihyZWdpb24udG9wLCB0b3AsIGJvdHRvbSkgfHxcbiAgICAgICAgZmFsbHNCZXR3ZWVuKHJlZ2lvbi5ib3R0b20sIHRvcCwgYm90dG9tKSB8fFxuICAgICAgICAocmVnaW9uLnRvcCA8PSB0b3AgJiYgcmVnaW9uLmJvdHRvbSA+PSBib3R0b20pXG4gICAgKTtcbn07XG5cblZpZXdwb3J0LnByb3RvdHlwZS5oYXNIb3Jpem9udGFsT3ZlcmxhcCA9IGZ1bmN0aW9uIChyZWdpb24pXG57XG4gICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQgLSB0aGlzLmludGVyc2VjdGlvblRvbGVyYW5jZTtcbiAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0ICsgdGhpcy5pbnRlcnNlY3Rpb25Ub2xlcmFuY2U7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICBmYWxsc0JldHdlZW4ocmVnaW9uLmxlZnQsIGxlZnQsIHJpZ2h0KSB8fFxuICAgICAgICBmYWxsc0JldHdlZW4ocmVnaW9uLnJpZ2h0LCBsZWZ0LCByaWdodCkgfHxcbiAgICAgICAgKHJlZ2lvbi5sZWZ0IDw9IGxlZnQgJiYgcmVnaW9uLnJpZ2h0ID49IHJpZ2h0KVxuICAgICk7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUU6IFNob3VsZCB0aGlzIGNoZWNrIHRoZSBpbm5lciBkaW1lbnNpb25zIGFzIHdlbGw/XG4gICAgdGhpcy5fd2lkdGggPSBjbGFtcE1heCh0aGlzLm91dGVyLmNsaWVudFdpZHRoLCB0aGlzLm1heEV4dGVudCk7XG4gICAgdGhpcy5faGVpZ2h0ID0gY2xhbXBNYXgodGhpcy5vdXRlci5jbGllbnRIZWlnaHQsIHRoaXMubWF4RXh0ZW50KTtcblxuICAgIHRoaXMuX3RvcCA9IHRoaXMub3V0ZXIuc2Nyb2xsVG9wO1xuICAgIHRoaXMuX2xlZnQgPSB0aGlzLm91dGVyLnNjcm9sbExlZnQ7XG59O1xuXG5WaWV3cG9ydC5wcm90b3R5cGUuc2V0SW5uZXJEaW1lbnNpb25zID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMpXG57XG4gICAgdGhpcy5faW5uZXJEaW1lbnNpb25zID0gZGltZW5zaW9ucztcblxuICAgIGlmIChkaW1lbnNpb25zKVxuICAgIHtcbiAgICAgICAgdGhpcy5fdG9wID0gY2xhbXAodGhpcy5fdG9wLCAwLCBkaW1lbnNpb25zLmhlaWdodCAtIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIHRoaXMuX2xlZnQgPSBjbGFtcCh0aGlzLl9sZWZ0LCAwLCBkaW1lbnNpb25zLndpZHRoIC0gdGhpcy5fd2lkdGgpO1xuICAgIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFZpZXdwb3J0LnByb3RvdHlwZSwge1xuICAgIHRvcDogZ2V0Q29vcmRpbmF0ZURlc2NyaXB0b3IoJ3RvcCcsICdoZWlnaHQnKSxcbiAgICBsZWZ0OiBnZXRDb29yZGluYXRlRGVzY3JpcHRvcignbGVmdCcsICd3aWR0aCcpLFxuXG4gICAgd2lkdGg6IGdldERpbWVuc2lvbkRlc2NyaXB0b3IoJ3dpZHRoJyksXG4gICAgaGVpZ2h0OiBnZXREaW1lbnNpb25EZXNjcmlwdG9yKCdoZWlnaHQnKSxcblxuICAgIGJvdHRvbToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90b3AgKyB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQgKyB0aGlzLl93aWR0aDtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlRGVzY3JpcHRvcihjb29yZCwgYXNzb2NpYXRlZERpbWVuc2lvbilcbntcbiAgICB2YXIgcHJpdmF0ZVByb3AgPSAnXycgKyBjb29yZDtcbiAgICB2YXIgc291cmNlID0gJ3Njcm9sbCcgKyBjb29yZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNvb3JkLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1twcml2YXRlUHJvcF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1ZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgbm9ybWFsaXplZDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2lubmVyRGltZW5zaW9ucylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF4QWxsb3dlZCA9IHRoaXMuX2lubmVyRGltZW5zaW9uc1thc3NvY2lhdGVkRGltZW5zaW9uXSAtIHRoaXNbYXNzb2NpYXRlZERpbWVuc2lvbl07XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IGNsYW1wKG5ld1ZhbHVlLCAwLCBtYXhBbGxvd2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gY2xhbXBNaW4obmV3VmFsdWUsIDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzW3ByaXZhdGVQcm9wXSA9IHRoaXMub3V0ZXJbc291cmNlXSA9IG5vcm1hbGl6ZWQ7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXREaW1lbnNpb25EZXNjcmlwdG9yKGRpbWVuKVxue1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ18nICsgZGltZW5dO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZmFsbHNCZXR3ZWVuKHBvaW50LCBzdGFydCwgZW5kKVxue1xuICAgIHJldHVybiBwb2ludCA+PSBzdGFydCAmJiBwb2ludCA8PSBlbmQ7XG59XG5cbmZ1bmN0aW9uIGNsYW1wKHZhbHVlLCBtaW4sIG1heClcbntcbiAgICByZXR1cm4gY2xhbXBNaW4oY2xhbXBNYXgodmFsdWUsIG1heCksIG1pbik7XG59XG5cbmZ1bmN0aW9uIGNsYW1wTWluKHZhbHVlLCBtaW4pXG57XG4gICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlLCBtaW4pO1xufVxuXG5mdW5jdGlvbiBjbGFtcE1heCh2YWx1ZSwgbWF4KVxue1xuICAgIHJldHVybiBNYXRoLm1pbih2YWx1ZSwgbWF4KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc291cmNlL2pzL3ZpZXdwb3J0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXG5DYW52YXMgcGx1Z2luIGZvciBkaXZhLmpzXG5BZGRzIGFuIGFkanVzdG1lbnQgaWNvbiBuZXh0IHRvIGVhY2ggaW1hZ2VcblxuKi9cblxudmFyIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xudmFyIGRpdmEgPSByZXF1aXJlKCcuLi9kaXZhJyk7XG5cbnJlcXVpcmUoJy4uL3V0aWxzL2pxdWVyeS1leHRlbnNpb25zJyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKVxuICAgIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHt9LFxuICAgICAgICAgICAgbWFwID0ge30sXG4gICAgICAgICAgICBzZXR0aW5ncyA9IHt9LFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICBzbGlkZXJzLFxuICAgICAgICAgICAgc2xpZGVyTW9kZTtcblxuICAgICAgICAvLyBTZXQgdXAgc29tZSBkZWZhdWx0IHNldHRpbmdzIChjYW4gYmUgb3ZlcnJpZGRlbiB0aGUgbm9ybWFsIHdheSlcbiAgICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICAgICAgYnJpZ2h0bmVzc01heDogMTUwLFxuICAgICAgICAgICAgYnJpZ2h0bmVzc01pbjogLTEwMCxcbiAgICAgICAgICAgIGJyaWdodG5lc3NTdGVwOiAxLFxuICAgICAgICAgICAgY29udHJhc3RNYXg6IDMsXG4gICAgICAgICAgICBjb250cmFzdE1pbjogLTEsXG4gICAgICAgICAgICBjb250cmFzdFN0ZXA6IDAuMDUsXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2VQcmVmaXg6ICdjYW52YXMtJyxcbiAgICAgICAgICAgIG1vYmlsZVdlYmtpdE1heFpvb206IDIsXG4gICAgICAgICAgICByZ2JNYXg6IDUwLFxuICAgICAgICAgICAgcmdiTWluOiAtNTAsXG4gICAgICAgICAgICB0aHJvYmJlckZhZGVTcGVlZDogMjAwLFxuICAgICAgICAgICAgdGhyb2JiZXJUaW1lb3V0OiAxMDAsXG4gICAgICAgICAgICBidXR0b25zOiBbXG4gICAgICAgICAgICAgICAgJ2NvbnRyYXN0JyxcbiAgICAgICAgICAgICAgICAnYnJpZ2h0bmVzcycsXG4gICAgICAgICAgICAgICAgJ3JvdGF0aW9uJyxcbiAgICAgICAgICAgICAgICAnem9vbSdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBDb252ZXJ0IGFuIGFuZ2xlIGZyb20gZGVncmVlcyB0byByYWRpYW5zXG4gICAgICAgIHZhciB0b1JhZGlhbnMgPSBmdW5jdGlvbiAoYW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBuZXcgY2VudGVyIG9mIHRoZSBwYWdlIGFmdGVyIHJvdGF0aW5nIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICAgICAgICB2YXIgZ2V0TmV3Q2VudGVyID0gZnVuY3Rpb24gKGN1cnJlbnRDZW50ZXIsIGFuZ2xlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgeCA9IGN1cnJlbnRDZW50ZXIueCAtIGNhbnZhcy5jZW50ZXJYO1xuICAgICAgICAgICAgLy8gVGFrZSB0aGUgbmVnYXRpdmUgYmVjYXVzZSB0aGUgcm90YXRpb24gaXMgY291bnRlcmNsb2Nrd2lzZVxuICAgICAgICAgICAgdmFyIHkgPSAtKGN1cnJlbnRDZW50ZXIueSAtIGNhbnZhcy5jZW50ZXJZKTtcblxuICAgICAgICAgICAgdmFyIHRoZXRhID0gdG9SYWRpYW5zKHNsaWRlcnMucm90YXRpb24ucHJldmlvdXMgLSBhbmdsZSk7XG4gICAgICAgICAgICB2YXIgbmV3WCA9IE1hdGguY29zKHRoZXRhKSAqIHggLSBNYXRoLnNpbih0aGV0YSkgKiB5ICsgY2FudmFzLmNlbnRlclg7XG4gICAgICAgICAgICB2YXIgbmV3WSA9IC0oTWF0aC5zaW4odGhldGEpICogeCArIE1hdGguY29zKHRoZXRhKSAqIHkpICsgY2FudmFzLmNlbnRlclk7XG5cbiAgICAgICAgICAgIHJldHVybiB7J3gnOiBuZXdYLCAneSc6IG5ld1l9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFJvdGF0ZXMgdGhlIGltYWdlIG9uIHRoZSBnaXZlbiBjYW52YXMgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gICAgICAgIHZhciByb3RhdGVDYW52YXMgPSBmdW5jdGlvbiAoYUNhbnZhcywgYW5nbGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gYUNhbnZhcy5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGFDYW52YXMuc2l6ZSAvIDI7XG4gICAgICAgICAgICB2YXIgc3RhcnRYID0gLShhQ2FudmFzLndpZHRoIC8gMik7XG4gICAgICAgICAgICB2YXIgc3RhcnRZID0gLShhQ2FudmFzLmhlaWdodCAvIDIpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzIHNvIHRoYXQgcmVtbmFudHMgb2YgdGhlIG9sZCBpbWFnZSBkb24ndCBzaG93XG4gICAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBhQ2FudmFzLnNpemUsIGFDYW52YXMuc2l6ZSk7XG5cbiAgICAgICAgICAgIC8vIERvIHRoZSByb3RhdGlvblxuICAgICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgICBjb250ZXh0LnJvdGF0ZSh0b1JhZGlhbnMoYW5nbGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBzdGFydFgsIHN0YXJ0WSwgYUNhbnZhcy53aWR0aCwgYUNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIG5ldyBwaXhlbCBkYXRhIHNvIHRoYXQgaXQgY2FuIGxhdGVyIGJlIGFkanVzdGVkIGluIGFkanVzdExldmVsc1xuICAgICAgICAgICAgYUNhbnZhcy5kYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgYUNhbnZhcy5zaXplLCBhQ2FudmFzLnNpemUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbGFyZ2UgY2FudmFzXG4gICAgICAgIHZhciBzaG91bGRBZGp1c3RMZXZlbHMgPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc2xpZGVyO1xuXG4gICAgICAgICAgICAvLyBSZXR1cm5zIHRydWUgaWYgc29tZXRoaW5nIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgICAgICAgIGZvciAoc2xpZGVyIGluIHNsaWRlcnMpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlcnNbc2xpZGVyXS5jdXJyZW50ICE9PSBzbGlkZXJzW3NsaWRlcl0ucHJldmlvdXMpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXRzIHRoZSBcInByZXZpb3VzXCIgdmFsdWUgdG8gdGhlIFwiY3VycmVudFwiIHZhbHVlIGZvciBldmVyeSBzbGlkZXJcbiAgICAgICAgdmFyIHVwZGF0ZVByZXZpb3VzTGV2ZWxzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHNsaWRlcjtcblxuICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVycylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzbGlkZXJzW3NsaWRlcl0ucHJldmlvdXMgPSBzbGlkZXJzW3NsaWRlcl0uY3VycmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHRodW1ibmFpbCBwcmV2aWV3IChjYWxsZWQgd2hlbiBhIHNsaWRlciBpcyBtb3ZlZC9yZXNldClcbiAgICAgICAgdmFyIHVwZGF0ZU1hcCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJvdGF0ZUNhbnZhcyhtYXAsIHNsaWRlcnMucm90YXRpb24uY3VycmVudCk7XG4gICAgICAgICAgICBhZGp1c3RMZXZlbHMobWFwKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGxhcmdlIGNhbnZhcyAocm90YXRpb24sIHpvb21pbmcsIHNjcm9sbGluZywgcGl4ZWwgbWFuaXB1bGF0aW9uKVxuICAgICAgICB2YXIgdXBkYXRlQ2FudmFzID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gc2xpZGVycy5yb3RhdGlvbi5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIG9sZEFuZ2xlID0gc2xpZGVycy5yb3RhdGlvbi5wcmV2aW91cztcbiAgICAgICAgICAgIHZhciB6b29tTGV2ZWwgPSBzbGlkZXJzLnpvb20uY3VycmVudDtcbiAgICAgICAgICAgIHZhciBvbGRab29tTGV2ZWwgPSBzbGlkZXJzLnpvb20ucHJldmlvdXM7XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCB0aGUgdXNlciB0byB0aGUgZGVzaXJlZCBsb2NhdGlvblxuICAgICAgICAgICAgaWYgKGFuZ2xlICE9PSBvbGRBbmdsZSB8fCB6b29tTGV2ZWwgIT09IG9sZFpvb21MZXZlbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBmaWd1cmUgb3V0IHRoZSBjdXJyZW50IGNlbnRlciBvZiB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFNjcm9sbCA9ICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdCgpO1xuICAgICAgICAgICAgICAgIHZhciB0b3BTY3JvbGwgPSAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCgpO1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gc2V0dGluZ3Mudmlld3BvcnQud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHZhciB0b3BPZmZzZXQgPSBzZXR0aW5ncy52aWV3cG9ydC5oZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBkZXRlcm1pbmUgdGhlIG5ldyBjZW50ZXIgKHRoZSBzYW1lIHBhcnQgb2YgdGhlIGltYWdlKVxuICAgICAgICAgICAgICAgIHZhciBuZXdDZW50ZXIgPSBnZXROZXdDZW50ZXIoe3g6IGxlZnRTY3JvbGwgKyBsZWZ0T2Zmc2V0LCB5OiB0b3BTY3JvbGwgKyB0b3BPZmZzZXR9LCBhbmdsZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmNvcnBvcmF0ZSB0aGUgem9vbSBjaGFuZ2UgcmF0aW8gKHdvdWxkIGJlIDEgaWYgbm8gY2hhbmdlKVxuICAgICAgICAgICAgICAgIHZhciB6b29tQ2hhbmdlID0gTWF0aC5wb3coMiwgem9vbUxldmVsIC0gb2xkWm9vbUxldmVsKTtcbiAgICAgICAgICAgICAgICB2YXIgdG9MZWZ0U2Nyb2xsID0gem9vbUNoYW5nZSAqIG5ld0NlbnRlci54IC0gbGVmdE9mZnNldDtcbiAgICAgICAgICAgICAgICB2YXIgdG9Ub3BTY3JvbGwgPSB6b29tQ2hhbmdlICogbmV3Q2VudGVyLnkgLSB0b3BPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBSb3RhdGUgdGhlIGxhcmdlIGNhbnZhc1xuICAgICAgICAgICAgICAgIHJvdGF0ZUNhbnZhcyhjYW52YXMsIGFuZ2xlKTtcblxuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0aGUgbmV3IGNlbnRlclxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdCh0b0xlZnRTY3JvbGwpO1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsVG9wKHRvVG9wU2Nyb2xsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSBjYWxsIGFkanVzdExldmVscyBhZ2FpbiBpZiB3ZSByZWFsbHkgbmVlZCB0byAoZXhwZW5zaXZlKVxuICAgICAgICAgICAgaWYgKHNob3VsZEFkanVzdExldmVscygpKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFkanVzdExldmVscyhjYW52YXMpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVByZXZpb3VzTGV2ZWxzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ29waWVzIHRoZSBjYW52YXMnIHBpeGVsIGFycmF5IGFuZCByZXR1cm5zIHRoZSBjb3B5XG4gICAgICAgIHZhciBjb3B5SW1hZ2VEYXRhID0gZnVuY3Rpb24gKGFDYW52YXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvbGRJbWFnZURhdGEgPSBhQ2FudmFzLmRhdGE7XG4gICAgICAgICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gYUNhbnZhcy5jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShvbGRJbWFnZURhdGEpO1xuICAgICAgICAgICAgdmFyIHBpeGVsQXJyYXkgPSBuZXdJbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIHZhciBpLCBsZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHBpeGVsQXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGl4ZWxBcnJheVtpXSA9IG9sZEltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3SW1hZ2VEYXRhO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIERldGVybWluZXMgd2hldGhlciBvciBub3Qgd2UgbmVlZCB0byBhZGp1c3QgdGhpcyBsZXZlbCAtIHZlcnkgc2ltcGxlXG4gICAgICAgIHZhciBzaG91bGRBZGp1c3QgPSBmdW5jdGlvbiAobW9kZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHRoaXNDaGFuZ2VkID0gc2xpZGVyc1ttb2RlXS5jdXJyZW50ICE9PSBzbGlkZXJzW21vZGVdLnByZXZpb3VzO1xuICAgICAgICAgICAgdmFyIHRoaXNOb3REZWZhdWx0ID0gc2xpZGVyc1ttb2RlXS5jdXJyZW50ICE9PSBzbGlkZXJzW21vZGVdLmluaXRpYWw7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzQ2hhbmdlZCB8fCB0aGlzTm90RGVmYXVsdDtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYWRqdXN0TGV2ZWxzID0gZnVuY3Rpb24gKGFDYW52YXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIENvcHkgdGhlIHBpeGVsIGFycmF5IHRvIGF2b2lkIGRlc3RydWN0aXZlbHkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNvcHlJbWFnZURhdGEoYUNhbnZhcyk7XG4gICAgICAgICAgICB2YXIgcGl4ZWxBcnJheSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBhbmQgY2FsY3VsYXRlIHNvbWUgc2NhbGUgZmFjdG9ycyBhbmQgb2Zmc2V0c1xuICAgICAgICAgICAgdmFyIGJyaWdodG5lc3MgPSBzbGlkZXJzLmJyaWdodG5lc3MuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBjb250cmFzdCA9IHNsaWRlcnMuY29udHJhc3QuY3VycmVudDtcblxuICAgICAgICAgICAgdmFyIGJyaWdodE11bCA9IDEgKyBNYXRoLm1pbihzZXR0aW5ncy5icmlnaHRuZXNzTWF4LCBNYXRoLm1heChzZXR0aW5ncy5icmlnaHRuZXNzTWluLCBicmlnaHRuZXNzKSkgLyBzZXR0aW5ncy5icmlnaHRuZXNzTWF4O1xuICAgICAgICAgICAgdmFyIGJyaWdodFRpbWVzQ29udHJhc3QgPSBicmlnaHRNdWwgKiBjb250cmFzdDtcbiAgICAgICAgICAgIHZhciBjb250cmFzdE9mZnNldCA9IDEyOCAtIChjb250cmFzdCAqIDEyOCk7XG5cbiAgICAgICAgICAgIHZhciByZWRPZmZzZXQgPSBzbGlkZXJzLnJlZC5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIGdyZWVuT2Zmc2V0ID0gc2xpZGVycy5ncmVlbi5jdXJyZW50O1xuICAgICAgICAgICAgdmFyIGJsdWVPZmZzZXQgPSBzbGlkZXJzLmJsdWUuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlIG5lZWQgdG8gYWRqdXN0IGNlcnRhaW4gdGhpbmdzXG4gICAgICAgICAgICB2YXIgYWRqdXN0UmVkID0gc2hvdWxkQWRqdXN0KCdyZWQnKTtcbiAgICAgICAgICAgIHZhciBhZGp1c3RHcmVlbiA9IHNob3VsZEFkanVzdCgnZ3JlZW4nKTtcbiAgICAgICAgICAgIHZhciBhZGp1c3RCbHVlID0gc2hvdWxkQWRqdXN0KCdibHVlJyk7XG5cbiAgICAgICAgICAgIHZhciBhZGp1c3RCcmlnaHRuZXNzID0gc2hvdWxkQWRqdXN0KCdicmlnaHRuZXNzJyk7XG4gICAgICAgICAgICB2YXIgYWRqdXN0Q29udHJhc3QgPSBzaG91bGRBZGp1c3QoJ2NvbnRyYXN0Jyk7XG4gICAgICAgICAgICB2YXIgYWRqdXN0T3RoZXJzID0gYWRqdXN0QnJpZ2h0bmVzcyB8fCBhZGp1c3RDb250cmFzdDtcblxuICAgICAgICAgICAgdmFyIHgsIHksIHdpZHRoLCBoZWlnaHQsIG9mZnNldCwgciwgZywgYjtcblxuICAgICAgICAgICAgZm9yICh4ID0gMCwgd2lkdGggPSBpbWFnZURhdGEud2lkdGg7IHggPCB3aWR0aDsgeCsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZvciAoeSA9IDAsIGhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7IHkgPCBoZWlnaHQ7IHkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9ICh5ICogd2lkdGggKyB4KSAqIDQ7XG5cbiAgICAgICAgICAgICAgICAgICAgciA9IHBpeGVsQXJyYXlbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICAgICAgZyA9IHBpeGVsQXJyYXlbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGIgPSBwaXhlbEFycmF5W29mZnNldCArIDJdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgZG8gc29tZXRoaW5nIGlmIHRoZSBwaXhlbCBpcyBub3QgYmxhY2sgb3JpZ2luYWxseVxuICAgICAgICAgICAgICAgICAgICBpZiAociArIGcgKyBiID4gMClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGp1c3QgaW5kaXZpZHVhbCBjb2xvdXIgY2hhbm5lbHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0UmVkICYmIHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSByZWRPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RHcmVlbiAmJiBnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgKz0gZ3JlZW5PZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZGp1c3RCbHVlICYmIGIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBibHVlT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIGFkanVzdCBicmlnaHRuZXNzIGFuZC9vciBjb250cmFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkanVzdE90aGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciA9IHIgKiBicmlnaHRUaW1lc0NvbnRyYXN0ICsgY29udHJhc3RPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZyA9IGcgKiBicmlnaHRUaW1lc0NvbnRyYXN0ICsgY29udHJhc3RPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiA9IGIgKiBicmlnaHRUaW1lc0NvbnRyYXN0ICsgY29udHJhc3RPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsQXJyYXlbb2Zmc2V0XSA9IHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaXhlbEFycmF5W29mZnNldCArIDFdID0gZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpeGVsQXJyYXlbb2Zmc2V0ICsgMl0gPSBiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhQ2FudmFzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgYUNhbnZhcy5jb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYm94IGluIHRoZSBwcmV2aWV3IHNob3dpbmcgd2hlcmUgeW91IGN1cnJlbnRseSBhcmVcbiAgICAgICAgdmFyIHVwZGF0ZVZpZXdib3ggPSBmdW5jdGlvbiAoKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHRvcCBsZWZ0IGNvcm5lciBjb29yZGluYXRlcyBiYXNlZCBvbiBvdXIgY3VycmVudCBwb3NpdGlvblxuICAgICAgICAgICAgdmFyIGNvcm5lclggPSAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQoKSAqIG1hcC5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgIHZhciBjb3JuZXJZID0gJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxUb3AoKSAqIG1hcC5zY2FsZUZhY3RvcjtcblxuICAgICAgICAgICAgLy8gU3VidHJhY3QgNCB0byBjb21wZW5zYXRlIGZvciB0aGUgYm9yZGVyc1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWluKE1hdGgucm91bmQoc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0ICogbWFwLnNjYWxlRmFjdG9yKSwgc2V0dGluZ3MubWFwU2l6ZSkgLSA0O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5taW4oTWF0aC5yb3VuZChzZXR0aW5ncy52aWV3cG9ydC53aWR0aCAqIG1hcC5zY2FsZUZhY3RvciksIHNldHRpbmdzLm1hcFNpemUpIC0gNDtcblxuICAgICAgICAgICAgJCgnI2RpdmEtbWFwLXZpZXdib3gnKS5oZWlnaHQoaGVpZ2h0KS53aWR0aCh3aWR0aCkuY3NzKHt0b3A6IGNvcm5lclksIGxlZnQ6IGNvcm5lclh9KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBEcmF3IHRoZSB0aHVtYm5haWwgcHJldmlldyBpbiB0aGUgdG9vbGJhclxuICAgICAgICB2YXIgbG9hZE1hcCA9IGZ1bmN0aW9uIChpbWFnZSlcbiAgICAgICAge1xuICAgICAgICAgICAgbWFwLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy1taW5pbWFwJyk7XG4gICAgICAgICAgICBtYXAuc2l6ZSA9IHNldHRpbmdzLm1hcFNpemU7XG4gICAgICAgICAgICBtYXAuY2FudmFzLndpZHRoID0gbWFwLnNpemU7XG4gICAgICAgICAgICBtYXAuY2FudmFzLmhlaWdodCA9IG1hcC5zaXplO1xuXG4gICAgICAgICAgICAvLyBHaXZlIGl0IGEgYmxhY2sgYmFja2dyb3VuZFxuICAgICAgICAgICAgbWFwLmNvbnRleHQgPSBtYXAuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBtYXAuY29udGV4dC5maWxsUmVjdCgwLCAwLCBtYXAuc2l6ZSwgbWFwLnNpemUpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGNvb3JkaW5hdGVzL2RpbWVuc2lvbnMgb2YgdGhlIHByZXZpZXdcbiAgICAgICAgICAgIG1hcC5zY2FsZUZhY3RvciA9IHNldHRpbmdzLm1hcFNpemUgLyBjYW52YXMuc2l6ZTtcbiAgICAgICAgICAgIG1hcC5jb3JuZXJYID0gY2FudmFzLmNvcm5lclggKiBtYXAuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBtYXAuY29ybmVyWSA9IGNhbnZhcy5jb3JuZXJZICogbWFwLnNjYWxlRmFjdG9yO1xuICAgICAgICAgICAgbWFwLndpZHRoID0gaW1hZ2Uud2lkdGggKiBtYXAuc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICBtYXAuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0ICogbWFwLnNjYWxlRmFjdG9yO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBpbWFnZSB3aXRoaW4gdGhlIG1hcCAobm8gYWRqdXN0bWVudHMpIGFuZCBzYXZlIHRoZSBwaXhlbCBhcnJheVxuICAgICAgICAgICAgbWFwLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBtYXAuY29ybmVyWCwgbWFwLmNvcm5lclksIG1hcC53aWR0aCwgbWFwLmhlaWdodCk7XG4gICAgICAgICAgICBtYXAuZGF0YSA9IG1hcC5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBzZXR0aW5ncy5tYXBTaXplLCBzZXR0aW5ncy5tYXBTaXplKTtcblxuICAgICAgICAgICAgLy8gU2hvdyB0aGUgdmlld2JveCwgbWFrZSBpdCByZWZsZWN0IHdoZXJlIHdlIGN1cnJlbnRseSBhcmVcbiAgICAgICAgICAgICQoJyNkaXZhLW1hcC12aWV3Ym94Jykuc2hvdygpO1xuICAgICAgICAgICAgdXBkYXRlVmlld2JveCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIExvYWQgdGhlIGltYWdlIHdpdGhpbiB0aGUgbGFyZ2UgYW5kIHNtYWxsIGNhbnZhc2VzXG4gICAgICAgIHZhciBsb2FkQ2FudmFzID0gZnVuY3Rpb24gKGltYWdlVVJMLCBjYWxsYmFjaylcbiAgICAgICAge1xuICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcblxuICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNpemUgb2YgdGhlIChzcXVhcmUpIGNhbnZhcyBiYXNlZCBvbiB0aGUgaHlwb3RlbmV1c2VcbiAgICAgICAgICAgICAgICBjYW52YXMuc2l6ZSA9IE1hdGguc3FydChpbWFnZS53aWR0aCAqIGltYWdlLndpZHRoICsgaW1hZ2UuaGVpZ2h0ICogaW1hZ2UuaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2l6ZSB0aGUgY2FudmFzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGNhbnZhcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMnKTtcbiAgICAgICAgICAgICAgICBjYW52YXMuY2FudmFzLndpZHRoID0gY2FudmFzLnNpemU7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNhbnZhcy5oZWlnaHQgPSBjYW52YXMuc2l6ZTtcbiAgICAgICAgICAgICAgICBjYW52YXMuY29ybmVyWCA9IChjYW52YXMuc2l6ZSAtIGltYWdlLndpZHRoKSAvIDI7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNvcm5lclkgPSAoY2FudmFzLnNpemUgLSBpbWFnZS5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jZW50ZXJYID0gY2FudmFzLnNpemUgLyAyO1xuICAgICAgICAgICAgICAgIGNhbnZhcy5jZW50ZXJZID0gY2FudmFzLnNpemUgLyAyO1xuXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgaW1hZ2UgdG8gdGhlIGxhcmdlIGNhbnZhcywgYW5kIHNhdmUgdGhlIHBpeGVsIGFycmF5XG4gICAgICAgICAgICAgICAgY2FudmFzLmNvbnRleHQgPSBjYW52YXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCBjYW52YXMuY29ybmVyWCwgY2FudmFzLmNvcm5lclksIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuZGF0YSA9IGNhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMuc2l6ZSwgY2FudmFzLnNpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzRXJyb3IgPSAnPGRpdiBpZD1cImRpdmEtZXJyb3JcIiBjbGFzcz1cImRpdmEtZXJyb3JcIj48cD48c3Ryb25nPkVycm9yPC9zdHJvbmc+PC9wPjxwPicgKyBlcnJvci5tZXNzYWdlICsgJzwvcD4nO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0Vycm9yICs9ICc8cD5Zb3UgbWF5IG5lZWQgdG8gdXBkYXRlIHlvdXIgc2VydmVyIGNvbmZpZ3VyYXRpb24gaW4gb3JkZXIgdG8gdXNlIHRoZSBpbWFnZSBtYW5pcHVsYXRpb24gdG9vbHMuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0ZvciBoZWxwLCBzZWUgdGhlIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vRERNQUwvZGl2YS5qcy93aWtpL1RoZS1BUEktYW5kLVBsdWdpbnMjYS1ub3RlLWFib3V0LScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NhbnZhcy1hbmQtY3Jvc3Mtc2l0ZS1kYXRhXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Y2FudmFzIGNyb3NzLXNpdGUgZGF0YSBkb2N1bWVudGF0aW9uPC9hPi48L3A+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgY2FudmFzRXJyb3IgKz0gJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1iYWNrZHJvcCcpLmFwcGVuZChjYW52YXNFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVUaHJvYmJlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9ubHkgbG9hZCB0aGUgbWFwIHRoZSBmaXJzdCB0aW1lICh3aGVuIHRoZXJlIGlzIG5vIGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRNYXAoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbWFwIGFuZCB0aGUgY2FudmFzIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIHVwZGF0ZU1hcCgpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhbnZhcyhjYW52YXMpO1xuXG4gICAgICAgICAgICAgICAgLy8gSGlkZSB0aGUgdGhyb2JiZXIgaWYgaXQgaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGV4aXN0cywgZXhlY3V0ZSBpdCAoZm9yIHpvb21pbmcpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChjYWxsYmFjayk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpbWFnZS5zcmMgPSBpbWFnZVVSTDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsb2FkIGV2ZW50IGZpcmVzIGZvciBjYWNoZWQgaW1hZ2VzIHRvb1xuICAgICAgICAgICAgaWYgKCBpbWFnZS5jb21wbGV0ZSB8fCBpbWFnZS5jb21wbGV0ZSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95d0FBQUFBQVFBQkFBQUNBVXdBT3c9PVwiO1xuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IGltYWdlVVJMO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGRhdGVTbGlkZXJMYWJlbCA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB0aGlzU2xpZGVyID0gc2xpZGVyc1tzbGlkZXJNb2RlXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXNTbGlkZXIuY3VycmVudDtcbiAgICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9ICh0aGlzU2xpZGVyLnRyYW5zZm9ybSkgPyB0aGlzU2xpZGVyLnRyYW5zZm9ybSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy12YWx1ZScpLmh0bWwoc3RyaW5nVmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB1cGRhdGVTbGlkZXJWYWx1ZSA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1zbGlkZXInKS52YWwoc2xpZGVyc1tzbGlkZXJNb2RlXS5jdXJyZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBVUkwgZm9yIHRoZSBpbWFnZSBhdCB0aGUgc3BlY2lmaWVkIHpvb20gbGV2ZWxcbiAgICAgICAgdmFyIGdldEltYWdlVVJMID0gZnVuY3Rpb24gKHpvb21MZXZlbClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc2V0dGluZ3Muem9vbVdpZHRoUmF0aW8gKiBNYXRoLnBvdygyLCB6b29tTGV2ZWwpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuZGl2YUluc3RhbmNlLmdldFBhZ2VJbWFnZVVSTChzZXR0aW5ncy5zZWxlY3RlZFBhZ2VJbmRleCwgeyB3aWR0aDogd2lkdGggfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHNob3dUaHJvYmJlciA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyB0aGUgdGhyb2JiZXIgaWYgaXQgd2lsbCB0YWtlIGEgbG9uZyB0aW1lXG4gICAgICAgICAgICBpZiAoc2xpZGVycy56b29tLmN1cnJlbnQgPiAwIHx8IHNldHRpbmdzLm1vYmlsZVdlYmtpdClcbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLnNlbGVjdG9yICsgJ3Rocm9iYmVyJykuYWRkQ2xhc3MoJ2NhbnZhcy10aHJvYmJlcicpLnNob3coKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIaWRlcyB0aGUgbG9hZGluZyBpbmRpY2F0b3IgaWNvblxuICAgICAgICB2YXIgaGlkZVRocm9iYmVyID0gZnVuY3Rpb24gKClcbiAgICAgICAge1xuICAgICAgICAgICAgJChzZXR0aW5ncy5zZWxlY3RvciArICd0aHJvYmJlcicpLnJlbW92ZUNsYXNzKCdjYW52YXMtdGhyb2JiZXInKS5oaWRlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSWYgYW55IG1vZGlmaWNhdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWQsIHNhdmUgdGhlbSB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgdmFyIHNhdmVTZXR0aW5ncyA9IGZ1bmN0aW9uICgpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBzbGlkZXJTZXR0aW5ncyA9IHt9O1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlS2V5ID0gc2V0dGluZ3MubG9jYWxTdG9yYWdlUHJlZml4ICsgc2V0dGluZ3MuZmlsZW5hbWU7XG4gICAgICAgICAgICB2YXIgc2xpZGVyO1xuXG4gICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJzKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChzbGlkZXJzW3NsaWRlcl0ucHJldmlvdXMgIT09IHNsaWRlcnNbc2xpZGVyXS5pbml0aWFsKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyU2V0dGluZ3Nbc2xpZGVyXSA9IHNsaWRlcnNbc2xpZGVyXS5wcmV2aW91cztcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBtb2RpZmljYXRpb25zIG5lZWQgdG8gYmUgc2F2ZWQsIHVwZGF0ZSB0aGUgY2FudmFzIHBsdWdpbiBpY29uXG4gICAgICAgICAgICBpZiAoY2hhbmdlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wbHVnaW5JY29uLmFkZENsYXNzKCduZXcnKTtcbiAgICAgICAgICAgICAgICBzdG9yZU9iamVjdChzdG9yYWdlS2V5LCBzbGlkZXJTZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luSWNvbi5yZW1vdmVDbGFzcygnbmV3Jyk7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSGFuZGxlcyB6b29taW5nIGluIHdoZW4gdGhlIHpvb20gc2xpZGVyIGlzIGNoYW5nZWQgYW5kIHRoZSBjaGFuZ2UgaXMgYXBwbGllZFxuICAgICAgICB2YXIgdXBkYXRlWm9vbSA9IGZ1bmN0aW9uIChuZXdab29tTGV2ZWwsIGNhbGxiYWNrKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZXR0aW5ncy56b29tTGV2ZWwgPSBuZXdab29tTGV2ZWw7XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIFVSTCBmb3IgdGhlIGltYWdlIGF0IHRoaXMgbmV3IHpvb20gbGV2ZWxcbiAgICAgICAgICAgIHZhciBpbWFnZVVSTCA9IGdldEltYWdlVVJMKG5ld1pvb21MZXZlbCk7XG5cbiAgICAgICAgICAgIGxvYWRDYW52YXMoaW1hZ2VVUkwsIGZ1bmN0aW9uICgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgc2NhbGUgZmFjdG9yIGFuZCB1cGRhdGUgdGhlIHZpZXdib3hcbiAgICAgICAgICAgICAgICBtYXAuc2NhbGVGYWN0b3IgPSBtYXAuc2l6ZSAvIGNhbnZhcy5zaXplO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXdib3goKTtcblxuICAgICAgICAgICAgICAgIHNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGJpbmRDYW52YXNLZXlFdmVudHMgPSBmdW5jdGlvbiAoZXZlbnQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB1cEFycm93S2V5ID0gMzgsXG4gICAgICAgICAgICAgICAgZG93bkFycm93S2V5ID0gNDAsXG4gICAgICAgICAgICAgICAgbGVmdEFycm93S2V5ID0gMzcsXG4gICAgICAgICAgICAgICAgcmlnaHRBcnJvd0tleSA9IDM5O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FzZSB1cEFycm93S2V5OlxuICAgICAgICAgICAgICAgICAgICAvLyBVcCBhcnJvdyAtIHNjcm9sbCB1cFxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCAtIHNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBkb3duQXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvd24gYXJyb3cgLSBzY3JvbGwgZG93blxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCArIHNldHRpbmdzLmFycm93U2Nyb2xsQW1vdW50KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBsZWZ0QXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZnQgYXJyb3cgLSBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpdmEtY2FudmFzLXdyYXBwZXInKS5zY3JvbGxMZWZ0IC0gc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBjYXNlIHJpZ2h0QXJyb3dLZXk6XG4gICAgICAgICAgICAgICAgICAgIC8vIFJpZ2h0IGFycm93IC0gc2Nyb2xsIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbExlZnQgKyBzZXR0aW5ncy5hcnJvd1Njcm9sbEFtb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTZXJpYWxpemUgYW4gb2JqZWN0IHRvIEpTT04gYW5kIHNhdmUgaXQgaW4gbG9jYWxTdG9yYWdlXG4gICAgICAgIHZhciBzdG9yZU9iamVjdCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTG9hZCBhbmQgZGVzZXJpYWxpemUgYSBsb2NhbFN0b3JhZ2Ugb2JqZWN0XG4gICAgICAgIHZhciBsb2FkU3RvcmVkT2JqZWN0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSAmJiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmV0dmFsID1cbiAgICAgICAge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY2FudmFzLCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gQW5kLCBkaXNhYmxlIHRoaXMgcGx1Z2luXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc1N1cHBvcnRlZCA9ICEhd2luZG93LkhUTUxDYW52YXNFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmICghY2FudmFzU3VwcG9ydGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBPdmVycmlkZSBhbGwgdGhlIGNvbmZpZ3VyYWJsZSBzZXR0aW5ncyBkZWZpbmVkIHVuZGVyIGNhbnZhc1BsdWdpblxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKHNldHRpbmdzLCBkZWZhdWx0cywgZGl2YVNldHRpbmdzLmNhbnZhc1BsdWdpbik7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kaXZhSW5zdGFuY2UgPSBkaXZhSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuaW5DYW52YXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5paXBTZXJ2ZXJVUkwgPSBkaXZhU2V0dGluZ3MuaWlwU2VydmVyVVJMO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmltYWdlRGlyID0gZGl2YVNldHRpbmdzLmltYWdlRGlyO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnNlbGVjdG9yID0gZGl2YVNldHRpbmdzLnNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1vYmlsZVdlYmtpdCA9IGRpdmFTZXR0aW5ncy5tb2JpbGVXZWJraXQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQgPSBkaXZhU2V0dGluZ3MuYXJyb3dTY3JvbGxBbW91bnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdXAgdGhlIHNldHRpbmdzIGZvciB0aGUgc2xpZGVycy9pY29uc1xuICAgICAgICAgICAgICAgIHNsaWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICdjb250cmFzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBzZXR0aW5ncy5jb250cmFzdE1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBzZXR0aW5ncy5jb250cmFzdE1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogc2V0dGluZ3MuY29udHJhc3RTdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdDaGFuZ2UgdGhlIGNvbnRyYXN0J1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnYnJpZ2h0bmVzcyc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbml0aWFsJzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdtaW4nOiBzZXR0aW5ncy5icmlnaHRuZXNzTWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHNldHRpbmdzLmJyaWdodG5lc3NNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IHNldHRpbmdzLmJyaWdodG5lc3NTdGVwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ0FkanVzdCB0aGUgYnJpZ2h0bmVzcydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3JvdGF0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogMzU5LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0ZXAnOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RyYW5zZm9ybSc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArICcmZGVnOyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RpdGxlJzogJ1JvdGF0ZSB0aGUgaW1hZ2UnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICd6b29tJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCwgbWluIGFuZCBtYXggdmFsdWVzIHVwZGF0ZWQgd2l0aGluIHNldHVwSG9va1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWF4JzogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdBZGp1c3QgdGhlIHpvb20gbGV2ZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdyZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc2V0dGluZ3MucmdiTWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHNldHRpbmdzLnJnYk1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdBZGp1c3QgdGhlIHJlZCBjaGFubmVsJ1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAnZ3JlZW4nOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5pdGlhbCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAnbWluJzogc2V0dGluZ3MucmdiTWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21heCc6IHNldHRpbmdzLnJnYk1heCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdGVwJzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0aXRsZSc6ICdBZGp1c3QgdGhlIGdyZWVuIGNoYW5uZWwnXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICdibHVlJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luaXRpYWwnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ21pbic6IHNldHRpbmdzLnJnYk1pbixcbiAgICAgICAgICAgICAgICAgICAgICAgICdtYXgnOiBzZXR0aW5ncy5yZ2JNYXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RlcCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGl0bGUnOiAnQWRqdXN0IHRoZSBibHVlIGNoYW5uZWwnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29weSB0aGUgXCJkZWZhdWx0XCIgdmFsdWUgaW50byBcInZhbHVlXCIgYW5kIFwicHJldmlvdXNcIiBmb3IgZWFjaCBzbGlkZXJcbiAgICAgICAgICAgICAgICB2YXIgcmVzZXRTbGlkZXJzID0gZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUsIHRoaXNTbGlkZXIsIHNsaWRlcjtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChzbGlkZXIgaW4gc2xpZGVycylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1NsaWRlciA9IHNsaWRlcnNbc2xpZGVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHRoaXNTbGlkZXIuaW5pdGlhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTbGlkZXIuY3VycmVudCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNTbGlkZXIucHJldmlvdXMgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmVzZXRTbGlkZXJzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIERPTSBlbGVtZW50cyBpZiB0aGV5IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICBpZiAoJCgnI2RpdmEtY2FudmFzLWJhY2tkcm9wJykubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgdG8ga2VlcCB0aGUgcGx1Z2luIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0J1dHRvbnNMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkhUTUwsIGJ1dHRvbiwgYnV0dG9uVGl0bGUsIGk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgaW4gc2V0dGluZ3MuYnV0dG9ucylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IHNldHRpbmdzLmJ1dHRvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvblRpdGxlID0gc2xpZGVyc1tidXR0b25dLnRpdGxlO1xuICAgICAgICAgICAgICAgICAgICBidXR0b25IVE1MID0gJzxkaXYgY2xhc3M9XCInICsgYnV0dG9uICsgJ1wiIHRpdGxlPVwiJyArIGJ1dHRvblRpdGxlICsgJ1wiPjwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0J1dHRvbnNMaXN0LnB1c2goYnV0dG9uSFRNTCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNCdXR0b25zID0gY2FudmFzQnV0dG9uc0xpc3Quam9pbignJyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzVG9vbHMgPSAnPGRpdiBpZD1cImRpdmEtY2FudmFzLXRvb2xzXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtdG9vbGJhclwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy1jbG9zZVwiIHRpdGxlPVwiUmV0dXJuIHRvIHRoZSBkb2N1bWVudCB2aWV3ZXJcIj48L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtbWluaW1pc2VcIiB0aXRsZT1cIk1pbmltaXNlIHRoZSB0b29sYmFyXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4gaWQ9XCJkaXZhLWNhbnZhcy1pbmZvXCI+VGVzdDwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLXRvb2x3aW5kb3dcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1tYXAtdmlld2JveFwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxjYW52YXMgaWQ9XCJkaXZhLWNhbnZhcy1taW5pbWFwXCI+PC9jYW52YXM+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPGRpdiBpZD1cImRpdmEtY2FudmFzLWJ1dHRvbnNcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNCdXR0b25zICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8ZGl2IGlkPVwiZGl2YS1jYW52YXMtcGFuZVwiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8cCBpZD1cImRpdmEtY2FudmFzLXRvb2x0aXBcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJzxzcGFuIGlkPVwiZGl2YS1jYW52YXMtbW9kZVwiPmNvbnRyYXN0PC9zcGFuPjogJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBpZD1cImRpdmEtY2FudmFzLXZhbHVlXCI+MDwvc3Bhbj4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8c3BhbiBpZD1cImRpdmEtY2FudmFzLXJlc2V0XCIgY2xhc3M9XCJsaW5rXCI+KFJlc2V0KTwvc3Bhbj4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPC9wPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cInJhbmdlXCIgaWQ9XCJkaXZhLWNhbnZhcy1zbGlkZXJcIj48L2lucHV0PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxiciAvPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhY3Rpb24tYnV0dG9uc1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI1wiIGlkPVwiZGl2YS1jYW52YXMtcmVzZXQtYWxsXCI+UmVzZXQgYWxsPC9hPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YSBocmVmPVwiI1wiIGlkPVwiZGl2YS1jYW52YXMtYXBwbHlcIj5BcHBseTwvYT4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXNXcmFwcGVyID0gJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy13cmFwcGVyXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8Y2FudmFzIGlkPVwiZGl2YS1jYW52YXNcIj48L2NhbnZhcz4nICtcbiAgICAgICAgICAgICAgICAnPC9kaXY+JztcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzU3RyaW5nID0gJzxkaXYgaWQ9XCJkaXZhLWNhbnZhcy1iYWNrZHJvcFwiPicgK1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNUb29scyArXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1dyYXBwZXIgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuXG4gICAgICAgICAgICAgICAgJCgnYm9keScpLmFwcGVuZChjYW52YXNTdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgc2l6ZSBvZiB0aGUgbWFwLCBhcyBkZWZpbmVkIGluIHRoZSBDU1NcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYXBTaXplID0gJCgnI2RpdmEtY2FudmFzLW1pbmltYXAnKS53aWR0aCgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRqdXN0IHRoZSBzbGlkZXIgd2hlbiBzb21ldGhpbmcgaXMgY2xpY2tlZCwgYW5kIG1ha2UgdGhhdCB0aGUgY3VycmVudCBtb2RlXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWJ1dHRvbnMgZGl2JykuY2xpY2soZnVuY3Rpb24gKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1idXR0b25zIC5jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2NsaWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyKCQodGhpcykuYXR0cignY2xhc3MnKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlU2xpZGVyID0gZnVuY3Rpb24gKG5ld01vZGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJNb2RlID0gbmV3TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWRlckRhdGEgPSBzbGlkZXJzW3NsaWRlck1vZGVdO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1idXR0b25zIC4nICsgc2xpZGVyTW9kZSkuYWRkQ2xhc3MoJ2NsaWNrZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtbW9kZScpLnRleHQoc2xpZGVyTW9kZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gc2xpZGVyRGF0YS5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWVTdHJpbmcgPSAoc2xpZGVyRGF0YS50cmFuc2Zvcm0pID8gc2xpZGVyRGF0YS50cmFuc2Zvcm0obmV3VmFsdWUpIDogbmV3VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaXZhLWNhbnZhcy1zbGlkZXInKTtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVyLm1pbiA9IHNsaWRlckRhdGEubWluO1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXIubWF4ID0gc2xpZGVyRGF0YS5tYXg7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci5zdGVwID0gc2xpZGVyRGF0YS5zdGVwO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtc2xpZGVyJykudmFsKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXZhbHVlJykuaHRtbChuZXdWYWx1ZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlcignY29udHJhc3QnKTtcblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc2xpZGVyXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXNsaWRlcicpLm9uKCdpbnB1dCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBzbGlkZXJzW3NsaWRlck1vZGVdLmN1cnJlbnQgPSBwYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVNYXAoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFsbCB0aGUgc2xpZGVycyB0byB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1yZXNldC1hbGwnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaWRlcjtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXJzW3NsaWRlcl0uY3VycmVudCA9IHNsaWRlcnNbc2xpZGVyXS5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyVmFsdWUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZXZpZXdcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTWFwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgY3VycmVudCBzbGlkZXIgdG8gdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtcmVzZXQnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB0aGUgc2xpZGVyXG4gICAgICAgICAgICAgICAgICAgIHNsaWRlcnNbc2xpZGVyTW9kZV0uY3VycmVudCA9IHNsaWRlcnNbc2xpZGVyTW9kZV0uaW5pdGlhbDtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyTGFiZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyVmFsdWUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByZXZpZXdcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlTWFwKCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhcmdlIGNhbnZhcyB3aGVuIHRoZSBhcHBseSBidXR0b24gaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1hcHBseScpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWRqdXN0TGV2ZWxzKCkpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dUaHJvYmJlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlcnMuem9vbS5jdXJyZW50ICE9PSBzbGlkZXJzLnpvb20ucHJldmlvdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVab29tKHNsaWRlcnMuem9vbS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2FudmFzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVUaHJvYmJlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbW9kaWZpY2F0aW9ucyB0byBsb2NhbFNldHRpbmdzIChhbHNvIGRvbmUgaW4gdXBkYXRlWm9vbSBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2V0dGluZ3MudGhyb2JiZXJUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGV4aXRpbmcgY2FudmFzIG1vZGVcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtY2xvc2UnKS5jbGljayhmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnYm9keScpLnJlbW92ZUNsYXNzKCdvdmVyZmxvdy1oaWRkZW4nKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzZXMgYW5kIGhpZGUgdGhpbmdzXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgaW1wcm92ZWQgLSBub3QgZG9uZSBwcm9wZXJseT9cbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy5zaXplLCBjYW52YXMuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcC5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBtYXAuc2l6ZSwgbWFwLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcCgwKS5zY3JvbGxMZWZ0KDApO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYmFja2Ryb3AnKS5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLW1hcC12aWV3Ym94JykuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBoaWRlVGhyb2JiZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZS1lbmFibGUgc2Nyb2xsaW5nIG9mIGRpdmEgd2hlbiBpdCBpcyBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZW5hYmxlU2Nyb2xsYWJsZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vZmYoJ2tleWRvd24nLCBiaW5kQ2FudmFzS2V5RXZlbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBldmVyeXRoaW5nXG4gICAgICAgICAgICAgICAgICAgIHJlc2V0U2xpZGVycygpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJMYWJlbCgpO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTbGlkZXJWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYnV0dG9ucyAuY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdjbGlja2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlcignY29udHJhc3QnKTtcblxuICAgICAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKFwiQ2FudmFzVmlld0RpZEhpZGVcIik7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIaWRlIHRoZSB0b29sYmFyIHdoZW4gdGhlIG1pbmltaXNlIGljb24gaXMgY2xpY2tlZFxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1taW5pbWlzZScpLmNsaWNrKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtdG9vbHdpbmRvdycpLnNsaWRlVG9nZ2xlKCdmYXN0Jyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGp1c3QgdGhlIHNpemUgb2YgdGhlIGNhbnZhcyB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyByZXNpemVkXG4gICAgICAgICAgICAgICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mudmlld3BvcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCAtIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGRpdmFTZXR0aW5ncy5zY3JvbGxiYXJXaWR0aFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFsd2F5cyB1cGRhdGUgdGhlIHNldHRpbmdzIGJ1dCBvbmx5IHJlZHJhdyBpZiBpbiBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmluQ2FudmFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld2JveCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2aWV3Ym94IHdoZW4gdGhlIGxhcmdlIGNhbnZhcyBpcyBzY3JvbGxlZFxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaW5DYW52YXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3Ym94KCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgY2xpY2tpbmcvZHJhZ2dpbmcgb2YgdGhlIHZpZXdib3ggKHNob3VsZCBzY3JvbGwgdGhlIGxhcmdlIGNhbnZhcylcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtbWluaW1hcCwgI2RpdmEtbWFwLXZpZXdib3gnKS5tb3VzZXVwKGZ1bmN0aW9uIChldmVudClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyIGNhY2hpbmcgdGhpcyBldmVudHVhbGx5IChjYW4ndCBiZSBkb25lIGluIGluaXQgdGhvdWdoKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gJCgnI2RpdmEtY2FudmFzLW1pbmltYXAnKS5vZmZzZXQoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGVkWCA9IChldmVudC5wYWdlWCAtIG9mZnNldC5sZWZ0KSAvIG1hcC5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlZFkgPSAoZXZlbnQucGFnZVkgLSBvZmZzZXQudG9wKSAvIG1hcC5zY2FsZUZhY3RvcjtcblxuICAgICAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLnNjcm9sbFRvcChzY2FsZWRZIC0gc2V0dGluZ3Mudmlld3BvcnQuaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy13cmFwcGVyJykuc2Nyb2xsTGVmdChzY2FsZWRYIC0gc2V0dGluZ3Mudmlld3BvcnQud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIEVuYWJsZSBkcmFnIHNjcm9sbFxuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcycpLm1vdXNlZG93bihmdW5jdGlvbiAoKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnZ3JhYmJpbmcnKTtcbiAgICAgICAgICAgICAgICB9KS5tb3VzZXVwKGZ1bmN0aW9uICgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdncmFiYmluZycpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdG91Y2ggZXZlbnRzXG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLXdyYXBwZXInKS5raW5ldGljKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBtb3VzZSBldmVudHNcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtd3JhcHBlcicpLmRyYWdzY3JvbGxhYmxlKHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0UHJvcGFnYXRlZEV2ZW50OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ09iamVjdERpZExvYWQnLCB0aGlzLnNldHVwSG9vaywgZGl2YVNldHRpbmdzLklEKTtcbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1ZpZXdlckRpZFRlcm1pbmF0ZScsIHRoaXMuZGVzdHJveSwgZGl2YVNldHRpbmdzLklEKTtcbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ1BhZ2VEaWRMb2FkJywgdGhpcy5vblBhZ2VMb2FkLCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnY2FudmFzJyxcblxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnVmlldyB0aGUgaW1hZ2Ugb24gYSBjYW52YXMgYW5kIGFkanVzdCB2YXJpb3VzIHNldHRpbmdzJyxcblxuICAgICAgICAgICAgc2V0dXBIb29rOiBmdW5jdGlvbihkaXZhU2V0dGluZ3MpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mudmlld3BvcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IC0gZGl2YVNldHRpbmdzLnNjcm9sbGJhcldpZHRoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGggLSBkaXZhU2V0dGluZ3Muc2Nyb2xsYmFyV2lkdGhcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbWluIGFuZCBtYXggem9vbSBsZXZlbCwgYW5kIHVwZGF0ZSB0aGUgem9vbSBzbGlkZXJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5taW5ab29tTGV2ZWwgPSBkaXZhU2V0dGluZ3MubWluWm9vbUxldmVsO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1heFpvb21MZXZlbCA9IGRpdmFTZXR0aW5ncy5tYXhab29tTGV2ZWw7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBvbiB0aGUgaVBhZCwgbGltaXQgdGhlIG1heCB6b29tIGxldmVsIHRvIDJcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCBkbyBjYW52YXMgZWxlbWVudHMgdGhhdCBhcmUgPiA1IG1lZ2FwaXhlbHMgKGlzc3VlICMxMTIpXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm1vYmlsZVdlYmtpdClcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubWF4Wm9vbUxldmVsID0gTWF0aC5taW4oc2V0dGluZ3MubWF4Wm9vbUxldmVsLCBzZXR0aW5ncy5tb2JpbGVXZWJraXRNYXhab29tKTtcblxuICAgICAgICAgICAgICAgIHNsaWRlcnMuem9vbS5taW4gPSBzZXR0aW5ncy5taW5ab29tTGV2ZWw7XG4gICAgICAgICAgICAgICAgc2xpZGVycy56b29tLm1heCA9IHNldHRpbmdzLm1heFpvb21MZXZlbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbihldmVudCwgZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UsIHNlbGVjdGVkUGFnZUluZGV4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGxvYWRDYW52YXMoKSBjYWxscyBhbGwgdGhlIG90aGVyIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gbG9hZFxuICAgICAgICAgICAgICAgIHZhciBmaWxlbmFtZSA9IGRpdmFJbnN0YW5jZS5nZXRGaWxlbmFtZXMoKVtzZWxlY3RlZFBhZ2VJbmRleF07XG5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHJhdGlvbmFsZSBmb3IgLTEgZnJvbSBXaWtpIChUTERSIGFuIG9sZCBJSVAgYnVnKVxuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IGRpdmFJbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0UGFnZURpbWVuc2lvbnMoc2VsZWN0ZWRQYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIC53aWR0aCAtIDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgem9vbUxldmVsID0gZGl2YVNldHRpbmdzLnpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICB2YXIgc2xpZGVyO1xuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muem9vbVdpZHRoUmF0aW8gPSB3aWR0aCAvIE1hdGgucG93KDIsIHpvb21MZXZlbCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucGx1Z2luSWNvbiA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tYW5pZmVzdCA9IGRpdmFTZXR0aW5ncy5tYW5pZmVzdDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zZWxlY3RlZFBhZ2VJbmRleCA9IHNlbGVjdGVkUGFnZUluZGV4O1xuXG4gICAgICAgICAgICAgICAgLy8gTGltaXQgdGhlIG1heCB6b29tIGxldmVsIGlmIHdlJ3JlIG9uIHRoZSBpUGFkXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm1vYmlsZVdlYmtpdCkge1xuICAgICAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSBNYXRoLm1pbihzZXR0aW5ncy5tYXhab29tTGV2ZWwsIHpvb21MZXZlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgICAgICAgICBzbGlkZXJzLnpvb20uaW5pdGlhbCA9IHpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICBzbGlkZXJzLnpvb20uY3VycmVudCA9IHpvb21MZXZlbDtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHNldHRpbmdzIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2UsIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgICAgICAgICB2YXIgc2xpZGVyU2V0dGluZ3MgPSBsb2FkU3RvcmVkT2JqZWN0KHNldHRpbmdzLmxvY2FsU3RvcmFnZVByZWZpeCArIHNldHRpbmdzLmZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVyU2V0dGluZ3MpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHNsaWRlciBpbiBzbGlkZXJTZXR0aW5ncylcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyc1tzbGlkZXJdLmN1cnJlbnQgPSBzbGlkZXJTZXR0aW5nc1tzbGlkZXJdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBzbGlkZXIncyB2YWx1ZSBoYXMgY2hhbmdlZCwgdXBkYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2xpZGVyID09PSBzbGlkZXJNb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNsaWRlckxhYmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2xpZGVyVmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNsaWRlciA9PT0gJ3pvb20nKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb21MZXZlbCA9IHNsaWRlclNldHRpbmdzW3NsaWRlcl07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzbGlkZXJzLnpvb20ucHJldmlvdXMgPSB6b29tTGV2ZWw7XG5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbCBpbiBib2R5LCBhbmQgc2hvdyB0aGUgY2FudmFzIGJhY2tkcm9wXG4gICAgICAgICAgICAgICAgJCgnYm9keScpLmFkZENsYXNzKCdvdmVyZmxvdy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAkKCcjZGl2YS1jYW52YXMtYmFja2Ryb3AnKS5zaG93KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIHNjcm9sbGluZyBvbiBtYWluIGRpdmEgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZGlzYWJsZVNjcm9sbGFibGUoKTtcbiAgICAgICAgICAgICAgICAvLyBFbmFibGUgY2FudmFzIHNjcm9sbGluZ1xuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLmtleWRvd24oYmluZENhbnZhc0tleUV2ZW50cyk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyB0byB0cnVlIHNvIGV2ZW50cyBjYW4gYmUgY2FwdHVyZWRcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pbkNhbnZhcyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VVUkwgPSBnZXRJbWFnZVVSTCh6b29tTGV2ZWwpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIHRoZSB0aXRsZSBvZiB0aGUgcGFnZVxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIGlzIGxlZ2FjeSBiZWhhdmlvdXIuIFNob3VsZCB0aGlzIGJlIGEgZmlsZW5hbWUvbGFiZWw/XG4gICAgICAgICAgICAgICAgJCgnI2RpdmEtY2FudmFzLWluZm8nKS50ZXh0KCdQYWdlICcgKyAoc2VsZWN0ZWRQYWdlSW5kZXggKyAxKSk7XG5cbiAgICAgICAgICAgICAgICBzaG93VGhyb2JiZXIoKTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnB1Ymxpc2goJ0NhbnZhc1ZpZXdEaWRBY3RpdmF0ZScsIFtzZWxlY3RlZFBhZ2VJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgbG9hZENhbnZhcyhpbWFnZVVSTCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblBhZ2VMb2FkOiBmdW5jdGlvbihwYWdlSW5kZXgsIGZpbGVuYW1lLCBzZWxlY3RvcilcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgZXhpc3RzIGZvciB0aGlzIHBhZ2UgaW4gbG9jYWxTdG9yYWdlLCB0aGVuIGNoYW5nZSBpY29uIGNvbG9yXG4gICAgICAgICAgICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5sb2NhbFN0b3JhZ2VQcmVmaXggKyBmaWxlbmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShzdG9yYWdlS2V5KSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICQoc2VsZWN0b3IpLmZpbmQoJy5kaXZhLWNhbnZhcy1pY29uJykuYWRkQ2xhc3MoJ25ldycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICQoJyNkaXZhLWNhbnZhcy1iYWNrZHJvcCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHRoaXMgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhbGwgb2YgdGhlIG5lY2Vzc2FyeSBob29rcyBhbmQgY2FsbGJhY2tzXG4gICAgICAgIC8vIGVtYmVkZGVkLlxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuXG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2NhbnZhcy5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbkRvd25sb2FkIHBsdWdpbiBmb3IgZGl2YS5qc1xuQWxsb3dzIHlvdSB0byBkb3dubG9hZCBpbWFnZXMgc2VydmVkIGJ5IElJUEltYWdlIG9yIElJSUYgY29tcGF0aWJsZSBpbWFnZSBzZXJ2ZXJzXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpdmFJbnN0YW5jZSA9IGRpdmFJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnZG93bmxvYWQnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnRG93bmxvYWQgaW1hZ2UgYXQgdGhlIGdpdmVuIHpvb20gbGV2ZWwnLFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50LCBkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSwgcGFnZUluZGV4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgcmF0aW9uYWxlIGZvciAtMSBmcm9tIFdpa2kgKFRMRFIgYW4gb2xkIElJUCBidWcpXG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gZGl2YUluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0UGFnZURpbWVuc2lvbnMocGFnZUluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgLndpZHRoIC0gMTtcblxuICAgICAgICAgICAgICAgIHZhciBpbWFnZSA9IHNldHRpbmdzLmRpdmFJbnN0YW5jZS5nZXRQYWdlSW1hZ2VVUkwocGFnZUluZGV4LCB7IHdpZHRoOiB3aWR0aCB9KTtcblxuICAgICAgICAgICAgICAgIHdpbmRvdy5vcGVuKGltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmV0dmFsO1xuICAgIH0pKCk7XG59KShqUXVlcnkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGx1Z2lucy9kb3dubG9hZC5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcbkhpZ2hsaWdodCBwbHVnaW4gZm9yIGRpdmEuanNcbkFsbG93cyB5b3UgdG8gaGlnaGxpZ2h0IHJlZ2lvbnMgb2YgYSBwYWdlIGltYWdlXG4qL1xuXG52YXIgalF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG52YXIgZWx0ID0gcmVxdWlyZSgnLi4vdXRpbHMvZWx0Jyk7XG52YXIgZGl2YSA9IHJlcXVpcmUoJy4uL2RpdmEnKTtcblxuKGZ1bmN0aW9uICgkKVxue1xuICAgIG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKClcbiAgICB7XG4gICAgICAgIHZhciByZXR2YWwgPVxuICAgICAgICB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbihkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0TWFuYWdlciA9IG5ldyBIaWdobGlnaHRNYW5hZ2VyKGRpdmFJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5kYXRhKCdoaWdobGlnaHRNYW5hZ2VyJywgaGlnaGxpZ2h0TWFuYWdlcik7XG5cbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEhpZ2hsaWdodDtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0IHRoZSBoaWdobGlnaHRzIG9iamVjdCBhbmQgcmVtb3ZlcyBhbGwgaGlnaGxpZ2h0cyBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZXNldEhpZ2hsaWdodHMgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0cyB0aGUgaGlnaGxpZ2h0cyBmb3IgYSBzaW5nbGUgcGFnZS5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZW1vdmVIaWdobGlnaHRzT25QYWdlID0gZnVuY3Rpb24ocGFnZUlkeClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIucmVtb3ZlSGlnaGxpZ2h0c09uUGFnZShwYWdlSWR4KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSGlnaGxpZ2h0cyByZWdpb25zIG9uIG11bHRpcGxlIHBhZ2VzLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcGFnZUlkeHMgQW4gYXJyYXkgb2YgcGFnZSBpbmRleCBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBjb2xvdXIgICAob3B0aW9uYWwpIEEgY29sb3VyIGZvciB0aGUgaGlnaGxpZ2h0aW5nLCBzcGVjaWZpZWQgaW4gUkdCQSBDU1MgZm9ybWF0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlcyA9IGZ1bmN0aW9uKHBhZ2VJZHhzLCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSBwYWdlSWR4cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqLS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UocGFnZUlkeHNbal0sIHJlZ2lvbnNbal0sIGNvbG91ciwgZGl2Q2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEhpZ2hsaWdodHMgcmVnaW9ucyBvbiBhIHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSBwYWdlSWR4ICBBIHBhZ2UgaW5kZXggbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIEBwYXJhbSByZWdpb25zICBBbiBhcnJheSBvZiByZWdpb25zLiBVc2Ugeyd3aWR0aCc6aSwgJ2hlaWdodCc6aSwgJ3VseCc6aSwgJ3VseSc6IGksICdkaXZJRCc6IHN0cn0gZm9yIGVhY2ggcmVnaW9uLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gY29sb3VyICAgKG9wdGlvbmFsKSBBIGNvbG91ciBmb3IgdGhlIGhpZ2hsaWdodGluZywgc3BlY2lmaWVkIGluIFJHQkEgQ1NTIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gZGl2Q2xhc3MgKG9wdGlvbmFsKSBBIGNsYXNzIHRvIGlkZW50aWZ5IGEgZ3JvdXAgb2YgaGlnaGxpZ2h0ZWQgcmVnaW9ucyBvbiBhIHNwZWNpZmljIHBhZ2UgYnlcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5oaWdobGlnaHRPblBhZ2UgPSBmdW5jdGlvbihwYWdlSWR4LCByZWdpb25zLCBjb2xvdXIsIGRpdkNsYXNzKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG91ciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXIgPSAncmdiYSgyNTUsIDAsIDAsIDAuMiknO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdkNsYXNzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzID0gZGl2YVNldHRpbmdzLklEICsgJ2hpZ2hsaWdodCBkaXZhLWhpZ2hsaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZDbGFzcyA9IGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQgZGl2YS1oaWdobGlnaHQgJyArIGRpdkNsYXNzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0TWFuYWdlci5hZGRIaWdobGlnaHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogcGFnZUlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lvbnM6IHJlZ2lvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvdXI6IGNvbG91cixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdkNsYXNzOiBkaXZDbGFzc1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgSnVtcHMgdG8gYSBoaWdobGlnaHQgc29tZXdoZXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGRpdklEIFRoZSBJRCBvZiB0aGUgZGl2IHRvIGp1bXAgdG8uIFRoaXMgSUQgbXVzdCBiZSBhdHRhY2hlZCB0byB0aGUgZGl2IHVzaW5nIC5oaWdobGlnaHRPblBhZ2UocykgYXMgdGhlIGhpZ2hsaWdodCBtYXkgbm90IGJlIGN1cnJlbnRseSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9IaWdobGlnaHQgPSBmdW5jdGlvbihkaXZJRClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodEJ5UmVnaW9uSWQoZGl2SUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ290b0RpdihyZXN1bHQuaGlnaGxpZ2h0LnBhZ2UsIHJlc3VsdC5yZWdpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRpdmEganVzdCB0cmllZCB0byBmaW5kIGEgaGlnaGxpZ2h0IHRoYXQgZG9lc24ndCBleGlzdC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgKiBNb3ZlcyB0aGUgZGl2YSBwYW5lIHRvIChwYWdlKSBhbmQgbWFrZXMgYSBkYXJrZXIgYm9yZGVyIG9uICh0aGlzRGl2KVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGdvdG9EaXYgPSBmdW5jdGlvbihwYWdlLCB0aGlzRGl2KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXRzIGNlbnRlciBvZiB0aGUgZGl2XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZT2ZEaXYgPSBwYXJzZUZsb2F0KHRoaXNEaXYudWx5KSArIHBhcnNlRmxvYXQodGhpc0Rpdi5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlclhPZkRpdiA9IHBhcnNlRmxvYXQodGhpc0Rpdi51bHgpICsgcGFyc2VGbG9hdCh0aGlzRGl2LndpZHRoKSAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRZID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWU9mRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRYID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWE9mRGl2KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25hdmlnYXRlcyB0byB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICBwYWdlID0gcGFyc2VJbnQocGFnZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b1BhZ2VCeUluZGV4KHBhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRPYmplY3QgPSBkaXZhSW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS52aWV3cG9ydE9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoKSArIGRlc2lyZWRZIC0gKHZpZXdwb3J0T2JqZWN0LmhlaWdodCgpIC8gMikgKyBkaXZhU2V0dGluZ3MudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExlZnQgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxMZWZ0KCkgKyBkZXNpcmVkWCAtICh2aWV3cG9ydE9iamVjdC53aWR0aCgpIC8gMikgKyBkaXZhU2V0dGluZ3MuaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2VzIHRoZSBzY3JvbGwgbG9jYXRpb24gdG8gY2VudGVyIG9uIHRoZSBkaXYgYXMgbXVjaCBhcyBpcyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoY3VycmVudFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoY3VycmVudExlZnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRIaWdobGlnaHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb246IHRoaXNEaXYsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWdlOiBwYWdlXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YS5FdmVudHMucHVibGlzaChcIlNlbGVjdGVkSGlnaGxpZ2h0Q2hhbmdlZFwiLCBbdGhpc0Rpdi5pZCwgY3VycmVudEhpZ2hsaWdodC5wYWdlXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zZWxlY3RzIHRoZSBoaWdobGlnaHRcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ3VycmVudEhpZ2hsaWdodChkaXZhSW5zdGFuY2UsIGN1cnJlbnRIaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0Rpdi5pZDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGdldERpdkNlbnRlciA9IGZ1bmN0aW9uKHRoaXNEaXYpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgcmV0dXJuIGRpdmFJbnN0YW5jZS50cmFuc2xhdGVGcm9tTWF4Wm9vbUxldmVsKHBhcnNlRmxvYXQodGhpc0Rpdi51bHkpICsgcGFyc2VGbG9hdCh0aGlzRGl2LmhlaWdodCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwocGFyc2VGbG9hdCh0aGlzRGl2LnVseCkgKyBwYXJzZUZsb2F0KHRoaXNEaXYud2lkdGgpIC8gMik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIHRoZSBuZXh0IGhpZ2hsaWdodCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBmaW5kQWRqYWNlbnRIaWdobGlnaHQgPSBmdW5jdGlvbihmb3J3YXJkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlck9mVGFyZ2V0RGl2O1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0Rm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlck9mQ3VycmVudERpdjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQYWdlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uQXJyLCBhcnJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VEaW1zO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VudGVyT2ZEaXYsIHRhcmdldERpdjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGhpc0RpdjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbXBGdW5jdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjdXJyZW50SGlnaGxpZ2h0IGRvZXMgbm90IGFscmVhZHkgZXhpc3RzLFxuICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IHByZXRlbmQgd2UncmUgc3RhcnRpbmcgYXQgdGhlIG5vcnRod2VzdCBjb3JuZXIgb2YgZGl2YS1pbm5lclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRIaWdobGlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mQ3VycmVudERpdiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGFnZSA9IGN1cnJlbnRIaWdobGlnaHQucGFnZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBjZW50ZXIgb2YgdGhlIGN1cnJlbnQgZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZkN1cnJlbnREaXYgPSBnZXREaXZDZW50ZXIoY3VycmVudEhpZ2hsaWdodC5yZWdpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiB3ZSBkbyBoYXZlIGEgY3VycmVudCBoaWdobGlnaHQsIHRyeSB0byBmaW5kIHRoZSBuZXh0IG9uZSBpbiB0aGUgc2FtZSBwYWdlXG5cbiAgICAgICAgICAgICAgICAgICAgcmVnaW9uQXJyID0gaGlnaGxpZ2h0TWFuYWdlci5nZXRIaWdobGlnaHRSZWdpb25zKGN1cnJlbnRQYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYXJySW5kZXggPSByZWdpb25BcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBwYWdlRGltcyA9IGRpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsKGN1cnJlbnRQYWdlLCBkaXZhSW5zdGFuY2UuZ2V0Wm9vbUxldmVsKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vaW5pdGlhbGl6ZSB0aGUgY2VudGVyIG9mIHRoZSBkaXYgdG8gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZCkgY2VudGVyT2ZUYXJnZXREaXYgPSAoZGl2YVNldHRpbmdzLnZlcnRpY2FsbHlPcmllbnRlZCkgPyBwYWdlRGltcy5oZWlnaHQgOiBwYWdlRGltcy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjZW50ZXJPZlRhcmdldERpdiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcEZ1bmN0aW9uID0gZnVuY3Rpb24odGhpc0MsIGN1ckMsIHRhcmdldEMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzQyA+IGN1ckMgJiYgdGhpc0MgPCB0YXJnZXRDKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wRnVuY3Rpb24gPSBmdW5jdGlvbih0aGlzQywgY3VyQywgdGFyZ2V0QylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXNDIDwgY3VyQyAmJiB0aGlzQyA+IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlKGFyckluZGV4LS0pXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNEaXYgPSByZWdpb25BcnJbYXJySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZEaXYgPSBnZXREaXZDZW50ZXIodGhpc0Rpdik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBkaXYgaXMgZmFydGhlciBhbG9uZyB0aGUgbWFpbiBheGlzIGJ1dCBjbG9zZXIgdGhhbiB0aGUgY3VycmVudCBjbG9zZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcEZ1bmN0aW9uKGNlbnRlck9mRGl2LCBjZW50ZXJPZkN1cnJlbnREaXYsIGNlbnRlck9mVGFyZ2V0RGl2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSB0YXJnZXREaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyT2ZUYXJnZXREaXYgPSBjZW50ZXJPZkRpdjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXREaXYgPSB0aGlzRGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBhIGhpZ2hsaWdodCB3YXMgZm91bmQgb24gdGhlIGN1cnJlbnQgcGFnZSB0aGF0IHdhcyBuZXh0OyB0aGlzIGNhbiBnZXQgb3ZlcndyaXR0ZW4gYnV0IHdlJ3JlIHN0aWxsIGdvb2RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpZ2hsaWdodEZvdW5kKSByZXR1cm4gZ290b0RpdihjdXJyZW50UGFnZSwgdGFyZ2V0RGl2KTtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBpdCB3YXNuJ3QgZm91bmQsIGNvbnRpbnVlIG9uLi4uXG5cbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBtaW5pbXVtIGRpdiBvbiB0aGUgbmV4dCBwYWdlIHdpdGggaGlnaGxpZ2h0cyBhbmQgbG9vcCBhcm91bmQgaWYgbmVjZXNzYXJ5XG5cbiAgICAgICAgICAgICAgICAgICAgLy9maW5kIHRoZSBuZXh0IHBhZ2UgaW4gdGhlIHBhZ2VBcnI7IHRoaXMgd2lsbCBiZSBpbiBvcmRlclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFnZUFyciA9IGhpZ2hsaWdodE1hbmFnZXIuZ2V0SGlnaGxpZ2h0ZWRQYWdlcygpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VySWR4ID0gcGFnZUFyci5pbmRleE9mKGN1cnJlbnRQYWdlLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRQYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZvcndhcmQpXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghdGFyZ2V0UGFnZSB8fCAhZGl2YUluc3RhbmNlLmlzUGFnZUluZGV4VmFsaWQgKHRhcmdldFBhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVmYXVsdCB0byBmaXJzdCBwYWdlLCBtb3ZlIHRvIG5leHQgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VySWR4ID09IHBhZ2VBcnIubGVuZ3RoIC0gMSkgdGFyZ2V0UGFnZSA9IHBhZ2VBcnJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0YXJnZXRQYWdlID0gcGFnZUFyclsrK2N1cklkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICghdGFyZ2V0UGFnZSB8fCAhZGl2YUluc3RhbmNlLmlzUGFnZUluZGV4VmFsaWQgKHRhcmdldFBhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZGVmYXVsdCB0byBsYXN0IHBhZ2UsIG1vdmUgdG8gcHJldmlvdXMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VySWR4ID09PSAwKSB0YXJnZXRQYWdlID0gcGFnZUFycltwYWdlQXJyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgdGFyZ2V0UGFnZSA9IHBhZ2VBcnJbLS1jdXJJZHhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9yZXNldCByZWdpb25BcnIgYW5kIGNlbnRlck9mVGFyZ2V0RGl2IGZvciB0aGUgbmV3IHBhZ2Ugd2UncmUgdGVzdGluZ1xuICAgICAgICAgICAgICAgICAgICByZWdpb25BcnIgPSBoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodFJlZ2lvbnModGFyZ2V0UGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIGFyckluZGV4ID0gcmVnaW9uQXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcGFnZURpbXMgPSBkaXZhSW5zdGFuY2UuZ2V0UGFnZURpbWVuc2lvbnNBdFpvb21MZXZlbCh0YXJnZXRQYWdlLCBkaXZhSW5zdGFuY2UuZ2V0TWF4Wm9vbUxldmVsKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGZvcndhcmQpIGNlbnRlck9mVGFyZ2V0RGl2ID0gKGRpdmFTZXR0aW5ncy52ZXJ0aWNhbGx5T3JpZW50ZWQpID8gcGFnZURpbXMuaGVpZ2h0IDogcGFnZURpbXMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgY2VudGVyT2ZUYXJnZXREaXYgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vZmluZCB0aGUgbWluaW11bSB0aGlzIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgaWYoZm9yd2FyZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcEZ1bmN0aW9uID0gZnVuY3Rpb24odGhpc0MsIHRhcmdldEMpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzQyA8IHRhcmdldEMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBGdW5jdGlvbiA9IGZ1bmN0aW9uKHRoaXNDLCB0YXJnZXRDKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodGhpc0MgPiB0YXJnZXRDKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZShhcnJJbmRleC0tKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRGl2ID0gcmVnaW9uQXJyW2FyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck9mRGl2ID0gZ2V0RGl2Q2VudGVyKHRoaXNEaXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBGdW5jdGlvbihjZW50ZXJPZkRpdiwgY2VudGVyT2ZUYXJnZXREaXYpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJPZlRhcmdldERpdiA9IGNlbnRlck9mRGl2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldERpdiA9IHRoaXNEaXY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvL3dlJ3ZlIGZvdW5kIGl0IHRoaXMgdGltZSwgYXMgdGhlcmUnbGwgYmUgYSByZWdpb24gaW4gdGhlIGZ1bGwgcmVnaW9uQXJyIHRvIGJlIHRoZSBtaW5pbXVtXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnb3RvRGl2KHRhcmdldFBhZ2UsIHRhcmdldERpdik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEp1bXBzIHRvIHRoZSBuZXh0IGhpZ2hsaWdodCBhbG9uZyB0aGUgcHJpbWFyeSBheGlzIG9mIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nb3RvTmV4dEhpZ2hsaWdodCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodENvdW50KCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRBZGphY2VudEhpZ2hsaWdodCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBKdW1wcyB0byB0aGUgcHJldmlvdXMgaGlnaGxpZ2h0IGFsb25nIHRoZSBwcmltYXJ5IGF4aXMgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmdvdG9QcmV2aW91c0hpZ2hsaWdodCA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRNYW5hZ2VyLmdldEhpZ2hsaWdodENvdW50KCkgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmRBZGphY2VudEhpZ2hsaWdodChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJXaWxsVGVybWluYXRlJywgdGhpcy5kZXN0cm95LCBkaXZhU2V0dGluZ3MuSUQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKGRpdmFTZXR0aW5ncylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgaGlnaGxpZ2h0TWFuYWdlciA9IGRpdmFTZXR0aW5ncy5wYXJlbnRPYmplY3QuZGF0YSgnaGlnaGxpZ2h0TWFuYWdlcicpO1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LnJlbW92ZURhdGEoJ2hpZ2hsaWdodE1hbmFnZXInKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnaGlnaGxpZ2h0JyxcbiAgICAgICAgICAgIHRpdGxlVGV4dDogJ0hpZ2hsaWdodCByZWdpb25zIG9mIHBhZ2VzJyxcblxuICAgICAgICAgICAgLy8gRXhwb3NlZCBleHBvcnRcbiAgICAgICAgICAgIEhpZ2hsaWdodE1hbmFnZXI6IEhpZ2hsaWdodE1hbmFnZXJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJldHZhbDtcbiAgICB9KSgpO1xufSkoalF1ZXJ5KTtcblxuLyoqIE1hbmFnZXMgdGhlIGFkZGl0aW9uIGFuZCByZW1vdmFsIG9mIHRoZSBwYWdlIG92ZXJsYXlzIHdoaWNoIGRpc3BsYXkgdGhlIGhpZ2hsaWdodHMgKi9cbmZ1bmN0aW9uIEhpZ2hsaWdodE1hbmFnZXIoZGl2YUluc3RhbmNlLCBnZXRDdXJyZW50SGlnaGxpZ2h0KVxue1xuICAgIHRoaXMuX2RpdmFJbnN0YW5jZSA9IGRpdmFJbnN0YW5jZTtcbiAgICB0aGlzLl9vdmVybGF5cyA9IHt9O1xuICAgIHRoaXMuX2dldEN1cnJlbnRIaWdobGlnaHQgPSBnZXRDdXJyZW50SGlnaGxpZ2h0O1xufVxuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRDb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9vdmVybGF5cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KVxuICAgIHtcbiAgICAgICAgY291bnQgKz0gdGhpcy5fb3ZlcmxheXNba2V5XS5oaWdobGlnaHQucmVnaW9ucy5sZW5ndGg7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gY291bnQ7XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5nZXRIaWdobGlnaHRSZWdpb25zID0gZnVuY3Rpb24gKHBhZ2VJbmRleClcbntcbiAgICBpZiAoIXRoaXMuX292ZXJsYXlzW3BhZ2VJbmRleF0pXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIHJldHVybiB0aGlzLl9vdmVybGF5c1twYWdlSW5kZXhdLmhpZ2hsaWdodC5yZWdpb25zO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0ZWRQYWdlcyA9IGZ1bmN0aW9uICgpXG57XG4gICAgLy8gRklYTUU6IENvbmNlcHR1YWxseSBhd2t3YXJkIHRoYXQgdGhlc2UgYXJlIHN0cmluZ3NcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb3ZlcmxheXMpO1xufTtcblxuSGlnaGxpZ2h0TWFuYWdlci5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0QnlSZWdpb25JZCA9IGZ1bmN0aW9uIChpZClcbntcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX292ZXJsYXlzKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5cy5oYXNPd25Qcm9wZXJ0eShpKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciByZWdpb25zID0gdGhpcy5fb3ZlcmxheXNbaV0uaGlnaGxpZ2h0LnJlZ2lvbnM7XG4gICAgICAgIGZvciAodmFyIGogaW4gcmVnaW9ucylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFyZWdpb25zLmhhc093blByb3BlcnR5KGopKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAocmVnaW9uc1tqXS5kaXZJRCA9PT0gaWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0OiB0aGlzLl9vdmVybGF5c1tpXS5oaWdobGlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uc1tqXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLmFkZEhpZ2hsaWdodCA9IGZ1bmN0aW9uIChoaWdobGlnaHQpXG57XG4gICAgdmFyIGV4aXN0aW5nT3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2hpZ2hsaWdodC5wYWdlXTtcblxuICAgIGlmIChleGlzdGluZ092ZXJsYXkpXG4gICAgICAgIHRoaXMuX2RpdmFJbnN0YW5jZS5fX3JlbW92ZVBhZ2VPdmVybGF5KGV4aXN0aW5nT3ZlcmxheSk7XG5cbiAgICB2YXIgb3ZlcmxheSA9IG5ldyBIaWdobGlnaHRQYWdlT3ZlcmxheShoaWdobGlnaHQsIHRoaXMuX2RpdmFJbnN0YW5jZSwgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCk7XG4gICAgdGhpcy5fb3ZlcmxheXNbaGlnaGxpZ2h0LnBhZ2VdID0gb3ZlcmxheTtcbiAgICB0aGlzLl9kaXZhSW5zdGFuY2UuX19hZGRQYWdlT3ZlcmxheShvdmVybGF5KTtcbn07XG5cbkhpZ2hsaWdodE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUhpZ2hsaWdodHNPblBhZ2UgPSBmdW5jdGlvbiAocGFnZUluZGV4KVxue1xuICAgIGlmICghdGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdGhpcy5fZGl2YUluc3RhbmNlLl9fcmVtb3ZlUGFnZU92ZXJsYXkodGhpcy5fb3ZlcmxheXNbcGFnZUluZGV4XSk7XG4gICAgZGVsZXRlIHRoaXMuX292ZXJsYXlzW3BhZ2VJbmRleF07XG59O1xuXG5IaWdobGlnaHRNYW5hZ2VyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpXG57XG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9vdmVybGF5cylcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheXMuaGFzT3duUHJvcGVydHkoaSkpXG4gICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICB0aGlzLl9kaXZhSW5zdGFuY2UuX19yZW1vdmVQYWdlT3ZlcmxheSh0aGlzLl9vdmVybGF5c1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fb3ZlcmxheXMgPSB7fTtcbn07XG5cbi8qKlxuIFdoZW4gYSBuZXcgcGFnZSBpcyBsb2FkZWQsIHRoaXMgb3ZlcmxheSB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuIHBhZ2UgaW5kZXggZm9yIHRoZSBwYWdlLiBJdCBsb29rcyBhdCB0aGUgJ2hpZ2hsaWdodHMnIGRhdGEgb2JqZWN0XG4gc2V0IG9uIHRoZSBkaXZhIHBhcmVudCBlbGVtZW50LCBhbmQgZGV0ZXJtaW5lcyB3aGV0aGVyXG4gaGlnaGxpZ2h0cyBleGlzdCBmb3IgdGhhdCBwYWdlLlxuXG4gSWYgc28sIHRoZSBvdmVybGF5IHdpbGwgY3JlYXRlIGFuZCByZW5kZXIgZWxlbWVudHMgZm9yIGV2ZXJ5XG4gaGlnaGxpZ2h0ZWQgYm94LlxuXG4gQHBhcmFtIGhpZ2hsaWdodFxuIEBwYXJhbSBkaXZhSW5zdGFuY2VcbiBAcGFyYW0gZ2V0Q3VycmVudEhpZ2hsaWdodCAob3B0aW9uYWwpXG4gKi9cbmZ1bmN0aW9uIEhpZ2hsaWdodFBhZ2VPdmVybGF5KGhpZ2hsaWdodCwgZGl2YUluc3RhbmNlLCBnZXRDdXJyZW50SGlnaGxpZ2h0KVxue1xuICAgIHRoaXMucGFnZSA9IGhpZ2hsaWdodC5wYWdlO1xuICAgIHRoaXMuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMgPSBbXTtcbiAgICB0aGlzLl9kaXZhSW5zdGFuY2UgPSBkaXZhSW5zdGFuY2U7XG4gICAgdGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodCA9IGdldEN1cnJlbnRIaWdobGlnaHQ7XG59XG5cbkhpZ2hsaWdodFBhZ2VPdmVybGF5LnByb3RvdHlwZS5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGRpdmFTZXR0aW5ncyA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpO1xuXG4gICAgdmFyIGhpZ2hsaWdodCA9IHRoaXMuaGlnaGxpZ2h0O1xuICAgIHZhciByZWdpb25zID0gaGlnaGxpZ2h0LnJlZ2lvbnM7XG4gICAgdmFyIGNvbG91ciA9IGhpZ2hsaWdodC5jb2xvdXI7XG4gICAgdmFyIGRpdkNsYXNzID0gaGlnaGxpZ2h0LmRpdkNsYXNzO1xuXG4gICAgdmFyIGogPSByZWdpb25zLmxlbmd0aDtcbiAgICB3aGlsZSAoai0tKVxuICAgIHtcbiAgICAgICAgdmFyIHJlZ2lvbiA9IHJlZ2lvbnNbal07XG5cbiAgICAgICAgLy8gRklYTUU6IFVzZSBDU1MgY2xhc3MgaW5zdGVhZCBvZiBpbmxpbmUgc3R5bGVcbiAgICAgICAgdmFyIGJveCA9IGVsdCgnZGl2Jywge1xuICAgICAgICAgICAgY2xhc3M6IGRpdkNsYXNzLFxuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvdXIsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNTU1XCIsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmVnaW9uLmRpdklEICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaGlnaGxpZ2h0LWlkJywgcmVnaW9uLmRpdklEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZWQgYnkgSUlJRkhpZ2hsaWdodFxuICAgICAgICBpZiAocmVnaW9uLm5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJywgcmVnaW9uLm5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGJveCxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdGhpcy5faGlnaGxpZ2h0UmVnaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChoaWdobGlnaHQpXG4gICAge1xuICAgICAgICBmcmFnLmFwcGVuZENoaWxkKGhpZ2hsaWdodC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIGRpdmFTZXR0aW5ncy5pbm5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoZnJhZyk7XG5cbiAgICBpZiAodGhpcy5fZ2V0Q3VycmVudEhpZ2hsaWdodClcbiAgICAgICAgdXBkYXRlQ3VycmVudEhpZ2hsaWdodCh0aGlzLl9kaXZhSW5zdGFuY2UsIHRoaXMuX2dldEN1cnJlbnRIaWdobGlnaHQoKSk7XG5cbiAgICBkaXZhLkV2ZW50cy5wdWJsaXNoKFwiSGlnaGxpZ2h0Q29tcGxldGVkXCIsIFt0aGlzLnBhZ2UsIHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRGaWxlbmFtZXMoKVt0aGlzLnBhZ2VdXSk7XG59O1xuXG5IaWdobGlnaHRQYWdlT3ZlcmxheS5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uICgpXG57XG4gICAgdmFyIGlubmVyRWxlbWVudCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRTZXR0aW5ncygpLmlubmVyRWxlbWVudDtcblxuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaGlnaGxpZ2h0KVxuICAgIHtcbiAgICAgICAgaW5uZXJFbGVtZW50LnJlbW92ZUNoaWxkKGhpZ2hsaWdodC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2hpZ2hsaWdodFJlZ2lvbnMgPSBbXTtcbn07XG5cbi8vIEZJWE1FOiBVcGRhdGluZyBhIGJveCBwZXIgaGlnaGxpZ2h0IHJlZ2lvbiBtaWdodCBiZSB0b28gZXhwZW5zaXZlXG4vLyBNYXliZSBzdGljayBhbGwgdGhlIGVsZW1lbnRzIGluIGEgY29udGFpbmVyIGFuZCB0aGVuIHNjYWxlIGl0IHVzaW5nIENTUyB0cmFuc2Zvcm1zP1xuSGlnaGxpZ2h0UGFnZU92ZXJsYXkucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKVxue1xuICAgIHZhciBtYXhab29tID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldE1heFpvb21MZXZlbCgpO1xuXG4gICAgdmFyIG1heFpvb21XaWR0aCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9uc0F0Wm9vbUxldmVsKHRoaXMucGFnZSwgbWF4Wm9vbSkud2lkdGg7XG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IHRoaXMuX2RpdmFJbnN0YW5jZS5nZXRQYWdlRGltZW5zaW9ucyh0aGlzLnBhZ2UpLndpZHRoO1xuICAgIHZhciB6b29tRGlmZmVyZW5jZSA9IE1hdGgubG9nKG1heFpvb21XaWR0aCAvIGN1cnJlbnRXaWR0aCkgLyBNYXRoLmxvZygyKTtcblxuICAgIHZhciBwYWdlT2Zmc2V0ID0gdGhpcy5fZGl2YUluc3RhbmNlLmdldFBhZ2VPZmZzZXQodGhpcy5wYWdlLCB7XG4gICAgICAgIGV4Y2x1ZGVQYWRkaW5nOiB0cnVlLFxuICAgICAgICBpbmNvcnBvcmF0ZVZpZXdwb3J0OiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLl9oaWdobGlnaHRSZWdpb25zLmZvckVhY2goZnVuY3Rpb24gKGhpZ2hsaWdodClcbiAgICB7XG4gICAgICAgIHZhciByZWdpb24gPSBoaWdobGlnaHQucmVnaW9uO1xuXG4gICAgICAgIGVsdC5zZXRBdHRyaWJ1dGVzKGhpZ2hsaWdodC5lbGVtZW50LCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLndpZHRoLCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCIsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLmhlaWdodCwgem9vbURpZmZlcmVuY2UpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIHRvcDogcGFnZU9mZnNldC50b3AgKyBpbmNvcnBvcmF0ZVpvb20ocmVnaW9uLnVseSwgem9vbURpZmZlcmVuY2UpICsgXCJweFwiLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBhZ2VPZmZzZXQubGVmdCArIGluY29ycG9yYXRlWm9vbShyZWdpb24udWx4LCB6b29tRGlmZmVyZW5jZSkgKyBcInB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBpbmNvcnBvcmF0ZVpvb20ocG9zaXRpb24sIHpvb21EaWZmZXJlbmNlKVxue1xuICAgIHJldHVybiBwb3NpdGlvbiAvIE1hdGgucG93KDIsIHpvb21EaWZmZXJlbmNlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ3VycmVudEhpZ2hsaWdodChkaXZhSW5zdGFuY2UsIGN1cnJlbnRIaWdobGlnaHQpXG57XG4gICAgdmFyIGNsYXNzU3RyaW5nID0gZGl2YUluc3RhbmNlLmdldEluc3RhbmNlSWQoKSArIFwic2VsZWN0ZWQtaGlnaGxpZ2h0XCI7XG4gICAgdmFyIGNsYXNzRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xhc3NTdHJpbmcpO1xuICAgIHZhciBpZHg7XG4gICAgdmFyIGJveDtcbiAgICB2YXIgYm94ZXM7XG5cbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IGNsYXNzRWxlbS5sZW5ndGg7IGlkeCsrKVxuICAgIHtcbiAgICAgICAgYm94ID0gY2xhc3NFbGVtW2lkeF07XG4gICAgICAgIGlmIChib3guaWQgIT09IGN1cnJlbnRIaWdobGlnaHQuaWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveC5jbGFzc05hbWUgPSBib3guY2xhc3NOYW1lLnJlcGxhY2UoJyAnK2NsYXNzU3RyaW5nLCAnJyk7XG4gICAgICAgICAgICBib3guc3R5bGUuYm9yZGVyID0gXCIxcHggc29saWQgIzU1NVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpdmFJbnN0YW5jZS5pc1BhZ2VJblZpZXdwb3J0KGN1cnJlbnRIaWdobGlnaHQucGFnZSkpXG4gICAge1xuICAgICAgICBib3hlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2RhdGEtaGlnaGxpZ2h0LWlkPVwiICsgY3VycmVudEhpZ2hsaWdodC5pZCArIFwiXVwiKTtcbiAgICAgICAgZm9yKGlkeCA9IDA7IGlkeCA8IGJveGVzLmxlbmd0aDsgaWR4KyspXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJveCA9IGJveGVzW2lkeF07XG4gICAgICAgICAgICBib3guY2xhc3NOYW1lID0gYm94LmNsYXNzTmFtZSArIFwiIFwiICsgY2xhc3NTdHJpbmc7XG4gICAgICAgICAgICBib3guc3R5bGUuYm9yZGVyID0gXCIycHggc29saWQgIzAwMFwiO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UvanMvcGx1Z2lucy9oaWdobGlnaHQuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXG5JSUlGIEhpZ2hsaWdodCBwbHVnaW4gZm9yIGRpdmEuanNcbkFsbG93cyB5b3UgdG8gaGlnaGxpZ2h0IHJlZ2lvbnMgb2YgYSBwYWdlIGltYWdlIGJhc2VkIG9mZiBvZiBhbm5vdGF0aW9ucyBpbiBhIElJSUYgTWFuaWZlc3RcbiovXG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi4vZGl2YScpO1xudmFyIEhpZ2hsaWdodE1hbmFnZXIgPSByZXF1aXJlKCcuL2hpZ2hsaWdodCcpLkhpZ2hsaWdodE1hbmFnZXI7XG5cbihmdW5jdGlvbiAoJClcbntcbiAgICBtb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpXG4gICAge1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHRNYW5hZ2VyID0gbmV3IEhpZ2hsaWdodE1hbmFnZXIoZGl2YUluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LmRhdGEoJ2hpZ2hsaWdodE1hbmFnZXInLCBoaWdobGlnaHRNYW5hZ2VyKTtcblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpZ2hsaWdodGVkUGFnZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0IHRoZSBoaWdobGlnaHRzIG9iamVjdCBhbmQgcmVtb3ZlcyBhbGwgaGlnaGxpZ2h0cyBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZXNldEhpZ2hsaWdodHMgPSBmdW5jdGlvbigpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHRNYW5hZ2VyLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIFJlc2V0cyB0aGUgaGlnaGxpZ2h0cyBmb3IgYSBzaW5nbGUgcGFnZS5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5yZW1vdmVIaWdobGlnaHRzT25QYWdlID0gZnVuY3Rpb24ocGFnZUlkeClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIucmVtb3ZlSGlnaGxpZ2h0c09uUGFnZShwYWdlSWR4KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZGVIaWdobGlnaHRzID0gZnVuY3Rpb24oKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuaGlnaGxpZ2h0c1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3MuaW5uZXJFbGVtZW50KS5hZGRDbGFzcygnYW5ub3RhdGlvbnMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5zaG93SGlnaGxpZ2h0cyA9IGZ1bmN0aW9uKClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhpZ2hsaWdodHNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3MuaW5uZXJFbGVtZW50KS5yZW1vdmVDbGFzcygnYW5ub3RhdGlvbnMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIEhpZ2hsaWdodHMgcmVnaW9ucyBvbiBtdWx0aXBsZSBwYWdlcy5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIHBhZ2VJZHhzIEFuIGFycmF5IG9mIHBhZ2UgaW5kZXggbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcmVnaW9ucyAgQW4gYXJyYXkgb2YgcmVnaW9uc1xuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gY29sb3VyICAgKG9wdGlvbmFsKSBBIGNvbG91ciBmb3IgdGhlIGhpZ2hsaWdodGluZywgc3BlY2lmaWVkIGluIFJHQkEgQ1NTIGZvcm1hdFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZXMgPSBmdW5jdGlvbihwYWdlSWR4cywgcmVnaW9ucywgY29sb3VyLCBkaXZDbGFzcylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqID0gcGFnZUlkeHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoai0tKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlKHBhZ2VJZHhzW2pdLCByZWdpb25zW2pdLCBjb2xvdXIsIGRpdkNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBIaWdobGlnaHRzIHJlZ2lvbnMgb24gYSBwYWdlLlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcGFnZUlkeCAgQSBwYWdlIGluZGV4IG51bWJlclxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gcmVnaW9ucyAgQW4gYXJyYXkgb2YgcmVnaW9ucy4gVXNlIHsnd2lkdGgnOmksICdoZWlnaHQnOmksICd1bHgnOmksICd1bHknOiBpLCAnZGl2SUQnOiBzdHJ9IGZvciBlYWNoIHJlZ2lvbi5cbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGNvbG91ciAgIChvcHRpb25hbCkgQSBjb2xvdXIgZm9yIHRoZSBoaWdobGlnaHRpbmcsIHNwZWNpZmllZCBpbiBSR0JBIENTUyBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgQHBhcmFtIGRpdkNsYXNzIChvcHRpb25hbCkgQSBjbGFzcyB0byBpZGVudGlmeSBhIGdyb3VwIG9mIGhpZ2hsaWdodGVkIHJlZ2lvbnMgb24gYSBzcGVjaWZpYyBwYWdlIGJ5XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuaGlnaGxpZ2h0T25QYWdlID0gZnVuY3Rpb24ocGFnZUlkeCwgcmVnaW9ucywgY29sb3VyLCBkaXZDbGFzcylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xvdXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjIpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXZDbGFzcyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZDbGFzcyA9IGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQgZGl2YS1oaWdobGlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2Q2xhc3MgPSBkaXZhU2V0dGluZ3MuSUQgKyAnaGlnaGxpZ2h0IGRpdmEtaGlnaGxpZ2h0ICcgKyBkaXZDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodE1hbmFnZXIuYWRkSGlnaGxpZ2h0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IHBhZ2VJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpb25zOiByZWdpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3VyOiBjb2xvdXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZDbGFzczogZGl2Q2xhc3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICBKdW1wcyB0byBhIGhpZ2hsaWdodCBzb21ld2hlcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0gZGl2SUQgVGhlIElEIG9mIHRoZSBkaXYgdG8ganVtcCB0by4gVGhpcyBJRCBtdXN0IGJlIGF0dGFjaGVkIHRvIHRoZSBkaXYgdXNpbmcgLmhpZ2hsaWdodE9uUGFnZShzKSBhcyB0aGUgaGlnaGxpZ2h0IG1heSBub3QgYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5nb3RvSGlnaGxpZ2h0ID0gZnVuY3Rpb24oZGl2SUQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaGlnaGxpZ2h0TWFuYWdlci5nZXRIaWdobGlnaHRCeVJlZ2lvbklkKGRpdklEKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdvdG9EaXYocmVzdWx0LmhpZ2hsaWdodC5wYWdlLCByZXN1bHQucmVnaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEaXZhIGp1c3QgdHJpZWQgdG8gZmluZCBhIGhpZ2hsaWdodCB0aGF0IGRvZXNuJ3QgZXhpc3QuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1vdmVzIHRoZSBkaXZhIHBhbmUgdG8gKHBhZ2UpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGdvdG9EaXYgPSBmdW5jdGlvbihwYWdlLCB0aGlzRGl2KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9nZXRzIGNlbnRlciBvZiB0aGUgZGl2XG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZT2ZEaXYgPSBwYXJzZUZsb2F0KHRoaXNEaXYudWx5KSArIHBhcnNlRmxvYXQodGhpc0Rpdi5oZWlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlclhPZkRpdiA9IHBhcnNlRmxvYXQodGhpc0Rpdi51bHgpICsgcGFyc2VGbG9hdCh0aGlzRGl2LndpZHRoKSAvIDI7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRZID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWU9mRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2lyZWRYID0gZGl2YUluc3RhbmNlLnRyYW5zbGF0ZUZyb21NYXhab29tTGV2ZWwoY2VudGVyWE9mRGl2KTtcblxuICAgICAgICAgICAgICAgICAgICAvL25hdmlnYXRlcyB0byB0aGUgcGFnZVxuICAgICAgICAgICAgICAgICAgICBwYWdlID0gcGFyc2VJbnQocGFnZSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBkaXZhSW5zdGFuY2UuZ290b1BhZ2VCeUluZGV4KHBhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRPYmplY3QgPSBkaXZhSW5zdGFuY2UuZ2V0U2V0dGluZ3MoKS52aWV3cG9ydE9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRUb3AgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoKSArIGRlc2lyZWRZIC0gKHZpZXdwb3J0T2JqZWN0LmhlaWdodCgpIC8gMikgKyBkaXZhU2V0dGluZ3MudmVydGljYWxQYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudExlZnQgPSB2aWV3cG9ydE9iamVjdC5zY3JvbGxMZWZ0KCkgKyBkZXNpcmVkWCAtICh2aWV3cG9ydE9iamVjdC53aWR0aCgpIC8gMikgKyBkaXZhU2V0dGluZ3MuaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2VzIHRoZSBzY3JvbGwgbG9jYXRpb24gdG8gY2VudGVyIG9uIHRoZSBkaXYgYXMgbXVjaCBhcyBpcyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydE9iamVjdC5zY3JvbGxUb3AoY3VycmVudFRvcCk7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0T2JqZWN0LnNjcm9sbExlZnQoY3VycmVudExlZnQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgc2hvd0Fubm90YXRpb25zID0gZnVuY3Rpb24oY2FudmFzSW5kZXgpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgc3RhdHVzLCBqcVhIUilcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc0Fubm90YXRpb25zID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1Bbm5vdGF0aW9ucyA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnZlcnQgYW5ub3RhdGlvbnMgaW4gYW5ub3RhdGlvbnMgb2JqZWN0IHRvIGRpdmEgaGlnaGxpZ2h0IG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWdpb25zID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9vcCBvdmVyIGFubm90YXRpb25zIGluIGEgc2luZ2xlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Bbm5vdGF0aW9uczsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QW5ub3RhdGlvbiA9IGNhbnZhc0Fubm90YXRpb25zW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0ZXh0IGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGN1cnJlbnRBbm5vdGF0aW9uLnJlc291cmNlLmNoYXJzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHgseSx3LGggKHNsaWNlIHN0cmluZyBmcm9tICcjeHl3aD0nIHRvIGVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25TdHJpbmcgPSBjdXJyZW50QW5ub3RhdGlvbi5vbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRTdHJpbmcgPSBvblN0cmluZy5zbGljZShvblN0cmluZy5pbmRleE9mKCcjeHl3aD0nKSArIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IGNvb3JkU3RyaW5nLnNwbGl0KCcsJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVnaW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bHg6IHBhcnNlSW50KGNvb3JkaW5hdGVzWzBdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVseTogcGFyc2VJbnQoY29vcmRpbmF0ZXNbMV0sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KGNvb3JkaW5hdGVzWzJdLCAxMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoY29vcmRpbmF0ZXNbM10sIDEwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdpb25zLnB1c2gocmVnaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZ2hsaWdodE9uUGFnZShjYW52YXNJbmRleCwgcmVnaW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL2ZsYWcgdGhpcyBwYWdlJ3MgYW5ub3RhdGlvbnMgYXMgaGF2aW5nIGJlZW4gcmV0cmlldmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaWdobGlnaHRlZFBhZ2VzLnB1c2goY2FudmFzSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZ2V0QW5ub3RhdGlvbnNMaXN0ID0gZnVuY3Rpb24ocGFnZUluZGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBwYWdlIGhhcyBhbm5vdGF0aW9uTGlzdFxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzZXMgPSBzZXR0aW5ncy5tYW5pZmVzdC5zZXF1ZW5jZXNbMF0uY2FudmFzZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhc2VzW3BhZ2VJbmRleF0uaGFzT3duUHJvcGVydHkoJ290aGVyQ29udGVudCcpKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb250ZW50ID0gY2FudmFzZXNbcGFnZUluZGV4XS5vdGhlckNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3RoZXJDb250ZW50Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdGhlckNvbnRlbnRbal1bJ0B0eXBlJ10gPT09ICdzYzpBbm5vdGF0aW9uTGlzdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjYW52YXMgaGFzIGFubm90YXRpb25zLiBnZXQgdGhlIGFubm90YXRpb25zOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvdGhlckNvbnRlbnRbal1bJ0BpZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2Vzczogc2hvd0Fubm90YXRpb25zKHBhZ2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXRNYW5pZmVzdCA9IGZ1bmN0aW9uKG1hbmlmZXN0KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubWFuaWZlc3QgPSBtYW5pZmVzdDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdNYW5pZmVzdERpZExvYWQnLCBzZXRNYW5pZmVzdCwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgIGRpdmEuRXZlbnRzLnN1YnNjcmliZSgnUGFnZVdpbGxMb2FkJywgZnVuY3Rpb24ocGFnZUluZGV4KVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5oaWdobGlnaHRzVmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9pZiBoaWdobGlnaHRzIGZvciB0aGlzIHBhZ2UgaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZC9sb2FkZWQsIHJldHVyblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldHRpbmdzLmhpZ2hsaWdodGVkUGFnZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5oaWdobGlnaHRlZFBhZ2VzW2ldID09PSBwYWdlSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZ2V0QW5ub3RhdGlvbnNMaXN0KHBhZ2VJbmRleCwgc2V0dGluZ3MubWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIH0sIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlT3ZlcmxheXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vb24gbW91c2VvdmVyLCBzaG93IHRoZSBhbm5vdGF0aW9uIHRleHRcbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MuaW5uZXJPYmplY3Qub24oJ21vdXNlZW50ZXInLCAnLicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnaGlnaGxpZ2h0JywgZnVuY3Rpb24oZSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbm5vdGF0aW9uRWxlbWVudCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IGFubm90YXRpb25FbGVtZW50LmRhdGFzZXQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRPdmVybGF5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUudG9wID0gKGFubm90YXRpb25FbGVtZW50Lm9mZnNldFRvcCArIGFubm90YXRpb25FbGVtZW50Lm9mZnNldEhlaWdodCAtIDEpICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUubGVmdCA9IGFubm90YXRpb25FbGVtZW50LnN0eWxlLmxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLmJhY2tncm91bmQgPSAnI2ZmZic7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLmJvcmRlciA9ICcxcHggc29saWQgIzU1NSc7XG4gICAgICAgICAgICAgICAgICAgIHRleHRPdmVybGF5LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkuc3R5bGUuekluZGV4ID0gMTAxO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5jbGFzc05hbWUgPSAnYW5ub3RhdGlvbi1vdmVybGF5JztcbiAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJsYXkudGV4dENvbnRlbnQgPSBuYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRpb25FbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGV4dE92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVPdmVybGF5cy5wdXNoKHRleHRPdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpdmFTZXR0aW5ncy5pbm5lck9iamVjdC5vbignbW91c2VsZWF2ZScsICcuJyArIGRpdmFTZXR0aW5ncy5JRCArICdoaWdobGlnaHQnLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFjdGl2ZU92ZXJsYXlzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRPdmVybGF5ID0gYWN0aXZlT3ZlcmxheXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRleHRPdmVybGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZGl2YS5FdmVudHMuc3Vic2NyaWJlKCdWaWV3ZXJEaWRMb2FkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgLy9idXR0b24gdG8gdG9nZ2xlIGFubm90YXRpb25zXG4gICAgICAgICAgICAgICAgICAgICQoJyMnICsgZGl2YVNldHRpbmdzLklEICsgJ3BhZ2UtbmF2JykuYmVmb3JlKCc8ZGl2IGlkPVwiJyArIGRpdmFTZXR0aW5ncy5JRCArICdhbm5vdGF0aW9ucy1pY29uXCIgY2xhc3M9XCJkaXZhLWJ1dHRvbiBkaXZhLWFubm90YXRpb25zLWljb25cIiB0aXRsZT1cIlR1cm4gYW5ub3RhdGlvbnMgb24gb3Igb2ZmXCI+PC9kaXY+Jyk7XG5cbiAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnYW5ub3RhdGlvbnMtaWNvbicpLmFkZENsYXNzKCdhbm5vdGF0aW9ucy1pY29uLWFjdGl2ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgICQoJyMnICsgZGl2YVNldHRpbmdzLklEICsgJ2Fubm90YXRpb25zLWljb24nKS5vbignY2xpY2snLCBmdW5jdGlvbihlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RvZ2dsZSB2aXNpYmlsaXR5IG9mIGFubm90YXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuaGlnaGxpZ2h0c1Zpc2libGUpXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2YUluc3RhbmNlLmhpZGVIaWdobGlnaHRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnYW5ub3RhdGlvbnMtaWNvbicpLnJlbW92ZUNsYXNzKCdhbm5vdGF0aW9ucy1pY29uLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmFJbnN0YW5jZS5zaG93SGlnaGxpZ2h0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ2Fubm90YXRpb25zLWljb24nKS5hZGRDbGFzcygnYW5ub3RhdGlvbnMtaWNvbi1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZGl2YVNldHRpbmdzLklEKTtcblxuICAgICAgICAgICAgICAgIC8vZW5hYmxlIGFubm90YXRpb25zIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5oaWdobGlnaHRzVmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoZGl2YVNldHRpbmdzLCBkaXZhSW5zdGFuY2UpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5yZW1vdmVEYXRhKCdoaWdobGlnaHRzJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ0lJSUZIaWdobGlnaHQnLFxuICAgICAgICAgICAgdGl0bGVUZXh0OiAnSGlnaGxpZ2h0IHJlZ2lvbnMgb2YgcGFnZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtaGlnaGxpZ2h0LmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBJSUlGIE1ldGFkYXRhIHBsdWdpbiBmb3IgZGl2YS5qc1xuLy8gRGlzcGxheXMgb2JqZWN0IG1ldGFkYXRhIGZyb20gYSBJSUlGIG1hbmlmZXN0XG5cbnZhciBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcbnZhciBkaXZhID0gcmVxdWlyZSgnLi4vZGl2YScpO1xuXG4oZnVuY3Rpb24gKCQpXG57XG4gICAgbW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIHJldHZhbCA9XG4gICAgICAgIHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGRpdmFTZXR0aW5ncywgZGl2YUluc3RhbmNlKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfZGlzcGxheU1ldGFkYXRhID0gZnVuY3Rpb24obWFuaWZlc3QpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd01ldGFkYXRhID0gZnVuY3Rpb24obGFiZWwsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFiZWxQcm9wZXIgPSBsYWJlbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGxhYmVsLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsRm9ybWF0dGVkID0gbGFiZWxQcm9wZXIucmVwbGFjZSgnXycsICcgJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICc8YSBocmVmPVwiJyArIHZhbHVlICsgJ1wiIHRhcmdldD1cIl9ibGFua1wiPicgKyB2YWx1ZSArICc8L2E+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2IGNsYXNzPVwibWV0YWRhdGEtcm93XCI+PHNwYW4gY2xhc3M9XCJtZXRhZGF0YS1sYWJlbFwiPicgKyBsYWJlbEZvcm1hdHRlZCArICc6PC9zcGFuPiA8c3BhbiBjbGFzcz1cIm1ldGFkYXRhLXZhbHVlXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgICsgJzwvc3Bhbj48L2Rpdj4nO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXREYXRhRm9yTGFuZ3VhZ2UgPSBmdW5jdGlvbihkYXRhLCBsYW5ndWFnZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldWydAbGFuZ3VhZ2UnXSA9PT0gbGFuZ3VhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVtpXVsnQHZhbHVlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgbm8gbGFuZ3VhZ2UgaXMgc3BlY2lmaWVkLCBvciB3aGVuIGEgc2luZ2xlIG9iamVjdCBpcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhWzBdWydAdmFsdWUnXSB8fCBkYXRhWydAdmFsdWUnXTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogU2hvd3MgbWV0YWRhdGEgZnJvbSBsYWJlbCBuYW1lcyAoaWYgdGhlIG1ldGFkYXRhIGV4aXN0cykuXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lcyB7QXJyYXl9IC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyByZXByZXNlbnRpbmcgZmllbGQgbmFtZXMgdG8gZGlzcGxheS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaG93TWV0YWRhdGFGcm9tTGFiZWxOYW1lcyA9IGZ1bmN0aW9uKG5hbWVzKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSAnJztcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmllbGQgPSBuYW1lc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYW5pZmVzdC5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFuaWZlc3RbZmllbGRdLmNvbnN0cnVjdG9yID09PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tdWx0aXBsZSBsYW5ndWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbGl6ZWREYXRhID0gZ2V0RGF0YUZvckxhbmd1YWdlKG1hbmlmZXN0W2ZpZWxkXSwgJ2VuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyArPSBzaG93TWV0YWRhdGEoZmllbGQsIGxvY2FsaXplZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgKz0gc2hvd01ldGFkYXRhKGZpZWxkLCBtYW5pZmVzdFtmaWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhRWxlbWVudCA9ICc8ZGl2IGlkPVwiJyArIGRpdmFTZXR0aW5ncy5JRCArICdtZXRhZGF0YVwiIGNsYXNzPVwiZGl2YS1tb2RhbFwiPic7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRWxlbWVudCArPSBzaG93TWV0YWRhdGFGcm9tTGFiZWxOYW1lcyhbJ2xhYmVsJ10pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYW5pZmVzdC5oYXNPd25Qcm9wZXJ0eSgnbWV0YWRhdGEnKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGFkYXRhRmllbGQgPSBtYW5pZmVzdC5tZXRhZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YUZpZWxkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YUZpZWxkW2ldLnZhbHVlLmNvbnN0cnVjdG9yID09PSBBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW5vbmljYWxEYXRhID0gZ2V0RGF0YUZvckxhbmd1YWdlKG1ldGFkYXRhRmllbGRbaV0udmFsdWUsICdlbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVsZW1lbnQgKz0gc2hvd01ldGFkYXRhKG1ldGFkYXRhRmllbGRbaV0ubGFiZWwsIGNhbm9uaWNhbERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVsZW1lbnQgKz0gc2hvd01ldGFkYXRhKG1ldGFkYXRhRmllbGRbaV0ubGFiZWwsIG1ldGFkYXRhRmllbGRbaV0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhRWxlbWVudCArPSBzaG93TWV0YWRhdGFGcm9tTGFiZWxOYW1lcyhbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZGVzY3JpcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3dpdGhpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VlX2Fsc28nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2F0dHJpYnV0aW9uJ1xuICAgICAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YUVsZW1lbnQgKz0gJzwvZGl2Pic7XG5cbiAgICAgICAgICAgICAgICAgICAgZGl2YVNldHRpbmdzLnBhcmVudE9iamVjdC5wcmVwZW5kKG1ldGFkYXRhRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICQoZGl2YVNldHRpbmdzLnNlbGVjdG9yICsgJ21ldGFkYXRhJykuaGlkZSgpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvL3N1YnNjcmliZSB0byBNYW5pZmVzdERpZExvYWQgZXZlbnQsIGdldCB0aGUgbWFuaWZlc3RcbiAgICAgICAgICAgICAgICBkaXZhLkV2ZW50cy5zdWJzY3JpYmUoJ01hbmlmZXN0RGlkTG9hZCcsIF9kaXNwbGF5TWV0YWRhdGEsIGRpdmFTZXR0aW5ncy5JRCk7XG5cbiAgICAgICAgICAgICAgICBkaXZhU2V0dGluZ3MucGFyZW50T2JqZWN0LnByZXBlbmQoJzxkaXYgc3R5bGU9XCJ0ZXh0LWFsaWduOiBjZW50ZXI7IGNsZWFyOiBib3RoXCI+PGEgaHJlZj1cIiNcIiBpZD1cIicgKyBkaXZhU2V0dGluZ3MuSUQgKyAnbWV0YWRhdGEtbGlua1wiIGNsYXNzPVwiZGl2YS1tZXRhZGF0YS1saW5rXCI+RGV0YWlsczwvYT48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgICAvLyAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICd0aXRsZScpLmFwcGVuZCgnPGRpdj48YSBocmVmPVwiI1wiIGlkPVwiJyArIGRpdmFTZXR0aW5ncy5JRCArICdtZXRhZGF0YS1saW5rXCIgY2xhc3M9XCJkaXZhLW1ldGFkYXRhLWxpbmtcIj5EZXRhaWxzPC9hPjwvZGl2PicpO1xuXG4gICAgICAgICAgICAgICAgJChkaXZhU2V0dGluZ3Muc2VsZWN0b3IgKyAnbWV0YWRhdGEtbGluaycpLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAkKGRpdmFTZXR0aW5ncy5zZWxlY3RvciArICdtZXRhZGF0YScpLmZhZGVUb2dnbGUoJ2Zhc3QnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIChkaXZhU2V0dGluZ3MsIGRpdmFJbnN0YW5jZSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnSUlJRk1ldGFkYXRhJyxcbiAgICAgICAgICAgIHRpdGxlVGV4dDogJ1Nob3cgbWV0YWRhdGEgZnJvbSBhIElJSUYgbWFuaWZlc3QnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXR2YWw7XG4gICAgfSkoKTtcbn0pKGpRdWVyeSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NvdXJjZS9qcy9wbHVnaW5zL2lpaWYtbWV0YWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=